% @c -*- Coding: utf-8; Mode: Texinfo -*-
% @c Note that Texinfo does not support UTF-8. Please do not use literal
% @c UTF-8 characters in this document.
\input texinfo

@setfilename mcclim
@settitle McCLIM User's Manual

@set MCCLIMVERSION 0.9.7-dev

@copying
Copyright @copyright{} 2004,2005,2006,2007,2008 the McCLIM hackers.
@end copying

@dircategory Common Lisp
@direntry
* McCLIM User's Manual: (mcclim). A free implementation of CLIM.
@end direntry

@titlepage
@title{McCLIM User's Manual}

@sp 5
@center @titlefont{The Users Guide}
@sp 2
@center @titlefont{and}
@sp 2
@center @titlefont{API Reference}
@sp 2

@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@iftex
@contents
@end iftex

@macro glossentry{ENTRY}
@b{\ENTRY\}
@cindex \ENTRY\
@end macro

@macro func{FUN}
@b{\FUN\}
@end macro

@macro fmacro{MACRO}
@func{\MACRO\}
@end macro

@macro genfun{FUN}
@func{\FUN\}
@end macro

@alias gloss = i
@alias func = code
@alias class = code
@alias package = code
@alias gadget = code
@alias pane = code
@alias methcomp = t
@alias slot = code
@alias longref = t
@alias cl = code
@alias initarg = code

@ifnottex
@node Top
@top McCLIM User's Manual
@insertcopying
@end ifnottex

@menu
* Introduction::

Getting started
* CLIM Demos and Applications::
* The First Application::
* Using presentation types::

User Manual
* Using views::
* Using command tables::

Reference Manual
* Concepts::
* Windowing system drawing functions::
* CLIM drawing functions::
* Panes::
* Output Protocol::
* Command Processing::

Extensions
* Output Protocol Extensions::
* Output Recording Extensions::
* Drawing Two-Dimensional Images::
* File Selector Gadget::
* PostScript Backend::
* Drei::
* Fonts and Extended Text Styles::
* Tab Layout::

Utility Programs
* Listener::
* Inspector::

Auxilliary Material
* Glossary::
* Development History::

Index
* Concept Index::
* Variable Index::
* Function And Macro Index::
@end menu

@node Introduction
@chapter Introduction
@cindex ehtoota

CLIM is a large layered software system that allows the user to
customize it at each level.  The most simple ways of using CLIM is to
directly use its top layer, which contains application frames, panes,
and gadgets, very similar to those of traditional windowing system
toolkits such as GTK, Tk, and Motif.

But there is much more to using CLIM.  In CLIM, the upper layer with
panes and gadgets is written on top of a basic layer containing more
basic functionality in the form of sheets.  Objects in the upper layer
are typically instances of classes derived from those of the lower
layer.  Thus, nothing prevents a user from adding new gadgets and panes
by writing code that uses the sheet layer.

Finally, since CLIM is written in Common Lisp, essentially all parts of
it can be modified, replaced, or extended.

For that reason, a user's manual for CLIM must contain not only a
description of the protocols of the upper layer, but also of all
protocols, classes, functions, macros, etc. that are part of the
specification.

@menu
* Standards::
* How CLIM Is Different::
@end menu

@node Standards
@section Standards

This manual documents McCLIM @value{MCCLIMVERSION} which is a mostly
complete implementation of the CLIM 2.0 specification and its revision
2.2. To our knowledge version~2.2 of the CLIM specification is only
documented in the ``CLIM 2 User's Guide'' by Franz. While that document
is not a formal specification, it does contain many cleanups and is
often clearer than the official specification; on the other hand, the
original specification is a useful reference. This manual will note
where McCLIM has followed the 2.2 API.
@cindex specification

Also, some protocols mentioned in the 2.0 specification, such as parts
of the incremental redisplay protocol, are clearly internal to CLIM and
not well described.  It will be noted here when they are partially
implemented in McCLIM or not implemented at all.

@node How CLIM Is Different
@section How CLIM Is Different

Many new users of CLIM have a hard time trying to understand how it
works and how to use it.  A large part of the problem is that many such
users are used to more traditional GUI toolkits, and they try to fit
CLIM into their mental model of how GUI toolkits should work.

But CLIM is much more than just a GUI toolkit, as suggested by its name,
it is an @emph{interface manager}, i.e. it is a complete mediator
between application ``business logic'' and the way the user interacts
with objects of the application.  In fact, CLIM doesn't have to be used
with graphics output at all, as it contains a large collection of
functionality to manage text.
@cindex interface manager

Traditional GUI toolkits have an @emph{event loop}.
@cindex event loop
Events are delivered to GUI elements called @emph{gadgets} (or
@emph{widgets}), and the programmer attaches @emph{event handlers} to
those gadgets in order to invoke the functionality of the application
logic.  While this way of structuring code is sometimes presented as a
virtue (``Event-driven programming''), it has an unfortunate side
effect, namely that event handlers are executed in a null context, so
that it becomes hard to even remember two consecutive events.  The
effect of event-driven programming is that applications written that way
have very rudimentary interaction policies.

At the lowest level, CLIM also has an event loop, but most application
programmers never have any reason to program at that level with CLIM.
Instead, CLIM has a @emph{command loop}
@cindex command loop
at a much higher level than the event loop.  At each iteration of the
command loop:

@enumerate
@item
 A command is acquired.  You might satisfy this demand by clicking on a
  menu item, by typing the name of a command, by hitting some kind of
  keystroke, by pressing a button, or by pressing some visible object
  with a command associated with it;
@item
 Arguments that are required by the command are acquired.  Each argument
    is often associated with a @emph{presentation type}, and visible
    objects of the right presentation type can be clicked on to satisfy
    this demand.  You can also type a textual representation of the
    argument, using completion, or you can use a context menu;
@item
 The command is called on the arguments, usually resulting in some
    significant modification of the data structure representing your
    application logic;
@item
 A @emph{display routine} is called to update the views of the
  application logic.  The display routine may use features such as
  incremental redisplay.
@end enumerate

Instead of attaching event handlers to gadgets, writing a CLIM
application therefore consists of:

@itemize @bullet
@item
 writing CLIM commands that modify the application data structures
  independently of how those commands are invoked, and which may take
  application objects as arguments;
@item
 writing display routines that turn the application data structures (and
  possibly some "view" object) into a collection of visible
  representations (having presentation types) of application objects;
@item
 writing completion routines that allow you to type in application
  objects (of a certain presentation type) using completions;
@item
 independently deciding how commands are to be invoked (menus, buttons,
  presentations, textual commands, etc).
@end itemize

By using CLIM as a mediator of command invocation and argument
acquisition, you can obtain some very modular code.  Application logic
is completely separate from interaction policies, and the two can evolve
separately and independently.

@c @node Getting Started
@c @part Getting Started

@node CLIM Demos and Applications
@chapter CLIM Demos and Applications
@cindex demo applications

@menu
* Running the Demos::
* McCLIM Installation and Usage Tips::
@end menu

@node Running the Demos
@section Running the Demos

The McCLIM source distribution comes with a number of demos and
applications.  They are intended to showcase specific CLIM features,
demonstrate programming techniques or provide useful tools.

These demos and applications are available in the @t{Examples} and
@t{Apps} subdirectories of the source tree's root directory.
Instructions for compiling, loading and running some of the demos are
included in the files with the McCLIM installation instructions for your
Common Lisp implementation. See for example the file @t{INSTALL} if you
use Allegro CL, @t{INSTALL.CMU} for CMUCL, @t{INSTALL.OPENMCL} for
OpenMCL, and so on.

Below is a complete list of the McCLIM demos and applications, sorted in
alphabetical order.  Each entry provides a short description of what the
program does, with instructions for compiling and running it if not
mentioned in the general installation instructions.

@table @t
@item Apps/Listener
CLIM-enabled Lisp listener.  See the compilation and execution
instructions in @t{Apps/Listener/README}.
@item Examples/address-book.lisp
Simple address book.  See McCLIM's installation instructions.
@item Examples/calculator.lisp
Simple desk calculator.  See McCLIM's installation instructions.
@item Examples/clim-fig.lisp
Simple paint program.  You can run it by evaluating this form at the
Lisp prompt:
@lisp
(clim-demo::clim-fig)
@end lisp
@item Examples/colorslider.lisp
Interactive color editor.  See McCLIM's installation instructions.
@item Examples/demodemo.lisp
Demonstrates different pane types.  You can compile it by evaluating:
@lisp
(compile-file "Examples/demodemo.lisp")
@end lisp
Then load it with:
@lisp
(load "Examples/demodemo")
@end lisp
Finally, run it with:
@lisp
(clim-demo::demodemo)
@end lisp
@item Examples/goatee-test.lisp
Text editor with Emacs-like key bindings.  See McCLIM's installation
instructions.
@item Examples/menutest.lisp
Displays a window with a simple menu bar.  See McCLIM's installation
instructions.
@item Examples/postscript-test.lisp
Displays text and graphics to a PostScript file.  Run it with:
@lisp
(clim-demo::postscript-test)
@end lisp
The resulting file @t{ps-test.ps} is generated in the current directory
and can be displayed by a PostScript viewer such as @t{gv} on Unix-like
systems.
@item Examples/presentation-test.lisp
Displays an interactive window in which you type numbers that are
successively added.  When a number is expected as input, you can either
type it at the keyboard, or click on a previously entered number. Run it
with:
@lisp
(clim:run-frame-top-level (clim:make-application-frame
                           'clim-demo::summation))
@end lisp
@item Examples/sliderdemo.lisp
Apparently a calculator demo (see above).  Compile with:
@lisp
(compile-file "Examples/sliderdemo.lisp")
@end lisp
Load with:
@lisp
(load "Examples/sliderdemo")
@end lisp
Run with:
@lisp
(clim-demo::slidertest)
@end lisp
@item Examples/stream-test.lisp
Interactive command processor that echoes its input.  Run with:
@lisp
(clim-demo::run-test)
@end lisp
@end table

The following programs are currently @b{known not to work}:
@itemize @bullet
@item
 @t{Examples/fire.lisp}
@item
 @t{Examples/gadget-test-kr.lisp}
@item
 @t{Examples/gadget-test.lisp}
@item
 @t{Examples/puzzle.lisp}
@item
 @t{Examples/traffic-lights.lisp}
@item
 @t{Examples/transformations-test.lisp}
@end itemize

@node McCLIM Installation and Usage Tips
@section McCLIM Installation and Usage Tips

This section collects useful installation and usage tips.  They refer to
specific Common Lisp implementations or McCLIM features.

@menu
* Multiprocessing with CMUCL::
* Adding Mouse Button Icons::
@end menu

@node Multiprocessing with CMUCL
@subsection Multiprocessing with CMUCL
@cindex multiprocessing

Before beginning a McCLIM session with CMUCL, @b{you are strongly
advised} to initialize multiprocessing by evaluating the form:
@lisp
(mp::startup-idle-and-top-level-loops)
@end lisp
If you use the SLIME development environment under Emacs, evaluate the
above form from the @t{*inferior-lisp*} buffer, not from
@t{*slime-repl[n]*}.  Initializing multiprocessing can make a difference
between an application that starts instantaneously on, say, a Pentium IV
class PC, and one that may take @emph{minutes} on the same machine.

@node Adding Mouse Button Icons
@subsection Adding Mouse Button Icons

McCLIM comes with experimental code for adding graphical mouse button
icons to pointer documentation panes.  To use this feature, you have to
first compile the file @t{Experimental/pointer-doc-hack.lisp} in the
source tree.  Assuming you have built McCLIM from source as explained in
the installation instructions, evaluate this form to compile the file:
@lisp
(compile-file "Experimental/pointer-doc-hack.lisp")
@end lisp
Then, to activate the feature, load the compiled file before starting a
McCLIM session or application:
@lisp
(load "Experimental/pointer-doc-hack")
@end lisp
Alternatively, you may dump a Lisp image containing McCLIM and the
graphical pointer documentation code.  See the documentation of your
Common Lisp system for more information.

@node The First Application
@chapter The First Application
@cindex building an application
@cindex writing an application

@menu
* How CLIM applications produce output::
* Panes and Gadgets::
* Defining Application Frames::
* A First Attempt::
* Executing the Application::
* Adding Functionality::
* An application displaying a data structure::
* Incremental redisplay::
@end menu

@node How CLIM applications produce output
@section How CLIM applications produce output

CLIM stream panes use output recording.  This means that such a pane
maintains a display list, consisting of a sequence of output records,
ordered chronologically, from the first output record to be drawn to
the last.  

This display list is used to fill in damaged areas of the pane, for
instance as a result of the pane being partially or totally covered by
other panes, and then having some or all of its area again becoming
visible.  The output records of the display list that have some parts
in common with the exposed area are partially or totally replayed (in
chronological order) to redraw the contents of the area.

An application can have a pane establish this display list in several
fundamentally different ways.

Very simple applications have no internal data structure to keep track
of application objects, and simply produce output to the pane from
time to time as a result of running commands, occasionally perhaps
erasing the pane and starting over.  Such applications typically use
text or graphics output as a result of running commands.  CLIM
maintains the display list for the pane, and adds to the end of it,
each time also producing the pixels that result from drawing the new
output record.  If the pane uses scrolling (which it typically does),
then CLIM must determine the extent of the pane so as to update the
scroll bar after each new output.  

More complicated applications use a display function.  Before the
display function is run, the existing display list is typically
deleted, so that the purpose of the display function becomes to
establish an entirely new display list.  The display function might
for instance produce some kind of form to be filled in, and
application commands can use text or graphics operations to fill in
the form.  A game of tic-tac-toe could work this way, where the
display function draws the board and commands draw shapes into the
squares.  

Even more complicated applications might have some internal data
structure that has a direct mapping to output, and commands simply
modify this internal data structure.  In this case, the display
function is run after each time around the command loop, because a
command can have modified the internal data structure in some
arbitrary ways.  Some such applications might simply want to delete
the existing display list and produce a new one each time (to minimize
flicker, double buffering could be used).  This is a very simple way
of structuring an application, and entirely acceptable in many cases.
Consider, for instance, a board game where pieces can be moved (as
opposed to just added).  A very simple way of structuring such an
application is to have an internal representation of the board, and to
make the display function traverse this data structure and produce the
complete output each time in the command loop.  

Some applications have very large internal data structures to be
displayed, and it would cause a serious performance problem if the
display list had to be computer from scratch each time around the
command loop.  To solve this problem, CLIM contains a feature called
incremental redisplay.  It allows many of the output records to be
kept from one iteration of the command loop to the next.  This can be
done in two different ways.  The simplest way is for the application
to keep the simple structure which consists of traversing the entire
data structure each time, but at various points indicate to CLIM that
the output has not changed since last time, so as to avoid actually
invoking the application code for computing it.  This is accomplished
by the use of @t{updating-output}.  The advantage of
@t{updating-output} is that the application logic remains
straightforward, and it is up to CLIM to do the hard work of recycling
output records.  The disadvantage is that for some very demanding
applications, this method might not be fast enough.

The other way is more complicated and requires the programmer to
structure the application differently.  Essentially, the application
has to keep track of the output records in the display list, and
inform CLIM about modifications to it.  The main disadvantage of this
method is that the programmer must now write the application to keep
track of the output records itself, as opposed to leaving it to CLIM. 

@node Panes and Gadgets
@section Panes and Gadgets

A CLIM application is made up of a hierarchy of @gloss{panes} and
@gloss{gadgets} (gadgets are special kinds of panes).  These elements
correspond to what other toolkits call @emph{widgets}.  Frequently used
CLIM gadgets are @gadget{button}s, @gadget{slider}s, etc, and typical
panes are the layout panes such as @pane{hbox}, @pane{vbox},
@pane{hrack}, etc.
@cindex pane
@cindex gadget

@node Defining Application Frames
@section Defining Application Frames

Each CLIM application is defined by an @gloss{application frame}.  An
application frame is an instance of the class @class{application-frame}.
As a CLIM user, you typically define a class that inherits from the
class @class{application-frame}, and that contains additional slots
needed by your application.  It is considered good style to keep all
your application-specific data in slots in the application frame (rather
than, say, in global variables), and to define your application-specific
application frame in its own package.
@cindex application frame

The usual way to define an application frame is to use the macro
@fmacro{define-application-frame}.  This macro works much like
@fmacro{defclass}, but also allows you to specify the hierarchy of
@gloss{panes} and @gloss{gadgets} to use.

@node A First Attempt
@section A First Attempt

Let us define a very primitive CLIM application.  For that, let us put
the following code in a file:

@lisp
@include ex1.lisp
@end lisp

As we can see in this example, we have put our application in a separate
package, here a package named @t{APP}.  While not required, putting the
application in its own package is good practice.

The package for the application uses two packages: @package{CLIM} and
@package{CLIM-LISP}.  The @package{CLIM} package is the one that
contains all the symbols needed for using CLIM.  The @package{CLIM-LISP}
package replaces the @package{COMMON-LISP} package for CLIM
applications.  It is essentially the same as the @package{COMMON-LISP}
package as far as the user is concerned.

In our example, we export the symbol that corresponds to the main
function to start our application, here called @t{APP-MAIN}.

The most important part of the code in our example is the definition of
the application-frame.  In our example, we have defined an application
frame called @t{superapp}, which becomes a CLOS class that automatically
inherits from some standard CLIM application frame class.

The second argument to @fmacro{define-application-frame} is a list of
additional superclasses from which you want your application frame to
inherit.  In our example, this list is empty, which means that our
application frame only inherits from the standard CLIM application
frame.

The third argument to @fmacro{define-application-frame} is a list of
CLOS slots to be added to any instance of this kind of application
frame.  These slots are typically used for holding all
application-specific data.  The current instance of the application
frame will always be the value of the special variable
@t{*application-frame*},
@vindex *application-frame*
so that the values of these slots can be accessed.  In our example, we
do not initially have any further slots.

The rest of the definition of an application frame contains additional
elements that CLIM will allow the user to define.  In our example, we
have two additional (mandatory) elements: @t{:panes} and @t{:layouts}.

The @t{:panes} element defines a collection of CLIM panes that each
instance of your application may have.  Each pane has a name, a type,
and perhaps some options that are used to instantiate that particular
type of pane.  Here, we have a pane called @t{int} of type
@t{:interactor} with a height of 400 units and a width of 600 units.  In
McCLIM, the units are initially physical units (number of pixels) of the
native windowing system.

The @t{:layouts} element defines one or more ways of organizing the
panes in a hierarchy.  Each layout has a name and a description of a
hierarchy.  In our example, only one layout, named @t{default}, is
defined.  The layout called @t{default} is the one that is used by CLIM
at startup.  In our example, the corresponding hierarchy is trivial,
since it contains only the one element @t{int}, which is the name of our
only pane.

@node Executing the Application
@section Executing the Application

In order to run a CLIM application, you must have a Lisp system that
contains McCLIM.  If you use CMUCL or SBCL, you either need a @t{core}
file that already has McCLIM in it, or else, you have to load the McCLIM
compiled files that make up the McCLIM distribution.  The fist solution
is recommended so as to avoid having to load the McCLIM files each time
you start your CLIM application.

To execute the application, load the file containing your code (possibly
after compiling it) into your running Lisp system.  Then start the
application.  Our example can be started by typing @t{(app:app-main)}.

@node Adding Functionality
@section Adding Functionality

In a serious application, you would probably want some area where your
application objects are to be displayed.  In CLIM, such an area is
called an @emph{application pane}, and would be an instance (direct or
indirect) of the CLIM class @t{application-pane}.  In fact, instances of
this class are in reality also @emph{streams} which can be used in calls
both to ordinary input and output functions such as @t{format} and
@t{read} and to CLIM-specific functions such as @t{draw-line}.

In this example we have such an application pane, the name of which is
@t{app}.  As you can see, we have defined it with an option
@t{:display-time nil}.  The default value for this option for an
application pane is @t{:command-loop}, which means that the pane is
cleared after each iteration in the command loop, and then redisplayed
using a client-supplied @emph{display function}.  The default display
function does nothing, and we have not supplied any, so if we had
omitted the @t{:display-time nil} option, the @t{parity} command would
have written to the pane.  Then, at the end of the command loop, the
pane would have been cleared, and nothing else would have been
displayed.  The net result is that we would have seen no visible output.
With the option @t{:display-time nil}, the pane is never cleared, and
output is accumulated every time we execute the @t{parity} command.

For this example, let us also add a few @emph{commands}.
@cindex command
Such commands are defined by the use of a macro called
@fmacro{@t{define-}@i{name}@t{-command}}, where @i{name} is the name of
the application, in our case @t{superapp}. This macro is automatically
defined by @t{define-application-frame}.

Let us also add a pane that automatically provides documentation for
different actions on the pointer device.

Here is our improved example:

@lisp
@include ex2.lisp
@end lisp

If you execute this example, you will find that you now have three
different panes, the application pane, the interactor pane and the
pointer documentation pane.  In the pointer documentation pane, you will
see the text @t{R possibilities} which indicates that if you click the
right mouse button, you will automatically see a popup menu that lets
you choose a command.  In our case, you will have the default commands
that are automatically proposed by McCLIM plus the commands that you
defined yourself, in this case @t{quit} and @t{parity}.

@ref{fig:figex2} shows what ought to be visible on the screen.

@float Figure,fig:figex2
@image{ex2,5in,5in,View of the improved example}
@end float

Notice that commands, in order to be available from the command line,
must have an option of @t{:name t}.  The reason is that some commands
will be available only from menus or by some other mechanism.

You may notice that if the output of the application is hidden (say by
the window of some other application) and then re-exposed, the output
reappears normally, without any intervention necessary on the part of
the programmer.  This effect is accomplished by a CLIM mechanism called
@emph{output recording}.
@cindex output recording
Essentially, every piece of output is not only displayed in the pane,
but also captured in an @emph{output record} associated with the pane.
When a pane is re-exposed, its output records are consulted and if any
of them overlap the re-exposed region, they are redisplayed.  In fact,
some others may be redisplayed as well, because CLIM guarantees that the
effect will be the same as when the initial output was created.  It does
that by making sure that the order between (partially) overlapping
output records is respected.

Not all panes support output recording, but certainly application panes
do, so it is good to use some subclass of @t{application-pane} to
display application-specific object, because output recording is then
automatic.

@node An application displaying a data structure
@section An application displaying a data structure

Many applications use a central data structure that is to be on display
at all times, and that is modified by the commands of the application.
CLIM allows for a very easy way to write such an application.  The main
idea is to store the data structure in slots of the application frame,
and to use a @emph{display function}
@cindex display function
that after each iteration of the command loop displays the entire data
structure to the application pane.

Here is a variation of the previous application that shows this
possibility:

@lisp
@include ex2b.lisp
@end lisp

Here, we have added a slot that is called @t{current-number} to the
application frame.  It is initialized to @cl{NIL} and it has an accessor
function that allow us to query and to modify the value.

Observe that in this example, we no longer have the option
@t{:display-time nil} set in the application pane.  By default, then,
the @t{:display-time} is @t{:command-loop} which means that the pane is
erased after each iteration of the command loop.  Also observe the
option @t{:display-function} which takes a symbol that names a function
to be called to display the pane after it has been cleared.  In this
case, the name is @t{display-app}, the name of the function defined
immediately after the application frame.

Instead of immediately displaying information about its argument, the
command @t{com-parity} instead modifies the new slot of the application
frame.  Think of this function as being more general, for instance a
command to add a new object to a set of graphical objects in a figure
drawing program, or as a command to add a new name to an address book.
Notice how this function accesses the current application frame by means
of the special variable @t{*application-frame*}.

A display function is called with the frame and the pane as arguments.
It is good style to use the pane as the stream in calls to functions
that will result in output.  This makes it possible for the same
function to be used by several different frames, should that be called
for.  In our simple example, the display function only displays the
value of a single number (or @cl{NIL}), but you could think of this as
displaying all the objects that have been drawn in some figure drawing
program or displaying all the entries in an address book.

@node Incremental redisplay
@section Incremental redisplay

While the example in the previous section is a very simple way of
structuring an application (let commands arbitrarily modify the data
structure, and simply erase the pane and redisplay the structure after
each iteration of the command loop), the visual result is not so great
when many objects are to be displayed.  There is most often a noticeable
flicker between the moment when the pane is cleared and the objects are
drawn.  Sometimes this is inevitable (as when nearly all objects
change), but most of the time, only an incremental modification has been
made, and most of the objects are still in the same place as before.

In simple toolkits, the application programmer would have to figure out
what has changed since the previous display, and only display the
differences.  CLIM offers a mechanism called @emph{incremental
redisplay}
@cindex incremental redisplay
that automates a large part of this task.  As we mentioned earlier, CLIM
captures output in the form of @emph{output records}.  The same
mechanism is used to obtain incremental redisplay.

To use incremental redisplay, Client code remains structured in the
simple way that was mention above: after each iteration of the command
loop, the display function output the entire data structure as usual,
except that it helps the incremental redisplay mechanism by telling CLIM
which piece of output corresponds to which piece of output during the
previous iteration of the command loop.  It does this by giving some
kind of @emph{unique identity} to some piece of output, and some means
of indicating whether the contents of this output is @emph{the same} as
it was last time.  With this information, the CLIM incremental redisplay
mechanism can figure out whether some output is new, has disappeared, or
has been moved, compared to the previous iteration of the command loop.
As with re-exposure, CLIM guarantees that the result is identical to
that which would have been obtained, had all the output records been
output in order to a blank pane.

The next example illustrates this idea.  It is a simple application that
displays a fixed number (here 20) of lines, each line being a number.
Here is the code:

@lisp
@include ex2c.lisp
@end lisp

We store the numbers in a slot called @t{numbers} of the application
frame.  However, we store each number in its own list.  This is a simple
way to provide a unique identity for each number.  We could not use the
number itself, because two numbers could be the same and the identities
would not be unique.  Instead, we use the cons cell that store the
number as the unique identity.  By using @t{:id-test #'eq} we inform
CLIM that it can figure out whether an output record is the same as one
that was issued previous time by using the function @t{eq} to compare
them.  But there is a second test that has to be verified, namely
whether an output record that was issued last time has to be redisplayed
or not.  That is the purpose of the cache-value.  Here we use the number
itself as the cache value and @t{eql} as the test to determine whether
the output is going to be the same as last time.

For convenience, we display a @t{*} at the beginning of the current
line, and we provide two commands @t{next} and @t{previous} to navigate
between the lines.

Notice that in the declaration of the pane in the application frame, we
have given the option @t{:incremental-redisplay t}.  This informs CLIM
not to clear the pane after each command-loop iteration, but to keep the
output records around and compare them to the new ones that are produced
during the new iteration.

@node Using presentation types
@chapter Using presentation types
@cindex presentation type

@menu
* What is a presentation type::
* A simple example::
@end menu

@node What is a presentation type
@section What is a presentation type

The concept of @emph{presentation types} is central to CLIM.  Client
code can choose to output graphical or textual representations of
application objects either as just graphics or text, or to associate
such output with an arbitrary Common Lisp object and a presentation
type.  The presentation type is not necessarily related to the idea
Common Lisp might have of the underlying object.

When a CLIM command or some other client code requests an object (say as
an argument) of a certain presentation type, the user of the application
can satisfy the request by clicking on any visible output labeled with a
compatible presentation type.  The command then receives the underlying
Common Lisp object as a response to the request.

CLIM presentation types are usually distinct from Common Lisp types.
The reason is that the Common Lisp type system, although very powerful,
is not quite powerful enough to represent the kind of relationships
between types that are required by CLIM.  However, every Common Lisp
class (except the built-in classes) is automatically a presentation
type.

A presentation type has a name, but can also have one or more
@emph{parameters}.  Parameters of presentation types are typically used
to restrict the type.  For instance, the presentation type @t{integer}
takes as parameters the low and the high values of an interval.  Such
parameters allow the application to restrict objects that become
clickable in certain contexts, for instance if a date in the month of
March is requested, only integers between 1 and 31 should be clickable.

@node A simple example
@section A simple example

Consider the following example:

@lisp
@include ex3.lisp
@end lisp

In this application, we have two main panes, an application pane and an
interactor pane.  The application pane is given the option
@t{:display-time t} which means that it will not be erased before every
iteration of the command loop.

We have also defined two presentation types: @t{name-of-month} and
@t{day-of-month}.  The @t{out} command uses
@t{with-output-as-presentation} in order to associate some output, a
presentation type, and an underlying object.  In this case, it will show
the string ``March'' which is considered to be of presentation type
@t{name-of-month} with the underlying object being the character string
@t{"The third month"}.  It will also show the string ``fifteen'' which
is considered to be of presentation type @t{day-of-month} with the
underlying object being the number 15.  The argument @t{t} to
@t{with-output-as-presentation} indicates that the stream to present on
is @t{*standard-output*}.

Thus, if the @t{out} command has been executed, and then the user types
``Get Date'' in the interactor pane, the @t{get-date} command will try
to acquire its arguments, the first of presentation type
@t{name-of-month} and the second of type @t{day-of-month}.  At the first
prompt, the user can click on the string ``March'' but not on the string
``fifteen'' in the application pane.  At the second prompt it is the
string ``fifteen'' that is clickable, whereas ``March'' is not.

The @t{get-date} command will acquire the underlying objects.  What is
finally displayed (in the interactor pane, which is the standard input
of the frame), is ``the 15 of The third month''.

@c @node User Manual
@c @part User Manual

@node Using views
@chapter Using views
@cindex view

The CLIM specification mentions a concept called a @emph{view}, and also
lists a number of predefined views to be used in various different
contexts.

In this chapter we show how the @emph{view} concept can be used in some
concrete programming examples.  In particular, we show how to use a
single pane to show different views of the application data structure at
different times.  To switch between the different views, we supply a set
of commands that alter the @t{stream-default-view} feature of all CLIM
extended output streams.

The example shown here has been stripped to a bare minimum in order to
illustrate the important concepts.  A more complete version can be found
in @t{Examples/views.lisp} in the McCLIM source tree.

Here is the example:

@lisp
@include views.lisp
@end lisp

The example shows a stripped-down example of a simple database of
members of some organization.

The main trick used in this example is the @t{display-main-pane}
function that is declared to be the display function of the main pane in
the application frame.  The @t{display-main-pane} function trampolines
to a generic function called @t{display-pane-with-view}, and which takes
an additional argument compared to the display functions of CLIM panes.
This additional argument is of type @t{view} which allows us to dispatch
not only on the type of frame and the type of pane, but also on the type
of the current default view.  In this example the view argument is
simply taken from the default view of the pane.

A possibility that is not obvious from reading the CLIM specification is
to have views that contain additional slots.  Our example defines two
subclasses of the CLIM @t{view} class, namely @t{members-view} and
@t{person-view}.

The first one of these does not contain any additional slots, and is
used when a global view of the members of our organization is wanted.
Since no instance-specific data is required in this view, we follow the
idea of the examples of the CLIM specification to instantiate a
singleton of this class and store that singleton in the
@t{stream-default-view} of our main pane whenever a global view of our
organization is required.

The @t{person-view} class, on the other hand, is used when we want a
closer view of a single member of the organization.  This class
therefore contains an additional slot which holds the particular person
instance we are interested in.  The method on @t{display-pane-with-view}
that specializes on @t{person-view} displays the data of the particular
person that is contained in the view.

To switch between the views, we provide two commands.  The command
@t{com-show-all} simply changes the default view of the main pane to be
the singleton instance of the @t{members-view} class.  The command
@t{com-show-person} is more complicated.  It takes an argument of type
person, creates an instance of the @t{person-view} class initialized
with the person that was passed as an argument, and stores the instance
as the default view of the main pane.

@node Using command tables
@chapter Using command tables
@cindex command table

(to be filled in)

@c @node Reference Manual
@c @part Reference Manual

@node Concepts
@chapter Concepts

@menu
* Coordinate systems::
* Arguments to drawing functions::
@end menu

@node Coordinate systems
@section Coordinate systems

CLIM uses a number of different coordinate systems and transformations
to transform coordinates between them.

The coordinate system used for the arguments of drawing functions is
called the @gloss{user coordinate system},
@cindex user coordinate system
 and coordinate values expressed in the user coordinate system are known
as @gloss{user coordinates}.
@cindex user coordinates

Each sheet has its own coordinate system called the @gloss{sheet
coordinate system},
@cindex sheet coordinate system
 and positions expressed in this coordinate system are said to be
expressed in @gloss{sheet coordinates}.
@cindex sheet coordinates
  User coordinates are translated to @gloss{sheet coordinates} by means
of the @gloss{user transformation} also called the @gloss{medium
transformation}.  This transformation is stored in the @gloss{medium}
used for drawing.  The medium transformation can be composed temporarily
with a transformation given as an explicit argument to a drawing
function.  In that case, the user transformation is temporarily modified
for the duration of the drawing.

Before drawing can occur, coordinates in the sheet coordinate system
must be transformed to @gloss{native coordinates}, which are coordinates
of the coordinate system of the native windowing system.  The
transformation responsible for computing native coordinates from sheet
coordinates is called the @gloss{native transformation}.  Notice that
each sheet potentially has its own native coordinate system, so that the
native transformation is specific for each sheet.  Another way of
putting it is that each sheet has a mirror, which is a window in the
underlying windowing system.  If the sheet has its own mirror, it is the
@emph{direct mirror} of the sheet.  Otherwise its mirror is the direct
mirror of one of its ancestors.  In any case, the native transformation
of the sheet determines how sheet coordinates are to be translated to
the coordinates of that mirror, and the native coordinate system of the
sheet is that of its mirror.

The composition of the user transformation and the native transformation
is called the @gloss{device transformation}.  It allows drawing
functions to transform coordinates only once before obtaining native
coordinates.

Sometimes, it is useful to express coordinates of a sheet in the
coordinate of its parent.  The transformation responsible for that is
called the @gloss{sheet transformation}.

@node Arguments to drawing functions
@section Arguments to drawing functions

Drawing functions are typically called with a sheet as an argument.

A sheet often, but not always, corresponds to a window in the underlying
windowing system.

@node Windowing system drawing functions
@chapter Windowing system drawing functions

A typical windowing system provides a hierarchy of rectangular areas
called windows.  When a drawing functions is called to draw an object
(such as a line or a circle) in a window of such a hierarchy, the
arguments to the drawing function will include at least the window and a
number of coordinates relative to (usually) the upper left corner of the
window.

To translate such a request to the actual altering of pixel values in
the video memory, the windowing system must translate the coordinates
given as argument to the drawing functions into coordinates relative to
the upper left corner of the entire screen.  This is done by a
composition of translation transformations applied to the initial
coordinates.  These transformations correspond to the position of each
window in the coordinate system of its parent.

Thus a window in such a system is really just some values indicating its
height, its width, and its position in the coordinate system of its
parent, and of course information about background and foreground colors
and such.

@node CLIM drawing functions
@chapter CLIM drawing functions

CLIM generalizes the concept of a hierarchy of window in a windowing
system in several different ways.  A window in a windowing system
generalizes to a @gloss{sheet} in CLIM.  More precisely, a window in a
windowing system generalizes to the @gloss{sheet region} of a sheet.  A
CLIM sheet is an abstract concept with an infinite @gloss{drawing plane}
and the @gloss{region} of the sheet is the potentially visible part of
that drawing plane.

CLIM @gloss{sheet region}s don't have to be rectangular the way windows
in most windowing systems have to be.  Thus, the width and the height of
a window in a windowing system generalizes to an arbitrary
@gloss{region} in CLIM.  A CLIM region is simply a set of mathematical
points in a plane.  CLIM allows this set to be described as a
combination (union, intersection, difference) of elementary regions made
up of rectangles, polygons and ellipses.

Even rectangular regions in CLIM are generalizations of the width+height
concept of windows in most windowing systems.  While the upper left
corner of a window in a typical windowing system has coordinates (0,0),
that is not necessarily the case of a CLIM region.  CLIM uses that
generalization to implement various ways of scrolling the contents of a
sheet.  To see that, imagine just a slight generalization of the
width+height concept of a windowing system into a rectangular region
with x+y+width+height.  Don't confuse the x and y here with the position
of a window within its parent, they are different.  Instead, imagine
that the rectangular region is a hole into the (infinite) drawing plane
defined by all possible coordinates that can be given to drawing
functions.  If graphical objects appear in the window with respect to
the origin of some coordinate system, and the upper-left corner of the
window has coordinates (x,y) in that coordinate system, then changing x
and y will have the effect of scrolling.

CLIM sheets also generalize windows in that a window typically has
pixels with integer-value coordinates.  CLIM sheets, on the other hand,
have infinte resolution.  Drawing functions accept non-integer
coordinate values which are only translated into integers just before
the physical rendering on the screen.

The x and y positions of a window in the coordinate system of its parent
window in a typical windowing system is a translation transformation
that takes coordinates in a window and transform them into coordinates
in the parent window.  CLIM generalizes this concepts to arbitrary
affine transformations (combinations of translations, rotations, and
scalings).  This generalization makes it possible for points in a sheet
to be not only translated compared to the parent sheet, but also rotated
and scaled (including negative scaling, giving mirror images).  A
typical use for scaling would be for a sheet to be a zoomed version of
its parent, or for a sheet to have its y-coordinate go the opposite
direction from that of its parent.

When the shapes of, and relationship between sheets are as simple as
those of a typical windowing system, each sheet typically has an
associated window in the underlying windowing system.  In that case,
drawing on a sheet translates in a relativly straightforward way into
drawing on the corresponding window.  CLIM sheets that have associated
windows in the underlying windowing system are called @gloss{mirrored
sheets} and the system-dependent window object is called the
@gloss{mirror}.  When shapes and relationships are more complicated,
CLIM uses its own transformations to transform coordinates from a sheet
to its parent and to its grandparent, etc., until a @gloss{mirrored
sheet} is found.  To the user of CLIM, the net effect is to have a
windowing system with more general shapes of, and relationships between
windows.

@node Panes
@chapter Panes
@cindex pane

Panes are subclasses of sheets.  Some panes are @gloss{layout panes}
that determine the size and position of its children according to rules
specific to each particular type of layout pane.  Examples of layout
panes are vertical and horizontal boxes, tables etc.

According to the CLIM specification, all CLIM panes are
@emph{rectangular objects}.  For McCLIM, we interpret that phrase to
mean that:

@itemize
@item
 CLIM panes appear rectangular in the native windowing system;
@item
 CLIM panes have a native transformation that does not have a rotation
  component, only translation and scaling.
@end itemize

Of course, the specification is unclear here.  Panes are subclasses of
sheets, and sheets don't have a shape per-se.  Their @emph{regions} may
have a shape, but the sheet itself certainly does not.

The phrase in the specification @emph{could} mean that the
@gloss{sheet-region} of a pane is a subclass of the region class
@gloss{rectangle}.  But that would not exclude the possibility that the
region of a pane would be some non-rectangular shape in the
@gloss{native coordinate system}.  For that to happen, it would be
enough that the @gloss{sheet-transformation} of some ancestor of the
pane contain a rotation component.  In that case, the layout protocol
would be insufficient in its current version.

McCLIM panes have the following additional restrictions:

@itemize
@item
 McCLIM panes have a coordinate system that is only a translation
  compared to that of the frame manager;
@item
 The parent of a pane is either nil or another pane.
@end itemize

Thus, the panes form a @emph{prefix} in the hierarchy of sheets.  It is
an error for a non-pane to adopt a pane.

Notice that the native transformation of a pane need not be the identity
transformation.  If the pane is not mirrored, then its native
transformation is probably a translation of that of its parent.

Notice also that the native transformation of a pane need not be the
composition of the identity transformation and a translation.  That
would be the case only of the native transformation of the top level
sheet is the identity transformation, but that need not be the case.  It
is possible for the frame manager to impose a coordinate system in (say)
millimeters as opposed to pixels.  The native transformation of the top
level sheet of such a frame manager is a scaling with coefficients other
than 1.

@menu
* Layout protocol::
@end menu

@node Layout protocol
@section Layout protocol
@cindex layout protocol

There is a set of fundamental rules of CLIM dividing responsibility
between a parent pane and a child pane, with respect to the size and
position of the region of the child and the @gloss{sheet transformation}
of the child.  This set of rules is called the @gloss{layout protocol}.

The layout protocol is executed in two phases.  The first phase is
called the @gloss{space compostion} phase, and the second phase is
called the @gloss{space allocation} phase.

@menu
* Space composition::
* Space allocation::
* Change-space Notification Protocol::
@end menu

@node Space composition
@subsection Space composition

The space composition is accomplished by the generic function
@genfun{compose-space}.  When applied to a pane, @genfun{compose-space}
returns an object of type @gloss{space-requirement} indicating the needs
of the pane in terms of preferred size, minimum size and maximum size.
The phase starts when compose-space is applied to the top-level pane of
the application frame.  That pane in turn may ask its children for their
space requirements, and so on until the leaves are reached.  When the
top-level pane has computed its space requirments, it asks the system
for that much space.  A conforming window manager should respect the
request (space wanted, min space, max space) and allocate a top-level
window of an acceptable size.  The space given by the system must then
be distributed among the panes in the hierarchy
@longref{space-allocation}.

Each type of pane is responsible for a different method on
@genfun{compose-space}.  Leaf panes such as @gloss{labelled gadgets} may
compute space requirements based on the size and the text-style of the
label.  Other panes such as the vbox layout pane compute the space as a
combination of the space requirements of their children.  The result of
such a query (in the form of a space-requirement object) is stored in
the pane for later use, and is only changed as a result of a call to
@genfun{note-space-requirement-changed}.

Most @gloss{composite panes} can be given explicit values for the values
of @initarg{:width}, @initarg{:min-width}, @initarg{:max-width},
@initarg{:height}, @initarg{:min-height}, and @initarg{:max-height}
options.  If such arguments are not given (effectively making these
values nil), a general method is used, such as computing from children
or, for leaf panes with no such reasonable default rule, a fixed value
is given.  If such arguments are given, their values are used instead.
Notice that one of @initarg{:height} and @initarg{:width} might be
given, applying the rule only in one of the dimensions.

Subsequent calls to @genfun{compose-space} with the same arguments are
assumed to return the same space-requirement object, unless a call to
note-space-requirement-changed has been called in between.

@node Space allocation
@subsection Space allocation
@anchor{space-allocation}

When @genfun{allocate-space} is called on a pane @var{P}, it must
compare the space-requirement of the children of @var{P} to the
available space, in order to distribute it in the most preferable way.
In order to avoid a second recursive invokation of
@genfun{compose-space} at this point, we store the result of the
previous call to @genfun{compose-space} in each pane.

To handle this situtation and also explicitly given size options, we use
an @methcomp{:around} method on @genfun{compose-space}.  The
@methcomp{:around} method will call the primary method only if necessary
(i.e., @code{(eq (slot-value pane 'space-requirement) nil)}), and store
the result of the call to the primary method in the
@slot{space-requirement} slot.

We then compute the space requirement of the pane as follows:

@lisp
     (setf (space-requirement-width ...)  (or explicit-width
           (space-requirement-width request)) ...
           (space-requirement-max-width ...)  (or explicit-max-width
           explicit-width (space-requirement-max-width request)) ...)
@end lisp

When the call to the primary method is not necessary we simply return
the stored value.

The @pane{spacer-pane} is an exception to the rule indicated above.  The
explicit size you can give for this pane should represent the margin
size.  So its primary method should only call compose on the child.  And
the around method will compute the explicit sizes for it from the space
requirement of the child and for the values given for the surrounding
space.

@node Change-space Notification Protocol
@subsection Change-space Notification Protocol

The purpose of the change-space notification protocol is to force a
recalculation of the space occupied by potentially each pane in the
@gloss{pane hierarchy}.  The protocol is triggerred by a call to
@genfun{note-space-requirement-changed} on a pane @var{P}. In McCLIM, we
must therefore invalidate the stored space-requirement value and
re-invoke @genfun{compose-space} on @var{P}.  Finally, the
@gloss{parent} of @var{P} must be notified recursively.

This process would be repeated for all the panes on a path from @var{P}
to the top-level pane, if it weren't for the fact that some panes
compute their space requirements independently of those of their
children.  Thus, we stop calling @genfun{note-space-requirement-changed}
in the following cases:

@itemize @bullet
@item
 when @var{P} is a @pane{restraining-pane},
@item
 when @var{P} is a @pane{top-level-sheet-pane}, or
@item
 when @var{P} has been given explicit values for @initarg{:width} and
  @initarg{:height}
@end itemize

In either of those cases, @genfun{allocate-space} is called.

@node Output Protocol
@chapter Output Protocol

@menu
* Protocol Changes::
@end menu

@node Protocol Changes
@section Protocol Changes

@include fun-clim-extensions-line-style-effective-thickness.texi

@deffn {Generic Function} {(setf output-record-parent)} parent record

Additional protocol generic function. @var{parent} may be an output
record or @cl{nil}.

@end deffn

@include fun-clim-replay-output-record.texi
@include fun-clim-map-over-output-records-containing-position.texi
@include fun-clim-map-over-output-records-overlapping-region.texi

@c XXX \defgeneric displayed-output-record-ink for text records

@deffn {Generic Function} {add-output-record} child record

Sets @var{record} to be the parent of @var{child}.
@end deffn

@deffn {Generic Function} {delete-output-record} child record &optional (errorp t)

If @var{child} is a child of @var{record}, sets the parent of
@var{child} to @cl{nil}.
@end deffn

@deffn {Generic Function} {clear-output-record} record
@end deffn

Sets the parent of all children of @var{record} to @cl{nil}.

@c \defgeneric {invoke-with-new-output-record} :parent key

@include macro-clim-with-new-output-record.texi
@include macro-clim-with-output-to-output-record.texi

@node Command Processing
@chapter Command Processing
@cindex command
@cindex command processing
@cindex command tables

@deffn {Macro} {define-command-table} name &key inherit-from menu inherit-menu
@findex define-command-table
@end deffn
@deffn {Macro} {make-command-table} {name &key inherit-from inherit-menu (errorp t)}
@findex make-command-table
@end deffn

By default command tables inherit from
@cl{global-command-table}. According to the CLIM~2.0 specification, a
command table inherits from no command table if \nil\ is passed as an
explicit argument to @var{inherit-from}. In revision~2.2 all command
tables must inherit from @cl{global-command-table}. McCLIM treats a
\nil\ value of @var{inherit-from} as specifying
@cl{'(global-command-table)}.

@c @node Extensions
@c @part Extensions

@node Output Protocol Extensions
@chapter Output Protocol Extensions
@cindex extensions

@include fun-clim-extensions-medium-miter-limit.texi

@node Output Recording Extensions
@chapter Output Recording Extensions
@cindex extensions

@menu
* Standard classes::
@end menu

@c map-over-output-records

@node Standard classes
@section Standard classes

@deftp {Class} standard-output-recording-stream
@end deftp

This class is mixed into some other stream class to add output recording
facilities. It is not instantiable.

@node Drawing Two-Dimensional Images
@chapter Drawing Two-Dimensional Images

@menu
* Image Architecture::
* Reading Image Files::
@end menu

@node Image Architecture
@section Image Architecture

@menu
* Images::
* Utility Functions::
@end menu

@node Images
@subsection Images

Images are all rectangular arrangements of pixels.  The type of a pixel
depends on the exact type of the image.  In addition, a pixel has a
color which also depends on the exact type of the image.  You can think
of the color as an interpretation of the pixel value by the type of
image.

The coordinate system of an image has (0,0) in its upper-left corner.
The x coordinate grows to the right and the y coordinate downwards.

@deftp {Protocol Class} image

This class is the base class for all images.
@end deftp

@deffn {Generic Function} {image-width} image
@end deffn
@deffn {Generic Function} {image-height} image

This function returns the width and the height of the image
respectively.
@end deffn

@deffn {Generic Function} {image-pixels} image

This function returns a two-dimensional array of pixels, whose element
type depends on the exact subtype of the image.
@end deffn

@deffn {Generic Function} {image-pixel} image x y

This function returns the pixel at the coordinate indicated by the
values of x and y.  The type of the return value depends on the exact
image type.
@end deffn

@deffn {Generic Function} {(setf image-pixel)} x y pixel image

Set the value of the pixel at the coordinate indicated by the values of
x and y.  The exact type acceptable for the pixel argument depends on
the exact subtype of the image.  If x or y are not within the values of
the width and height of the image, an error is signaled.
@end deffn

@deffn {Generic Function} {image-color} image x y

This function returns the color value of the pixel indicated by the
values of x and y.  The exact type of the return value depends on the
specific subtype of the image.
@end deffn

@deffn {Generic Function} {(setf image-color)} x y color image

Set the color value of the pixel at the coordinate indicated by the
values of x and y.  The exact type acceptable for the color argument
depends on the exact subtype of the image.  In addition, the exact color
given to the pixel may be an approximation of the value of the color
argument.  For instance, if the image is a gray-level image, then the
color given will correspond to the intensity value of the color
argument.  If x or y are not within the values of the width and height
of the image, an error is signaled.
@end deffn

@deftp {Protocol Class} spectral-image

This class is a subclass of the image class.  It is the root of a
subhiearchy for manipulating images represented in various spectral
formats, other than RGB.  [This subhierarchy will be elaborated later in
the context of the color model of Strandh and Braquelaire].
@end deftp

@deftp {Protocol Class} rgb-image

This class is a subclass of the image class.  It is the root of a
subhierarchy for manipulating images whose pixel colors are represented
as RGB coordinates.  The function image-color always returns a value of
type (unsigned-byte 24) for images of this type, representing three
different intensity values of 0-255.
@end deftp

@deftp {Protocol Class} truecolor-image

This class is a subclass of the rgb-image class.  Images of this class
have pixel values of type (unsigned-byte 24).  The pixel values directly
represent RGB values.
@end deftp

@deftp {Protocol Class} colormap-image

This class is a subclass of the rgb-image class.  Images of this class
have pixel values that don't directly indicate the color of the pixel.
The translation between pixel value and color may be implicit (as is the
case of gray-level images) or explicit with a colormap stored in the
image object.
@end deftp

@deftp {Protocol Class} gray-level-image

This class is a subclass of the colormap-image class.  Images of this
type have pixel values that implicitely represent a gray-level.  The
function pixel-color always returns an RGB value that corresponds to the
identical intensities for red, green, and blue, according to the pixel
value.
@end deftp

@deffn {Generic Function} {gray-image-max-levels} gray-level-image

This function returns the maximum number of levels of gray that can be
represented by the image.  The value returned by this function minus one
would yield a color value of 255,255,255 if it were the value of a
pixel.
@end deffn

@deffn {Generic Function} {gray-image-max-level} gray-level-image

This function returns the maximum level currently present in the image.
This function may be very costly to compute, as it might have to scan
the entire image.
@end deffn

@deffn {Generic Function} {gray-image-min-level} gray-level-image

This function returns the minimum level currently present in the image.
This function may be very costly to compute, as it might have to scan
the entire image.
@end deffn

@deftp {Class} {256-gray-level-image}

This class is a subclass of the gray-level-image class.  Images of this
type have pixels represented as 8-bit unsigned pixels.  The function
image-pixel always returns a value of type (unsigned-byte 8) for images
of this type.  The function gray-image-max-levels returns 256 for all
instances of this class.
@end deftp

@deftp {Class} {binary-image}

This class is a subclass of the gray-level-image class.  Images of this
type have pixel values of type bit.  The function image-pixel returns
values of type bit when applied to an image of this type.  The function
pixel-color returns 0,0,0 for zero-valued bits and 255,255,255 for
one-valued bits.
@end deftp

@node Utility Functions
@subsection Utility Functions

@deffn {Generic Function} {rotate-image} image angle &key (antialias t)
@end deffn
@deffn {Generic Function} {flip-image} {image ...}
@end deffn
@deffn {Generic Function} {translate-image} {image ...}
@end deffn
@deffn {Generic Function} {scale-image} {image ...}
 ...
@end deffn

@node Reading Image Files
@section Reading Image Files

@deffn {Generic Function} {read-image} source &key type width height

Read an image from the source.  The source can be a pathname designator
(a string or a path), or a stream.  The caller can supply a value for
type, width, and height for sources that don't indicate these values.  A
value of nil for type means recognize the type automatically.  Other
values for type are :truecolor (an array of 3-byte color values)
:256-gray-level (an array of 1-byte gray-level values) :binary (an array
of bits).
@end deffn

@deffn {Generic Function} {write-image} image destination &key (type :pnm) (quality 1)

Write the image to the destination.  The destination can be a pathname
designator (a string or a path), or a stream.  Valid values of type are
:pnm (pbm, pgm, or ppm according to the type of image), :png, :jpeg,
(more...).  The quality argument is a value from 0 to 1 and indicates
desired image quality (for formats with lossy compression).
@end deffn

@node File Selector Gadget
@chapter File Selector Gadget

@node PostScript Backend
@chapter PostScript Backend

@menu
* Postscript Fonts::
* Additional functions::
@end menu

@node Postscript Fonts
@section Postscript Fonts

Font mapping is a cons, the car of which is the name of the font
(FontName field in the AFM file), and the cdr is the size in points.
Before establishing the mapping, an information about this font should
be loaded with the function @cl{load-afm-file}.

@node Additional functions
@section Additional functions

Package @cl{clim-postscript} exports the following functions:

@deffn {Function} {load-afm-file} afm-filename
@end deffn

Loads a description of a font from the specified AFM file.

@include drei.texi

@node Fonts and Extended Text Styles
@chapter Fonts and Extended Text Styles

@menu
* Extended Text Styles::
* Listing Fonts::
@end menu

@node Extended Text Styles
@section Extended Text Styles

McCLIM extends the legal values for the @cl{family} and @cl{face}
arguments to @cl{make-text-style} to include strings (in additional to
the portable keyword symbols), as permitted by the CLIM spec, section
11.1.

Each backend defines its own specific syntax for these family and face
names.

The CLX backend maps the text style family to the X font's
@emph{foundry} and @emph{family} values, separated by a dash.  The
face is mapped to @emph{weight} and @emph{slant} in the same way.  For
example, the following form creates a text style for
@emph{-misc-fixed-bold-r-*-*-18-*-*-*-*-*-*-*}:

@lisp
(make-text-style "misc-fixed" "bold-r" 18)
@end lisp

In the GTK backend, the text style family and face are used directly
as the Pango font family and face name.  Please refer to Pango
documentation for details on the syntax of face names.  Example:

@lisp
(make-text-style "Bitstream Vera Sans" "Bold Oblique" 54)
@end lisp

@node Listing Fonts
@section Listing Fonts

McCLIM's font listing functions allow applications to list all
available fonts available on a @class{port} and create text style
instances for them.

Example:

@lisp
* (find "Bitstream Vera Sans Mono"
        (clim-extensions:port-all-font-families (clim:find-port))
        :key #'clim-extensions:font-family-name
        :test #'equal)
#<CLIM-GTKAIRO::PANGO-FONT-FAMILY Bitstream Vera Sans Mono>

* (clim-extensions:font-family-all-faces *)
(#<CLIM-GTKAIRO::PANGO-FONT-FACE Bitstream Vera Sans Mono, Bold>
 #<CLIM-GTKAIRO::PANGO-FONT-FACE Bitstream Vera Sans Mono, Bold Oblique>
 #<CLIM-GTKAIRO::PANGO-FONT-FACE Bitstream Vera Sans Mono, Oblique>
 #<CLIM-GTKAIRO::PANGO-FONT-FACE Bitstream Vera Sans Mono, Roman>)

* (clim-extensions:font-face-scalable-p (car *))
T

* (clim-extensions:font-face-text-style (car **) 50)
#<CLIM:STANDARD-TEXT-STYLE "Bitstream Vera Sans Mono" "Bold" 50>
@end lisp

@include class-clim-extensions-font-family.texi
@include class-clim-extensions-font-face.texi

@include fun-clim-extensions-port-all-font-families.texi

@include fun-clim-extensions-font-family-name.texi
@include fun-clim-extensions-font-family-port.texi
@include fun-clim-extensions-font-family-all-faces.texi

@include fun-clim-extensions-font-face-name.texi
@include fun-clim-extensions-font-face-family.texi
@include fun-clim-extensions-font-face-all-sizes.texi
@include fun-clim-extensions-font-face-text-style.texi

@node Tab Layout
@chapter Tab Layout

The tab layout is a composite pane arranging its children so that
exactly one child is visible at any time, with a row of buttons
allowing the user to choose between them.

See also the tabdemo.lisp example code located under Examples/ in the
McCLIM distribution.  It can be started using demodemo.

@include class-clim-tab-layout-tab-layout.texi
@include class-clim-tab-layout-tab-layout-pane.texi
@include class-clim-tab-layout-tab-page.texi
@include macro-clim-tab-layout-with-tab-layout.texi

@include fun-clim-tab-layout-tab-layout-pages.texi

@include fun-clim-tab-layout-tab-page-tab-layout.texi
@include fun-clim-tab-layout-tab-page-title.texi
@include fun-clim-tab-layout-tab-page-pane.texi
@include fun-clim-tab-layout-tab-page-presentation-type.texi
@include fun-clim-tab-layout-tab-page-drawing-options.texi

@include fun-clim-tab-layout-add-page.texi
@include fun-clim-tab-layout-remove-page.texi
@include fun-clim-tab-layout-tab-layout-enabled-page.texi
@include fun-clim-tab-layout-sheet-to-page.texi
@include fun-clim-tab-layout-find-tab-page-named.texi
@include fun-clim-tab-layout-switch-to-page.texi
@include fun-clim-tab-layout-remove-page-named.texi

@include fun-clim-tab-layout-note-tab-page-changed.texi

@c com-switch-to-tab-page
@c com-remove-tab-page

@c @node Utility Programs
@c @part Utility Programs

@node Listener
@chapter Listener
@cindex Lisp Listener
@cindex CLIM Listener
@cindex Listener

@node Inspector
@chapter Inspector
@cindex inspector
@cindex Clouseau

The inspector, called ``Clouseau'', is used for interactively inspecting
objects. It lets you look inside objects, inspect slots, disassemble and
trace functions, view keys and values in hash tables, and quite a few
other things as well. It can be extended to aid in debugging of specific
programs, similar to the way the Lisp printer can be extended with
@genfun{print-object}.

@menu
* Usage::
* Extending Clouseau::
* API::
@end menu

@node Usage
@section Usage

@menu
* Quick Start::
* The Basics::
* Handling of Specific Data Types::
@end menu

@node Quick Start
@subsection Quick Start

To get up and running quickly with Clouseau:

@enumerate
@item
 With ASDF and McCLIM loaded, load the file

  @t{mcclim/Apps/Inspector/inspector.asd}.
@item
 Load Clouseau with:

@t{(asdf:operate 'asdf:load-op :clouseau)}
@item
 Inspect an object with @t{(clouseau:inspector @i{object})}. If you use
    a multithreaded Lisp implementation, you can also include the
    @cl{:new-process} keyword argument. If it is @cl{t}, then Clouseau
    is started in a seperate process. This should be relatively safe; it
    is even possible to have an inspector inspecting another running
    inspector.
@end enumerate

@node The Basics
@subsection The Basics

Once you inspect something, you will see a full representation of the
object you are inspecting and short representations of objects contained
within it. This short representation may be something like
@cl{#<STANDARD-CLASS SALAD-MIXIN>} or something as short as ``@dots{}''.
To see these objects inspected more fully, left-click on them and they
will be expanded. To shrink expanded objects, left-click on them again
and they will go back to a brief form.

That's really all you need to know to get started. The best way to learn
how to use Clouseau is to start inspecting your own objects.

@node Handling of Specific Data Types
@subsection Handling of Specific Data Types

@menu
* Standard Objects::
* Structures::
* Generic Functions::
* Functions::
* Symbols::
* Lists and Conses::
@end menu

Clouseau can handle numerous data types in different ways. Here are some
handy features you might miss if you don't know to look for them:

@node Standard Objects
@subsubsection Standard Objects

Standard objects have their slots shown, and by left-clicking on the
name of a slot you can change the slot's value. You can see various slot
attributes by middle clicking on a slot name.

@node Structures
@subsubsection Structures

Structures are inspected the same way as standard objects.

@node Generic Functions
@subsubsection Generic Functions

You can remove methods from generic functions with the @t{Remove Method}
command.

@node Functions
@subsubsection Functions

You can disassemble functions with the @t{Toggle Disassembly}
command. If the disassembly is already shown, this command hides it.

@node Symbols
@subsubsection Symbols

If a symbol is fbound, you can use the @t{Trace} and @t{Untrace}
commands to trace and untrace the function bound to it.

@node Lists and Conses
@subsubsection Lists and Conses

Lists and conses can be displayed in either the classic format (such as
@t{(1 3 (4 . 6) "Hello" 42)}) or a more graphical cons-cell diagram
format. The default is the classic format, but this can be toggled with
the @t{Toggle Show List Cells} command.

The new cons cell diagram format looks like this:

@center @image{inspect-as-cells}

@node Extending Clouseau
@section Extending Clouseau

Sometimes Clouseau's built-in inspection abilities aren't enough, and
you want to be able to extend it to inspect one of your own classes in a
special way. Clouseau supports this, and it's fairly simple and
straightforward.

Suppose that you're writing a statistics program and you want to
specialize the inspector for your application. When you're looking at a
sample of some characteristic of a population, you want to be able to
inspect it and see some statistics about it, like the average. This is
easy to do.

We define a class for a statistical sample. We're keeping this very
basic, so it'll just contain a list of numbers:

@lisp
(in-package :clim-user)
(use-package :clouseau)

(defclass sample ()
  ((data :initarg :data
         :accessor data
         :type list :initform '()))
  (:documentation "A statistical sample"))

(defgeneric sample-size (sample)
  (:documentation "Return the size of a statistical sample"))

(defmethod sample-size ((sample sample))
  (length (data sample)))
@end lisp

The @genfun{print-object} function we define will print samples
unreadably, just showing their sample size. For example, a sample with
nine numbers will print as @t{#<SAMPLE n=9>} We create such a sample
and call it @cl{*my-sample*}.

@lisp
(defmethod print-object ((object sample) stream)
  (print-unreadable-object (object stream :type t)
    (format stream "n=~D" (sample-size object))))

(defparameter *my-sample*
  (make-instance 'sample
                 :data '(12.8 3.7 14.9 15.2 13.66
                         8.97 9.81 7.0 23.092)))
@end lisp

We need some basic statistics functions. First, we'll do sum:

@lisp
(defgeneric sum (sample)
  (:documentation "The sum of all numbers in a statistical
sample"))

(defmethod sum ((sample sample))
  (reduce #'+ (data sample)))
@end lisp

Next, we want to be able to compute the mean. This is just the standard
average that everyone learns: add up all the numbers and divide by how
many of them there are. It's written @math{\overline {x}}

@lisp
(defgeneric mean (sample)
  (:documentation "The mean of the numbers in a statistical
sample"))

(defmethod mean ((sample sample))
  (/ (sum sample)
     (sample-size sample)))
@end lisp

Finally, to be really fancy, we'll throw in a function to compute the
standard deviation. You don't need to understand this, but the standard
deviation is a measurement of how spread out or bunched together the
numbers in the sample are. It's called @math{s}, and it's computed like
this: @math{s = \sqrt{{1 \over N-1} \sum_{i=1}^N (x_i - \overline {x})^2}}

@lisp
(defgeneric standard-deviation (sample)
  (:documentation "Find the standard deviation of the numbers
in a sample. This measures how spread out they are."))

(defmethod standard-deviation ((sample sample))
  (let ((mean (mean sample)))
    (sqrt (/ (loop for x in (data sample)
                   sum (expt (- x mean) 2))
             (1- (sample-size sample))))))
@end lisp

This is all very nice, but when we inspect @cl{*my-sample*} all we see
is a distinctly inconvenient display of the class, its superclass, and
its single slot, which we actually need to @emph{click on} to see. In
other words, there's a lot of potential being missed here. How do we
take advantage of it?

We can define our own inspection functions. To do this, we have two
methods that we can define. To change how sample objects are inspected
compactly, before they are clicked on, we can define an
@genfun{inspect-object-briefly} method for our @cl{sample} class. To
change the full, detailed inspection of samples, we define
@genfun{inspect-object} for the class. Both of these methods take two
arguments: the object to inspect and a CLIM output stream. They are
expected to print a representation of the object to the stream.

Because we defined @genfun{print-object} for the @cl{sample} class to
be as informative as we want the simple representation to be, we don't
need to define a special @genfun{inspect-object-briefly} method. We
should, however, define @genfun{inspect-object}.

@lisp
(defmethod inspect-object ((object sample) pane)
  (inspector-table (object pane)
      ;; This is the header
      (format pane "SAMPLE n=~D" (sample-size object))
    ;; Now the body
    (inspector-table-row (pane)
      (princ "mean" pane)
      (princ (mean object) pane))
    (inspector-table-row (pane)
      (princ "std. dev." pane)
      (princ (standard-deviation object) pane))))
@end lisp

Here, we introduce two new macros. @fmacro{inspector-table} sets up a box
in which we can display our representation of the sample. It handles
quite a bit of CLIM work for us. When possible, you should use it
instead of making your own, since using the standard facilities helps
ensure consistency.

The second macro, @fmacro{inspector-table-row}, creates a row with the
output of one form bolded on the left and the output of the other on the
right. This gives us some reasonably nice-looking output:

@center @image{inspect-object-1}

But what we really want is something more closely adapted to our
needs. It would be nice if we could just have a table of things like
@math{ \overline {x} = 12.125776 } and have them come out formatted
nicely. Before we attempt mathematical symbols, let's focus on getting
the basic layout right. For this, we can use CLIM's table formatting.

@lisp
(defmethod inspect-object ((object sample) pane)
  (inspector-table (object pane)
      ;; This is the header
      (format pane "SAMPLE n=~D" (sample-size object))
    ;; Now the body
    (inspector-table-row (pane)
      (princ "mean" pane)
      (princ (mean object) pane))
    (inspector-table-row (pane)
      (princ "std. dev." pane)
      (princ (standard-deviation object) pane))))
@end lisp

In this version, we define a local function @cl{x=y} which outputs a row
showing something in the form ``label = value''. If you look closely,
you'll notice that we print the label with @cl{princ} but we print the
value with @genfun{inspect-object}. This makes the value inspectable, as
it should be.

Then, in the @fmacro{inspector-table} body, we insert a couple of calls
to @cl{x=y} and we're done. It looks like this:

@center @image{inspect-object-2}

Finally, for our amusement and further practice, we'll try to get some
mathematical symbols---in this case we'll just need @math{\overline
{x}}. We can get this by printing an italic @math{x} and drawing a line
over it:

@lisp
(defun xbar (stream)
  "Draw an x with a bar over it"
  (with-room-for-graphics (stream)
    (with-text-face (stream :italic)
      (princ #\x stream)
      (draw-line* stream 0 0
                  (text-style-width *default-text-style*
                                    stream) 0))))

(defmethod inspect-object ((object sample) pane)
  (flet ((x=y (x y)
           (formatting-row (pane)
             (formatting-cell (pane :align-x :right)
               ;; Call functions, print everything else in italic
               (if (functionp x)
                   (funcall x pane)
                   (with-text-face (pane :italic)
                     (princ x pane))))
             (formatting-cell (pane) (princ "=" pane))
             (formatting-cell (pane)
               (inspect-object y pane)))))
    (inspector-table (object pane)
        ;; This is the header
        (format pane "SAMPLE n=~D" (sample-size object))
      ;; Now the body
      (x=y #'xbar (mean object))
      (x=y #\S (standard-deviation object)))))
@end lisp

Finally, to illustrate the proper use of
@genfun{inspect-object-briefly}, suppose that we want the ``n=9'' (or
whatever the sample size @math{n} equals) part to have an itlicised
@math{n}. We can fix this easily:

@lisp
(defmethod inspect-object-briefly ((object sample) pane)
  (with-output-as-presentation (pane object 'sample)
    (with-text-family (pane :fix)
      (print-unreadable-object (object pane :type t)
        (with-text-family (pane :serif)
          (with-text-face (pane :italic)
            (princ "n" pane)))
        (format pane "=~D" (sample-size object))))))
@end lisp

Notice that the body of @genfun{inspect-object-briefly} just prints a
representation to a stream, like @genfun{inspect-object} but shorter.
It should wrap its output in @fmacro{with-output-as-presentation}.
@genfun{inspect-object} does this too, but it's hidden in the
@fmacro{inspector-table} macro.

Our final version looks like this:

@center @image{inspect-object-3}

For more examples of how to extend the inspector, you can look at
@t{inspector.lisp}.

@node API
@section API

The following symbols are exported from the @cl{clouseau} package:

@deftp {Function} {inspector} object &key new-process

Inspect @cl{object}. If @cl{new-process} is @cl{t}, Clouseau will be run
in a new process.
@end deftp

@deffn {Generic Function} {inspect-object} object pane

Display inspected representation of @cl{object} to the extended output
stream @cl{pane}. This requires that @cl{*application-frame*} be bound
to an inspector application frame, so it isn't safe to use in other
applications.
@end deffn

@deffn {Generic Function} {inspect-object-briefly} object pane

A brief version of @genfun{inspect-object}. The output should be short,
and should try to fit on one line.
@end deffn

@deffn {Generic Function} {define-inspector-command} name args &rest body

This is just an inspector-specific version of
@genfun{define-command}. If you want to define an inspector command for
some reason, use this.
@end deffn

@deffn {Macro} {inspector-table} (object pane) header \body body

Present @cl{object} in tabular form on @cl{pane}, with @cl{header}
evaluated to print a label in a box at the top. @cl{body} should output
the rows of the table, possibly using @cl{inspector-table-row}.
@end deffn

@deffn {Macro} {inspector-table-row} (pane) left right

Output a table row with two items, produced by evaluating @cl{left} and
@cl{right}, on @cl{pane}. This should be used only within
@cl{inspector-table}.

When possible, you should try to use this and @cl{inspector-table} for
consistency, and because they handle quite a bit of effort for you.
@end deffn

@c @node Auxiliary Material
@c @part Auxiliary Material

@node Glossary
@chapter Glossary

@c @glossentry{Direct mirror}
@b{Direct mirror}
@cindex Direct mirror

A @gloss{mirror} of a sheet which is not shared with any of the
ancestors of the sheet.  All grafted McCLIM sheets have mirrors, but not
all have direct mirrors.  A McCLIM sheet that does not have a direct
mirror uses the direct mirror of its first ancestor having a direct
mirror for graphics output.  Asking for the direct mirror of a sheet
that does not have a direct mirror returns nil.

Whether a McCLIM sheet has a direct mirror or not, is decided by the
frame manager.  Some frame managers may only allow for the graft to be a
mirrored sheet.  Even frame managers that @emph{allow} hierarchical
mirrors may decide not to allocate a direct mirror for a particular
sheet.  Although sheets with a direct mirror must be instances of the
class mirrored-sheet-mixin, whether a McCLIM sheet has a direct mirror
or not is not determined statically by the class of a sheet, but
dynamically by the frame manager.

@c @glossentry{Mirror}
@b{Mirror}
@cindex Mirror

A device window such as an X11 window that parallels a @gloss{sheet} in
the CLIM @gloss{sheet hierarchy}.  A @gloss{sheet} having such a
@emph{direct} mirror is called a @gloss{mirrored sheet}.  When
@gloss{drawing functions} are called on a @gloss{mirrored sheet}, they
are forwarded to the host windowing system as drawing commands on the
@gloss{mirror}.

CLIM @gloss{sheet}s that are not mirrored must be @gloss{descendents}
(direct or indirect) of a @gloss{mirrored sheet}, which will then be the
@gloss{sheet} that receives the drawing commands.

@c @glossentry{Mirrored sheet}
@b{Mirrored sheet}
@cindex Mirrored sheet

A @gloss{sheet} in the CLIM @gloss{sheet hiearchy} that has a direct
parallel (called the @gloss{direct mirror}) in the host windowing
system.  A mirrored sheet is always an instance of the class
@class{mirrored-sheet-mixin}, but instances of that class are not
necessarily mirrored sheets.  The sheet is called a mirrored sheet only
if it currently has a direct mirror.  There may be several reasons for
an instance of that class not to currently have a direct mirror.  One is
that the sheet is not @gloss{grafted}.  Only grafted sheets can have
mirrors.  Another one is that the @gloss{frame manager} responsible for
the look and feel of the sheet hierarchy may decide that it is
inappropriate for the sheet to have a direct mirror, for instance if the
underlying windowing system does not allow nested windows inside an
application, or that it would simply be a better use of resources not to
create a direct mirror for the sheet.  An example of the last example
would be a stream pane inside a the @gloss{viewport} of a
@gloss{scroller pane}.  The graphics objects (usually text) that appear
in a stream pane can have very large coordinate values, simply because
there are many lines of text.  Should the stream pane be mirrored, the
coordinate values used on the mirror may easily go beyond what the
underlying windowing system accepts.  X11, for instance, can not handle
coordinates greater than 64k (16 bit unsigned integer).  By not having a
direct mirror for the stream pane, the coordinates will be translated to
those of the (not necessarily direct) mirror of the @gloss{viewport}
before being submitted to the windowing system, which gives more
reasonable coordinate values.

It is important to realize the implications of this terminology.  A
mirrored sheet is therefore not a sheet that has a mirror.  All grafted
sheets have mirrors.  For the sheet to be a mirrored sheet it has to
have a @emph{direct} mirror.  Also, a call to @genfun{sheet-mirror}
returns a mirror for all grafted sheets, whether the sheet is a mirrored
sheet or not.  A call to @genfun{sheet-direct-mirror}, on the other
hand, returns nil if the sheet is not a mirrored sheet.

@c @glossentry{Mirror transformation}
@b{Mirror transformation}
@cindex Mirror transformation

The transformation that transforms coordinates in the coordinate system
of a mirror (i.e. the native coordinates of the mirror) to native
coordinates of its parent in the underlying windowing system.  On most
systems, including X, this transformation will be a simple translation.

@c @glossentry{Native coordinates}
@b{Native coordinates}
@cindex Native coordinates

Each mirror has a coordinate system called the native coordinate system.
Usually, the native coordinate system of a mirror has its origin in the
upper-left corner of the mirror, the x-axis grows to the right and the
y-axis downwards.  The unit is usually pixels, but the frame manager can
impose a native coordinate system with other units, such as millimeters.

The native coordinate system of a sheet is the native coordinate system
of its mirror (direct or not).  Thus, a sheet without a direct mirror
has the same native coordinate system as its parent.  To obtain native
coordinates of the parent of a mirror, use the @gloss{mirror
transformation}.

@c @glossentry{Native region}
@b{Native region}
@cindex Native region

The native region of a sheet is the intersection of its region and the
sheet region of all of its parents, expressed in the @gloss{native
coordinates} of the sheet.

@c @glossentry{Potentially visible area}
@b{Potentially visible area}
@cindex Potentially visible area

A bounded area of an otherwise infinte drawing plane that is visible
unless it is covered by other visible areas.

@c @glossentry{Sheet coordinates}
@b{Sheet coordinates}
@cindex Sheet coordinates

The coordinate system of coordinates obtained by application of the
@gloss{user transformation}.

@c @glossentry{Sheet region}
@b{Sheet region}
@cindex Sheet region

The @gloss{region} of a sheet determines the visible part of the drawing
plane.  The dimensions of the sheet region are given in @gloss{sheet
coordinates}.  The location of the visible part of a sheet within its
@gloss{parent sheet} is determined by a combination of the @gloss{sheet
transformation} and the position of the sheet region.

For instance, assuming that the sheet region is a rectangle with its
upper-left corner at (2, 1) and that the sheet transformation is a
simple translation (3, 2).  Then the origin of the @gloss{sheet
coordinate system} is at the point (3, 2) within the @gloss{sheet
coordinate system} of its @gloss{parent sheet}.  The origin of its the
coordinate system is not visible, however, because the visible region
has its upper-left corner at (2, 1) in the @gloss{sheet coordinate
system}.  Thus, the visible part will be a rectangle whose upper-left
corner is at (5, 3) in the @gloss{sheet coordinate system} of the
@gloss{parent sheet}.

Panes and gadgets alter the region and @gloss{sheet transformation} of
the underlying sheets (panes and gadgets are special kinds of sheets) to
obtain effects such as scrolling, zooming, coordinate system
transformations, etc.

@c @glossentry{Sheet transformation}
@b{Sheet transformation}
@cindex Sheet transformation

The transformation used to transform @gloss{sheet coordinates} of a
sheet to @gloss{sheet coordinates} of its @gloss{parent sheet}.  The
sheet transformation determine the position, shape, etc. of a sheet
within the coordinate system of its parent.

Panes and gadgets alter the transformation and @gloss{sheet region} of
the underlying sheets (panes and gadgets are special kinds of sheets) to
obtain effects such as scrolling, zooming, coordinate system
transformations, etc.

@c @glossentry{User Clipping region }
@b{User Clipping region }
@cindex User Clipping region 

A @gloss{clipping region} used to limit the effect of @gloss{drawing
functions}.  The user @gloss{clipping region} is stored in the
@gloss{medium}.  It can be altered either by updating the
@gloss{medium}, or by passing a value for the :clipping-region
@gloss{drawing option} to a @gloss{drawing function}.

@c @glossentry{User Coordinates}
@b{User Coordinates}
@cindex User Coordinates

The coordinate system of coordinates passed to the @gloss{drawing
functions}.

@c @glossentry{User Transformation}
@b{User Transformation}
@cindex User Transformation

A transformation used to transform @gloss{user coordinates} into
@gloss{sheet coordinates}.  The user transformation is stored in the
@gloss{medium}.  It can be altered either by updating the
@gloss{medium}, or by passing a value for the :transformation
@gloss{drawing option} to a @gloss{drawing function}.

@c @glossentry{Visible area}
@b{Visible area}
@cindex Visible area

@node Development History
@chapter Development History

Mike McDonald started developing McCLIM in 1998.  His initial objective
was to be able to run the famous ``address book'' demo, and to
distribute the first version when this demo ran.  With this in mind, he
worked ``horizontally'', i.e., writing enough of the code for many of
the chapters of the specification to be able to run the address book
example.  In particular, Mike wrote the code for chapters 15 (Extended
Stream Output), 16 (Output Recording), and 28 (Application Frames), as
well as the code for interactor panes.  At the end of 1999, Mike got too
busy with other projects, and nothing really moved.

Also in 1998, Gilbert Baumann started working ``vertically'', writing a
mostly-complete implementation of the chapters 3 (Regions) and 5 (Affine
Transformations).  At the end of 1999, he realized that he was not going
to be able to finish the project by himself.  He therfore posted his
code to the free-CLIM mailing list.  Gilbert's code was distributed
according to the GNU Lesser General Public Licence (LGPL).

Robert Strandh picked up the project in 2000, starting from Gilbert's
code and writing large parts of chapters 7 (Properties of Sheets) and 8
(Sheet Protocols) as well as parts of chapters 9 (Ports, Grafts, and
Mirrored Sheets), 10 (Drawing Options), 11 (Text Styles), 12 (Graphics),
and 13 (Drawing in Color).

In early 2000, Robert got in touch with Mike and eventually convinced
him to distribute his code, also according to the LGPL.  This was a
major turning point for the project, as the code base was now
sufficiently large that a number of small demos were actually running.
Robert then spent a few months merging his code into that produced by
Mike.

Arthur Lemmens wrote the initial version of the code for the gadgets in
june of 2000.

Bordeaux students Iban Hatchondo and Julien Boninfante were hired by
Robert for a 3-month summer project during the summer of 2000.  Their
objective was to get most of the pane protocols written (in particular
space composition and space allocation) as well as some of the gadgets
not already written by Arthur, in particular push buttons.  The
calculator demo was written to show the capabilities of their code.

In July of 2000, Robert invited Gilbert to the LSM-2000 metting in
Bordeaux (libre software meeting).  This meeting is a gathering of
developers of free software with the purpose of discussing strategy,
planning future projects, starting new ones, and working on existing
ones.  The main result of this meeting was that Gilbert managed to merge
his code for regions and transformations into the main code base written
by Mike, Robert, Iban, and Julien.  This was also a major step towards a
final system.  We now had one common code base, with a near-complete
implementation of regions, transformations, sheet protocols, ports,
grafts, graphics, mediums, panes, and gadgets.

Meanwhile, Mike was again able to work on the project, and during 2000
added much of the missing code for handling text interaction and
scrolling.  In particular, output recording could now be used to
redisplay the contents of an interactor pane.  Mike and Robert also
worked together to make sure the manipulation of sheet transformations
and sheet regions as part of scrolling and space-allocation respected
the specification.

Robert had initially planned for Iban and Julien to work on McCLIM for
their fifth-year student project starting late 2000 and continuing until
end of march 2001.  For reasons beyond his control, however, he was
forced to suggest a different project.  Thus, Iban and Julien, together
with two other students, were assigned to work on Gsharp, an interactive
score editor.  Gsharp was the original reason for Robert to start
working on CLIM as he needed a toolkit for writing a graphical user
interface for Ghsarp.  The lack of a freely-available version of a
widely-accepted toolkit such as CLIM made him decide to give it a shot.
Robert's idea was to define the student project so that a maximum of
code could be written as part of McCLIM.  The result was a complete
rewrite of the space-allocation and space-composition protocols, and
many minor code snippets.

As part of the Gsharp project, Robert wrote the code for menu bars and
for a large part of chapter 27 (Command Processing).

Julien was hired for six months (April to September of 2001) by Robert
to make major progress on McCLIM.  Julien's first task was to create a
large demo that showed many of the existing features of McCLIM (a
``killer app'').  It was decided to use Gsharp since Julien was already
familiar with the application and since it was a sufficiently
complicated application that most of the features would be tested.  An
additional advantage of a large application was to serve as a ``smoke
test'' to run whenever substantial modifications to the code base had
been made.  As part of the Gsharp project, Julien first worked on adding
the possibility of using images as button labels.

Early 2001, Robert had already written the beginning of a library for
manipulating 2-dimensional images as part of McCLIM.  A group of four
fourth-year students (Gregory Bossard, Michel Cabot, Cyrille Dindart,
Lionel Verg@'e) at the university of Bordeaux was assigned the task of
writing efficient code for displaying such images subject to arbitrary
affine transformations.  This code would be the base for drawing all
kinds of images such as icons and button labels, but also for an
application for manipulating document images.  The project lasted from
January to May of 2001.

Another group of four fourth-year students (Lo@"ic Lacomme, Nicolas Louis,
Arnaud Rouanet, Lionel Salabartan) at the university of Bordeaux was
assigned the task of writing a file-selector gadget presented as a tree
of directories and files, and with the ability to open and close
directories, to select files, etc.  The project lasted from January to
May of 2001.

One student in particular, Arnaud Rouanet started becoming interested in
the rest of CLIM as well.  During early 2001, he fixed several bugs and
also added new code, in particular in the code for regions, graphics,
and clx-mediums.

Arnaud and Lionel were hired by Robert for the summer of 2001 to work on
several things.  In particular, they worked on getting output recording
to work and wrote CLIM-fig, a demo that shows how output recording is
used.  They also worked on various sheet protocols, and wrote the first
version of the PostScript backend.

Alexey Dejneka joined the project in the summer of 2001. He wrote the
code for table formatting, bordered output and continued to develop the
PostScript output facility.

In the fall of 2001 Tim Moore became interested in the presentation type
system.  He implemented presentation type definition and presentation
method dispatch.  Wanting to see that work do something useful, he went
on to implement present and accept methods, extended input streams,
encapsulating streams, and the beginnings of input editing streams.  In
the spring of 2002 he wrote the core of Goatee, an Emacs-like editor.
This is used to implement CLIM input editing.

Brian Spilsbury became involved towards the beginning of 2001.  His
motivation for getting involved was in order to have
internationalization support.  He quickly realized that the first step
was to make SBCL and CMUCL support Unicode.  He therefore worked to make
that happen.  So far (summer 2001) he has contributed a number of
cosmetic fixes to McCLIM and also worked on a GTK-like gadget set.  He
finally started work to get the OpenGL backend operational.

@node Concept Index
@unnumbered Concept Index

@printindex cp

@node Variable Index
@unnumbered Variable Index

@printindex vr

@node Function And Macro Index
@unnumbered Function And Macro Index

@printindex fn

@c LocalWords:  viewport scroller mixin PostScript

@bye
