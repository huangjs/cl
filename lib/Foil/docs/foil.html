<html>
<head>
    <link rel="stylesheet" type="text/css" media="screen" href="foil.css">
    <title>Foil - a Foreign Object Interface for Lisp</title>
    <meta name="keywords" content="Rich Hickey, Foil, Lisp, Common Lisp, LispWorks, Java, CLI, CLR, JVM, C#"/>
    <meta name="author" content="Rich Hickey" />
</head>
    <body>
    <h2>Foil - a Foreign Object Interface for Lisp</h2> <h5>Copyright (c) Rich 
    Hickey and Eric Thorsen. All rights reserved.</h5>

    <p>
    The use and distribution terms for this software are covered by the <a href="http://opensource.org/licenses/cpl.php">Common 
    Public License 1.0</a>, which can be found in the file CPL.TXT at the root of 
    this distribution. By using this software in any fashion, you are agreeing to be 
    bound by the terms of this license. You must not remove this notice, or any 
    other, from this software.
    </p>

    <h2>Contents</h2>

    <ul>
        <li>
            <a href="#description">Description</a>
        </li>
        <li>
            <a href="#download">Download</a>
        </li>
        <li>
            <a href="#quickstart">Quick Start</a>
        </li>

        <li>
            <a href="#api">API Reference</a>
            <ul>
                <li>
                    <a href="#fvms">Foreign VMs</a>
                </li>
                <li>
                    <a href="#frefs">Foreign References</a>
                </li>
                <li>
                    <a href="#wrappergen">Wrapper Generation</a>
                </li>
                <li>
                    <a href="#objects">Object Creation</a>
                </li>
                <li>
                    <a href="#objectservices">Object Services</a>
                </li>
                <li>
                    <a href="#vectors">Vectors</a>
                </li>
                <li>
                    <a href="#misc">Miscellaneous</a>
                </li>
                <li>
                    <a href="#proxies">Proxies and Callbacks</a>
                </li>
                <li>
                    <a href="#marshalling">Marshalling</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#runtimeservers">Runtime Servers</a>
        </li>
        <li>
            <a href="#protocol">Protocol</a>
        </li>
        <li>
            <a href="#summary">Summary</a>
        </li>
    </ul>

    <a name="description"></a><h2>Description and Rationale</h2>

    Foil consists of a protocol and a set of libraries that facilitate access to 
    popular object runtimes, such as the JVM and the CLI/CLR, and their libraries, 
    from Lisp.  A protocol is defined which abstracts out the common features 
    provided by Java-like environments - object construction, method, field, and 
    property access, object lifetime management etc.  The protocol defines a set of 
    features as well as an s-expression based stream format for communication. 
    Runtime server applications are provided that utilize Java and C# libraries to 
    implement the object runtime side of the protocol for Java and the CLI.  Source 
    for the applications is provided so that custom hosts can be built.  A library 
    for Common Lisp is provided that implements the consumer side of the protocol, 
    and offers seamless access to the foreign objects in a Lisp-like manner.

    The design of Foil owes much to <a href="http://jfli.sourceforge.net/">jfli</a>, 
    an in-process solution to the same problem for Java, and it remains extremely 
    similar in its Lisp interface. Several factors motivated the significant 
    difference in the Foil design - its use of an out-of-process instance of the 
    foreign runtime:

    <ul>
        <li>
            jfli did not see wide porting, due to its use of LispWorks' sophisticated FLI to 
            access JNI, and the lack of corresponding facilities in some other Lisps
        </li>
        <li>
            I found that I needed to access already-running instances of the JVM, for 
            instance servlet containers, as done in <a href="http://lisplets.sourceforge.net/">Lisplets</a>, 
            and felt I could accomplish similar things with less effort with Foil + 
            marshallers
        </li>
        <li>
            I wanted to access the CLR/CLI in a similar fashion to Java
        </li>
        <li>
            It allows for more flexibility in dealing with threading issues
        </li>
    </ul>

    The major tradeoff in stream-based access to out-of-proc runtimes is a 
    significant drop in per-call performance.  However, even with jfli, which was 
    very fast, the overhead of reflection per call could be high in certain 
    scenarios, since the APIs of these platforms tend to be very 'chatty'.  Foil 
    includes a marshalling system that allows for efficient transfer of large and 
    composite objects with minimal call overhead, in a manner that doesn't pollute 
    the Lisp code on the consumer side.

    <h4>Foil provides all the facilities of jfli and more - </h4>


    <h5>Features of jfli that are retained/enhanced:</h5>

    <ul>

        <li>
            Automatic function generation for constructors, fields, methods, and properties 
            either by named class, or entire package (sub)trees given a jar file or assembly 
            name.
        </li>

        <li>
            Java/CLI -> Lisp package and name mapping with an eye towards lack of surprise, 
            lack of conflict, and useful editor completion.
        </li>

        <li>
            setf-able setter generation for fields and properties
        </li>

        <li>
            Java/CLI vector creation and aref-like access to Java/CLI vectors.
        </li>

        <li>
            Constructors that allow for keyword-style property initialization.
        </li>

        <li>
            Typed references to Java/CLI objects with an inheritance hierarchy on the Lisp 
            side mirroring that on the Java/CLI side - allowing for Lisp methods specialized 
            on Java/CLI class and interface types.
        </li>

        <li>
            Implementation of arbitrary Java/CLI interfaces in Lisp, and callbacks from Java/CLI 
            to Lisp via those interfaces.
        </li>

        <li>
            Automatic lifetime maintenance of Lisp-referenced Java/CLI objects, boxing/unboxing 
            of primitive args/returns, string conversions, Java/CLI exception handling, 
            overload resolution etc.
        </li>
    </ul>
    <h5>Some of the additions are:</h5>

    <ul>
        <li>
            (Hopefully) Much improved portability (n.b. it has not been ported, but is 
            mostly standard CL)
        <li>
            Access to the CLR with the same API
        </li>
        <li>
            Support for CLR and JavaBean properties
        </li>
        <li>
            Simultaneous access to multiple runtimes
        </li>
        <li>
            Simultaneous access to the CLR and Java
        </li>
        <li>
            A marshalling system which can, in a single call, pull across the types, 
            hashcodes, and/or values of reference objects to an arbitrary depth, with user 
            customizable value marshallers.
        </li>
        <li>
            All references to the same remote object are <code>eq</code> on the Lisp side
        </li>
        <li>
            <code>ensure-typed-ref</code>, which makes a remote reference its most fully 
            derived type in Lisp, works in place, using <code>change-class</code>
        </li>
        <li>
            vector argument boxing, so lightweight vectors-as-arguments can be created in-place 
            without the overhead of multiple calls to create and initialize the vector
        </li>
        <li>
            keyword-style init of properties in constructor calls is supported by the ctor 
            functions, and can be leveraged in apply and mapping scenarios (this feature was 
            limited in jfli to the <code>new</code> macro)
        </li>
    </ul>



    <a name="download"></a> <h3>Download and Communication</h3>

    <p>
    <a href="http://sourceforge.net/projects/foil/">Foil is hosted on SourceForge</a>
    <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=125543&amp;type=1"
                                width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
    </p>
    <p>
    We are going to try using SourceForge facilities for all communication regarding 
    Foil, so please use the project tracker and forums there.
    </p>

    <a name="quickstart"></a> <h3>Quick Start</h3> Build and start the Java or CLI <a href="#runtimeservers">runtime 
    server</a> of your choice.

    <pre>
(compile-file "/dev/foil/foil.lisp")
(load "/dev/foil/foil")
(use-package :foil)
;this is specific to LispWorks' sockets support
(require "comm")
;create a foreign VM
(setf *fvm* (make-instance 'foreign-vm
                           :stream
                           (comm:open-tcp-stream "localhost" 13579)))

;;;;;;;;; if Java ;;;;;;;;;;;
;create a wrapper for dialog class
(def-foil-class "javax.swing.JOptionPane")
;use the wrapper
(use-package "javax.swing")
;show it
(joptionpane.showmessagedialog nil "Hello World from Lisp")

;;;;;;;;; if CLI ;;;;;;;;;;;;
;create a wrapper for dialog class
(def-foil-class "System.Windows.Forms.MessageBox")
;use the wrapper
(use-package "System.Windows.Forms")
;show it
(messagebox.show "Hello World from Lisp")</pre>

    <p>
    Typically you wouldn't define single class wrappers by hand, but would instead 
    pre-generate wrappers for entire packages using <code>get-library-classnames</code> 
    and <code>dump-wrapper-defs-to-file</code>. See <code>foil-java.lisp</code> and <code>foil-cli.lisp</code> 
    for examples.
    </p>

    <a name="api"></a> <h2>Lisp API Reference</h2>

    Other than 2 wrapper-generator helpers, all of the code for the Lisp side of 
    foil resides in <code>foil.lisp</code>, and is runtime server independent. Foil 
    is designed to be very portable, and is 99% pure Common Lisp. A complete port 
    requires some facility for weak hash tables and object finalization.

    <a name="fvms"></a> <h3>Foreign VMs</h3>
    <p>
    Foil is built upon the notion of interactions with one or more foreign VMs, 
    instances of the JVM or CLR, running the Foil libraries, in another process on 
    the same or another machine. The connection to a specific VM is via one or more 
    bidirectional streams. Note that the instantiation of the foreign VM and the 
    establishment of the streams is outside the scope of this Lisp API. It is 
    presumed you might utilize one of the supplied runtime servers, creating stream 
    connections via sockets or pipes with the API provided by your Lisp 
    implementation. Many scenarios are possible, including embedding the Foil 
    support libraries into your existing Java or C# application, multiple streams to 
    different threads in the same VM, etc.
    </p>
    <p>
    A foreign VM is represented by an instance of the <code>foreign-vm</code> class. 
    Each instance has a primary default stream over which communication will occur. 
    The special variable <code>*fvm*</code> represents the default VM to which any 
    unqualified Foil calls will be directed, and can be bound in a specific context, 
    thus allowing for multiple VMs. Note - instance property/method calls will 
    always be routed to the VM hosting that instance.
    </p>
    <p>
    Foreign VMs maintain their own foreign reference pools, type caches etc, and 
    objects from one VM cannot be passed to another, even if they are both Java or 
    CLI. However, in multi-thread, multi-stream scenarios, references are valid 
    across threads in the same VM, and the runtime server implementations are thread 
    safe.
    </p>
    <p>
    A simple startup scenario would look like this:
    </p>
    <p>
    - First, outside of Lisp, start the Java or CLI Foil runtime server supplied 
    with Foil, running on port 13579, then:
    <pre>
   (load "/dev/foil/foil")
   (use-package :foil)
   (require "comm") ;LispWorks-specific socket library
   (setf *fvm* (make-instance 'foreign-vm
                           :stream
                           (comm:open-tcp-stream "localhost" 13579)))
    ;use Foil  </pre>
    </p>
    <ul>
        <li>
            <strong>Special Variable</strong> <code>*fvm*</code>
            <p>
            This must be bound to an instance of <code>foreign-vm</code>. Default: nil <br>
            Direct use of this other than during initial setup is not recommended, use 
            instead <code>with-vm</code> or <code>with-vm-of</code>
            </p>
        </li>
        <li>
            <strong>Special Variable</strong> <code>*thread-fvm*</code>
            <p>
            If set, this thread is waiting on a callback from this VM. Default: nil <br>
            This is only used for advanced multi-thread scenarios
            </p>
        </li>
        <li>
            <strong>Special Variable</strong> <code>*thread-fvm-stream*</code>
            <p>
            If this thread is waiting on a callback (i.e. <code>*thread-fvm*</code> is bound), 
            and <code>(eql *fvm* *thread-fvm*)</code>, use this stream instead of the 
            primary default stream for the VM. Default: nil <br>
            This is only used for advanced multi-thread scenarios
            </p>
        </li>
        <li>
            <strong>Class</strong> <code>foreign-vm</code>
            <p>
            Manages a foreign VM. Requires the initarg <code>:stream</code> be set to a 
            bidirectional stream with an instance of the Foil runtime services on the other 
            end.
            </p>
        </li>
        <li>
            <strong>Macro</strong> <code>(with-vm vm &body body)</code>
            <p>
            Causes the body to be evaluated in a context where <code>*fvm*</code> is bound 
            to <code>vm</code>
            </p>
        </li>

        <li>
            <strong>Macro</strong> <code>(with-vm-of this &body body)</code>
            <p>
            Causes the body to be evaluated in a context where <code>*fvm*</code> is bound 
            to the source VM of <code>this</code>
            </p>
        </li>

    </ul>


    <a name="frefs"></a> <h3>Foreign References</h3> Foil programs invariably create 
    instances of objects in the foreign VM. Those objects are tracked by Lisp in 
    instances of the <code>fref</code> class. The Foil API and the runtime server 
    cooperate to ensure that objects referenced by Lisp are kept alive in the 
    foreign runtime, and that when no longer referenced by Lisp, they become 
    available for collection in the foreign VM. <code>frefs</code> maintain their 
    source VM, an ID and revision counter for this purpose. In addition, <code>frefs</code> 
    can cache hash codes, types, and values that have been marshalled. Only a single <code>fref</code> 
    will be created for each remote object, thus any 2 <code>frefs</code> that 
    reference the same object are themselves <code>eq</code>.

    <ul>
        <li>
            <strong>Class</strong> <code>fref</code>
            <p>
            Reference to a foreign object. <code>fref</code> is the superclass of all of the 
            Foil classes generated to mirror the foreign hierarchy.
            </p>
        </li>
        <li>
            <strong>Method</strong> <code>(fref-vm fref)</code> ->The foreign-vm from which 
            this reference originated
        </li>
        <li>
            <strong>Method</strong> <code>(fref-id fref)</code> ->An integer ID, unique 
            within a VM
        </li>

        <li>
            <strong>Method</strong> <code>(fref-type fref)</code> ->A Class or Type fref
            <p>
            This will only be set if the type has been marshalled or <code>get-type</code> 
            has been called on this fref.
            </p>
        </li>
        <li>
            <strong>Method</strong> <code>(fref-hash fref)</code> ->int
            <p>
            This will only be set if the hash code has been marshalled or <code>hash</code> 
            has been called on this fref.
            </p>
        </li>

        <li>
            <strong>Method</strong> <code>(fref-val fref)</code> -> A Lisp object 
            representing the value of the object
            <p>
            This will only be set if the value has been marshalled.
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(ensure-typed-reference fref)</code> -> <code>fref</code>, 
            whose class may have been changed
            <p>
            Given a generic Foil fref, determines the full type of the object and uses <code>change-class</code> 
            to convert the fref to that type. Since we don't want to always incur the cost 
            of type determination, the wrapper-generated API functions return generic 
            references. Use this function to convert to a typed reference corresponding to 
            the full actual type of the object when desired:
            <pre>
CL-USER 42 > (setf string-class (get-type-for-name "java.lang.String"))
#}1

CL-USER 43 > (type-of string-class)
FREF

CL-USER 44 > (ensure-typed-ref string-class)
#}1

CL-USER 45 > (type-of string-class)
CLASS.      </pre>
            </p>
        </li>


    </ul>

    <a name="wrappergen"></a> <h3>Wrapper Generation</h3>

    <ul>
        <li>
            <strong>Macro</strong> <code>(def-foil-class full-class-name) -> unspecified</code>
            <p>
            Given the package-qualified, case-correct name of a Java/CLI class as a string, 
            will generate wrapper functions for its public constructors, fields, properties 
            and methods.
            </p>
            <p>
            The core API for generating interfaces to Java/CLI is the <code>def-foil-class</code> 
            macro. This macro will, at expansion time, use Java/CLI reflection to find all 
            of the public constructors, fields, properties and methods of the given class 
            and generate functions to access them.
            </p>
            <h4>The Generated API</h4> When you e.g. <code>(def-foil-class "java.lang.ClassName 
             ")</code> you get several symbols/functions:
            <ul>
                <li>
                    A package named <code>|java.lang|</code> (note case)<br>
                    from which the following are exported:
                </li>
                <li>
                    A class-symbol: <code>classname.</code> (note the dot is part of the name)<br>
                    which can usually be used where a typename is required. It also serves as the 
                    name of the Lisp typed reference class.
                </li>
                <li>
                    Every non-interface class with a public constructor will get;
                    <ul>
                        <li>
                            A constructor, <code>(classname.new &rest args) -> fref</code>, which returns a 
                            foreign-reference (fref) to the newly created object. Note that the constructor 
                            function, and therefore everything built upon it, can take the actual arguments 
                            to the Java/CLI ctor, followed by zero or more property initializers, which take 
                            the form:<br>
                            :keywordized-propertyname value<br>
                            e.g. <code>(window.new parent :width 200 :height 200)</code> <br>
                            thus supporting the creation and some setup of a new object in a single call

                        </li>
                        <li>
                            A method defined on <a href=#makenew><code>make-new</code></a>, ultimately 
                            calling <code>classname.new</code>, specialized on (the value of) the class-symbol
                        </li>
                    </ul>
                    Note that if the constructor is overloaded, there is just one function generated, 
                    which handles overload resolution. The function documentation string describes 
                    the constructor signature(s) from the Java/CLI perspective. The same argument 
                    conversions are performed as are for fields (see below).
                </li>
                <li>
                    All public fields will get a getter function:<br>
                    <code>(classname.fieldname [instance]) -> field value</code><br>
                    and a setter:<br>
                    <code>(setf classname.fieldname [instance])</code><br>
                    Instance field wrappers take a first arg which is the instance. Static fields 
                    get a symbol-macro <code>*classname.fieldname*</code>
                    <p>
                    If the type of the field is primitive, the field value will be converted to a 
                    native Lisp value. If it is a Java/CLI String, it will be converted to a Lisp 
                    string. Otherwise, a foreign reference to the Java/CLI object is returned. 
                    Similarly, when setting, Lisp values will be accepted for primitives, Lisp 
                    strings for Strings, or foreign references for reference types.
                    </p>
                </li>
                <li>
                    All public properties (explicit properties in the case of the CLI, implied 
                    properties in the case of Java as specified by the JavaBeans protocol) will get 
                    a getter function if the property supports get:<br>
                    <code>(classname.propertyname [instance] [args]) -> property value</code><br>
                    and a setter if the property supports set:<br>
                    <code>(setf classname.propertyname [instance] [args])</code><br>
                    Instance property wrappers take a first arg which is the instance. Static 
                    properties get a symbol-macro <code>*classname.propertyname*</code>
                </li>
                <li>
                    Every public method will get a wrapper function:<br>
                    <code>(classname.methodname &rest args) -> return-value</code><br>
                    As with constructors, if a method is overloaded a single wrapper is created that 
                    handles overload resolution.
                    <p>
                    The same argument and return value conversions are performed as are for fields. 
                    The function documentation string describes the method signature(s) from the 
                    Java/CLI perspective.
                    </p>

                </li>
                <li>
                    A Lisp class with the class-symbol as its name. It will have as its superclasses 
                    other Lisp classes corresponding to the Java/CLI superclass/superinterfaces, 
                    some of which may be forward-referenced-classes, and will be ultimately derived 
                    from <code>fref</code>. An instance of this class will be returned by <code>ensure-typed-ref</code>, 
                    at which point the entire hierarchy will consist of finalized standard-classes.
                </li>
                <li>
                    Note that, due to the need to reference other Java/CLI types during the 
                    definition of a class wrapper, symbols, classes, and packages relating to those 
                    other types may also be created. In all cases they will be created with names 
                    and packages as described above.
                </li>
            </ul>

        </li>
        <li>
            <strong>Function</strong> <code>(get-library-classnames jar-or-assembly-filename 
            &rest packages) -> list-of-strings</code>
            <p>
            Returns a list of class name strings. Packages should be strings of the form "java/lang 
             " or "System/IO" for recursive lookup and "java/util/" or "System/IO/" (note 
             trailing slash) for non-recursive.
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(dump-wrapper-defs-to-file filename classnames)  -> 
            filename</code>
            <p>
            Given a list of classnames (say from <code>get-library-classnames</code>), 
            writes the consolidated expansions of calls to <code>def-foil-class</code> to a 
            file:
            </p>
            <pre>
(dump-wrapper-defs-to-file "/lisp/java-lang.lisp"
  (get-library-classnames "/j2sdk1.4.2_01/jre/lib/rt.jar " "java/lang/"))
(compile-file "/lisp/java-lang")
(load "/lisp/java-lang")
(use-package "java.lang")
;Wrappers for all of java.lang are now available
            </pre>
            This is the recommended way to access entire library packages. In particular, it 
            has the advantage that the dumped code does not require a foreign runtime to 
            either compile or load.
        </li>
    </ul>

    <a name="objects"></a> <h3>Object Creation</h3> In addition to the generated 
    ctor wrappers (<code>classname.new</code> described above), the following, built 
    upon the same, add some additional capabilites and ease of use:
    <ul>
        <li>
            <strong><a name="makenew"></a>Generic Function</strong> <code>(make-new 
            classname. &rest args) -> fref</code>
            <p>
            Allows for definition of before/after methods on constructors. Calls <code>classname.new</code> 
            ctor. The new macro expands into a call to this.
            </p>
        </li>
        <li>
            <strong>Macro</strong> <code>(new class-spec args &body body) -> fref</code>
            <p>
            <code>class-spec -> class-sym | (class-sym this-name) <br>
            class-sym -> classname. <br>
            args -> as per ctors and make-new</code>
            </p
                        <p>
            Creates a new instance of class, using the <code>make-new</code> generic 
            function, then runs the body replacing all top-level calls of the form <code>(.anything 
            whatever)</code> with <code>(classname.anything new-object whatever)</code> If <code>this-name</code> 
            is supplied it will be bound to the newly-allocated object and available to the 
            body (note - but not to the args!)
            </p>
            Example:
            <pre>
(new shell. (*display* :text "SWT Apropos" :layout (gridlayout.new 1 t ))
                  (.setsize 800 600)
                  (.setlocation 100 100))            </pre>
            Expands into:
            <pre>
(LET ((#:G2249 (MAKE-NEW SHELL. *DISPLAY* :TEXT "SWT Apropos" :LAYOUT (
GRIDLAYOUT.NEW 1 T))))
  (PROGN
    (SHELL.SETSIZE #:G2249 800 600)
    (SHELL.SETLOCATION #:G2249 100 100))
  #:G2249)</pre>
        </li>
    </ul>


    <a name="objectservices"></a> <h3>Object Services</h3> These functions provide 
    access to basic facilities provided by all runtimes (usually through syntax or 
    the Object class), but should be used instead, as they are portable and can be 
    more efficient, caching and resolving some things locally on the Lisp side.
    <ul>
        <li>
            <strong>Function</strong> <code>(equals fref1 fref2) -> boolean</code>
            <p>
            Portable Object.equals/Equals
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(instance-of fref type) -> boolean</code>
            <p>
            Portable instanceof/is
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(to-string fref) -> string</code>
            <p>
            Portable Object.toString/ToString
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(hash fref &key rehash) -> int</code>
            <p>
            Portable Object.hasCode/GetHashCode. Note: will cache the value on the fref. If 
            already cached, will return that, unless :rehash is t.
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(get-type fref) -> Class or Type fref</code>
            <p>
            Portable Object.getClass/GetType. Note: will cache the value on the fref. Note 
            also that obtaining the exact type of the object is completely independent of 
            the coercion of the fref to its corresponding Lisp type (see <code>ensure-typed-ref</code>)
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(iref indexable-obj &rest indexes) -> a value</code>
            <p>
            Calls the default indexer for the object. CLI only. Settable.
            </p>
        </li>

    </ul>

    <a name="vectors"></a> <h3>Vectors</h3>
    <ul>

        <li>
            <strong>Function</strong> <code>(make-new-vector type length &rest inits) -> 
            array fref</code>
            <p>
            Creates a foreign vector of specified type and length. There can be fewer inits 
            than the length, in which case the remaining values take the default.
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(vref vector index) -> value</code>
            <p>
            Returns the value at the index. Settable.
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(vlength vector index) -> int</code>
            <p>
            Returns the length of the vector.
            </p>
        </li>
    </ul>

    <a name="misc"></a> <h3>Miscellaneous</h3> <h4>Arguments and Boxing</h4>
    <p>
    In most cases argument matching and conversion should be transparent. Lisp 
    strings can be passed where Strings are required, Lisp numbers where int float 
    etc are required. <code>t</code> and <code>nil</code> can be passed where 
    booleans are required etc. <code>nil</code> can be passed for <code>null</code>. 
    Some Foil APIs (e.g. make-new-vector) require <code>type</code> arguments, and 
    unless specified otherwise, any of the following are acceptable:
    <ul>
        <li>
            (the value of) A class-symbol - <code>classname.</code>
        </li>
        <li>
            A primitive designator keyword - <code>:boolean|:byte|:char|:double|:float|:int|:long|:short</code>
        </li>
        <li>
            A fref referring to an actual Class/Type instance
        </li>
        <li>
            A <code>"package.qualified.ClassName"</code> string, case-sensitive. This is 
            least efficient and should only be used in dynamic scenarios.
        </li>
    </ul>
    Note that this only applies to Foil APIs, if a foreign runtime API takes a Class/Type 
    argument, you must supply a fref referring to an actual Class/Type instance.
    </p>
    <p>
    Occasionally it may be necessary to provide a hint as to the intended type of a 
    numeric argument in order to force resolution to a particular overload.
    <li>
        <strong>Function</strong> <code>(box type val)</code>
        <p>
        Type must be a primitive designator keyword - <code>:boolean|:byte|:char|:double|:float|:int|:long|:short</code>
        <br>
        Produces an object that when passed to a Foil-generated function will be 
        interpreted by the runtime as that type. Note that silent truncation may occur.
        </p>
    </li>
    </p>
    <p>
    It is also possible to create vectors in-line as arguments, which will avoid 
    multiple round-trips vs. calling <code>make-new-vector</code> in place. Note 
    this is only good for ephemeral vectors, as there is no way to retain a 
    reference to the newly-created vector.
    <li>
        <strong>Function</strong> <code>(box-vector type &rest vals)</code>
        <p>
        Produces an object that when passed to a Foil-generated function will be an 
        array of type with the supplied values.
        </p>
    </li>
    Example:
    <pre>
CL-USER 102 > (vref (box-vector string. "a" "b" "c" "d") 2) ;only one round-trip
"c"</pre>
    </p>
    <h4>Class/Type Helpers</h4>
    <ul>
        <li>
            <strong>Function</strong> <code>(get-type-for-name full-class-name)</code>
            <p>
            Returns a Class/Type instance corresponding to name. Portable Class.forName/Type.GetType.
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(full-class-name class-symbol)</code>
            <p>
            Returns the package qualified name string corresponding to the class symbol:
            <pre>
CL-USER 104 > (full-class-name string.)
"java.lang.String"</pre>
            </p>
        </li>
    </ul>

    <a name="proxies"></a> <h3>Proxies and Callbacks</h3> Proxies allow the creation 
    of foreign objects that implement one or more interfaces (or in the case of CLI, 
    one or more interfaces or a single delegate) in Lisp, and thus callbacks from 
    the foreign VM to Lisp. Foil supports Lisp calling foreign runtime calling Lisp... 
    to an arbitrary (probably stack-limited) depth.
    <ul>
        <li>
            <strong>Generic Function</strong> <code>(handle-proxy-call method-symbol proxy 
            &rest args))</code>
            <p>
            The proxy infrastructure routes all callbacks to this generic function. If a 
            proxy p implements an interface i, and the foreign VM ends up invoking i.foo on 
            p, it will map to a call to <code>handle-proxy-call</code> with the first 2 
            arguments of 'i.foo and p, followed by the actual arguments to the invocation. 
            So, callback handlers can be defined by specializing methods on the method-symbol, 
            the proxy object, or both. The unspecialized method spews out "unhandled proxy 
            call" to standard output and returns nil to the foreign VM. Any unhandled errors 
            that occur on the Lisp side during a callback turn into exceptions on the 
            runtime server.
            </p>
        </li>

        <li>
            <strong>Function</strong> <code>(make-new-proxy arg-marshall-flags arg-marshall-depth 
            &rest interface-types) -> proxy fref</code>
            <p>
            Creates and returns a proxy object that implements the given interface types or 
            delegate type. <code>arg-marshall-flags</code> and <code>arg-marshall-depth</code> 
            will be used to marshall the arguments to the callback. No handlers are defined 
            by this function.
            </p>
        </li>

        <li>
            <strong>Macro</strong> <code>(new-proxy proxy arg-marshall-flags arg-marshall-depth 
            &rest interface-defs) -> proxy fref</code>
            <p>
            Creates and returns a proxy object that implements the given interface types or 
            delegate. <code><br>
            proxy -> a symbol <br>
            interface-def -> (interface-name method-defs+) <br>
            interface-name -> classname. (must name an interface or delegate type) <br>
            method-def -> (method-name (args*) body) <br>
            method-name -> symbol (without classname)</code> <br>
            The symbol <code>proxy</code> will be bound to the proxy instance in the body of 
            the method implementations.
            </p>
            Example:
            <pre>
(new-proxy p +MARSHALL-ID+ 0
           (keylistener.
             (keyreleased (event)
               (when (eql *SWT.CR* (keyevent.character event))
                 (gob)))))                </pre>
        </li>

    </ul>


    <a name="marshalling"></a> <h3>Marshalling</h3>
    <p>
    Foil supports an extensible marshalling system which allows the values of 
    reference/composite types to be returned in addition to, or even instead of, the 
    references themselves. Used appropriately, this can substantially reduce the 
    number of round trips between processes and avoid significant 'chatter' overhead.

    </p>

    <p>
    Marshalling comes into play whenever a reference type is returned from a Foil 
    function. With certain settings, it is possible to return any or all of a 
    reference, its hash code, its type, and its value (and the same for any of its 
    value's reference members), to a specific depth. The nature and depth of the 
    marshalling is governed by two special variables on the Lisp side - <code>*marshalling-flags*</code> 
    and <code>*marshalling-depth*</code>.
    </p>


    <p>
    The format of marshalled values is determined by the runtime servers, and both 
    the Java and CLI servers provided with Foil have facilities for adding new 
    marshallers for specific types. The way an object's value is marshalled is a 
    function of its type.
    </p>

    <p>
    Class or Types will always marshall the string representing the 
    packageQualifiedTypeName, ignoring <code>*marshalling-depth*</code>
    <p>
    By default, the following marshalling will be performed when requested, i.e. <code>*marshalling-depth*</code> 
    > 0
    </p>
    <ul>
        <li>
            Arrays marshall as simple Lisp vectors
        </li>
        <li>
            Collections and other enumerable entities marshall as simple Lisp lists
        </li>
        <li>
            Default, if no other marshaller applies - a Lisp assoc-list of keywordized-property-name/value 
            pairs for any public properties of the object
        </li>
    </ul>
    </p>

    <ul>
        <li>
            <strong>Special Variable</strong> <code>*marshalling-depth*</code>
            <p>
            Default: 0 <br>
            A depth of 0 means no values are marshalled, a setting of 1 means that values 
            will be marshalled for the returned object (if it is a reference), but not any 
            nested references. When > 1 nested reference types will marshall, to that depth 
            of nesting.
            </p>
        </li>
        <li>
            <strong>Special Variable</strong> <code>*marshalling-flags*</code>
            <p>
            Either <code>+MARSHALL-NO-IDS+</code>, or the logical or-ing of <code>+MARSHALL-ID+</code> 
            and zero or more of: <code>+MARSHALL-HASH+</code> and <code>+MARSHALL-TYPE+</code>
            <br>
            Default: <code>+MARSHALL-ID+</code> <br>
            A setting of <code>+MARSHALL-NO-IDS+</code> means that no frefs will be returned, 
            and thus no references will be held on the VM side. If <code>*marshalling-depth*</code> 
            is 0 then nil will be returned. If <code>*marshalling-depth*</code> > 0 then the 
            value will be returned instead of the fref.
            </p>
            <p>
            Otherwise, <code>+MARSHALL-ID+</code> must be set, and frefs will be returned 
            for reference types. If <code>*marshalling-depth*</code> > 0, then the 
            marshalled values will be in the <code>fref-val</code> slot. If <code>+MARSHALL-HASH+</code> 
            is set then the object's hash code will be calculated and stored in the <code>fref-hash</code> 
            slot. Similarly, if <code>+MARSHALL-TYPE+</code> is set then the object's class/type 
            will be determined and stored in the <code>fref-type</code> slot.
            </p>
        </li>
        <li>
            <strong>Macro</strong> <code>(with-marshalling (depth &rest flags) &body body)</code>
            <p>
            Evaluates the body in a context in which the <code>*marshalling-depth*</code> is 
            set to depth and <code>*marshalling-flags*</code> to the <code>logior</code> of 
            flags.
            </p>
        </li>
        <li>
            <strong>Function</strong> <code>(marshall fref)</code>
            <p>
            Explicitly marshalls the object with the current <code>*marshalling-flags*</code> 
            and <code>*marshalling-depth*</code> settings, and returns the marshalled object 
            (which may be the same fref, but with additional data in its type/hash/val slots)
            </p>
        </li>

    </ul>

    Marshalling example:
    <pre>
CL-USER 79 > (setf string-class (get-type-for-name "java.lang.String"))
#}1

CL-USER 88 > (class.getpackage string-class)
#}12

CL-USER 90 > (pprint (with-marshalling (1 +MARSHALL-NO-IDS+)
                       (class.getpackage string-class)))

((:IMPLEMENTATIONTITLE . "Java Runtime Environment")
 (:IMPLEMENTATIONVENDOR . "Sun Microsystems, Inc.")
 (:IMPLEMENTATIONVERSION . "1.4.2_05")
 (:NAME . "java.lang")
 (:SEALED)
 (:SPECIFICATIONTITLE . "Java Platform API Specification")
 (:SPECIFICATIONVENDOR . "Sun Microsystems, Inc.")
 (:SPECIFICATIONVERSION . "1.4")) </pre>



    <a name="runtimeservers"></a><h2>Runtime Servers</h2>

    <p>
    Foil includes 2 complete implementations of the runtime server portion of the 
    protocol, one for Java/JVM, the other for C#/CLI. The implementations are 100% 
    Java/Managed, and use only standard libraries.

    Both will run the protocol over one or more TCP sockets specified on the command 
    line, or, if none specified, via standard IO.
    </p>

    <p>
    Project files are included for Eclipse and Visual Studio. All of the Java code 
    is in com/richhickey/foil and the stand-alone server is in RuntimeServer.Main. 
    The CLI implementation is in 2 projects, one for the Foil library itself - 
    FoilCLI, and the other for the stand-alone server - FoilCLISvr.
    </p>
    <p>
    After building, you can invoke the Java server as follows:
    </p>
    <p>
    <code>java -cp . com.richhickey.foil.RuntimeServer 13579</code>
    </p>
    <p>
    Make sure the classpath includes the libraries and .jars you will want to use 
    via Foil.
    </p>

    <p>
    After building, you can invoke the CLI server as follows:
    </p>

    <code>foilclisvr 13479</code>



    <a name="protocol"></a><h2>Protocol</h2>

    The foil protocol describes the on-stream interface between a Lisp instance and 
    a runtime instance, and should not be confused with the foil library which 
    provides the interface to the protocol for Common Lisp.  A user of Foil will not 
    need to know the protocol, but if you intend to add support for another runtime 
    environment (Python anyone?) or host language (Scheme anyone?), hopefully this 
    section will help. Note that the protocol docs are not formal, and mostly 
    consists of notes to myself and Eric. This will be improved when I get time. For 
    the moment, should there be any omissions or inaccuracies here, the Lisp and 
    Java implementations should be considered canonic.

    <h3>Connection Services</h3>

    Foil is a stream-based protocol.  However, no protocol is provided for the 
    establishment of the streams - that is an implementation detail of the runtime 
    and Lisp libraries.  It is suggested that any foil runtime implementation 
    provide at least a stand-alone executable server that implements the protocol 
    over its standard IO ports, as well as being able to run over a TCP/IP socket. 
    Many other scenarios are possible, including multi-socket servers, pre-existing 
    Lisp and runtime instances discovering each other etc.  The remainder of the 
    protocol description presumes a bi-directional stream has been established.

    Sendable messages:
    <ul>

        <li>
            (:cref
        </li>
        <li>
            (:call
        </li>
        <li>
            (:free
        </li>
        <li>
            (:new
        </li>
        <li>
            (:marshall
        </li>
        <li>
            (:hash
        </li>
        <li>
            (:equals
        </li>
        <li>
            (:type-of
        </li>
        <li>
            (:is-a
        </li>
        <li>
            (:str
        </li>
        <li>
            (:tref
        </li>
        <li>
            (:bases
        </li>
        <li>
            (:members
        </li>
        <li>
            (:vector
        </li>
        <li>
            (:vget
        </li>
        <li>
            (:vset
        </li>
        <li>
            (:vlen
        </li>
        <li>
            (:proxy
        </li>
        <li>
            (:iget
        </li>
        <li>
            (:iset
        </li>


    </ul>
    <p>
    Returnable messages:
    <ul>

        <li>
            (:ret
        </li>
        <li>
            (:err
        </li>
        <li>
            (:proxy-call    ;only async or from withing a :call
        </li>

    </ul>

    <h3>Invocation Services</h3> Obtaining callable references (crefs)
    <p>
    <code>(:cref member-type tref|"packageQualifiedTypeName" "memberName")</code>
    <p>
    Where member-type is an integer representing one of:
    <ul>
        <li>
            method (0)
        </li>
        <li>
            field (1)
        </li>
        <li>
            property-get (3)
        </li>
        <li>
            property-set (4)
        </li>
    </ul>

    <p>
    Note that both Java and the CLI support overloading, so a single member name 
    might map to multiple overloads. The resolution of the overloading must occur in 
    the runtime server at the time of invocation, i.e. any of the overloads may be 
    called through the same cref.

    <p>
    Returns -> A reference to a callable thing is returned in the standard return 
    format (see below).
    <p>
    <code>(:ret #{:ref ...})</code>

    <p>
    <h4>Creating new object instances</h4>
    <p>
    <code>(:new tref marshall-flags marshall-value-depth-limit (args ...) property-inits 
    ...)</code><br>
    <p>
    where property-inits is a set of <code>:keyword-style-name value</code> pairs
    <p>
    <h4>Calling a callable</h4> <code>(:call cref marshall-flags marshall-value-depth-limit 
    target args ...)</code><br>

    <p>
    Example:
    <p>
    <code>(:call #}101 1 0 2 #}17 "fred")</code>

    <p>
    Where cref is an cref that has been obtained via :cref, or, only in the case of 
    calls to Lisp, a symbol that names a function.

    <br>
    marshalling-flags is an integer representing a bitwise-or'ing of:
    <ul>

        <li>
            marshall-id (1)
        </li>
        <li>
            marshall-type (2)
        </li>
        <li>
            marshall-hash (4)
        </li>

    </ul>
    a marshall-value-depth-limit of 0 means no reference values are marshalled, a 
    setting of 1 means that reference values will be marshalled for the return value 
    (if it is a reference), but not any nested references. When > 1 nested reference 
    types will marshall to that depth of nesting. <br>
    If marshalling-flags is 0, no references will be returned (only values) and if 
    depth is also 0 then nil will be returned. <br>
    target is the object upon which to invoke the method/field/property - pass nil 
    if static <br>
    args are zero or more args as per below.
    <p>
    <h4>Return Format</h4> <br>
    one of:
    <ul>
        <li>
            <code>(:ret value)</code><br>
            All normal returns are packaged in a form as above, value is as per below. If a 
            function has a void return type, nil should be returned.
        </li>
        <li>
            <code>(:proxy-call ...)</code><br>
            A nested callback, in the proxy-call format described below. The receiver should 
            process the call, send back its return, then re-read the stream for the return 
            value of the original call.
        </li>
        <li>
            <code>(:err "error description" "stack trace")</code><br>
            returned if an exception occurred while processing the request
        </li>

    </ul>
    <h4>Argument and Return Values</h4> Primitives and Value Types<br>
    <ul>

        <li>
            "Strings are in double quotes"
        </li>
        <li>
            Numbers are unadorned decimal numbers with or without a decimal point,leading -, 
            e etc
        </li>
        <li>
            nil is null
        </li>
        <li>
            nil is false
        </li>
        <li>
            t is true
        </li>
    </ul>

    <p>
    <h4>Boxed Primitives</h4> Occasionally it may be necessary to provide a hint as 
    to the intended type of a numeric argument in order to force resolution to a 
    particular overload.

    <p>
    <code>#{:box typename value}</code><br>

    <p>
    Where typename is one of <code>:byte :int :long :short :float :double</code>
    <p>
    N.B. silent truncation may occur
    <p>
    Return values should never be boxed<br>

    <p>
    <h4>vector literals</h4> A vector can be specified in-line as an argument <code>#{:vector 
     "packageQualifiedTypeName"|tref|:int(etc) value ...}</code><br>

    <p>
    <h4>References</h4>

    Reference types are returned with the following tagged syntax:<br>

    <code>#{:ref id rev :type a-ref :hash an-int :val marshalled-value}</code>
    <ul>


        <li>
            :ref, id, and rev must be supplied, all others are optional
        </li>

        <li>
            id - A unique integer reference that identifies the object. The object will be 
            kept alive on the hosting side until it is freed. Multiple references to the 
            same object will always have the same id.
        </li>

        <li>
            :type - A reference to the Type (CLI) or Class (Java) object that is the type of 
            the object. Note that this may be the first time this reference is seen (and 
            thus it must be registered for lifetime maintenance) This will only be available 
            if the marshall-type flag is set.
        </li>

        <li>
            :hash - An integer representing the hash value of the object. This will only be 
            available if the marshall-hash flag is set.
        </li>

        <li>
            :val - A Lisp-readable representation of the value of the object. This will be 
            obtained by using the marshaller registered for the type of the object. This 
            will only be available when marshall-value-depth-limit is > 0. Note #{ and #} 
            user-space read macros are used by the implementation of foil.
        </li>


    </ul>
    Note that it is possible to return marshalled values of reference objects 
    without maintaining the reference object on the hosting side (by setting the 
    marshall-id flag to 0 and having marshall-value-depth-limit > 0

    <p>
    A reference (obtained previously) is passed back to its host like this:
    <p>
    <code>#}123</code>

    <p>
    The host will look up the object with that id and pass it along to the call. <br>
    <h4>Exception Reporting</h4> All exceptions are reported via a return of the 
    form:
    <p>
    <code>(:err "error description" "stack trace")</code>
    <p>
    if an exception occurred while processing the request. Unless the exception 
    originated in the reflection API, it is preferred that the stack trace be of the 
    inner (reflection-invoked) call.

    <h3>Object support services</h3> <h4>Object references</h4> <h4>Object lifetime 
    management</h4> <code>(:free refid refrev ...)</code> -> nil


    <p>
    a list of id/rev pairs is passed.  Allows one or more refs to be GC-ed on the 
    hosting side.  It is an error to refer to these refids again.<br>

    <h4>Object marshalling</h4>
    <p>
    It is anticipated that runtime servers will provide for user-installable 
    marshallers, associated with types, that will render the value of an object of 
    that type on a stream in a form readable by Lisp. By default at least the 
    following marshallers should be provided:
    <ul>

        <li>
            Type|Class - must always marshall the string representing the 
            packageQualifiedTypeName, ignoring marshalling-depth
        </li>
        <li>
            arrays - should marshall as simple vector literals: #(...)
        </li>
        <li>
            collections and other enumerable entities - should marshall as simple lists (...)
        </li>
        <li>
            default, if no other marshaller applies - should yield an assoc-list of 
            keywordized-property-name/value pairs
        </li>

    </ul>
    <p>
    In addition to marshalling returns during calls, the value of an object 
    reference can be explicitly marshalled:
    <p>
    <code>(:marshall ref marshall-flags marshall-value-depth-limit)</code> -> Lisp-readable-value

    <p>
    Hash values<br>
    <code>(:hash ref)</code> -> int<br>

    <p>
    Object equality<br>
    <code>(:equals ref ref)</code> -> t|nil, per Object.Equals<br>

    <p>
    ToString<br>
    <code>(:str ref)</code> -> "string value"<br>

    <p>
    <h3>Reflection Services</h3>


    Note, when trefs are returned by these reflection calls, the :val field of the 
    reference is always (default) marshalled, i.e. set to the 
    packageQualifiedTypeName as a string.

    <p>
    <h4>Obtaining a reference to a Type/Class object</h4> <code>(:tref "packageQualifiedTypeName 
     ")</code> -> tref<br>

    <p>
    <h4>Object type</h4> <code>(:type-of ref)</code> -> tref<br>


    <p>
    <code>(:is-a ref tref)</code> -> t|nil<br>

    <p>
    <code>(:bases tref|"packageQualifiedTypeName")</code><br>
    <pre>
-> (:ret ("packageQualifiedTypeName" ...))    ;most-derived to least-derived
    </pre>


    <p>
    <code>(:members tref|"packageQualifiedTypeName")</code><br>

    <code>
    <pre>
-> (:ret ( (:ctors doc-string ...)
        (:methods ((:name string)
                   (:static bool)
                   (:doc doc-string)) ...)
        (:fields ((:name string)
                  (:static bool)
                  (:doc doc-string)) ...)
        (:properties ((:name string)
                      (:static bool)
                      (:get-doc doc-string)
                      (:get-function string)
                      (:set-doc doc-string)
                      (:set-function string) ...)))</pre>
    </code>

    <h4>Proxies</h4>
    <pre>
<code>(:proxy marshall-flags marshall-value-depth-limit interface-trefs ...)</code><br>
-> (:ret proxy-ref)
    </pre>
    <p>
    Creates a proxy object that implements the given interface(s). When any of the 
    object's methods are called, sends a :proxy-call message of the form:
    <p>
    <code>(:proxy-call method-symbol proxy-ref args ...)</code>
    <p>
    where the proxy-ref is the same one originally returned from the :proxy message, 
    and the args are marshalled with the flags and depth requested in the :proxy 
    message. method-symbol has the form
    <p>
    <code>|package.name|::classname.methodname</code>
    <p>
    note this means that the Lisp names are not independent, hmmm... <h3>Vectors</h3> 
    Creating an vector:<br>
    <ul>

        <li>
            (:vector tref|"packageQualifiedTypeName" length value ...) Creates an vector of 
            the specified type with the specified length Initial values are optional and may 
            be fewer than the length. -> aref
        </li>
        <li>
            (:vget aref marshall-flags marshall-value-depth-limit index) -> value
        </li>
        <li>
            (:vset aref index value) -> nil
        </li>
        <li>
            (:vlen aref) -> int
        </li>
    </ul>

    <a name="summary"></a> <h2>Summary</h2>
    <p>
    I'd like to thank my good friend Eric Thorsen for his hard work on the CLI/C# 
    port.
    </p>
    <p>
    I hope you find Foil useful. It is my sincere intent that it enhance the utility 
    and interoperability of Common Lisp. I welcome comments and code contributions.
    </p>
    <p>
    Rich Hickey, February, 2005
    </p>
    </body>
</html>
