GCL (GNU Common Lisp)  Version(2.3) Sat Apr 28 16:33:10 MET DST 2001
Licensed under GNU Library General Public License
Contains Enhancements by W. Schelter

 ACL2 Version 2.6 built February 11, 2002  04:56:29.
 Copyright (C) 2001  University of Texas at Austin
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the GNU General Public License.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*
                      NIL).
 See the documentation topic note-2-6 for recent changes.

 NOTE!!  Proof trees are disabled in ACL2.  To enable them in emacs,
 look under the ACL2 source directory in interface/emacs/README.doc; 
 and, to turn on proof trees, execute :START-PROOF-TREE in the ACL2 
 command loop.   Look in the ACL2 documentation under PROOF-TREE.

ACL2 Version 2.6.  Level 1.  Cbd "/local/crash/gp34/nif2acl2/".
Type :help for help.

ACL2 !>(ld "vhdl-acl2.lisp")
   .......

ACL2 !>(v2acl2)

----------------------------------------------
               =============
             ((  MAIN MENU  ))
               =============

     1 - Vhdl -> nif
     2 - nif  -> acl2
     3 - Load a description
                  --
     4 - Change directory path

q:quit           $Date: 2002/05/02 12:29:52 $
----------------------------------------------
"/local/crash/gp34/nif2acl2/"
Vhdl_Acl2> 2

Name of .nif file:fact



 -------  File "fact.lisp" generated -------- 

------  File "fact-thm.lisp" generated ------- 

----------------------------------------------
               =============
             ((  MAIN MENU  ))
               =============

     1 - Vhdl -> nif
     2 - nif  -> acl2
     3 - Load a description
                  --
     4 - Change directory path

q:quit           $Date: 2002/05/02 12:29:52 $
----------------------------------------------
"/local/crash/gp34/nif2acl2/"
Vhdl_Acl2> 3

Choose name :fact


Opening "fact"...

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : FACT
Vhdl_Acl2> 2

Memory state: 

  ARG            : 0
  START          : 0
  OP1            : 0
  OP2            : 0
  RESMULT        : 0
  STARTMULT      : 0
  ENDMULT        : 0
  OP1+           : 0
  OP2+           : 0
  RESMULT+       : 0
  STARTMULT+     : 0
  ENDMULT+       : 0
  |DOIT.MYSTATE| 
                 : 0
  R              : 0
  F              : 0
  RES            : 0
  |FACT.DONE|    : 0
  RES+           : 0
  |FACT.DONE+|   : 0

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 2

Memory state: 

  ARG            : 0
  START          : 0
  OP1            : 0
  OP2            : 0
  RESMULT        : 0
  STARTMULT      : 0
  ENDMULT        : 0
  OP1+           : 0
  OP2+           : 0
  RESMULT+       : 0
  STARTMULT+     : 0
  ENDMULT+       : 0
  |DOIT.MYSTATE| 
                 : 0
  R              : 0
  F              : 0
  RES            : 0
  |FACT.DONE|    : 0
  RES+           : 0
  |FACT.DONE+|   : 0

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 3

--------------- MYSYSTEM FACT-----------------
input signals: ARG and START
generic parameter: 
local signals: OP1, OP2, RESMULT, STARTMULT and ENDMULT
variables: |DOIT.MYSTATE|, R and F
----------------------------------------
Enter values like :(var1 val1 var2 val2....)
***** For a list or a symbol, use a quote
***** e.g : (a 'a b #b1101 c #b1010)
*****
Modify memory state>(arg 5 start 1)

  ARG            : 5
  START          : 1
  OP1            : 0
  OP2            : 0
  RESMULT        : 0
  STARTMULT      : 0
  ENDMULT        : 0
  OP1+           : 0
  OP2+           : 0
  RESMULT+       : 0
  STARTMULT+     : 0
  ENDMULT+       : 0
  |DOIT.MYSTATE| 
                 : 0
  R              : 0
  F              : 0
  RES            : 0
  |FACT.DONE|    : 0
  RES+           : 0
  |FACT.DONE+|   : 0

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 1

How many simulation cycle : 6

Save in file ? (give a name or nil) : nil

  ARG            : 5
  START          : 1
  OP1            : 4
  OP2            : 5
  RESMULT        : 5
  STARTMULT      : 1
  ENDMULT        : 0
  OP1+           : 4
  OP2+           : 5
  RESMULT+       : 20
  STARTMULT+     : 1
  ENDMULT+       : 1
  |DOIT.MYSTATE| 
                 : 2
  R              : 4
  F              : 5
  RES            : 0
  |FACT.DONE|    : 0
  RES+           : 0
  |FACT.DONE+|   : 0

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 1

How many simulation cycle : 20

Save in file ? (give a name or nil) : nil

  ARG            : 5
  START          : 1
  OP1            : 2
  OP2            : 60
  RESMULT        : 60
  STARTMULT      : 1
  ENDMULT        : 0
  OP1+           : 2
  OP2+           : 60
  RESMULT+       : 120
  STARTMULT+     : 1
  ENDMULT+       : 1
  |DOIT.MYSTATE| 
                 : 2
  R              : 2
  F              : 60
  RES            : 120
  |FACT.DONE|    : 1
  RES+           : 120
  |FACT.DONE+|   : 1

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 4


----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 3

--------------- MYSYSTEM FACT-----------------
input signals: ARG and START
generic parameter: 
local signals: OP1, OP2, RESMULT, STARTMULT and ENDMULT
variables: |DOIT.MYSTATE|, R and F
----------------------------------------
Enter values like :(var1 val1 var2 val2....)
***** For a list or a symbol, use a quote
***** e.g : (a 'a b #b1101 c #b1010)
*****
Modify memory state>(arg 'arg start 1)
[SGC for 948 CONS pages..(3801 writable)..(T=11).GC finished]

  ARG            : ARG
  START          : 1
  OP1            : 0
  OP2            : 0
  RESMULT        : 0
  STARTMULT      : 0
  ENDMULT        : 0
  OP1+           : 0
  OP2+           : 0
  RESMULT+       : 0
  STARTMULT+     : 0
  ENDMULT+       : 0
  |DOIT.MYSTATE| 
                 : 0
  R              : 0
  F              : 0
  RES            : 0
  |FACT.DONE|    : 0
  RES+           : 0
  |FACT.DONE+|   : 0

----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 1

How many simulation cycle : 1

Enter constraints for symbolic simulation (or return) : (naturalp arg)

NOTE:  Starting first repetition of rewrite.

Save in file ? (give a name or nil) : nil

  OP1 :
    0
  OP2 :
    0
  RESMULT :
    0
  STARTMULT :
    0
  ENDMULT :
    0
  RESMULT+ :
    0
  ENDMULT+ :
    0
  |DOIT.MYSTATE| :
    1
  R :
    ARG
  F :
    1
  RES :
    0
  |FACT.DONE| :
    0

----------------------------------------------
               ===================
             ((  SYMBOLIC MENU  ))
               ===================

   1 - Print constraints
   2 - Print Runes
   3 - Remove Runes
             ---
   4 - Prove something

q:return to SIMULATION MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> q


----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 1

How many simulation cycle : 5

Enter constraints for symbolic simulation (or return) : (and (naturalp arg) (> arg 5))

NOTE:  Starting first repetition of rewrite.

Save in file ? (give a name or nil) : nil

  OP1 :
    ARG
  OP2 :
    1
  RESMULT :
    ARG
  STARTMULT :
    0
  ENDMULT :
    1
  OP1+ :
    (+
       -1
       ARG)
  OP2+ :
    ARG
  RESMULT+ :
    ARG
  STARTMULT+ :
    1
  ENDMULT+ :
    0
  |DOIT.MYSTATE| :
    2
  R :
    (+
       -1
       ARG)
  F :
    ARG
  RES :
    0
  |FACT.DONE| :
    0

----------------------------------------------
               ===================
             ((  SYMBOLIC MENU  ))
               ===================

   1 - Print constraints
   2 - Print Runes
   3 - Remove Runes
             ---
   4 - Prove something

q:return to SIMULATION MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> q


----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 1

How many simulation cycle : 12

Enter constraints for symbolic simulation (or return) : (and (naturalp arg) (> arg 12))
[SGC for 948 CONS pages..(3809 writable)..(T=12).GC finished]

NOTE:  Starting first repetition of rewrite.

Save in file ? (give a name or nil) : nil

  OP1 :
    (+
       -3
       ARG)
  OP2 :
   (+ (* 2 arg) (- (* arg arg)) (- (* 2 arg arg)) (* arg arg arg))
  RESMULT :
   (+ (* 2 arg) (- (* arg arg)) (- (* 2 arg arg)) (* arg arg arg))
  STARTMULT :
    1
  ENDMULT :
    0
  OP1+ :
    (+
       -3
       ARG)
  OP2+ :
   (+ (* 2 arg) (- (* arg arg)) (- (* 2 arg arg)) (* arg arg arg))
  RESMULT+ :
   
(+ (- (* 6 arg))
   (* 2 arg arg)
   (* 3 arg arg)
   (* 6 arg arg)
   (- (* arg arg arg))
   (- (* 2 arg arg arg))
   (- (* 3 arg arg arg))
   (* arg arg arg arg))

  STARTMULT+ :
    1
  ENDMULT+ :
    1
  |DOIT.MYSTATE| :
    2
  R :
    (+
       -3
       ARG)
  F :
   (+ (* 2 arg) (- (* arg arg)) (- (* 2 arg arg)) (* arg arg arg))
  RES :
    0
  |FACT.DONE| :
    0

----------------------------------------------
               ===================
             ((  SYMBOLIC MENU  ))
               ===================

   1 - Print constraints
   2 - Print Runes
   3 - Remove Runes
             ---
   4 - Prove something

q:return to SIMULATION MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> 4

Enter memory element to prove (or return): F

Enter expression: (* arg (- arg 1) (- arg 2))

==========================================

             THEOREM TO BE PROVEN

==========================================
(thm
 (implies
  (and (equal (nth 0 st) arg)
       (equal (nth 1 st) 1)
       (equal (nth 2 st) 0)
       (equal (nth 3 st) 0)
       (equal (nth 4 st) 0)
       (equal (nth 5 st) 0)
       (equal (nth 6 st) 0)
       (equal (nth 7 st) 0)
       (equal (nth 8 st) 0)
       (equal (nth 9 st) 0)
       (equal (nth 10 st) 0)
       (equal (nth 11 st) 0)
       (equal (nth 12 st) 0)
       (equal (nth 13 st) 0)
       (equal (nth 14 st) 0)
       (equal (nth 15 st) 0)
       (equal (nth 16 st) 0)
       (equal (nth 17 st) 0)
       (equal (nth 18 st) 0)
       (and (naturalp arg) (> arg 12)))
  (equal
   (mysystemfact-getst
    'f
    (update-nth
     2 (+ -3 arg)
     (update-nth
      3
      (+ (* 2 arg)
         (- (* arg arg))
         (- (* 2 arg arg))
         (* arg arg arg))
      (update-nth
       4
       (+ (* 2 arg)
          (- (* arg arg))
          (- (* 2 arg arg))
          (* arg arg arg))
       (update-nth
        5 1
        (update-nth
         6 0
         (update-nth
          7 (+ -3 arg)
          (update-nth
           8
           (+ (* 2 arg)
              (- (* arg arg))
              (- (* 2 arg arg))
              (* arg arg arg))
           (update-nth
            9
            (+ (- (* 6 arg))
               (* 2 arg arg)
               (* 3 arg arg)
               (* 6 arg arg)
               (- (* arg arg arg))
               (- (* 2 arg arg arg))
               (- (* 3 arg arg arg))
               (* arg arg arg arg))
            (update-nth
             10 1
             (update-nth
              11 1
              (update-nth
               12 2
               (update-nth
                    13 (+ -3 arg)
                    (update-nth
                         14
                         (+ (* 2 arg)
                            (- (* arg arg))
                            (- (* 2 arg arg))
                            (* arg arg arg))
                         (update-nth 15 0 (update-nth 16 0 st))))))))))))))))
   (* arg (- arg 1) (- arg 2)))))


*****************************************
Do you want to print at screen ? (y or n): y

[Note:  A hint was supplied for our processing of the goal above. 
Thanks!]

By the simple :definition MYSYSTEMFACT-GETST and the :executable-counterpart
of MYSYSTEMFACT-GET-NTH we reduce the conjecture to

Goal'
(implies
 (and (equal (nth 0 st) arg)
      (equal (nth 1 st) 1)
      (equal (nth 2 st) 0)
      (equal (nth 3 st) 0)
      (equal (nth 4 st) 0)
      (equal (nth 5 st) 0)
      (equal (nth 6 st) 0)
      (equal (nth 7 st) 0)
      (equal (nth 8 st) 0)
      (equal (nth 9 st) 0)
      (equal (nth 10 st) 0)
      (equal (nth 11 st) 0)
      (equal (nth 12 st) 0)
      (equal (nth 13 st) 0)
      (equal (nth 14 st) 0)
      (equal (nth 15 st) 0)
      (equal (nth 16 st) 0)
      (equal (nth 17 st) 0)
      (equal (nth 18 st) 0)
      (integerp arg)
      (<= 0 arg)
      (< 12 arg))
 (equal
  (nth
   14
   (update-nth
    2 (+ -3 arg)
    (update-nth
     3
     (+ (* 2 arg)
        (- (* arg arg))
        (- (* 2 arg arg))
        (* arg arg arg))
     (update-nth
      4
      (+ (* 2 arg)
         (- (* arg arg))
         (- (* 2 arg arg))
         (* arg arg arg))
      (update-nth
       5 1
       (update-nth
        6 0
        (update-nth
         7 (+ -3 arg)
         (update-nth
          8
          (+ (* 2 arg)
             (- (* arg arg))
             (- (* 2 arg arg))
             (* arg arg arg))
          (update-nth
           9
           (+ (- (* 6 arg))
              (* 2 arg arg)
              (* 3 arg arg)
              (* 6 arg arg)
              (- (* arg arg arg))
              (- (* 2 arg arg arg))
              (- (* 3 arg arg arg))
              (* arg arg arg arg))
           (update-nth
            10 1
            (update-nth
             11 1
             (update-nth
               12 2
               (update-nth
                    13 (+ -3 arg)
                    (update-nth
                         14
                         (+ (* 2 arg)
                            (- (* arg arg))
                            (- (* 2 arg arg))
                            (* arg arg arg))
                         (update-nth 15 0 (update-nth 16 0 st))))))))))))))))
  (* arg (+ -1 arg) (+ -2 arg)))).

But simplification reduces this to T, using the :definition FIX, the
:executable-counterparts of BINARY-*, EQUAL, NFIX and UNARY--, primitive
type reasoning and the :rewrite rules ASSOCIATIVITY-OF-+, COMMUTATIVITY-
2-OF-*, COMMUTATIVITY-2-OF-+, COMMUTATIVITY-OF-*, DISTRIBUTIVITY, DISTRIBUTIVI\
TY-OF-MINUS-OVER-+, FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-RIGHT, LEMMA_-
NTH_UPDATE-NTH1, LEMMA_NTH_UPDATE-NTH2BIS and UNICITY-OF-1.

Q.E.D.

Summary
Form:  ( THM ...)
Rules: ((:definition fix)
        (:definition mysystemfact-getst)
        (:definition not)
        (:executable-counterpart binary-*)
        (:executable-counterpart equal)
        (:executable-counterpart mysystemfact-get-nth)
        (:executable-counterpart nfix)
        (:executable-counterpart unary--)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite distributivity)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite lemma_nth_update-nth1)
        (:rewrite lemma_nth_update-nth2bis)
        (:rewrite unicity-of-1))
Warnings:  None
Time:  0.37 seconds (prove: 0.31, print: 0.00, other: 0.06)

Proof succeeded.

Congratulations ;-) Your property is True.

----------------------------------------------
               ===================
             ((  SYMBOLIC MENU  ))
               ===================

   1 - Print constraints
   2 - Print Runes
   3 - Remove Runes
             ---
   4 - Prove something

q:return to SIMULATION MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> q


----------------------------------------------
               ===================
             ((  SIMULATION MENU  ))
               ===================

   1 - Run numeric or symbolic simulation
   2 - Print memory state
   3 - Edit memory state
   4 - Reset memory state

q:return to MAIN MENU  
----------------------------------------------
loaded : "MYSYSTEM FACT"
Vhdl_Acl2> q

----------------------------------------------
               =============
             ((  MAIN MENU  ))
               =============

     1 - Vhdl -> nif
     2 - nif  -> acl2
     3 - Load a description
                  --
     4 - Change directory path

q:quit           $Date: 2002/05/02 12:29:52 $
----------------------------------------------
"/local/crash/gp34/nif2acl2/"
Vhdl_Acl2> q
<state>
ACL2 !>