;;; This file demonstrates the tail recursion generic theory on the following
;;; 6502 program that sums the integers from 1 to N.

;;;        {N=nsave ^ (N*(N+1))/2 < 256}

;;;         LDA #0     load the A register immediate with the value 0
;;;         CLC        clear the carry flag
;;; LOOP    ADC N      add with carry N to the contents of A
;;;         DEC N      decrement N by 1
;;;         BNE LOOP   branch on non-zero to LOOP

;;;        {A=(nsave*(nsave+1))/2}

;;; Provide semantics for the Mostek 6502 DEC instruction.  The remaining
;;; instructions have semantics built into the weakest precondition generation
;;; program.

(note-lib "modularithmetic-98")
(load "generic-theories.events")

(defn dec (x)
  (if (zerop x)
      255
    (sub1 x)))

;;; Mechanically generated weakest precondition at location LOOP

(DEFN WP-LOOP (N A C NSAVE)
  (IF (EQUAL (DEC N) 0)
      (EQUAL (REMAINDER (PLUS C (PLUS A N)) 256)
	     (QUOTIENT (TIMES NSAVE (PLUS 1 NSAVE)) 2))
      (WP-LOOP (DEC N)
	       (REMAINDER (PLUS C (PLUS A N)) 256)
	       (QUOTIENT (PLUS C (PLUS A N)) 256)
	       NSAVE))
  ((lessp (if (zerop n) 256 n))))

;;; Weakest precondition at start of program

(DEFN WP-1 (N NSAVE) (WP-LOOP N 0 0 NSAVE))

;;; We represent the "a" component of state directly by a, and the "s"
;;; component by a list.

(defn n (s) (car s))
(defn c (s) (cadr s))
(defn nsave (s) (caddr s))

;;; Define the instantiation of h from the generic theory.

(defn wp-loop-h (s)
  (if (equal (dec (n s)) 0)
      0
    (plus (n s) (wp-loop-h (list (dec (n s)) (c s) (nsave s)))))
  ((lessp (if (zerop (n s)) 256 (n s)))))

;;; Instantiate g=h from the tail recursion theory.

(functionally-instantiate wp-loop-g=h nil
  (implies (and (not (zerop (n s)))
		(equal (c s) 0)
		(lessp (plus a (quotient (times (n s) (add1 (n s))) 2)) 256))
	   (equal (wp-loop (n s) a (c s) (nsave s))
		  (if (equal (dec (n s)) 0)
		      (equal (remainder (plus a (n s)) 256)
			     (quotient (times (nsave s) (add1 (nsave s))) 2))
		    (let ((a (if (equal (dec (n s)) 0)
				 a
			       (plus a (wp-loop-h s))))
			  (s (if (equal (dec (n s)) 0)
				 s
			       (list 1 (c s) (nsave s)))))
		      (equal (remainder (plus a (n s)) 256)
			     (quotient (times (nsave s) (add1 (nsave s))) 2))))))
  g=h
  ((bb (lambda (s) (equal (dec (n s)) 0)))
   (qt (lambda (a s) (equal (remainder (plus a (n s)) 256)
			    (quotient (times (nsave s) (add1 (nsave s))) 2))))
   (g (lambda (a s) (wp-loop (n s) a (c s) (nsave s))))
   (measure-g (lambda (s) (if (zerop (n s)) 256 (n s))))
   (tau (lambda (s) (list (dec (n s)) (c s) (nsave s))))
   (rho (lambda (a s) (remainder (plus a (c s) (n s)) 256)))
   (rhoh (lambda (a s) (plus a (n s))))
   (h (lambda (s) (wp-loop-h s)))
   (rt (lambda (a s) (and (not (zerop (n s)))
			  (equal (c s) 0)
			  (lessp (plus a (quotient (times (n s) (add1 (n s))) 2))
				 256))))
   (id (lambda () 0))
   (op (lambda (a x s) (if (equal (dec (n s)) 0)
			   a
			 (plus a x))))
   (hs (lambda (s) (if (equal (dec (n s)) 0)
		       s
		     (list 1 (c s) (nsave s))))))
  ((disable-theory if-normalization)
   (expand (times v v) (times v w))
   (disable quotient-add1-arg2
	    remainder-add1-arg2
	    quotient-plus-arg1
	    remainder-plus-arg1
	    remainder-plus-arg1-simple
	    equal-add1
	    remainder-difference-arg1
	    difference-add1
	    times-add1
	    difference-plus-arg1
	    sub1-quotient
	    sub1-remainder
	    sub1-plus
	    sub1-times
	    dichotomy)))

;;; Transform above to a flat state space rule.

(prove-lemma wp-loop-g=h-rewrite (rewrite)
 (implies (and (not (zerop n))
	       (equal c 0)
	       (lessp (plus a (quotient (times n (add1 n)) 2)) 256))
	   (equal (wp-loop n a c nsave)
		  (if (equal (dec n) 0)
		      (equal (remainder (plus a n) 256)
			     (quotient (times nsave (add1 nsave)) 2))
		    (let ((a (plus a (wp-loop-h (list n c nsave)))))
		      (equal (remainder (add1 a) 256)
			     (quotient (times nsave (add1 nsave)) 2))))))
 ((disable-theory if-normalization)
  (use (wp-loop-g=h (a a) (s (list n c nsave))))
  (hands-off difference)
  (disable quotient-add1-arg2
	   remainder-add1-arg2
	   quotient-plus-arg1
	   remainder-plus-arg1
	   remainder-plus-arg1-simple
	   equal-add1
	   times-add1
	   plus-add1
	   sub1-plus
	   remainder-difference-arg1
	   )))

;;; Closed form for wp-loop-h

(prove-lemma wp-loop-h-closed (rewrite)
  (implies (not (zerop (n s)))
	   (equal (wp-loop-h s)
		  (sub1 (quotient (times (n s) (add1 (n s))) 2))))
  ((induct (wp-loop-h s))
   (disable quotient-add1-arg2
	    remainder-add1-arg2
	    sub1-quotient
	    quotient-times-arg1
	    quotient-times-arg1-kb
	    quotient-plus-arg1
	    remainder-difference-arg1
	    )))

;;; Final correctness result

(prove-lemma wp-loop-is-correct (rewrite)
	     (implies (and (not (zerop n))
			   (lessp (quotient (times n (add1 n)) 2) 256)
			   (equal nsave n))
		      (wp-1 n nsave))
	     ((disable-theory if-normalization)
	      (hands-off difference)
	      (disable quotient-add1-arg2
		       remainder-add1-arg2
		       quotient-plus-arg1
		       remainder-plus-arg1
		       remainder-plus-arg1-simple
		       equal-add1
		       times-add1
		       sub1-plus
		       plus-add1
		       remainder-add1-arg1
		       sub1-times
		       )))
