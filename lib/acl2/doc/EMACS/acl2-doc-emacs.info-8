This is acl2-doc-emacs.info, produced by makeinfo version 4.5 from
acl2-doc-emacs.texinfo.

This is documentation for ACL2 Version 3.1
Copyright (C) 2006  University of Texas at Austin

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

Written by:  Matt Kaufmann and J Strother Moore
Department of Computer Sciences
University of Texas at Austin
Austin, TX 78712-1188 U.S.A.

INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* acl2: (acl2-doc-emacs.info). Applicative Common Lisp
END-INFO-DIR-ENTRY


File: acl2-doc-emacs.info,  Node: MORE!,  Next: MORE-DOC,  Prev: MORE,  Up: DOCUMENTATION

MORE!    another response to ``(type :more for more, :more! for the rest)''

NOTE:  The command :more! only makes sense at the terminal.

     Example:
     ACL2 !>:more!

will print all of the remaining documentation started by the last :doc
or :more-doc.

See *Note MORE:: for some background.  Typing :more! will print all
remaining blocks of documentation.

:More! is like :more except that it prints all the text at once.  For
example, if you type :doc name you will see some text followed by
"(type :more for more, :more! for the rest)".  If you then type simply
:more! you will see all of the details, while if you type :more you
will be fed the next block of details.


File: acl2-doc-emacs.info,  Node: MORE-DOC,  Next: NQTHM-TO-ACL2,  Prev: MORE!,  Up: DOCUMENTATION

MORE-DOC    a continuation of the :doc documentation

NOTE:  The :more-doc command only makes sense at the terminal.

     Examples:
     ACL2 !>:more-doc DEFTHM
     ACL2 !>:more-doc logical-name

Often it is assumed in the text provided by :more-doc name that you
have read the text provided by :doc name.

:More-doc just continues spewing out at you the documentation string
provided with a definition.  If the user has done his job, :doc will
probably remind you of the basics and :more-doc, if read after :doc,
will address obscure details that are nevertheless worth noting.

When :more-doc types "(type :more for more, :more! for the rest)" you
can get the next block of the continuation by typing :more or all of
the remaining blocks by typing :more!.  See *Note MORE::.


File: acl2-doc-emacs.info,  Node: NQTHM-TO-ACL2,  Prev: MORE-DOC,  Up: DOCUMENTATION

NQTHM-TO-ACL2    ACL2 analogues of Nqthm functions and commands

     Example Forms:
     :nqthm-to-acl2 prove-lemma   ; Display ACL2 topic(s) and/or print
                                  ; information corresponding to Nqthm
                                  ; PROVE-LEMMA command.
     (nqthm-to-acl2 'prove-lemma) ; Same as above.
     
     General Form:
     (nqthm-to-acl2 name)

where name is a notion documented for Nqthm:  either a function in the
Nqthm logic, or a command.  If there is corresponding information
available for ACL2, it will be printed in response to this command.
This information is not intended to be completely precise, but rather,
is intended to help those familiar with Nqthm to make the transition to
ACL2.

We close with two tables that contain all the information used by this
nqthm-to-acl2 command.  The first shows the correspondence between
functions in the Nqthm logic and corresponding ACL2 functions (when
possible); the second is similar, but for commands rather than
functions.

     Nqthm functions  -->     ACL2
     ----------------------------------------
     ADD1          -->  1+
     ADD-TO-SET    -->  ADD-TO-SET-EQUAL and ADD-TO-SET-EQ
     AND           -->  AND
     APPEND        -->  APPEND and BINARY-APPEND
     APPLY-SUBR    -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     APPLY$        -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     ASSOC         -->  ASSOC-EQUAL, ASSOC and ASSOC-EQ
     BODY          -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     CAR           -->  CAR
     CDR           -->  CDR
     CONS          -->  CONS
     COUNT         -->  ACL2-COUNT
     DIFFERENCE    -->  -
     EQUAL         -->  EQUAL, EQ, EQL and =
     EVAL$         -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     FALSE         -->  Nqthm's F corresponds to the ACL2 symbol NIL.
     FALSEP        -->  NOT and NULL
     FORMALS       -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     GEQ           -->  >=
     GREATERP      -->  >
     IDENTITY      -->  IDENTITY
     IF            -->  IF
     IFF           -->  IFF
     IMPLIES       -->  IMPLIES
     LEQ           -->  <=
     LESSP         -->  <
     LISTP         -->  CONSP
     LITATOM       -->  SYMBOLP
     MAX           -->  MAX
     MEMBER        -->  MEMBER-EQUAL, MEMBER and MEMBER-EQ
     MINUS         -->  - and UNARY--
     NEGATIVEP     -->  MINUSP
     NEGATIVE-GUTS -->  ABS
     NLISTP        -->  ATOM
     NOT           -->  NOT
     NUMBERP       -->  ACL2-NUMBERP, INTEGERP and RATIONALP
     OR            -->  OR
     ORDINALP      -->  O-P
     ORD-LESSP     -->  O<
     PACK          -->  See intern and coerce.
     PAIRLIST      -->  PAIRLIS$
     PLUS          -->  + and BINARY-+
     QUOTIENT      -->  /
     REMAINDER     -->  REM and MOD
     STRIP-CARS    -->  STRIP-CARS
     SUB1          -->  1-
     TIMES         -->  * and BINARY-*
     TRUE          -->  The symbol T.
     UNION         -->  UNION-EQUAL and UNION-EQ
     UNPACK        -->  See symbol-name and coerce.
     V&C$          -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     V&C-APPLY$    -->  No correspondent, but see the documentation for
                        DEFEVALUATOR and META.
     ZERO          -->  The number 0.
     ZEROP         -->  ZP
     
     ========================================
     
     Nqthm commands   -->     ACL2
     ----------------------------------------
     ACCUMULATED-PERSISTENCE
                   -->  ACCUMULATED-PERSISTENCE
     ADD-AXIOM     -->  DEFAXIOM
     ADD-SHELL     -->  There is no shell principle in ACL2.
     AXIOM         -->  DEFAXIOM
     BACKQUOTE-SETTING
                   -->  Backquote is supported in ACL2, but not
                        currently documented.
     BOOT-STRAP    -->  GROUND-ZERO
     BREAK-LEMMA   -->  MONITOR
     BREAK-REWRITE -->  BREAK-REWRITE
     CH            -->  PBT
                        See also :DOC history.
     CHRONOLOGY    -->  PBT
                        See also :DOC history.
     COMMENT       -->  DEFLABEL
     COMPILE-UNCOMPILED-DEFNS
                   -->  COMP
     CONSTRAIN     -->  See :DOC encapsulate and :DOC local.
     DATA-BASE     -->  Perhaps the closest ACL2 analogue of DATA-BASE
                        is PROPS.  But see :DOC history for a collection
                        of commands for querying the ACL2 database
                        (``world'').  Note that the notions of
                        supporters and dependents are not supported in
                        ACL2.
     DCL           -->  DEFSTUB
     DEFN          -->  DEFUN and DEFMACRO
     DEFTHEORY     -->  DEFTHEORY
     DISABLE       -->  DISABLE
     DISABLE-THEORY
                   -->  See :DOC theories.  The Nqthm command
                        (DISABLE-THEORY FOO) corresponds roughly to the
                        ACL2 command
                        (in-theory (set-difference-theories
                                     (current-theory :here)
                                     (theory 'foo))).
     DO-EVENTS     -->  LD
     DO-FILE       -->  LD
     ELIM          -->  ELIM
     ENABLE        -->  ENABLE
     ENABLE-THEORY -->  See :DOC theories.  The Nqthm command
                        (ENABLE-THEORY FOO) corresponds roughly to the
                        ACL2 command
                        (in-theory (union-theories
                                     (theory 'foo)
                                     (current-theory :here))).
     EVENTS-SINCE  -->  PBT
     FUNCTIONALLY-INSTANTIATE
                   -->  ACL2 provides a form of the :USE hint that
                        corresponds roughly to the
                        FUNCTIONALLY-INSTANTIATE event of Nqthm. See
                        :DOC lemma-instance.
     GENERALIZE    -->  GENERALIZE
     HINTS         -->  HINTS
     LEMMA         -->  DEFTHM
     MAINTAIN-REWRITE-PATH
                   -->  BRR
     MAKE-LIB      -->  There is no direct analogue of Nqthm's notion of
                        ``library.''  See :DOC books for a description
                        of ACL2's mechanism for creating and saving
                        collections of events.
     META          -->  META
     NAMES         -->  NAME
     NOTE-LIB      -->  INCLUDE-BOOK
     PPE           -->  PE
     PROVE         -->  THM
     PROVEALL      -->  See :DOC ld and :DOC certify-book.  The latter
                        corresponds to Nqthm's PROVE-FILE,which may be
                        what you're interested in,really.
     PROVE-FILE    -->  CERTIFY-BOOK
     PROVE-FILE-OUT
                   -->  CERTIFY-BOOK
     PROVE-LEMMA   -->  DEFTHM
                        See also :DOC hints.
     R-LOOP        -->  The top-level ACL2 loop is an evaluation loop as
                        well, so no analogue of R-LOOP is necessary.
     REWRITE       -->  REWRITE
     RULE-CLASSES  -->  RULE-CLASSES
     SET-STATUS    -->  IN-THEORY
     SKIM-FILE     -->  LD-SKIP-PROOFSP
     TOGGLE        -->  IN-THEORY
     TOGGLE-DEFINED-FUNCTIONS
                   -->  EXECUTABLE-COUNTERPART-THEORY
     TRANSLATE     -->  TRANS and TRANS1
     UBT           -->  UBT and U
     UNBREAK-LEMMA -->  UNMONITOR
     UNDO-BACK-THROUGH
                   -->  UBT
     UNDO-NAME     -->  See :DOC ubt.  There is no way to undo names in
                        ACL2 without undoing back through such names.
                        However, see :DOC ld-skip-proofsp for
                        information about how to quickly recover the
                        state.


File: acl2-doc-emacs.info,  Node: EVENTS,  Next: HISTORY,  Prev: DOCUMENTATION,  Up: Top

EVENTS    functions that extend the logic

* Menu:

* ADD-BINOP:: associate a binary function name with a macro name

* ADD-DEFAULT-HINTS:: add to the default hints

* ADD-DEFAULT-HINTS!:: add to the default hints non-locally

* ADD-DIVE-INTO-MACRO:: associate proof-checker diving function with macro name

* ADD-INCLUDE-BOOK-DIR:: associate directory to keyword for include-book's :dir argument

* ADD-INVISIBLE-FNS:: make some unary functions invisible to the loop-stopper algorithm

* ADD-MACRO-ALIAS:: associate a function name with a macro name

* ADD-MATCH-FREE-OVERRIDE:: set :match-free value to :once or :all in existing rules

* ADD-NTH-ALIAS:: associate one symbol with another for printing of nth/update-nth terms

* ASSERT-EVENT:: assert that a given form returns a non-nil value

* BINOP-TABLE:: associates binary function with the corresponding macro

* COMP:: compile some ACL2 functions

* DEFABBREV:: a convenient form of macro definition for simple expansions

* DEFAULT-HINTS-TABLE:: a table used to provide hints for proofs

* DEFAXIOM:: add an axiom

* DEFCHOOSE:: define a Skolem (witnessing) function

* DEFCONG:: prove that one equivalence relation preserves another in a given
 argument position of a given function

* DEFCONST:: define a constant

* DEFDOC:: add a documentation topic

* DEFEQUIV:: prove that a function is an equivalence relation

* DEFEVALUATOR:: introduce an evaluator function

* DEFEXEC:: attach a terminating executable function to a definition

* DEFLABEL:: build a landmark and/or add a documentation topic

* DEFMACRO:: define a macro

* DEFPKG:: define a new symbol package

* DEFREFINEMENT:: prove that equiv1 refines equiv2

* DEFSTOBJ:: define a new single-threaded object

* DEFSTUB:: stub-out a function symbol

* DEFTHEORY:: define a theory (to enable or disable a set of rules)

* DEFTHM:: prove and name a theorem

* DEFTHMD:: prove and name a theorem and then disable it

* DEFTTAG:: introduce a trust tag (ttag)

* DEFUN:: define a function symbol

* DEFUN-SK:: define a function whose body has an outermost quantifier

* DEFUND:: define a function symbol and then disable it

* DELETE-INCLUDE-BOOK-DIR:: remove association of keyword for include-book's :dir argument

* DIVE-INTO-MACROS-TABLE:: right-associated function information for the proof-checker

* ENCAPSULATE:: constrain some functions and/or hide some events

* IN-ARITHMETIC-THEORY:: designate ``current'' theory for some rewriting done in linear arithmetic

* IN-THEORY:: designate ``current'' theory (enabling its rules)

* INCLUDE-BOOK:: load the events in a file

* INVISIBLE-FNS-TABLE:: functions that are invisible to the loop-stopper algorithm

* LOCAL:: hiding an event in an encapsulation or book

* LOGIC:: to set the default defun-mode to :logic

* MACRO-ALIASES-TABLE:: a table used to associate function names with macro names

* MAKE-EVENT:: evaluate (expand) a given form and then evaluate the result

* MUTUAL-RECURSION:: define some mutually recursive functions

* NTH-ALIASES-TABLE:: a table used to associate names for nth/update-nth printing

* PROGN:: evaluate some events

* PROGN!:: evaluate some forms, not necessarily events

* PROGRAM:: to set the default defun-mode to :program

* PUSH-UNTOUCHABLE:: add name or list of names to the list of untouchable symbols

* REDO-FLAT:: redo up through a failure in an encapsulate or progn

* REMOVE-BINOP:: remove the association of a binary function name with a macro name

* REMOVE-DEFAULT-HINTS:: remove from the default hints

* REMOVE-DEFAULT-HINTS!:: remove from the default hints non-locally

* REMOVE-DIVE-INTO-MACRO:: removes association of proof-checker diving function with macro name

* REMOVE-INVISIBLE-FNS:: make some unary functions no longer invisible

* REMOVE-MACRO-ALIAS:: remove the association of a function name with a macro name

* REMOVE-NTH-ALIAS:: remove the association of one symbol with another for printing of nth/update-nth terms

* REMOVE-UNTOUCHABLE:: remove name or list of names to the list of untouchable symbols

* RESET-PREHISTORY:: reset the prehistory

* SET-BACKCHAIN-LIMIT:: Sets the backchain-limit used by the rewriter

* SET-BODY:: set the definition body

* SET-BOGUS-MUTUAL-RECURSION-OK:: allow unnecessary ``mutual recursion''

* SET-CASE-SPLIT-LIMITATIONS:: set the case-split-limitations

* SET-COMPILE-FNS:: have each function compiled as you go along.

* SET-DEFAULT-BACKCHAIN-LIMIT:: sets the default backchain-limit used when admitting a rule

* SET-DEFAULT-HINTS:: set the default hints

* SET-DEFAULT-HINTS!:: set the default hints non-locally

* SET-ENFORCE-REDUNDANCY:: require most events to be redundant

* SET-IGNORE-OK:: allow unused formals and locals without an ignore or ignorable declaration

* SET-INHIBIT-WARNINGS:: control warnings

* SET-INVISIBLE-FNS-TABLE:: set the invisible functions table

* SET-IRRELEVANT-FORMALS-OK:: allow irrelevant formals in definitions

* SET-LET*-ABSTRACTIONP:: to shorten many prettyprinted clauses

* SET-MATCH-FREE-DEFAULT:: provide default for :match-free in future rules

* SET-MATCH-FREE-ERROR:: control error vs. warning when :match-free is missing

* SET-MEASURE-FUNCTION:: set the default measure function symbol

* SET-NON-LINEARP:: to turn on or off non-linear arithmetic reasoning

* SET-NU-REWRITER-MODE:: to turn on and off the nu-rewriter

* SET-REWRITE-STACK-LIMIT:: Sets the rewrite stack depth used by the rewriter

* SET-STATE-OK:: allow the use of STATE as a formal parameter

* SET-VERIFY-GUARDS-EAGERNESS:: the eagerness with which guard verification is tried.

* SET-WELL-FOUNDED-RELATION:: set the default well-founded relation

* TABLE:: user-managed tables

* TERM-TABLE:: a table used to validate meta rules

* THEORY-INVARIANT:: user-specified invariants on theories

* USER-DEFINED-FUNCTIONS-TABLE:: an advanced table used to replace certain system functions

* VERIFY-GUARDS:: verify the guards of a function

* VERIFY-TERMINATION:: convert a function from :program mode to :logic mode

* WITH-OUTPUT:: suppressing or turning on specified output for an event

Any extension of the syntax of ACL2 (i.e., the definition of a new
constant or macro), the axioms (i.e., the definition of a function), or
the rule data base (i.e., the proof of a theorem), constitutes a
logical "event." Events change the ACL2 logical world (see *note
WORLD::).  Indeed, the only way to change the ACL2 world is via the
successful evaluation of an event function.  Every time the world is
changed by an event, a landmark is left on the world and it is thus
possible to identify the world "as of" the evaluation of a given event.
An event may introduce new logical names.  Some events introduce no
new names (e.g., verify-guards), some introduce exactly one (e.g.,
defmacro and defthm), and some may introduce many (e.g., encapsulate ).


File: acl2-doc-emacs.info,  Node: ADD-BINOP,  Next: ADD-DEFAULT-HINTS,  Prev: EVENTS,  Up: EVENTS

ADD-BINOP    associate a binary function name with a macro name

     Example:
     (add-binop append binary-append)

This example associates the function symbol binary-append with the
macro name append.  As a result, theory functions will understand that
append refers to binary-append -- see *note ADD-MACRO-ALIAS:: -- and
moreover, proof output will be printed using append rather than
binary-append, e.g., (append x y z w) is printed rather than
(binary-append x (binary-append y (binary-append z w))).

     General Form:
     (add-binop macro-name function-name)

This is a convenient way to add an entry to macro-aliases-table and at
the same time extend the :binop-table.  See *Note
MACRO-ALIASES-TABLE::, see *note REMOVE-MACRO-ALIAS::, see *note
BINOP-TABLE::, and see *note REMOVE-BINOP::.


File: acl2-doc-emacs.info,  Node: ADD-DEFAULT-HINTS,  Next: ADD-DEFAULT-HINTS!,  Prev: ADD-BINOP,  Up: EVENTS

ADD-DEFAULT-HINTS    add to the default hints


     Examples:
     (add-default-hints '((computed-hint-1 clause)
                          (computed-hint-2 clause
                                           stable-under-simplificationp)))

Note: This is an event!  It does not print the usual event summary but
nevertheless changes the ACL2 logical world and is so recorded.  It is
local to the book or encapsulate form in which it occurs (see *note
ADD-DEFAULT-HINTS!:: for a corresponding non-local event).

     General Form:
     (add-default-hints lst)

where lst is a list.  Generally speaking, the elements of lst should be
suitable for use as computed-hints.

This event is completely analogous to set-default-hints, the difference
being that add-default-hints appends the indicated hints to the list of
default hints, rather than *replacing* the default hints with the
indicated hints.

Finally, note that the effects of set-default-hints, add-default-hints,
and remove-default-hints are local to the book in which they appear.
Thus, users who include a book with such forms will not have their
default hints affected by such forms.  In order to export the effect of
setting the default hints, use set-default-hints!, add-default-hints!,
or remove-default-hints!.


File: acl2-doc-emacs.info,  Node: ADD-DEFAULT-HINTS!,  Next: ADD-DIVE-INTO-MACRO,  Prev: ADD-DEFAULT-HINTS,  Up: EVENTS

ADD-DEFAULT-HINTS!    add to the default hints non-locally

Please see *note ADD-DEFAULT-HINTS::, which is the same as
add-default-hints!  except that the latter is not local to the
encapsulate or the book in which it occurs.  Probably add-default-hints
is to be preferred unless you have a good reason for wanting to export
the effect of this event outside the enclosing encapsulate or book.


File: acl2-doc-emacs.info,  Node: ADD-DIVE-INTO-MACRO,  Next: ADD-INCLUDE-BOOK-DIR,  Prev: ADD-DEFAULT-HINTS!,  Up: EVENTS

ADD-DIVE-INTO-MACRO    associate proof-checker diving function with macro name

     Examples:
     (add-dive-into-macro cat expand-address-cat)

This feature is used so that the proof-checker's DV command and numeric
diving commands (e.g., 3) will dive properly into subterms.  Please see
*note DIVE-INTO-MACROS-TABLE::.


File: acl2-doc-emacs.info,  Node: ADD-INCLUDE-BOOK-DIR,  Next: ADD-INVISIBLE-FNS,  Prev: ADD-DIVE-INTO-MACRO,  Up: EVENTS

ADD-INCLUDE-BOOK-DIR    associate directory to keyword for include-book's :dir argument

     Example Form:
     (add-include-book-dir :smith "/u/smith/")
      ; For (include-book "foo" :dir :smith), prepend "/u/smith/" to "foo".
     
     General Form:
     (add-include-book-dir kwd dir)

where kwd is a keywordp and dir is the absolute pathname (see *note
PATHNAME::) of a directory.  The effect of this event is to modify the
meaning of the :dir keyword argument of include-book as indicated by
the examples above, namely by associating the indicated directory with
the indicated keyword for purposes of the include-book :dir argument.
See *Note DELETE-INCLUDE-BOOK-DIR:: for how to undo this effect.

Caveat: The keyword :system cannot be redefined.  It will always point
to the absolute pathname of the distributed books directory, which by
default is immediately under the directory where the ACL2 executable
was originally built (see *note INCLUDE-BOOK::, in particular the
discussion there of "books directory").

Note: This is an event!  It does not print the usual event summary but
nevertheless changes the ACL2 logical world and is so recorded.

This macro generates a call (table acl2-defaults-table
:include-book-dir-alist ...)  and hence is local to any books and
encapsulate events in which it occurs. See *Note ACL2-DEFAULTS-TABLE::.


File: acl2-doc-emacs.info,  Node: ADD-INVISIBLE-FNS,  Next: ADD-MACRO-ALIAS,  Prev: ADD-INCLUDE-BOOK-DIR,  Up: EVENTS

ADD-INVISIBLE-FNS    make some unary functions invisible to the loop-stopper algorithm

     Examples:
     (add-invisible-fns binary-+ unary-- foo)

The setting above has makes unary functions unary- and foo "invisible"
for the purposes of applying permutative :rewrite rules to binary-+
trees.  Thus, arg and (unary- arg) will be given the same weight and
will be permuted so as to be adjacent.

     General Form:
     (add-invisible-fns top-fn unary-fn1 ... unary-fnk)

where top-fn is a function symbol and the unary-fni are unary function
symbols.

For more information see *note INVISIBLE-FNS-TABLE::.  Also see *note
SET-INVISIBLE-FNS-TABLE::, which explains how to set the entire table
in a single event, and see *note REMOVE-INVISIBLE-FNS::.


File: acl2-doc-emacs.info,  Node: ADD-MACRO-ALIAS,  Next: ADD-MATCH-FREE-OVERRIDE,  Prev: ADD-INVISIBLE-FNS,  Up: EVENTS

ADD-MACRO-ALIAS    associate a function name with a macro name

     Example:
     (add-macro-alias append binary-append)

This example associates the function symbol binary-append with the
macro name append.  As a result, the name append may be used as a runic
designator (see *note THEORIES::) by the various theory functions.  See
*Note MACRO-ALIASES-TABLE:: for more details.

     General Form:
     (add-macro-alias macro-name function-name)

This is a convenient way to add an entry to macro-aliases-table.  See
*Note MACRO-ALIASES-TABLE:: and also see *note REMOVE-MACRO-ALIAS::.


File: acl2-doc-emacs.info,  Node: ADD-MATCH-FREE-OVERRIDE,  Next: ADD-NTH-ALIAS,  Prev: ADD-MACRO-ALIAS,  Up: EVENTS

ADD-MATCH-FREE-OVERRIDE    set :match-free value to :once or :all in existing rules

     Example Forms:
     (add-match-free-override :once t)
         ; Try only the first binding of free variables when relieving hypotheses
         ; of any rule of class :rewrite, :linear, or :forward-chaining.
     (add-match-free-override :all (:rewrite foo) (:rewrite bar))
         ; For rewrite rules foo and bar, try all bindings of free variables when
         ; relieving hypotheses.
     (add-match-free-override :clear)
         ; Restore :match-free to what was originally stored for each rule (either
         ; :all or :once).

As described elsewhere (see *note FREE-VARIABLES::), a rewrite, linear,
or forward-chaining rule may have free variables in its hypotheses, and
ACL2 can be directed either to try all bindings (":all") or just the
first (":once") when relieving a hypothesis, as a basis for relieving
subsequent hypotheses.  This direction is generally provided by
specifying either :match-free :once or :match-free :all in the
:rule-classes of the rule, or by using the most recent
set-match-free-default event.  Also see *note RULE-CLASSES::.

However, if a proof is going slowly, you may want to modify the
behavior of some such rules so that they use only the first match for
free variables in a hypothesis when relieving subsequent hypotheses,
rather than backtracking and trying additional matches as necessary.
The event (add-match-free-override :once t) has that effect.  Or at the
other extreme, perhaps you want to specify all rules as :all rules
except for a some specific exceptions.  Then you can execute
(add-match-free-override :all t) followed by, say,
(add-match-free-override :once (:rewrite foo) (:linear bar)).

     General Forms:
     (add-match-free-override :clear)
     (add-match-free-override flg t)
     (add-match-free-override flg rune1 rune2 ... runek)

where flg is :once or :all and the runei are runes.  If :clear is
specified then all rules will have the :all/:once behavior from when
they were first stored.  The second general form causes all rewrite
linear, and forward-chaining rules to have the behavior specified by
flg (:all or :once).  Finally, the last of these, where runes are
specified, is additive in the sense that only the indicated rules are
affected; all others keep the behavior they had just before this event
was executed (possible because of earlier add-match-free-override
events).

At the conclusion of this event, ACL2 prints out the list of all
:linear, :rewrite, and :forward-chaining runes whose rules contain free
variables in hypotheses that are to be bound :once, except that if
there are no overrides (value :clear was used), then :clear is printed.

This event only affects rules that exist at the time it is executed.
Future rules are not affected by the override.

Note: This is an event!  It does not print the usual event summary but
nevertheless changes the ACL2 logical world and is so recorded.  It
uses the acl2-defaults-table, and hence its effect is local to the book
or encapsulate form in which it occurs.

_Remarks_

Lists of the :rewrite, :linear, and :forward-chaining runes whose
behavior was originally :once or :all are returned by the following
forms, respectively.

     (free-var-runes :once (w state))
     (free-var-runes :all  (w state))

The form

     (match-free-override (w state))

evaluates to a pair, whose car is a number used by ACL2 to determine
whether a rune is sufficiently old to be affected by the override, and
whose cdr is the list of runes whose behavior is specified as :once by
add-match-free-override; except, if no runes have been overridden, then
the keyword :clear is returned.


File: acl2-doc-emacs.info,  Node: ADD-NTH-ALIAS,  Next: ASSERT-EVENT,  Prev: ADD-MATCH-FREE-OVERRIDE,  Up: EVENTS

ADD-NTH-ALIAS    associate one symbol with another for printing of nth/update-nth terms

     Example:
     (add-nth-alias st0 st)

This example associates the symbol st0 with the symbol st for purposes
of printing certain terms of the form (nth n st0) and (update-nth n val
st0).

     General Form:
     (add-nth-alias alias-name name)

This is a convenient way to add an entry to nth-aliases-table.  See
*Note NTH-ALIASES-TABLE:: and also see *note REMOVE-NTH-ALIAS::.


File: acl2-doc-emacs.info,  Node: ASSERT-EVENT,  Next: BINOP-TABLE,  Prev: ADD-NTH-ALIAS,  Up: EVENTS

ASSERT-EVENT    assert that a given form returns a non-nil value

     Examples:
     (assert-event (equal (+ 3 4) 7))
     (assert-event (equal (+ 3 4) 7) :on-skip-proofs t)
     
     General Forms:
     (assert-event form)
     (assert-event form :on-skip-proofs t)

Assert-event takes a ground form, i.e., one with no free variables;
stobjs are allowed but only a single non-stobj value can be returned.
The form is then evaluated and if the result is nil, then a so-called
hard error (see *note ER::) results.  This evaluation is however not
done if proofs are being skipped, as during include-book (also see
*note SKIP-PROOFS:: and see *note LD-SKIP-PROOFSP::), unless
:on-skip-proofs t is supplied.

This form may be put into a book to be certified (see *note BOOKS::),
because assert-event is a macro whose calls expand to calls of
value-triple (see *note EMBEDDED-EVENT-FORM::).


File: acl2-doc-emacs.info,  Node: BINOP-TABLE,  Next: COMP,  Prev: ASSERT-EVENT,  Up: EVENTS

BINOP-TABLE    associates binary function with the corresponding macro

     Examples:
     ACL2 !>(binop-table (w state))
     '((binary-+ . +)
       (binary-* . *)
       (binary-append . append)
       (binary-logand . logand)
       (binary-logior . logior)
       (binary-logxor . logxor)
       (binary-logeqv . logeqv))

See *Note TABLE:: for a general discussion of tables.

See *Note ADD-BINOP:: for a more general discussion of this table.


File: acl2-doc-emacs.info,  Node: COMP,  Next: DEFABBREV,  Prev: BINOP-TABLE,  Up: EVENTS

COMP    compile some ACL2 functions

     Examples:
     :comp t          ; compile all uncompiled ACL2 functions
     (comp t)         ; same as above, but can be put into a book
     (comp :exec)     ; compile all uncompiled logic (``*1*'') definitions
     :comp foo        ; compile the defined function foo
     :comp (:raw foo) ; compile the raw Lisp version of the defined function foo
                        but not the corresponding logic definition
     :comp (foo bar)  ; compile the defined functions foo and bar
     :comp (foo (:raw bar))  ; compile the defined functions foo and bar, but for
                             ; bar do not compile the corresponding logic definition
     
     General Form:
     :comp specifier
     where specifier is one of the following:
     
       t                     compile all user-defined ACL2 functions that are
                               currently uncompiled (redefined built-in functions
                               are not recompiled)
       :exec                 same as t, except that only logic versions are
                               compiled (see below), not raw Lisp definitions
       :raw                  same as t, except that only raw Lisp definitions are
                               compiled, not logic version (see below)
       (name-1 ... name-k)   a non-empty list of names of functions defined by
                               DEFUN in ACL2, except that each name-i can be of
                               the form (:raw sym) or (:exec sym), where sym is
                             the name of such a function
       name                  same as (name)

When you define a function in ACL2, you are really causing two
definitions to be made "under the hood" in Common Lisp: the definition
is submitted explicitly to raw Lisp, but so is a corresponding "logic
definition".  If guards have not been verified, then only the logic
definition will be evaluated; see *note GUARDS-AND-EVALUATION::, in
particular the section titled "Guards and evaluation V: efficiency
issues".

Thus, if you are not verifying guards and you want the benefit of Lisp
compilation for speed and space efficiency, then you may want to place
the form (comp :exec) in your books.

Generally it is not necessary to place the form (comp t), or the form
(comp :raw), in a book, because certify-book compiles the raw Lisp
definitions anyhow, by default.  But you may wish to put (comp t) or
(comp fn1 fn2 ... fnk) in a book when such a form precedes expensive
calls of functions, for example for proofs involving calls of functions
on large constants, or to support computationally expensive
macroexpansion.

As suggested by the examples above, if a function specifier is of the
form (:raw fn), then fn will be compiled in raw Common Lisp but its
corresponding logic definition will not be compiled; and for (:exec fn),
it's the other way around.

The use of :comp creates various files whose names start with "TMP*",
but then deletes them.  If you want to keep these files around for some
reason, evaluate (assign keep-tmp-files t).

* Menu:

* COMP-GCL:: compile some ACL2 functions leaving .c and .h files

Also see *note SET-COMPILE-FNS:: for a way to compile each function as
it is defined.  But note that set-compile-fns is ignored during
include-book.

:cited-by Programming


File: acl2-doc-emacs.info,  Node: COMP-GCL,  Prev: COMP,  Up: COMP

COMP-GCL    compile some ACL2 functions leaving .c and .h files

Comp-gcl is for use by experts who want to examine the results of GCL
compilation, and it may only be used with ACL2 implementations built on
top of GCL.  It takes exactly the same arguments as comp, and has the
same basic functionality (see *note COMP::), but has two additional
effects.  First, files "TMP.lisp" and "TMP1.lisp" are always created,
even when a single function is specified.  Second, comp-gcl always
leaves files "TMP.c", "TMP.h", "TMP1.c", and "TMP1.h" when compilation
is complete.


File: acl2-doc-emacs.info,  Node: DEFABBREV,  Next: DEFAULT-HINTS-TABLE,  Prev: COMP,  Up: EVENTS

DEFABBREV    a convenient form of macro definition for simple expansions

     Examples:
     (defabbrev snoc (x y) (append y (list x)))
     (defabbrev sq (x) (declare (type (signed-byte 8) x)) (* x x))
     
     General Form:
     (defabbrev name (v1 ... vn) doc-string decl1 ... declk body)

where name is a new function symbol, the vi are distinct variable
symbols, and body is a term.  The decli, if supplied, should be legal
declare forms; see *note DECLARE::.  Doc-string is an optional
documentation string; see *note DOC-STRING::.

Roughly speaking, the defabbrev event is akin to defining f so that (f
v1 ... vn) = body.  But rather than do this by adding a new axiom,
defabbrev defines f to be a macro so that (f a1 ... an) expands to
body, with the "formals," vi, replaced by the "actuals," ai.

For example, if snoc is defined as shown in the first example above,
then (snoc (+ i j) temp) is just an abbreviation for

     (append temp (list (+ i j))).

In order to generate efficiently executable Lisp code, the macro that
defabbrev introduces uses a let to bind the "formals" to the "actuals."
Consider the second example above.  Logically speaking, (sq (ack i j))
is an abbreviation for (* (ack i j) (ack i j)).  But in fact the macro
for sq introduced by defabbrev actually arranges for (sq (ack i j)) to
expand to:

     (let ((x (ack i j)))
       (* x x))

which executes more efficiently than (* (ack i j) (ack i j)).

In the theorem prover, the let above expands to

     ((lambda (x) (* x x)) (ack i j))

and thence to (* (ack i j) (ack i j)).

It is important to note that the term in body should not contain a call
of name -- i.e., defabbrev should not be used in place of defun when
the function is recursive.  ACL2 will not complain when the defabbrev
form is processed, but instead ACL2 will more than likely go into an
infinite loop during macroexpansion of any form that has a call of name.

It is also important to note that the parameters of any call of a macro
defined by defabbrev will, as is the case for the parameters of a
function call, be evaluated before the body is evaluated, since this is
the evaluation order of let.  This may lead to some errors or
unexpected inefficiencies during evaluation if the body contains any
conditionally evaluted forms like cond, case, or if.  Consider the
following example.

     (defabbrev foo (x y)
       (if (test x) (bar y) nil))

Notice a typical one-step expansion of a call of foo (see *note
TRANS1::):

     ACL2 !>:trans1 (foo expr1 expr2)
      (LET ((X EXPR1) (Y EXPR2))
           (IF (TEST X) (BAR Y) NIL))
     ACL2 !>

Now imagine that expr2 is a complicated expression whose evaluation is
intended only when the predicate test holds of expr1.  The expansion
above suggests that expr2 will always be evaluated by the call (foo
expr1 expr2), which may be inefficient (since perhaps we only need that
value when test is true of expr1).  The evaluation of expr2 may even
cause an error, for example in :program mode if the expression expr2 has
been constructed in a manner that could cause a guard violation unless
test holds of expr1.


File: acl2-doc-emacs.info,  Node: DEFAULT-HINTS-TABLE,  Next: DEFAXIOM,  Prev: DEFABBREV,  Up: EVENTS

DEFAULT-HINTS-TABLE    a table used to provide hints for proofs

Please see *note SET-DEFAULT-HINTS::, see *note ADD-DEFAULT-HINTS::, and
see *note REMOVE-DEFAULT-HINTS:: for how to use this table.  For
completeness, we mention here that under the hood, these events all
update the default-hints-table by updating its unique key, t, for
example as follows.

     (table default-hints-table t
            '((computed-hint-1 clause)
              (computed-hint-2 clause
                               stable-under-simplificationp)))

The use of default hints is explained elsewhere; see *note
SET-DEFAULT-HINTS::.


File: acl2-doc-emacs.info,  Node: DEFAXIOM,  Next: DEFCHOOSE,  Prev: DEFAULT-HINTS-TABLE,  Up: EVENTS

DEFAXIOM    add an axiom

WARNING: We strongly recommend that you not add axioms.  If at all
possible you should use defun or mutual-recursion to define new
concepts recursively or use encapsulate to constrain them
constructively.  If your goal is to defer a proof by using a top-down
style, consider using skip-proofs; see the discussion on "Top-Down
Proof" in Section B.1.2 of "Computer-Aided Reasoning: An Approach."
Adding new axioms frequently renders the logic inconsistent.

     Example:
     (defaxiom sbar (equal t nil)
               :rule-classes nil
               :doc ":Doc-Section ...")
     
     General Form:
     (defaxiom name term
              :rule-classes rule-classes
              :doc          doc-string)

where name is a new symbolic name (see *note NAME::), term is a term
intended to be a new axiom, and rule-classes and doc-string are as
described in the corresponding documentation topics .  The two keyword
arguments are optional.  If :rule-classes is not supplied, the list
(:rewrite) is used; if you wish the axiom to generate no rules, specify
:rule-classes nil.


File: acl2-doc-emacs.info,  Node: DEFCHOOSE,  Next: DEFCONG,  Prev: DEFAXIOM,  Up: EVENTS

DEFCHOOSE    define a Skolem (witnessing) function

     Examples:
     (defchoose choose-x-for-p-and-q (x) (y z)
       (and (p x y z)
            (q x y z)))
     
     (defchoose choose-x-for-p-and-q x (y z) ; equivalent to the above
       (and (p x y z)
            (q x y z)))
     
     ; The following is as above, but strengthens the axiom added to pick a sort
     ; of canonical witness, as described below.
     (defchoose choose-x-for-p-and-q x (y z)
       (and (p x y z)
            (q x y z))
       :strengthen t)
     
     (defchoose choose-x-and-y-for-p-and-q (x y) (z)
       (and (p x y z)
            (q x y z)))

     * Menu:
     
     * CONSERVATIVITY-OF-DEFCHOOSE:: proof of conservativity of defchoose
     
     General Form:
     (defchoose fn
                (bound-var1 ... bound-varn)
                (free-var1 ... free-vark)
                body
                :doc doc-string
                :strengthen b),

where fn is the symbol you wish to define and is a new symbolic name
(see *note NAME::), (bound-var1 ... bound-varn) is a list of distinct
`bound' variables (see below), (free-var1 ... free-vark) is the list of
formal parameters of fn and is disjoint from the bound variables, and
body is a term.  The use of lambda-list keywords (such as &optional) is
not allowed.  The documentation string argument, :doc doc-string, is
optional; for a description of the form of doc-string see *note
DOC-STRING::.  The :strengthen keyword argument is optional; if
supplied, it must be t or nil.

The system treats fn very much as though it were declared in the
signature of an encapsulate event, with a single axiom exported as
described below.  If you supply a :use hint (see *note HINTS::), :use
fn, it will refer to that axiom.  No rule (of class :rewrite or
otherwise; see *note RULE-CLASSES::) is created for fn.

Defchoose is only executed in defun-mode :logic; see *note
DEFUN-MODE::.  Also see *note DEFUN-SK::.

In the most common case, where there is only one bound variable, it is
permissible to omit the enclosing parentheses on that variable.  The
effect is the same whether or not those parentheses are omitted.  We
describe this case first, where there is only one bound variable, and
then address the other case.  Both cases are discussed assuming
:strengthen is nil, which is the default.  We deal with the case
:strengthen t at the end.

The effect of the form

     (defchoose fn bound-var (free-var1 ... free-vark)
       body)

is to introduce a new function symbol, fn, with formal parameters
(free-var1 ... free-vark).  Now consider the following axiom, which
states that fn picks a value of bound-var so that the body will be
true, if such a value exists:

     (1)   (implies body
                    (let ((bound-var (fn free-var1 ... free-vark)))
                      body))

This axiom is "clearly conservative" under the conditions expressed
above: the function fn simply picks out a "witnessing" value of
bound-var if there is one.  For a rigorous statement and proof of this
conservativity claim, see *note CONSERVATIVITY-OF-DEFCHOOSE::.

Next consider the case that there is more than one bound variable, i.e.,
there is more than one bound-var in the following.

     (defchoose fn
                (bound-var1 ... bound-varn)
                (free-var1 ... free-vark)
                body)

Then fn returns a multiple value with n componenets, and formula (1)
above is expressed using mv-let as follows:

     (implies body
              (mv-let (bound-var1 ... bound-varn)
                      (fn free-var1 ... free-vark)
                      body))

We now discuss the case that :strengthen t is supplied.  For simplicity
we return to our first example, with a single free variable, y.  The
idea is that if we pick the "smallest" witnessing bound-var for two
different free variables y and y1, then either those two witnesses are
the same, or else one is less than the other, in which case the smaller
one is a witness for its free variable but not for the other.  (See
comments in source function defchoose-constraint-extra for more
details.)  Below, body1 is the result of replacing y by y1 in body.

     (2)   (or (equal (fn y) (fn y1))
               (let ((bound-var (fn y)))
                 (and body
                      (not body1)))
               (let ((bound-var (fn y1)))
                 (and body1
                      (not body))))

An important application of this additional axiom is to be able to
define a "fixing" function that picks a canonical representative of
each equivalence class, for a given equivalence relation.  The
following events illustrate this point.

     (encapsulate
      ((equiv (x y) t))
      (local (defun equiv (x y) (equal x y)))
      (defequiv equiv))
     
     (defchoose efix (x) (y)
       (equiv x y)
       :strengthen t)
     
     (defthm equiv-implies-equal-efix-1
       (implies (equiv y y1)
                (equal (efix y) (efix y1)))
       :hints (("Goal" :use efix))
       :rule-classes (:congruence))
     
     (defthm efix-fixes
       (equiv (efix x) x)
       :hints (("Goal" :use ((:instance efix (y x))))))

If there is more than one bound variable, then (2) is modified in
complete analogy to (1) to use mv-let in place of let.

Comment for logicians:  As we point out in the documentation for
defun-sk, defchoose is "appropriate," by which we mean that it is
conservative, even in the presence of epsilon-0 induction.  For a
proof, See *Note CONSERVATIVITY-OF-DEFCHOOSE::.

