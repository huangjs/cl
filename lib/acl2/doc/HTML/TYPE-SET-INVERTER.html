<html>
<head><title>TYPE-SET-INVERTER.html  --  ACL2 Version 3.1</title></head>
<body text=#000000 bgcolor="#FFFFFF">
<h2>TYPE-SET-INVERTER</h2>exhibit a new decoding for an ACL2 type-set
<pre>Major Section:  <a href="RULE-CLASSES.html">RULE-CLASSES</a>
</pre><p>

See <a href="RULE-CLASSES.html">rule-classes</a> for a general discussion of rule classes and
how they are used to build rules from formulas.

<pre>
Example Rule Class:
(:type-set-inverter 
  :corollary (equal (and (counting-number x) (not (equal x 0)))
                    (and (integerp x) (&lt; x 0)))
  :type-set 2)
<p>
General Forms of Rule Class:
:type-set-inverter, or
(:type-set-inverter :type-set n)<p>

General Form of Theorem or Corollary:
(EQUAL new-expr old-expr)
</pre>

where <code>n</code> is a <code><a href="TYPE-SET.html">type-set</a></code> (see <a href="TYPE-SET.html">type-set</a>) and <code>old-expr</code> is the term
containing <code>x</code> as a free variable that ACL2 currently uses to
recognize <code><a href="TYPE-SET.html">type-set</a></code> <code>n</code>.  For a given <code>n</code>, the exact form of <code>old-expr</code> is
generated by

<pre>
(convert-type-set-to-term 'x n (ens state) (w state) nil)].
</pre>
<p>

If the <code>:</code><code><a href="TYPE-SET.html">type-set</a></code> field of the rule-class is omitted, we attempt to
compute it from the right-hand side, <code>old-expr</code>, of the corollary.
That computation is done by <code>type-set-implied-by-term</code>
(see <a href="TYPE-SET.html">type-set</a>).  However, it is possible that the type-set we
compute from <code>lhs</code> does not have the required property that when
inverted with <code>convert-type-set-to-term</code> the result is <code>lhs</code>.  If you
omit <code>:</code><code><a href="TYPE-SET.html">type-set</a></code> and an error is caused because <code>lhs</code> has the incorrect
form, you should manually specify both <code>:</code><code><a href="TYPE-SET.html">type-set</a></code> and the <code>lhs</code>
generated by <code>convert-type-set-to-term</code>.<p>

The rule generated will henceforth make <code>new-expr</code> be the term used by
ACL2 to recognize type-set <code>n</code>.  If this rule is created by a <code><a href="DEFTHM.html">defthm</a></code>
event named <code>name</code> then the rune of the rule is
<code>(:type-set-inverter name)</code> and by disabling that rune you can
prevent its being used to decode type-sets.<p>

Type-sets are inverted when forced assumptions are turned into
formulas to be proved.  In their internal form, assumptions are
essentially pairs consisting of a context and a goal term, which was
forced.  Abstractly a context is just a list of hypotheses which may
be assumed while proving the goal term.  But actually contexts are
alists which pair terms with type-sets, encoding the current
hypotheses.  For example, if the original conjecture contained the
hypothesis <code>(integerp x)</code> then the context used while working on that
conjecture will include the assignment to <code>x</code> of the type-set
<code>*ts-integer*</code>.
<br><br><br><a href="acl2-doc.html"><img src="llogo.gif"></a> <a href="acl2-doc-index.html"><img src="index.gif"></a>
</body>
</html>
