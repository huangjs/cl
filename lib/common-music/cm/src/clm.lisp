;;; **********************************************************************
;;; Copyright (C) 2007 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from clm.scm on 30-Jan-2007 07:38:59

(in-package :cm)

(defun clm-print-par-value (v s)
  (when (consp v) (write-char #\' s))
  (write v :stream s))

(defun clm-par-print (par objv filv timv)
  (let* ((raw
          (if (parameter-time? par) timv
              (slot-getter-form objv (parameter-slot par))))
         (acc
          (if (parameter-decimals par)
              `(decimals ,raw ,(parameter-decimals par)) raw))
         (delim #\ ))
    (case (parameter-type par)
      ((required)
       `(progn
         (write-char ,delim ,filv)
         (clm-print-par-value ,acc ,filv)))
      ((optional)
       (let ((form `(clm-print-par-value ,acc ,filv)))
         `(if (slot-boundp ,objv ',(parameter-slot par))
              (progn (write-char ,delim ,filv) ,form))))
      ((key)
       `(if (slot-boundp ,objv ',(parameter-slot par))
            (progn
             (write-char ,delim ,filv)
             (write ',(parameter-prefix par) :stream ,filv)
             (write-char ,delim ,filv)
             (clm-print-par-value ,acc ,filv))))
      ((rest)
       (let ((v (gensym)))
         `(if (slot-boundp ,objv ',(parameter-slot par))
              (do ((,v ,(slot-getter-form objv (parameter-slot par))
                       (cdr ,v)))
                  ((null ,v) nil)
                (write-char ,delim ,filv)
                (write (car ,v) :stream ,filv))))))))

(defun clm-writer (objclassname objclassvar pars supers sdecl)
  supers
  sdecl
  (define-output-method objclassname objclassvar 'obj 'clm-file
   '<clm-file> 'io 'scoretime
   (list
    `(let ((fp (io-open io)))
       (write-char #\( fp)
       (princ (object-name obj) fp)
       ,@(mapcar (lambda (p) (clm-par-print p 'obj 'fp 'scoretime))
                 pars)
       (write-char #\) fp)
       (terpri fp)
       (values)))))

(progn
 (defclass clm-file (event-file) nil #+metaclasses
           (:metaclass io-class))
 (defparameter <clm-file> (find-class 'clm-file))
 (finalize-class <clm-file>)
 (setf (io-class-definer <clm-file>) #'clm-writer)
 (setf (io-class-file-types <clm-file>) '("*.clm"))
 (values))

(defun set-clm-output-hook! (fn)
  (unless (or (not fn) (functionp fn))
    (error "Not a clm output hook: ~s" fn))
  (setf (io-class-output-hook <clm-file>) fn)
  (values))

(defmethod initialize-io ((io clm-file))
           (when (eq (io-direction io) ':output)
             (format (io-open io) ";;; ~a output on ~a~%"
                     (cm-version) (date-and-time))))

(defun play-clm-file (file &rest args)
  (let ((verbose (getf args :verbose t))
        (output (getf args ':output)))
    (if (not output) (setf output *clm-file-name*))
    (if verbose (apply #'tell-snd output args))
    (apply #'clm-load file args)))

(set-clm-output-hook! #'play-clm-file)

(defun snd-writer (objclassname objclassvar pars supers sdecl)
  supers
  sdecl
  (flet ((parf (par objv argsv timv)
           (let* ((raw
                   (if (parameter-time? par) timv
                       (slot-getter-form objv (parameter-slot par))))
                  (acc
                   (if (parameter-decimals par)
                       `(decimals ,raw ,(parameter-decimals par))
                       raw)))
             (case (parameter-type par)
               ((required)
                `(progn
                  (rplacd ,argsv (list ,acc))
                  (setf ,argsv (cdr ,argsv))))
               ((optional)
                `(if (slot-boundp ,objv ',(parameter-slot par))
                     (progn
                      (rplacd ,argsv (list ,acc))
                      (setf ,argsv (cdr ,argsv)))))
               ((key)
                `(if (slot-boundp ,objv ',(parameter-slot par))
                     (progn
                      (rplacd ,argsv (list ',(parameter-prefix par)))
                      (setf ,argsv (cdr ,argsv))
                      (rplacd ,argsv (list ,acc))
                      (setf ,argsv (cdr ,argsv)))))
               ((rest)
                `(if (slot-boundp ,objv ',(parameter-slot par))
                     (progn
                      (rplacd ,argsv ,acc)
                      (setf ,argsv (cdr ,argsv)))))))))
    (define-output-method objclassname objclassvar 'obj 'audio-file
     '<audio-file> 'io 'scoretime
     (list
      `(let* ((args (list nil)) (tail args))
         (if (eq (slot-value io 'output-trace) t)
             (format t "~a ~s..." (object-name obj)
                     (decimals scoretime 3)))
         ,@(mapcar (lambda (p) (parf p 'obj 'tail 'scoretime)) pars)
         (apply #',objclassname (cdr args))
         (values))))))

(progn
 (defclass audio-file (event-file)
           ((output-trace :initform :info :initarg :trace-output
             :accessor audio-file-output-trace))
           #+metaclasses  (:metaclass io-class))
 (defparameter <audio-file> (find-class 'audio-file))
 (finalize-class <audio-file>)
 (setf (io-class-definer <audio-file>) #'snd-writer)
 (setf (io-class-file-types <audio-file>)
         '("*.snd" "*.aiff" "*.aif" "*.wav"))
 (values))

(defun set-audio-output-hook! (fn)
  (unless (or (not fn) (functionp fn))
    (error "Not an audio output hook: ~s" fn))
  (setf (io-class-output-hook <audio-file>) fn)
  (values))

(defparameter *audio-player*
  (cond-expand
   (common-lisp
    (let ((os (os-name)))
      (cond
       ((member os '(unix cygwin linux darwin))
        (cond
         ((probe-file "/usr/local/bin/sndplay")
          "/usr/local/bin/sndplay")
         ((probe-file "/usr/bin/sndplay") "/usr/bin/sndplay")
         ((probe-file "/usr/local/bin/qtplay")
          "/usr/local/bin/qtplay")
         ((probe-file "/usr/bin/qtplay") "/usr/bin/qtplay")
         ((member os '(darwin osx maxosx)) "open") (t nil)))
       ((member os '(win32))
        (if
         (probe-file
          "/Program Files/Windows Media Player/mplayer2.exe")
         "\\Program Files\\Windows Media Player\\mplayer2.exe"))
       (t nil))))
   (else
    (let ((os (os-name)))
      (if (member (os-name) '(unix cygwin linux darwin))
          (cond
           ((probe-file "/usr/local/bin/sndplay")
            "/usr/local/bin/sndplay")
           ((probe-file "/usr/bin/sndplay") "/usr/bin/sndplay")
           ((probe-file "/usr/local/bin/qtplay")
            "/usr/local/bin/qtplay")
           ((probe-file "/usr/bin/qtplay") "/usr/bin/qtplay")
           ((member os '(darwin osx maxosx)) "open") (t nil))
          nil)))))

(defun play-audio-file (file &rest args)
  (if (getf args ':play t)
      (cond-expand
       (clm
        (funcall #'dac file :start (getf args ':start) :end
                 (getf args ':end) :wait (getf args ':wait)))
       (else
        (let ((cmd *audio-player*)
              (tyo (getf args ':verbose))
              (wai (getf args ':wait)))
          (setf cmd (concatenate 'string cmd " " file))
          (if tyo (format t "~%; ~a" cmd))
          (shell cmd :wait wai :output nil)
          file)))
      nil))

(set-audio-output-hook! #'play-audio-file)

(defun formals->defobject (form &optional tpar)
  (let* ((&keys '(&optional &rest &key &aux &allow-other-keys))
         (name (pop form))
         (pars
          (mapcar
           (lambda (x)
             (case x
               ((:optional) '&optional)
               ((:rest) '&rest)
               ((:key) '&key)
               ((:aux) '&aux)
               ((:allow-other-keys) '&allow-other-keys)
               (t (if (consp x) (car x) x))))
           form))
         (slots '()))
    (do ((tail pars (cdr tail)))
        ((null tail) (setf slots (reverse slots)))
      (unless (member (car tail) &keys)
        (if
         (or (and tpar (equal (car tail) tpar))
             (member (car tail) *time-slots*))
         (push (list (car tail) :accessor 'object-time) slots)
         (push (car tail) slots))))
    `(defobject ,name () ,slots (:parameters ,@pars)
      (:event-streams clm-file audio-file))))

(defparameter *clm-imports* (list))

(defparameter *clm-import-translations*
  '((let import-let
      )
    (let* import-let
      )
    (progn import-progn) (clm:with-sound import-with-sound)
    (defun import-defun)))

(defun import-form
       (form translate exclude include &optional toplevel?)
  (let ((sym (car form)))
    (if
     (or (not (and sym (symbolp sym)))
         (and toplevel? (member sym exclude)))
     nil
     (let* ((obj (find-class sym nil))
            (pars (and obj (class-parameters obj))))
       (if pars (import-object pars form)
           (let ((trans (assoc sym translate)))
             (if trans
                 (funcall (cadr trans) form translate exclude
                          include)
                 (if (or (fboundp sym) (special-operator-p sym)) form
                     (if
                      (and include
                           (or (eq include t) (member sym include)))
                      form
                      (progn
                       (format t "~%Skipping undefined function: ~s."
                               sym)
                       nil))))))))))

(defun import-let (form translate exclude include)
  (let ((body
         (loop for f in (cddr form) for r =
               (import-form f translate exclude include) when r
               collect r)))
    (if body (list* (car form) (cadr form) body) nil)))

(defun import-progn (form translate exclude include)
  (let ((body
         (loop for f in (cdr form) for r =
               (import-form f translate exclude include t) when r
               collect r)))
    (if body `(progn ,@body) nil)))

(defun import-with-sound (form translate exclude include)
  (values
   (loop for f in (cddr form) for r =
         (import-form f translate exclude include t) when r collect
         r)
   t))

(defun import-defun (form trans excl inc)
  (list* 'defun (cadr form) (caddr form)
         (loop for f in (cdddr form) collect
               (import-form f trans excl inc))))

(defun import-object (pars forms)
  (let ((save forms)
        (name (pop forms))
        (reqs nil)
        (opts nil)
        (rest nil)
        (keys nil))
    (setf reqs
            (loop with par while
                  (and (not (null forms))
                       (eq (parameter-type (car pars)) 'required))
                  do (setf par (pop pars)) collect
                  (parameter-slot par) collect (pop forms)))
    (setf opts
            (loop with par while
                  (and (not (null forms))
                       (eq (parameter-type (car pars)) 'optional))
                  do (setf par (pop pars)) collect
                  (parameter-slot par) collect (pop forms)))
    (when
        (and (not (null forms))
             (eq (parameter-type (car pars)) 'rest))
      (setf rest forms)
      (pop pars))
    (setf keys
            (loop with par while (not (null forms)) do
                  (setf par
                          (find-if
                           (lambda (x)
                             (eq (car forms) (parameter-prefix x)))
                           pars))
                  (or par
                      (error "No slot for ~s in ~s." (car forms)
                             save))
                  collect (parameter-slot par) collect (cadr forms)
                  do (setf forms (cddr forms))))
    `(push (new ,name ,@reqs ,@opts ,@rest ,@keys) *clm-imports*)))

(defmethod import-events
           ((io clm-file) &key (output nil)
            (translations *clm-import-translations*) (include nil)
            (exclude nil) (seq t))
           (flet ((fprint (f s)
                    (format s "~S~%" f)))
             (let* ((clmname (io-filename io))
                    (seqname
                     (format nil "from-~a" (filename-name clmname)))
                    (*print-case* ':downcase)
                    (outfil nil))
               (unless output
                 (setf output
                         (concatenate 'string
                                      (filename-directory clmname)
                                      (filename-name clmname)
                                      ".cm")))
               (unless (or (eq include t) (listp include))
                 (error ":include value not ~s or list: ~s" t
                        include))
               (unless (listp exclude)
                 (error ":exclude value not list: ~s." exclude))
               (setf outfil (open-file output :output))
               (with-open-io (infil io :input)
                (setf infil (io-open io))
                (format outfil ";;; Imported from ~s on ~a~%" clmname
                        (date-and-time))
                (fprint `(setf *clm-imports* (list)) outfil)
                (loop with trans and flag for form =
                      (file-form infil) until (file-eof? form) when
                      (and (consp form)
                           (let ((t14 (car form)))
                             (and t14 (symbolp t14))))
                      do
                      (unless (eq include t)
                        (when
                            (member (car form)
                                    '(defun define defmacro
                                       define-macro))
                          (unless (member (cadr form) exclude)
                            (unless (member (cadr form) include)
                              (push (cadr form) include)))))
                      (multiple-value-setq (trans flag)
                        (import-form form translations exclude
                         include t))
                      (when trans
                        (if flag (dolist (x trans) (fprint x outfil))
                            (fprint trans outfil))))
                (if seq
                    (fprint
                     `(setf *clm-imports*
                              (new seq :name
                               ,(if (eq seq t) seqname `',seq)
                               :subobjects (nreverse *clm-imports*)))
                     outfil)
                    (fprint
                     `(setf *clm-imports* (nreverse *clm-imports*))
                     outfil)))
               (close-file outfil ':output)
               (setf *clm-imports* (list))
               (load output)
               *clm-imports*)))

(defun tell-snd
       (file
        &key reverb decay-time reverb-data (channels *clm-channels*)
        (srate *clm-srate*) &allow-other-keys)
  (format t "~%; File: ~s" file)
  (format t "~%; Channels: ~s" channels)
  (format t "~%; Srate: ~s" srate)
  (format t "~%; Reverb: ~a~%" (or reverb "None"))
  (if decay-time (format t "decay time: ~s%" decay-time))
  (if reverb-data (format t "reverb data: ~s~%" reverb-data))
  (values))

(defmethod open-io ((io audio-file) dir &rest args) args
           (if (eq dir ':output)
               (let ((inits (event-stream-args io))
                     (ftype (filename-type (object-name io)))
                     (autype nil)
                     (fmat nil))
                 (cond
                  ((string-equal ftype "snd") (setf autype mus-next)
                   (setf fmat mus-bshort))
                  ((or (string-equal ftype "aiff")
                       (string-equal ftype "aif"))
                   (setf autype mus-aifc) (setf fmat mus-bshort))
                  ((string-equal ftype "wav") (setf autype mus-riff)
                   (setf fmat mus-lshort)))
                 (unless (getf inits ':header-type)
                   (push autype inits)
                   (push ':header-type inits))
                 (unless (getf inits ':data-format)
                   (push fmat inits)
                   (push ':data-format inits))
                 (setf (io-open io)
                         (apply #'init-with-sound ':output
                                (file-output-filename io) :play nil
                                inits))
                 (when (audio-file-output-trace io)
                   (apply #'tell-snd (file-output-filename io)
                          inits))
                 io)
               (call-next-method)))

(defmethod close-io ((io audio-file) &rest mode)
           (let ((wsd (io-open io)) (*clm-with-sound-depth* 1))
             *clm-with-sound-depth*
             (when (eq (slot-value io 'output-trace) t)
               (format t "Done!~&"))
             (when (and (consp mode) (car mode))
               (setf (wsdat-play wsd) nil))
             (finish-with-sound wsd)
             (setf (io-open io) nil)))

(defun definstrument-hook (name args)
  (let* ((opts (if (consp name) (cdr name) (list)))
         (tpar (getf opts ':time-parameter)))
    (formals->defobject
     (list* (if (consp opts) (first name) name) args) tpar)))

(defparameter *definstrument-hook* #'definstrument-hook)
