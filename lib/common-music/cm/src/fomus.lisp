;;; **********************************************************************
;;; Copyright (C) 2007 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from fomus.scm on 30-Jan-2007 07:39:04

(in-package :cm)

(in-package :cm)

(progn
 (defclass fomus-file (event-file)
           ((parts :initarg :parts :initform '() :accessor
             fomus-file-parts)
            (global :initarg :global :initform '() :accessor
             fomus-file-global)
            (view :initarg :view :initform t :accessor
             fomus-file-view)
            (play :initarg :play :initform nil :accessor
             fomus-file-play)
            (tempo :initarg :tempo :initform 60 :accessor
             fomus-file-tempo))
           #+metaclasses  (:metaclass io-class))
 (defparameter <fomus-file> (find-class 'fomus-file))
 (finalize-class <fomus-file>)
 (setf (io-class-file-types <fomus-file>) '("*.fms" "*.xml" "*.ly"))
 (values))

(defmethod object-time ((obj event-base)) (event-off obj))

(defmethod open-io ((io fomus-file) dir &rest args) args
           (when (eq dir ':output)
             (let ((parts (fomus-file-parts io))
                   (globs (fomus-file-global io)))
               (if (not (consp parts))
                   (setf (fomus-file-parts io)
                           (if (null parts) (list) (list parts))))
               (if (not (consp globs))
                   (setf (fomus-file-global io)
                           (if (null globs) (list) (list globs))))
               (map nil (lambda (p) (setf (part-events p) (list)))
                    (fomus-file-parts io))
               (setf (io-open io) t)))
           io)

(defmethod close-io ((io fomus-file) &rest mode)
           (let ((err?
                  (and (not (null mode)) (eq (car mode) ':error))))
             (setf (io-open io) nil)
             (unless err?
               (let* ((args (event-stream-args io))
                      (bend (getf args ':output)))
                 (unless bend
                   (let* ((file (io-filename io))
                          (type (filename-type file)))
                     (cond
                      ((equal type "ly")
                       (setf bend
                               (list ':lilypond :filename file :view
                                     (fomus-file-view io))))
                      ((equal type "xml")
                       (setf bend
                               (list ':musicxml :filename file :view
                                     (fomus-file-view io))))
                      (t (setf bend (list ':fomus :filename file))))
                     (when (fomus-file-play io)
                       (setf bend
                               (list bend
                                     (list ':midi :play t :filename
                                           (make-pathname :type "mid"
                                                          :defaults
                                                          file)
                                           :tempo
                                           (fomus-file-tempo io)))))
                     (setf args (list* ':output bend args))))
                 (apply #'fomus :parts (fomus-file-parts io) :global
                        (fomus-file-global io) args)))))

(defun fomus-file-part (stream id)
  (do ((tail (fomus-file-parts stream) (cdr tail))
       (part nil))
      ((or (null tail) part)
       (when (not part)
         (setf part
                 (make-part :partid id :instr
                  (if (keyword? id) id nil)))
         (setf (fomus-file-parts stream)
                 (cons part (fomus-file-parts stream))))
       part)
    (if (eq id (obj-partid (car tail))) (setf part (car tail)))))

(defmethod write-event ((obj event-base) (fil fomus-file) scoretime)
           (let ((part (fomus-file-part fil (obj-partid obj))))
             (setf (event-off obj) scoretime)
             (setf (part-events part) (cons obj (part-events part)))
             obj))

(defmethod write-event ((obj midi) (fil fomus-file) scoretime)
           (let* ((myid (midi-channel obj))
                  (part (fomus-file-part fil myid))
                  (marks '()))
             (setf (part-events part)
                     (cons
                      (make-note :partid myid :off scoretime :note
                       (midi-keynum obj) :dur (midi-duration obj)
                       :marks marks)
                      (part-events part)))))

(defun partid->part (pid)
  (loop for p in *parts* thereis (eq pid (obj-partid p))))

(defmethod schedule-object ((obj part) start sched)
           (let ((mystart (+ start 0)))
             (enqueue *qentry-seq* (cons obj (part-events obj))
              mystart mystart sched)))

(defmethod write-event ((obj note) (fil midi-file) scoretime)
           (let* ((myid (obj-partid obj))
                  (part (partid->part myid))
                  (opts (if (not part) (list) (part-opts part)))
                  (chan nil)
                  (ampl 64))
             opts
             (unless chan (setf chan (if (integerp myid) myid 0)))
             (write-event
              (make-instance <midi> :time (event-off obj) :amplitude
                             ampl :keynum (event-note obj) :duration
                             (event-dur obj) :channel chan)
              fil scoretime)))

(defmethod import-events ((file fomus-file) &key (seq t))
           (let ((fil (file-output-filename file)))
             (cond ((or (not seq) (typep seq <seq>)) nil)
                   ((eq seq t)
                    (setf seq
                            (make-instance <seq> :name
                                           (format nil "~a-notes"
                                                   (filename-name
                                                    fil)))))
                   (t
                    (error
                     "import-events: ~S is not a boolean or seq."
                     seq)))
             (multiple-value-bind
                 (parts notes globs sets)
                 (fomus-file fil)
               (setf (fomus-file-parts file) parts)
               (setf (fomus-file-global file) globs)
               (setf (event-stream-args file) sets)
               (if seq
                   (progn
                    (setf (container-subobjects seq) notes)
                    seq)
                   notes))))
