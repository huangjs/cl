;;; **********************************************************************
;;; Copyright (C) 2007 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from midishare.scm on 30-Jan-2007 07:39:04

(in-package :cm)

(defparameter *ms* nil)

(defparameter *midi-connections* '("MidiShare" "MidiShare"))

(progn
 (defclass midishare-stream (rt-stream midi-stream-mixin)
           ((connections :initform *midi-connections* :initarg
             :connections :accessor midishare-stream-connections)
            (receive-data :initform (list nil nil) :accessor
             rt-stream-receive-data)
            (receive-mode :initform :raw :initarg :receive-mode
             :accessor rt-stream-receive-mode)
            (latency :initform 0 :initarg :latency :accessor
             midishare-stream-latency))
           #+metaclasses  (:metaclass io-class))
 (defparameter <midishare-stream> (find-class 'midishare-stream))
 (finalize-class <midishare-stream>)
 (setf (io-class-file-types <midishare-stream>) '("*.ms"))
 (values))

(defmethod midishare-stream-refnum ((obj midishare-stream))
           (let ((ref (event-stream-stream obj)))
             (if (consp ref) (car ref) nil)))

(defmethod open-midishare-client ((obj midishare-stream) name)
           (midishare:midiopen name))

(defmethod close-midishare-client ((obj midishare-stream))
           (midishare:midiclose (midishare-stream-refnum obj)))

(defmethod open-io ((obj midishare-stream) dir &rest args) dir args
           (let ((res (midishare:midishare)))
             (unless (equal res 1)
               (error
                "Can't open MidiShare connection: MidiShare not loaded.")))
           (let ((name (object-name obj)))
             (unless (event-stream-stream obj)
               (let* ((client
                       (if
                        (or (not name)
                            (string-equal name "midi-port.ms"))
                        "Common Music" (filename-name name)))
                      (applid (midishare:midigetnamedappl client))
                      (refnum
                       (if (= applid -4)
                           (open-midishare-client obj client)
                           applid)))
                 (when (= refnum -4)
                   (error "Cannot open Midishare client ~S." client))
                 (setf (event-stream-stream obj)
                         (midishare-set-connections obj refnum))
                 (setf (io-open obj) (event-stream-stream obj))
                 (setf (object-time obj) 0)))
             obj))

(defun midishare-set-connections (obj client)
  (flet ((conn? (x y)
           (= 1 (midishare:midiisconnected x y)))
         (getref (x)
           (cond
            ((stringp x)
             (if (string= x "") nil
                 (let ((a (midishare:midigetnamedappl x)))
                   (if (= a -4)
                       (error "Not a Midishare client: ~s." x) a))))
            ((integerp x)
             (let ((a nil))
               (dotimes (i (midishare:midicountappls))
                 (if (= x (midishare:midigetindappl (+ i 1)))
                     (setf a x)))
               (or a
                   (error "Not a Midishare client refnum: ~S." x))))
            ((eq x t) 0) ((not x) nil)
            (t (error "Not a MidiShare client: ~s." x)))))
    (let ((conn (midishare-stream-connections obj))
          (inref nil)
          (outref nil))
      (cond
       ((consp conn) (setf inref (getref (first conn)))
        (when inref
          (unless (conn? inref client)
            (midishare:midiconnect inref client -1)
            (unless (conn? inref client)
              (error "Input connection from ~S to ~S failed."
                     (midishare:midigetname inref)
                     (midishare:midigetname client)))))
        (when (consp (cdr conn))
          (setf outref (getref (second conn)))
          (when outref
            (unless (conn? client outref)
              (midishare:midiconnect client outref -1)
              (unless (conn? client outref)
                (error "Output connection from ~S to ~S failed."
                       (midishare:midigetname client)
                       (midishare:midigetname outref)))))))
       (t (setf outref (getref conn))
        (when outref
          (unless (conn? client outref)
            (midishare:midiconnect client outref -1)
            (unless (conn? client outref)
              (error "Output connection from ~S to ~S failed."
                     (midishare:midigetname client)
                     (midishare:midigetname outref)))))))
      (list client inref outref nil))))

(defmethod close-io ((obj midishare-stream) &rest mode)
           (if (eq (car mode) ':force)
               (progn
                (close-midishare-client obj)
                (setf (event-stream-stream obj) nil)
                (setf (io-open obj) nil)))
           (values))

(defun midishare-open (&rest args)
  (apply #'open-io "midi-port.ms" t args))

(defun midishare-open? (&rest ms)
  (let ((p (if (null ms) (find-object "midi-port.ms") (car ms))))
    (let ((d (and p (io-open p))))
      (if d
          (if (second d) (if (third d) :inout :in)
              (if (third d) :out nil))
          nil))))

(defun midishare-close (&rest ms)
  (let ((p (if (null ms) (find-object "midi-port.ms") (car ms))))
    (if (and p (midishare-open? p))
        (close-io (find-object "midi-port.ms") ':force))
    (values)))

(defmethod initialize-io ((obj midishare-stream))
           (setf (object-time obj)
                   (+ (midishare:midigettime)
                      (midishare-stream-latency obj)))
           (channel-tuning-init obj))

(defmethod deinitialize-io ((obj midishare-stream))
           (setf (object-time obj) 0))

(defun midishare:new
       (type
        &key (date 0) (port 0) (chan 0) (pitch 60) (vel 64) (dur 500)
        (pressure 0) (controller 0) (change 0) (bend 0) (program 0)
        (numerator 4) (denominator 4) (clocks 24) (32nds 8) (sign 0)
        (mode 0) (tempo 120) (number 0) (prefix 0) (text "")
        (position 0) (song 0) (data '()) (offset '()))
  (let ((ev (midishare:midinewev type)))
    (midishare:date ev date)
    (midishare:port ev port)
    (midishare:chan ev chan)
    (cond
     ((<= midishare:typenote type midishare:typekeyoff)
      (midishare:field ev 0 pitch) (midishare:field ev 1 vel)
      (when (eq type midishare:typenote) (midishare:field ev 2 dur)))
     ((= type midishare:typekeypress) (midishare:field ev 0 pitch)
      (midishare:field ev 1 pressure))
     ((= type midishare:typectrlchange)
      (midishare:field ev 0 controller)
      (midishare:field ev 1 change))
     ((= type midishare:typeprogchange)
      (midishare:field ev 0 program))
     ((= type midishare:typechanpress)
      (midishare:field ev 0 pressure))
     ((= type midishare:typepitchbend)
      (midishare:bend ev
                      (if (<= -8192 bend 8191) bend
                          (error
                           ":bend value ~s not between -8192 8191."
                           bend))))
     ((= type midishare:typesongpos)
      (let ((num (/ position 6)))
        (multiple-value-bind
            (msb lsb)
            (floor num 128)
          (midishare:field ev 0 msb)
          (midishare:field ev 1 lsb))))
     ((= type midishare:typesongsel) (midishare:field ev 0 song))
     ((<= typeclock type midishare:typereset) nil)
     ((= type midishare:typesysex)
      (do ((l data (cdr l)))
          ((null l) nil)
        (midishare:midiaddfield ev (car l))))
     ((= type midishare:typeseqnum) (midishare:field ev 0 number))
     ((<= midishare:typetextual type midishare:typecuepoint)
      (midishare:text ev text))
     ((= type midishare:typechanprefix)
      (midishare:field ev 0 prefix))
     ((= type midishare:typeendtrack) nil)
     ((= type midishare:typetempo)
      (midishare:field ev 0 (floor (/ 60000000 tempo))))
     ((= type midishare:typesmpteoffset)
      (unless (= (length offset) 5)
        (error ":offset value ~s not (hr min sec frame subframe)"
               offset))
      (midishare:field ev 0
                       (+ (* (elt offset 0) 3600)
                          (* (elt offset 1) 60) (elt offset 2)))
      (midishare:field ev 1
                       (+ (* (elt offset 3) 100) (elt offset 4))))
     ((= type midishare:typetimesign)
      (midishare:field ev 0 numerator)
      (midishare:field ev 1 denominator)
      (midishare:field ev 2 clocks) (midishare:field ev 3 32nds))
     ((= type midishare:typekeysign)
      (midishare:field ev 0
                       (if (<= -7 sign 7)
                           (if (< sign 0) (+ sign 256) sign)
                           (error
                            ":sign value ~s is not between -7 and 7."
                            sign)))
      (midishare:field ev 1 mode))
     (t
      (error "Unimplemented MidiShare event type opcode: ~s." type)))
    ev))

(defparameter midievnames
  #("Note" "KeyOn" "KeyOff" "KeyPress" "CtrlChange" "ProgChange"
    "ChanPress" "PitchBend" "SongPos" "SongSel" "Clock" "Start"
    "Continue" "Stop" "Tune" "ActiveSens" "Reset" "SysEx" "SeqNum"
    "Text" "Copyright" "SeqName" "InstrName" "Lyric" "Marker"
    "CuePoint" "ChanPrefix" "EndTrack" "Tempo" "SMPTEOffset"
    "TimeSign" "KeySign"))

(defun midishare:midiprintev (ev &key (stream t) (eol t))
  (let ((to stream) (ty (midishare:evtype ev)) (cl nil))
    (cond
     ((<= midishare:typenote ty midishare:typesysex)
      (setf cl (elt midievnames ty)))
     ((<= midishare:typeseqnum ty midishare:typekeysign)
      (setf cl
              (elt midievnames
                   (+ (- ty midishare:typeseqnum) midishare:typesysex
                      1))))
     (t nil))
    (when (eq eol ':before) (terpri stream))
    (if (not cl) (format to "~s" ev)
        (let ((ch (midishare:chan ev))
              (po (midishare:port ev))
              (da (midishare:date ev)))
          (format to "#<MidiEv ~a port=~s chan=~s date=~s" cl po ch
                  da)
          (cond
           ((<= midishare:typenote ty midishare:typekeyoff)
            (if (= ty midishare:typenote)
                (format to " dur=~s" (midishare:field ev 3)))
            (format to " pitch=~s vel=~s" (midishare:field ev 0)
                    (midishare:field ev 1)))
           ((= ty midishare:typepitchbend)
            (format to " ~s ~s" (midishare:field ev 0)
                    (midishare:field ev 1)))
           ((= ty midishare:typeprogchange)
            (format to " ~s" (midishare:field ev 0)))
           ((= ty midishare:typectrlchange)
            (format to " ~s ~s" (midishare:field ev 0)
                    (midishare:field ev 1)))
           ((= ty midishare:typesongpos)
            (format to " ~s ~s" (midishare:field ev 0)
                    (midishare:field ev 1)))
           ((= ty midishare:typesongsel)
            (format to " ~s" (midishare:field ev 0)))
           ((= ty midishare:typesysex) nil)
           ((= ty midishare:typeseqnum)
            (format to " ~s" (midishare:field ev 0)))
           ((<= midishare:typetextual ty midishare:typecuepoint) nil)
           ((= ty midishare:typechanprefix)
            (format to " ~s" (midishare:field ev 0)))
           ((= ty midishare:typeendtrack) nil)
           ((= ty midishare:typetempo)
            (format to " ~susec" (midishare:field ev 0)))
           ((= ty midishare:typesmpteoffset)
            (format to " ~s ~s" (midishare:field ev 0)
                    (midishare:field ev 1)))
           ((= ty midishare:typetimesign)
            (format to " ~s ~s ~s ~s" (midishare:field ev 0)
                    (midishare:field ev 1) (midishare:field ev 2)
                    (midishare:field ev 3)))
           ((= ty midishare:typekeysign)
            (format to " ~s ~s" (midishare:field ev 0)
                    (midishare:field ev 1)))
           (t nil))
          (format to ">")))
    (when (eq eol t) (format to "~%"))))

(defmethod write-event
           ((obj midi) (stream midishare-stream) scoretime)
           (let* ((key (midi-keynum obj))
                  (amp (midi-amplitude obj))
                  (loc
                   (logical-channel (midi-channel obj)
                    (midi-stream-channel-map stream)))
                  (prt (car loc))
                  (chn (cadr loc))
                  (dur nil)
                  (at nil)
                  (evt (midishare:midinewev midishare:typenote))
                  (sched (scheduling-mode))
                  (evt nil))
             (cond
              ((eq sched ':events)
               (setf dur (floor (* (midi-duration obj) 1000)))
               (setf at
                       (+ (object-time stream)
                          (floor (* scoretime 1000)))))
              ((eq sched ':rts)
               (setf dur
                       (cond
                        ((eq rts:*time-format* ':msec)
                         (midi-duration obj))
                        ((eq rts:*time-format* ':sec)
                         (floor (* (midi-duration obj) 1000)))
                        (t (floor (midi-duration obj) 1000))))
               (setf at
                       (+ (midishare-stream-latency stream)
                          (midishare:midigettime))))
              (t (setf dur (floor (* (midi-duration obj) 1000)))
               (setf at
                       (let ((tim (object-time obj)))
                         (if (= tim 0) (midishare:midigettime)
                             (if (integerp tim) tim
                                 (+ (floor (* tim 1000))
                                    (midishare:midigettime))))))))
             (cond ((and (integerp amp) (<= 0 amp 127)) nil)
                   ((and (floatp amp) (<= 0.0 amp 1.0))
                    (setf amp (floor (* amp 127))))
                   (t
                    (error
                     "Can't convert amplitude ~s to midi velocity."
                     amp)))
             (ensure-microtuning key chn stream)
             (setf evt
                     (midishare:new midishare:typenote :port prt
                      :chan chn :pitch key :vel amp :dur dur))
             (midishare:midisendat (midishare-stream-refnum stream)
                                   evt at)
             (values)))

(defparameter opcodes-evtypes
  (list
   (list (list +ml-note-on-opcode+ 1) (list +ml-note-off-opcode+ 2)
         (list +ml-key-pressure-opcode+ 3)
         (list +ml-control-change-opcode+ 4)
         (list +ml-program-change-opcode+ 5)
         (list +ml-channel-pressure-opcode+ 6)
         (list +ml-pitch-bend-opcode+ 7))))

(defun midi-op->evtype (op set)
  (let ((e (assoc op (elt opcodes-evtypes set))))
    (if e
        (or (cadr e)
            (error "No MidiShare evType for event opcode ~s." op))
        (error "No MidiShare evType for event opcode ~s." op))))

(defmethod write-event
           ((obj midi-channel-event) (stream midishare-stream)
            scoretime)
           (let* ((opr (slot-value obj 'opcode))
                  (typ (midi-op->evtype opr 0))
                  (loc
                   (logical-channel (midi-event-channel obj)
                    (midi-stream-channel-map stream)))
                  (dat (midi-event-data2 obj))
                  (sched (scheduling-mode))
                  (evt (midishare:midinewev typ)))
             (midishare:port evt (car loc))
             (midishare:chan evt (cadr loc))
             (midishare:field evt 0 (midi-event-data1 obj))
             (if (= typ midishare:typepitchbend)
                 (midishare:bend evt (midi-pitch-bend-bend obj))
                 (if dat (midishare:field evt 1 dat)))
             (midishare:midisendat (midishare-stream-refnum stream)
                                   evt
                                   (cond
                                    ((eq sched ':events)
                                     (+ (object-time stream)
                                        (floor (* scoretime 1000))))
                                    ((eq sched ':rts)
                                     (+
                                      (midishare-stream-latency
                                       stream)
                                      (midishare:midigettime)))
                                    ((not sched)
                                     (let ((tim (object-time obj)))
                                       (if (= tim 0)
                                           (midishare:midigettime)
                                           (if (integerp tim) tim
                                               (+
                                                (floor (* tim 1000))
                                                (midishare:midigettime))))))))))

(defun make-proctable (num) (reset-proctable (make-array num)))

(defun reset-proctable (tbl)
  (do ((num (length tbl))
       (pos 0 (+ pos 1)))
      ((= pos num) (setf (elt tbl (- num 1)) nil) tbl)
    (setf (elt tbl pos) (+ pos 1))))

(defparameter *proctable* (make-proctable 64))

(defun add-proc (proc)
  (let ((free (elt *proctable* 0)))
    (if free
        (progn
         (setf (elt *proctable* 0) (elt *proctable* free))
         (setf (elt *proctable* free) proc)
         free)
        nil)))

(defun rem-proc (index)
  (setf (elt *proctable* index) (elt *proctable* 0))
  (setf (elt *proctable* 0) index)
  (values))

(defun midishare:sprout (obj ahead out)
  out
  (let ((id (add-proc obj)))
    (if id
        (midishare:miditask run-proc
                            (+ (midishare:midigettime) (or ahead 0))
                            (midishare-stream-refnum out) id 0 0)
        (warn "Can't sprout, no room left in process table!")))
  (values))

(defun parse-ms-output (forms clauses ops)
  clauses
  ops
  (let ((head forms)
        (oper (pop forms))
        (expr nil)
        (to nil)
        (args (list))
        (loop '()))
    (when (null forms)
      (loop-error ops head "Missing '" oper "' expression."))
    (setf expr (pop forms))
    (do ((stop nil))
        ((or stop (null forms)))
      (case (car forms)
        ((to :to)
         (when (null (cdr forms))
           (loop-error ops head "Missing '" oper " to' expression."))
         (setf to t)
         (setf args (nconc args (list :to (cadr forms))))
         (setf forms (cddr forms)))
        ((at :at)
         (when (null (cdr forms))
           (loop-error ops head "Missing '" oper
            " ahead' expression."))
         (setf args (nconc args (list :at (cadr forms))))
         (setf forms (cddr forms)))
        (t (setf stop t))))
    (unless to (setf args (nconc args (list ':to '*out*))))
    (setf loop (list `(,oper ,expr ,@args)))
    (values (make-loop-clause 'operator oper 'looping loop) forms)))

(defparameter *process-operators*
  (append *process-operators*
          (list
           (list 'midishare:output #'parse-ms-output 'task 'to))))

(defun midishare:output (ev &key (to *out*) at)
  (cond
   ((scheduling-mode? ':events)
    (midishare:midisendat (midishare-stream-refnum to) ev
                          (+ (object-time to) (midishare:date ev)
                             (floor (* *pstart* 1000)))))
   (t
    (when (= (midishare:date ev) 0)
      (midishare:date ev (or at (midishare:midigettime))))
    (midishare:midisend (midishare-stream-refnum to) ev))))

(defun midishare:now () (midishare:midigettime))

(defmethod stream-receive-init ((str midishare-stream) hook args)
           args
           (let ((data (rt-stream-receive-data str))
                 (mode (rt-stream-receive-mode str)))
             (cond
              ((not (functionp hook))
               (error "Receive: hook is not a function: ~s" hook))
              ((not (member mode '(:raw)))
               (error "receive: ~s is not a midishare receive mode."
                      mode))
              ((not (member (midishare-open? str) '(:in :inout)))
               (error "Stream not open for input: ~S." str))
              ((first data)
               (error
                "Can't set input hook: another hook is running!")))
             (let ((refn (first (io-open str))))
               (when (> (midishare:midicountevs refn) 0)
                 (midishare:midiflushevs refn))
               (setf (elt data 0) hook)
               (setf (elt data 1) refn))))

(defmethod stream-receive-deinit ((str midishare-stream))
           (let ((data (rt-stream-receive-data str)))
             (when (first data)
               (setf (elt data 0) nil)
               (setf (elt data 1) nil))))
