;;; **********************************************************************
;;; Copyright (C) 2007 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from spectral.scm on 30-Jan-2007 07:38:54

(in-package :cm)

(defun harmonics
       (h1 h2
        &key ((:hertz hz) 1) invert undertones ((:keynum knum) nil)
        ((:rescale scaler) nil) scale-order harmonic)
  (unless (< h1 h2) (error "harmonics: ~s not less than ~s." h1 h2))
  (when harmonic
    (unless (<= h1 harmonic h2)
      (error "harmonics: :harmonic ~s not between ~s and ~s."
             harmonic h1 h2)))
  (let* ((freq (if knum (hertz knum) hz))
         (spec
          (if invert
              (if undertones
                  (if harmonic (/ freq (/ h2 harmonic))
                      (loop for h from h2 downto h1 collect
                            (/ freq (/ h2 h))))
                  (if harmonic (* freq (/ h2 harmonic))
                      (loop for h from h2 downto h1 collect
                            (* freq (/ h2 h)))))
              (if undertones
                  (if harmonic (/ freq (/ harmonic h1))
                      (loop for h from h1 to h2 collect
                            (/ freq (/ h h1))))
                  (if harmonic (* freq (/ harmonic h1))
                      (loop for h from h1 to h2 collect
                            (* freq (/ h h1))))))))
    (when scaler
      (if knum (setf scaler (hertz scaler :hz t)))
      (do ((root (car spec))
           (term (elt spec (- h2 h1)))
           (tail (cdr spec) (cdr tail)))
          ((null tail) nil)
        (rplaca tail (rescale (car tail) root term root scaler))))
    (when scale-order
      (when harmonic
        (error
         "harmonics: :scale-order and :harmonic are exclusive."))
      (case scale-order
        ((:reverse reverse) (setf spec (nreverse spec)))
        ((:up up) (if undertones (setf spec (nreverse spec))))
        ((:down down)
         (if (not undertones) (setf spec (nreverse spec))))
        ((:random random) (setf spec (shuffle spec)))
        (t
         (error "harmonics: not a :scale-order value: ~S"
                scale-order))))
    (if knum (keynum spec :hz t) spec)))

(defun rm-spectrum
       (set1 set2
        &key (spectrum nil) (minimum nil) (maximum nil) (hz nil)
        (scale-order :up) (remove-duplicates nil))
  (flet ((sums-and-diffs (f1 f2)
           (if (= f1 f2) (list) (list (abs (- f1 f2)) (+ f1 f2)))))
    (let* ((type
            (cond
             ((not spectrum)
              (if hz ':hertz
                  (if (consp set1)
                      (if
                       (let ((t11 (car set1)))
                         (and t11 (symbolp t11)))
                       ':note ':keynum)
                      (if (and set1 (symbolp set1)) ':note
                          ':keynum))))
             ((member spectrum '(:note :keynum :hertz)) spectrum)
             (t
              (error "Spectrum ~S not one of: :note :keynum :hertz."
                     spectrum))))
           (spec
            (if (consp set1)
                (if (consp set2)
                    (loop with l2 = (hertz set2 :hz hz) for f1 in
                          (hertz set1 :hz hz) append
                          (loop for f2 in l2 append
                                (sums-and-diffs f1 f2)))
                    (loop with f2 = (hertz set2 :hz hz) for f1 in
                          (hertz set1 :hz hz) append
                          (sums-and-diffs f1 f2)))
                (if (consp set2)
                    (loop with f1 = (hertz set1 :hz hz) for f2 in
                          (hertz set2 :hz hz) append
                          (sums-and-diffs f1 f2))
                    (sums-and-diffs (hertz set1 :hz hz)
                     (hertz set2 :hz hz))))))
      (when minimum
        (do ((freq (hertz minimum :hz (eq type ':hertz)))
             (tail spec (cdr tail)))
            ((null tail) nil)
          (do ()
              ((not (< (car tail) freq)))
            (rplaca tail (* (car tail) 2)))))
      (when maximum
        (do ((freq (hertz maximum :hz (eq type ':hertz)))
             (tail spec (cdr tail)))
            ((null tail) nil)
          (do ()
              ((not (> (car tail) freq)))
            (rplaca tail (/ (car tail) 2)))))
      (cond ((eq scale-order ':up) (setf spec (sort spec #'<)))
            ((eq scale-order ':down) (setf spec (sort spec #'>)))
            ((eq scale-order ':random) (setf spec (shuffle spec))))
      (cond ((eq type ':note) (setf spec (note spec :hz t)))
            ((eq type ':keynum) (setf spec (keynum spec :hz t)))
            ((eq type ':hertz) nil))
      (if
       (and remove-duplicates
            (do ((tail spec (cdr tail))
                 (flag nil))
                ((or (null tail) flag) flag)
              (setf flag (member (car tail) (cdr tail)))))
       (do ((tail spec (cdr tail))
            (resl (list nil)))
           ((null tail) (cdr resl))
         (if (member (car tail) resl) nil
             (setf resl (nconc resl (list (car tail))))))
       spec))))

(defun fm-spectrum
       (carrier mratio index
        &key (spectrum nil) (minimum nil) (maximum nil) invert
        (ignore-zero nil izp) (amplitudes (eq spectrum ':raw))
        all-sidebands scale-order (remove-duplicates t))
  (let ((data nil) (type nil) (bot nil) (top nil))
    (case spectrum
      ((nil) (setf type spectrum))
      ((:hertz)
       (setf type spectrum)
       (unless izp (setf ignore-zero t)))
      ((:keynum)
       (setf type spectrum)
       (unless izp (setf ignore-zero t)))
      ((:note)
       (setf type spectrum)
       (unless izp (setf ignore-zero t)))
      (t
       (error "Spectrum ~s not one of: false :note :keynum :hertz."
              spectrum)))
    (when spectrum
      (if minimum (setf bot (hertz minimum :hz (eq type ':hertz))))
      (if maximum (setf top (hertz maximum :hz (eq type ':hertz)))))
    (setf data
            (fm-spectrum1 carrier mratio index (eq type nil) nil
             all-sidebands))
    (when ignore-zero
      (setf data (delete-if (lambda (x) (zerop (car x))) data)))
    (when invert
      (dolist (s data)
        (let ((f (first s)))
          (unless (= f 0.0)
            (rplaca s (abs (hz-invert (hz-ify carrier) f))))))
      (setf data (sort data (lambda (x y) (< (first x) (first y))))))
    (when (or (eq type ':note) (eq type ':keynum))
      (if (or top bot)
          (let ((f nil) (k nil) (e nil) (l (list)))
            (dolist (s data)
              (setf f (abs (first s)))
              (when (not (= f 0.0))
                (do () ((<= f top) nil) (setf f (* f 0.5)))
                (do () ((>= f bot) nil) (setf f (* f 2.0))))
              (setf k
                      (if (= f 0.0) 'r
                          (if (eq type ':keynum) (keynum f :hz t)
                              (note f :hz t))))
              (setf e (find-if (lambda (x) (equal k (car x))) l))
              (if (and e remove-duplicates)
                  (rplaca (cdr e) (+ (cadr e) (second s)))
                  (progn (rplaca s k) (push s l))))
            (setf data (nreverse l)))
          (do ((low (hertz 0))
               (tail data (cdr tail)))
              ((null tail) nil)
            (unless (< (caar tail) low)
              (setf (caar tail)
                      (if (eq type ':note) (note (caar tail) :hz t)
                          (keynum (caar tail) :hz t)))))))
    (unless (eq type nil)
      (setf data
              (cond
               ((not scale-order)
                (if (or top bot)
                    (sort data
                          (lambda (a b)
                            (scale< (first a) (first b))))
                    data))
               ((eq scale-order :up)
                (sort data
                      (lambda (a b) (scale< (first a) (first b)))))
               ((eq scale-order :down)
                (sort data
                      (lambda (a b) (scale> (first a) (first b)))))
               ((eq scale-order :random) (shuffle data))
               (t
                (error "Not a valid :scale-order: ~s."
                       scale-order)))))
    (cond
     ((not amplitudes)
      (do ((tail data (cdr tail)))
          ((null tail) nil)
        (rplaca tail (car (car tail)))))
     ((eq amplitudes :normalized)
      (dolist (s data) (rplaca (cdr s) (abs (second s)))))
     ((eq amplitudes :weights)
      (dolist (s data)
        (rplaca (cdr s) (abs (second s)))
        (rplacd s (cons ':weight (cdr s)))))
     ((eq amplitudes t) nil)
     (t (error "Not an amplitude value: ~s." amplitudes)))
    data))

(defun sidebands-to-cm (low high lb ub)
  (let* ((m (/ (- high low) (- ub lb))) (c (- high (* ub m))))
    (values c m (/ m c))))

(defun bes-jn (unn ux)
  (let ((nn unn) (x ux))
    (let* ((n (floor (abs nn)))
           (besn
            (if (= n 0) (bes-j0 x)
                (if (= n 1) (bes-j1 x)
                    (if (zerop x) 0.0
                        (let ((iacc 40)
                              (ans 0.0)
                              (bigno 1.e10)
                              (bigni 1.e-10))
                          (if (> (abs x) n)
                              (do ((tox (/ 2.0 (abs x)))
                                   (bjm (bes-j0 (abs x)))
                                   (bj (bes-j1 (abs x)))
                                   (j 1 (+ j 1))
                                   (bjp 0.0))
                                  ((= j n) (setf ans bj))
                                (setf bjp (- (* j tox bj) bjm))
                                (setf bjm bj)
                                (setf bj bjp))
                              (let ((tox (/ 2.0 (abs x)))
                                    (m
                                     (* 2
                                        (floor
                                         (/ (+ n (sqrt (* iacc n)))
                                            2))))
                                    (jsum 0.0)
                                    (bjm 0.0)
                                    (sum 0.0)
                                    (bjp 0.0)
                                    (bj 1.0))
                                (do ((j m (- j 1)))
                                    ((= j 0))
                                  (setf bjm (- (* j tox bj) bjp))
                                  (setf bjp bj)
                                  (setf bj bjm)
                                  (when (> (abs bj) bigno)
                                    (setf bj (* bj bigni))
                                    (setf bjp (* bjp bigni))
                                    (setf ans (* ans bigni))
                                    (setf sum (* sum bigni)))
                                  (if (not (= 0 jsum)) (incf sum bj))
                                  (setf jsum (- 1 jsum))
                                  (if (= j n) (setf ans bjp)))
                                (setf sum (- (* 2.0 sum) bj))
                                (setf ans (/ ans sum))))
                          (if (and (minusp x) (oddp n)) (- ans)
                              ans)))))))
      (if (and (minusp nn) (oddp nn)) (- besn) besn))))

(defun fm-spectrum1
       (carrier mratio index neg-freq? pos-amp? sideband-scaler)
  (setf carrier (hz-ify carrier))
  (let ((mfreq (* carrier mratio))
        (nsides
         (if sideband-scaler (round (* sideband-scaler index))
             (+ (round index) 1)))
        (spectrum '()))
    (setf spectrum
            (loop for k from (- nsides) to nsides for a =
                  (bes-jn k index) unless (= a 0.0) collect
                  (list (+ carrier (* mfreq k)) a)))
    (unless neg-freq?
      (do ((neg nil)
           (pos nil))
          ((not (minusp (caar spectrum))) nil)
        (setf neg (pop spectrum))
        (setf pos (abs (first neg)))
        (rplaca neg pos)
        (rplaca (cdr neg) (- (second neg)))
        (let ((side (assoc (first neg) spectrum)))
          (if side (rplaca (cdr side) (+ (cadr side) (second neg)))
              (let ((p
                     (do ((i (- (length spectrum) 1) (- i 1))
                          (f nil)
                          (x nil))
                         ((or f (< i 0)) f)
                       (setf x (car (elt spectrum i)))
                       (if (< x pos) (setf f i)))))
                (if (not p) (push neg spectrum)
                    (let ((tail (nthcdr p spectrum)))
                      (setf neg (list neg))
                      (rplacd neg (cdr tail))
                      (rplacd tail neg))))))))
    (when pos-amp?
      (dolist (s spectrum) (rplaca (cdr s) (abs (second s)))))
    spectrum))

(defun hz-ify (x) (if (and x (symbolp x)) (hertz x) (* x 1.0)))

(defun hz-invert (f1 f2)
  (let ((l1 (log f1)) (l2 (log f2)))
    (exp (+ l1 (- l1 l2)))))

(defun bes-j0 (x)
  (if (< (abs x) 8.0)
      (let* ((y (* x x))
             (ans1
              (+ 5.756849e10
                 (* y
                    (+ -1.3362591e10
                       (* y
                          (+ 6.5161965e8
                             (* y
                                (+ -1.1214424e7
                                   (* y
                                      (+ 77392.33
                                         (* y -184.90524)))))))))))
             (ans2
              (+ 5.756849e10
                 (* y
                    (+ 1.029533e9
                       (* y
                          (+ 9494681.0
                             (* y
                                (+ 59272.65
                                   (* y (+ 267.85327 y)))))))))))
        (/ ans1 ans2))
      (let* ((ax (abs x))
             (z (/ 8.0 ax))
             (y (* z z))
             (xx (- ax 0.7853982))
             (ans1
              (+ 1.0
                 (* y
                    (+ -0.0010986286
                       (* y
                          (+ 2.7345104e-5
                             (* y
                                (+ -2.0733708e-6
                                   (* y 2.0938872e-7)))))))))
             (ans2
              (+ -0.015625
                 (* y
                    (+ 1.4304888e-4
                       (* y
                          (+ -6.9111475e-6
                             (* y
                                (+ 7.621095e-7
                                   (* y -9.349451e-8))))))))))
        (* (sqrt (/ 0.63661975 ax))
           (- (* (cos xx) ans1) (* z (sin xx) ans2))))))

(defun bes-j1 (x)
  (if (< (abs x) 8.0)
      (let* ((y (* x x))
             (ans1
              (* x
                 (+ 7.2362615e10
                    (* y
                       (+ -7.8950595e9
                          (* y
                             (+ 2.4239685e8
                                (* y
                                   (+ -2972611.5
                                      (* y
                                         (+ 15704.482
                                            (* y
                                               -30.160366))))))))))))
             (ans2
              (+ 1.4472523e11
                 (* y
                    (+ 2.3005353e9
                       (* y
                          (+ 1.8583304e7
                             (* y
                                (+ 99447.44
                                   (* y (+ 376.99915 y)))))))))))
        (/ ans1 ans2))
      (let* ((ax (abs x))
             (z (/ 8.0 ax))
             (y (* z z))
             (xx (- ax 2.3561945))
             (ans1
              (+ 1.0
                 (* y
                    (+ 0.00183105
                       (* y
                          (+ -3.5163965e-5
                             (* y
                                (+ 2.4575202e-6
                                   (* y -2.4033702e-7)))))))))
             (ans2
              (+ 0.046875
                 (* y
                    (+ -2.0026909e-4
                       (* y
                          (+ 8.449199e-6
                             (* y
                                (+ -8.822899e-7
                                   (* y 1.05787414e-7))))))))))
        (* (signum x) (sqrt (/ 0.63661975 ax))
           (- (* (cos xx) ans1) (* z (sin xx) ans2))))))

(defun import-spear-data
       (path
        &key (start 0) end point-format freq-scaler amp-scaler
        time-scaler)
  (let ((ftype nil)
        (count nil)
        (file (open-file path ':input))
        (data (list))
        (err? t)
        (para nil)
        (parb nil))
    (unwind-protect
        (progn
         (loop for s = (file-line file) until
               (or (file-eof? s) (equal s "frame-data")
                   (equal s "partials-data"))
               do
               (cond
                ((equal s "par-text-frame-format")
                 (setf ftype ':frames))
                ((equal s "par-text-partials-format")
                 (setf ftype ':partials))
                ((equal s "point-type time frequency amplitude") nil)
                ((equal s "point-type index frequency amplitude")
                 nil)
                (t
                 (let ((x (string-substrings s)))
                   (cond ((null x) nil)
                         ((or (equal (car x) "partials-count")
                              (equal (car x) "frame-count"))
                          (setf count
                                  (read-from-string (cadr x)))))))))
         (cond
          ((eq ftype ':frames)
           (unless point-format
             (setf point-format '(:hertz :amplitude)))
           (cond
            ((consp point-format)
             (if (member (car point-format) '(:hertz :keynum :note))
                 (setf para (car point-format))
                 (error
                  "import-spear-data: illegal point-format: ~s."
                  point-format))
             (if
              (and (consp (cdr point-format))
                   (eq (car (cdr point-format)) ':amplitude))
              (setf parb t)
              (error "import-spear-data: illegal point-format: ~s."
                     point-format)))
            ((member point-format '(:hertz :keynum :note :raw))
             (setf para point-format))
            (t
             (error
              "import-spear-data: ~s is not a valid point-format."
              point-format))))
          ((eq ftype ':partials)
           (unless point-format (setf point-format '(:time :hertz)))
           (cond
            ((consp point-format)
             (if (eq (car point-format) ':time) (setf para ':time)
                 (error "import-spear-data: illegal point-format ~s."
                        point-format))
             (if
              (and (consp (cdr point-format))
                   (member (car (cdr point-format))
                           '(:hertz :keynum :note)))
              (setf parb (car (cdr point-format)))
              (error "import-spear-data: illegal point-format ~s."
                     point-format)))
            ((member point-format '(:hertz :keynum :note :raw))
             (setf parb point-format))
            (t
             (error
              "import-spear-data: ~s is not a valid point-format."
              point-format))))
          (t (error "import-spear-data: no frames or partials.")))
         (unless count
           (error
            "import-spear-data: file does not contain frame/partial count."))
         (loop with d for s = (file-line file) for i from 0 until
               (file-eof? s) do
               (when
                   (or (and (>= i start) (or (not end) (<= i end))))
                 (if (eq ftype ':partials)
                     (let ((hdr s))
                       (setf s (file-line file))
                       (setf d
                               (read-spear-partial hdr s para parb
                                freq-scaler amp-scaler)))
                     (setf d
                             (read-spear-frame s para parb
                              time-scaler freq-scaler)))
                 (if (consp d) (push d data))))
         (setf err? nil))
      (if file (close-file file ':input)))
    (if (not err?) (setf data (nreverse data)))
    data))

(defun read-spear-frame (str ftyp amp? freq-scaler amp-scaler)
  (let ((data (string->expr str :multiok t)))
    (if (eq ftyp ':raw) data
        (do ((tail (cddr data) (cdddr tail))
             (head (list))
             (freq nil)
             (ampl nil))
            ((null tail) (nreverse head))
          (setf freq (car (cdr tail)))
          (setf ampl (car (cddr tail)))
          (cond
           ((eq ftyp ':hertz)
            (if freq-scaler (setf freq (* freq freq-scaler))))
           (t
            (if freq-scaler
                (setf freq (+ (keynum freq :hz t) freq-scaler))
                (setf freq (keynum freq :hz t)))
            (if (eq ftyp ':note) (setf freq (note freq)))))
          (push freq head)
          (if amp?
              (push (if amp-scaler (* ampl amp-scaler) ampl)
                    head))))))

(defun read-spear-partial (hdr str tim? ftyp time-scaler freq-scaler)
  hdr
  (let ((data (string->expr str :multiok t)))
    (if (eq ftyp ':raw) data
        (do ((tail data (cdddr tail))
             (head (list))
             (time nil)
             (freq nil))
            ((null tail) (nreverse head))
          (setf time (car tail))
          (setf freq (car (cdr tail)))
          (if tim?
              (push (if time-scaler (* time time-scaler) time) head))
          (cond
           ((eq ftyp ':hertz)
            (if freq-scaler (setf freq (* freq freq-scaler))))
           (t
            (if freq-scaler
                (setf freq (+ (keynum freq :hz t) freq-scaler))
                (setf freq (keynum freq :hz t)))
            (if (eq ftyp ':note) (setf freq (note freq)))))
          (push freq head)))))

(defun spectrum-maxfreq (spec &optional fmat)
  (let ((freq (elt spec (- (length spec) 2))))
    (if (not fmat) freq
        (let ((type (spectrum-guess-type spec)))
          (case fmat
            ((:hertz :hz) (if (eq type ':hertz) freq (hertz freq)))
            ((:keynum)
             (if (eq fmat type) freq
                 (keynum freq :hz (eq type ':hertz))))
            ((:note)
             (if (eq fmat type) freq
                 (note freq :hz (eq type ':hertz))))
            (t
             (error "spectrum-maxfreq: ~s is not a frequency format."
                    fmat)))))))

(defun spectrum-minfreq (spec &optional fmat)
  (let ((freq (car spec)))
    (if (not fmat) freq
        (let ((type (spectrum-guess-type spec)))
          (case fmat
            ((:hertz :hz) (if (eq type ':hertz) freq (hertz freq)))
            ((:keynum)
             (if (eq fmat type) freq
                 (keynum freq :hz (eq type ':hertz))))
            ((:note)
             (if (eq fmat type) freq
                 (note freq :hz (eq type ':hertz))))
            (t
             (error "spectrum-minfreq: ~s is not a frequency format."
                    fmat)))))))

(defun spectrum-minamp (spec)
  (do ((tail (cdr spec) (cddr tail))
       (mina most-positive-fixnum))
      ((null tail) (if (eq mina most-positive-fixnum) nil mina))
    (setf mina (min mina (car tail)))))

(defun spectrum-maxamp (spec)
  (do ((tail (cdr spec) (cddr tail))
       (maxa most-negative-fixnum))
      ((null tail) (if (eq maxa most-negative-fixnum) nil maxa))
    (setf maxa (max maxa (car tail)))))

(defun spectrum-freqs (spec &optional fmat)
  (let* ((frqs (list nil)) (type (spectrum-guess-type spec)))
    (if (not fmat) (setf fmat type)
        (case fmat
          ((:note :notes) (setf fmat ':note))
          ((:keynum :keynums) (setf fmat ':keynum))
          ((:hertz :hz) (setf fmat ':hertz))
          (t
           (error "spectrum-freqs: ~s is not a frequency format."
                  fmat))))
    (do ((next spec (cddr next))
         (tail frqs))
        ((null next) (cdr frqs))
      (setf (cdr tail)
              (list
               (cond ((eq type fmat) (car next))
                     ((eq fmat ':hertz) (hertz (car next)))
                     ((eq fmat ':keynum)
                      (keynum (car next) :hz (eq type ':hertz)))
                     (t (note (car next) :hz (eq type ':hertz))))))
      (setf tail (cdr tail)))))

(defun spectrum-amps (spec)
  (let ((amps (list nil)))
    (do ((next (cdr spec) (cddr next))
         (tail amps))
        ((null next) (cdr amps))
      (setf (cdr tail) (list (car next)))
      (setf tail (cdr tail)))))

(defun spectrum-guess-type (spec)
  (if
   (let ((t12 (car spec)))
     (and t12 (symbolp t12)))
   ':note
   (let ((max (spectrum-maxfreq spec)))
     (if (< max 138) ':keynum ':hertz))))

(defun convert-spectrum (spec fmat)
  (let ((head (list nil)) (mode 0) (type (spectrum-guess-type spec)))
    (case type ((:keynum) (setf mode 1)) ((:note) (setf mode 2)))
    (case fmat
      ((:keynum :keynums) (setf mode (logior mode 4)))
      ((:note :notes) (setf mode (logior mode 8)))
      ((:hertz :hz) nil)
      (t
       (error "convert-spectrum: ~s is not :note :keynum or :hertz"
              fmat)))
    (if (member mode '(0 5 10)) spec
        (do ((next spec (cdr next))
             (tail head (cdr tail))
             (amp? nil (not amp?)))
            ((null next) (cdr head))
          (setf (cdr tail)
                  (list
                   (if amp? (car next)
                       (case mode
                         ((4) (keynum (car next) :hz t))
                         ((8) (note (car next) :hz t))
                         ((1 2) (hertz (car next)))
                         ((9) (note (car next)))
                         ((6) (keynum (car next)))
                         (t
                          (error
                           "convert-spectrum: Shouldn't: mode is ~s"
                           mode))))))))))

(defun rescale-spectrum (spec &optional f1 f2 a1 a2)
  (let* ((fmat (spectrum-guess-type spec))
         (amp? (or a1 a2))
         (next
          (if (eq fmat ':hertz) (append spec (list))
              (convert-spectrum spec ':hertz))))
    (when amp?
      (let ((mina (spectrum-minamp next))
            (maxa (spectrum-maxamp next)))
        (if (not a1) (setf a1 mina))
        (if (not a2) (setf a2 maxa))
        (do ((tail (cdr next) (cddr tail)))
            ((null tail) nil)
          (setf (car tail) (rescale (car tail) mina maxa a1 a2)))))
    (unless (and (eq fmat ':hertz) (not f1) (not f2))
      (let ((oldmin (spectrum-minfreq next))
            (oldmax (spectrum-maxfreq next))
            (newmin nil)
            (newmax nil))
        (cond
         ((eq fmat ':hertz) (setf newmin (or f1 oldmin))
          (setf newmax (or f2 oldmax)))
         (t (setf newmin (if f1 (hertz f1) oldmin))
          (setf newmax (if f2 (hertz f2) oldmax))))
        (do ((tail next (cddr tail)))
            ((null tail) nil)
          (setf (car tail)
                  (rescale (car tail) oldmin oldmax newmin newmax))
          (if (eq fmat ':keynum)
              (setf (car tail) (keynum (car tail) :hz t))
              (if (eq fmat ':note)
                  (setf (car tail) (note (car tail) :hz t)))))))
    next))

(defun invert-spectrum (spec &optional amps?)
  (let* ((isa (spectrum-guess-type spec))
         (new
          (if (eq isa ':note) (convert-spectrum spec ':keynum)
              (append spec (list))))
         (bot (spectrum-minfreq new))
         (top (spectrum-maxfreq new))
         (len (length new)))
    (do ((tail new (cddr tail))
         (soft (if amps? (spectrum-minamp new) nil))
         (loud (if amps? (spectrum-maxamp new) nil)))
        ((null tail) nil)
      (rplaca tail (rescale (car tail) bot top top bot))
      (if soft
          (rplaca (cdr tail)
                  (rescale (cadr tail) soft loud loud soft)))
      (if (eq isa ':note) (rplaca tail (note (car tail)))))
    (do ((head 0 (+ head 2))
         (tail (- len 2) (- tail 2))
         (temp nil))
        ((not (< head tail)) nil)
      (setf temp (elt new head))
      (setf (elt new head) (elt new tail))
      (setf (elt new tail) temp))
    new))

(defun spectrum->midi (spec &rest args)
  (let* ((type (spectrum-guess-type spec))
         (amps
          (if (eq (getf args ':amplitude) t) (spectrum-amps spec)
              nil))
         (keys
          (spectrum-freqs spec (if (eq type ':hertz) ':keynum nil)))
         (head (list nil)))
    (if (not amps)
        (do ((klis keys (cdr klis))
             (tail head))
            ((null klis) (cdr head))
          (setf (cdr tail)
                  (list
                   (apply #'make-instance (find-class 'midi) :keynum
                          (car klis) args)))
          (setf tail (cdr tail)))
        (do ((ampl (member ':amplitude args))
             (klis keys (cdr klis))
             (alis amps (cdr alis))
             (tail head))
            ((null klis) (cdr head))
          (setf (car (cdr ampl)) (car alis))
          (setf (cdr tail)
                  (list
                   (apply #'make-instance (find-class 'midi) :keynum
                          (car klis) args)))
          (setf tail (cdr tail))))))
