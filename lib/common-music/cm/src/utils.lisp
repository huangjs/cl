;;; **********************************************************************
;;; Copyright (C) 2007 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from utils.scm on 30-Jan-2007 07:38:48

(in-package :cm)

(defparameter %months
  #("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov"
    "Dec"))

(defun date-and-time ()
  (flet ((fnum (n)
           (if (< n 10) (concatenate 'string "0" (prin1-to-string n))
               (prin1-to-string n))))
    (let ((vect (get-current-time)))
      (concatenate 'string (fnum (elt vect 3)) " "
                   (elt %months (elt vect 4)) " " (fnum (elt vect 5))
                   ", " (fnum (elt vect 2)) ":" (fnum (elt vect 1))
                   ":" (fnum (elt vect 0))))))

(defmacro dopairs (decl &body body)
  (let* ((m "dopairs: (v1 v2 list [return]) . body")
         (s (if (consp decl) (pop decl) (error m)))
         (v (if (consp decl) (pop decl) (error m)))
         (l (if (consp decl) (pop decl) (error m)))
         (x (if (consp decl) (pop decl) nil))
         (a (gensym))
         (h (gensym)))
    `(let ((,h ,l))
       (do ((,a ,h (cddr ,a))
            (,s nil)
            (,v nil))
           ((null ,a) ,x)
         (setf ,s (car ,a))
         (if (null (cdr ,a)) (error "Uneven pair list: ~s" ,h)
             (setf ,v (cadr ,a)))
        ,@body))))

(defmacro make-cycl () `(make-list 2))

(defmacro cycl-data (cycl) `(car ,cycl))

(defmacro cycl-data-set! (cycl data) `(rplaca ,cycl ,data))

(defmacro cycl-last (cycl) `(cadr ,cycl))

(defmacro cycl-last-set! (cycl data) `(rplaca (cdr ,cycl) ,data))

(defmacro cycl-tail (cycl) `(cddr ,cycl))

(defmacro cycl-tail-set! (cycl tail) `(rplacd (cdr ,cycl) ,tail))

(defmacro pop-cycl (cycl) `(pop (cdr (cdr ,cycl))))

(defmacro reset-cycl (cycl)
  (let ((c (gensym)))
    `(let ((,c ,cycl))
       (cycl-tail-set! ,c (car ,c)))))

(defun format-integer (int field pad)
  (let* ((str (prin1-to-string int))
         (len (length str))
         (wid (abs field)))
    (if (< len wid)
        (let* ((d (- wid len))
               (s (make-string wid :initial-element pad)))
          (if (< field 0)
              (dotimes (i len) (setf (elt s i) (elt str i)))
              (dotimes (i len)
                (setf (elt s d) (elt str i))
                (setf d (+ d 1))))
          s)
        str)))

(defun quotify (token)
  (concatenate 'string "\""
               (if (stringp token) token (symbol-name token)) "\""))

(defun quote-if-necessary (x)
  (if
   (or (numberp x) (stringp x) (vectorp x)
       (and (consp x) (eq (car x) 'quote)))
   x `',x))

(defun parse-lambda-list (pars)
  (flet ((bind (par type maxlen)
           (if (consp par)
               (progn
                (if (eq type '&key)
                    (cond
                     ((consp (car par))
                      (unless
                          (and (keyword? (car (car par)))
                               (= (length (car par)) 2)
                               (let ((t2 (cadr (car par))))
                                 (and t2 (symbolp t2))))
                        (error "Malformed ~s parameter: ~s" type
                               par)))
                     ((let ((t3 (car par)))
                        (and t3 (symbolp t3)))
                      t)
                     (t
                      (error "Malformed ~s parameter: ~s." type
                             par)))
                    (unless
                        (let ((t4 (car par)))
                          (and t4 (symbolp t4)))
                      (error "Malformed ~s parameter: ~s." type
                             par)))
                (unless (<= (length par) maxlen)
                  (error "Malformed ~s parameter: ~s." type par))
                par)
               (if (and par (symbolp par)) (list par nil)
                   (error "Not a lambda parameter: ~s." par)))))
    (let ((mode '&required)
          (reqs '())
          (opts '())
          (rest '())
          (keys '())
          (auxs '())
          (aok? nil)
          (this nil)
          (head pars))
      (do ()
          ((null pars))
        (setf this (car pars))
        (setf pars (cdr pars))
        (if
         (member this '(&optional &rest &key &aux &allow-other-keys))
         (cond
          ((eq this '&optional)
           (unless (eq mode '&required)
             (error "Malformed lambda list: ~s." head))
           (setf mode '&optional))
          ((eq this '&rest)
           (unless (member mode '(&required &optional))
             (error "Malformed lambda list: ~s." head))
           (setf mode '&rest))
          ((eq this '&key)
           (unless (member mode '(&required &optional !rest))
             (error "Malformed lambda list: ~s." head))
           (setf mode '&key))
          ((eq this '&allow-other-keys)
           (unless (eq mode '&key)
             (error "Malformed lambda list: ~s." head))
           (setf mode '&allow-other-keys) (setf aok? t))
          ((eq this '&aux) (setf mode '&aux)))
         (case mode
           ((&required)
            (if (not (and this (symbolp this)))
                (error "Required argument not symbol: ~s" this))
            (push this reqs))
           ((&optional) (push (bind this mode 3) opts))
           ((&rest)
            (if (not (and this (symbolp this)))
                (error "&rest argument not symbol: ~s" this))
            (push this rest)
            (setf mode '!rest))
           ((&key) (push (bind this mode 3) keys))
           ((&aux) (push (bind this mode 2) auxs))
           (t (error "Malformed lambda list: ~s." head)))))
      (values (reverse reqs) (reverse opts) rest (reverse keys) aok?
              (reverse auxs)))))

(defparameter %cm-version% 688)

(defun cm-version-number (&rest arg) arg %cm-version%)

(defun cm-version-name ()
  (format nil "~a.~a.~a" (ldb (byte 4 8) %cm-version%)
          (ldb (byte 4 4) %cm-version%)
          (ldb (byte 4 0) %cm-version%)))

(defun cm-version (&rest fmat)
  (cond
   ((null fmat) (format nil "Common Music ~a" (cm-version-name)))
   ((not (null (cdr fmat)))
    (error "cm-version: more than one arg: ~s." fmat))
   ((eq (car fmat) ':number) %cm-version%)
   ((eq (car fmat) ':string) (cm-version-name))
   ((eq (car fmat) ':list)
    (list (ldb (byte 4 8) %cm-version%) (ldb (byte 4 4) %cm-version%)
          (ldb (byte 4 0) %cm-version%)))
   (t (error "cm-version: Bad format: ~s." (car fmat)))))

(defparameter *cm-logo* t)

(defun cm-logo ()
  (if *cm-logo*
      (progn
       (format t "~%")
       (do ((e "~%")
            (v (make-string 15))
            (y 0 (+ y 1)))
           ((= y 7) nil)
         (format t
                 (do ((x 0 (+ x 1)))
                     ((= x 15)
                      (if (= y 3)
                          (concatenate 'string v " " (cm-version) e)
                          (concatenate 'string v e)))
                   (setf (elt v x)
                           (if (<= 2 (- x y) 4) #\\
                               (if
                                (= (- x (- 4 (mod (+ 13 y) 15))) 1)
                                #\/
                                (if (<= 1 y 5) #\-
                                    (if (= (* (- x 6) (- y 3)) 15)
                                        #\/ #\ ))))))))
       (format t "~%")))
  (values))

(defun string-substrings
       (string
        &key (delimiters '(#\  #\Tab)) (start 0)
        (end (length string)) key)
  (let* ((pos1 start) (pos2 nil) (head (list nil)) (tail head))
    (do ()
        ((> pos1 end) (cdr head))
      (setf pos2
              (or
               (do ((i pos1 (+ i 1))
                    (f nil))
                   ((or f (= i end)) f)
                 (if (member (elt string i) delimiters) (setf f i)))
               end))
      (unless (= pos1 pos2)
        (rplacd tail
                (list
                 (if key (funcall key (subseq string pos1 pos2))
                     (subseq string pos1 pos2))))
        (setf tail (cdr tail)))
      (setf pos1 (+ pos2 1)))))

(defun string-readable?
       (string &optional (start 0) (end (length string)))
  (do ((pos start (+ pos 1))
       (tok nil)
       (num 0)
       (lev 0)
       (str nil)
       (chr nil))
      ((not (< pos end))
       (if (and (= pos end) (= lev 0) (not str))
           (if tok (+ num 1) num) nil))
    (setf chr (elt string pos))
    (cond
     ((char= chr #\() (if (= lev 0) (incf num)) (incf lev)
      (setf tok nil))
     ((char= chr #\)) (decf lev) (if (< lev 0) (setf pos end))
      (setf tok nil))
     ((char= chr #\") (setf str (not str))
      (if (and (= lev 0) str) (incf num)) (setf tok nil))
     ((member chr '(#\, #\`)) (if (not str) (setf pos end)))
     ((member chr '(#\  #\Return #\Tab))
      (if (and tok (= lev 0) (not str)) (incf num)) (setf tok nil))
     ((member chr '(#\' #\#)) (setf tok nil)) (t (setf tok t)))))

(defparameter +se-nullstring+ 0)

(defparameter +se-unreadable+ 1)

(defparameter +se-multiple+ 2)

(defparameter +se-incorrect+ 3)

(defparameter +se-not-number+ 4)

(defparameter +se-not-symbol+ 5)

(defparameter +se-not-cons+ 6)

(defun string->expr
       (str &key (read t) (test nil) (nullok t) (multiok nil) errval)
  (let ((text str)
        (trim '(#\  #\Newline #\Tab))
        (expr nil)
        (err? nil))
    (if (string= text "")
        (if nullok (values nil nil) (values "" +se-nullstring+))
        (let ((len (length text)) (raw text))
          (if
           (or (member (elt text 0) trim)
               (member (elt text (- len 1)) trim))
           (setf text (strip-chars text)))
          (if (string= text "")
              (if nullok (values nil nil)
                  (values raw +se-nullstring+))
              (progn
               (if (not read)
                   (progn (setf expr text) (setf err? nil))
                   (if (not (eq read t))
                       (multiple-value-setq (expr err?)
                         (funcall read text))
                       (let ((num (string-readable? text)))
                         (cond
                          ((not num) (setf expr text)
                           (setf err? +se-unreadable+))
                          ((= num 1)
                           (multiple-value-setq (expr num)
                             (string-read text))
                           (setf err? nil))
                          ((not multiok) (setf expr text)
                           (setf err? +se-multiple+))
                          (t
                           (do ((n 0)
                                (x nil)
                                (l (list)))
                               ((eq x ':eof)
                                (setf expr (nreverse l))
                                (setf err? nil))
                             (multiple-value-setq (x n)
                               (string-read text n))
                             (unless (eq x ':eof) (push x l))))))))
               (if err? (values expr err?)
                   (if test
                       (if (funcall test expr) (values expr nil)
                           (values test (or errval +se-incorrect+)))
                       (values expr err?)))))))))

(defmacro sv (obj slot &body args)
  (if (null args)
      (slot-getter-form obj
       (if (keyword? slot) (keyword->symbol slot) slot))
      (let ((o (gensym)))
        `(let ((,o ,obj))
           ,(slot-setter-form o
             (if (keyword? slot) (keyword->symbol slot) slot)
             (car args))
           ,@(if (null (cdr args)) (list)
                 (let ((res '()))
                   (dopairs (x y (cdr args))
                    (push
                     (slot-setter-form o
                      (if (keyword? x) (keyword->symbol x) x) y)
                     res))
                   (reverse res)))))))

(defun svaux (obj op slot val others)
  (let* ((ob (gensym)) (args (list ob)) (done nil))
    (do ()
        (done
         `(let ((,ob ,obj))
            (sv ,@args)))
      (nconc args (list slot `(,op (sv ,ob ,slot) ,val)))
      (if (null others) (setf done t)
          (progn
           (setf slot (car others))
           (setf val (cadr others))
           (setf others (cddr others)))))))

(defmacro sv+ (obj slot val &body more) (svaux obj '+ slot val more))

(defmacro sv* (obj slot val &body more) (svaux obj '* slot val more))

(defun u8vector-copy! (vec1 vec2 &rest args)
  (let ((p (if (null args) 0 (car args)))
        (l
         (if (or (null args) (null (cdr args)))
             (u8vector-length vec2) (cadr args))))
    (do ((i p (+ i 1))
         (j 0 (+ j 1)))
        ((= j l) vec1)
      (u8vector-set! vec1 i (u8vector-ref vec2 j)))))

(defun u8vector-append (&rest vecs)
  (let ((len 0))
    (map nil (lambda (x) (setf len (+ len (u8vector-length x))))
         vecs)
    (do ((tail vecs (cdr tail))
         (v (make-u8vector len 0))
         (p 0 (+ p l))
         (l nil))
        ((null tail) v)
      (setf l (u8vector-length (car tail)))
      (u8vector-copy! v (car tail) p l))))

(defun u8vector->uint (vec)
  (logior (ash (u8vector-ref vec 0) 24) (ash (u8vector-ref vec 1) 16)
          (ash (u8vector-ref vec 2) 8) (u8vector-ref vec 3)))

(defun u8vector->int (vec)
  (let ((int (u8vector->uint vec)))
    (if (> int (ash 4294967295 -1)) (- int 4294967295 1) int)))

(defun u8vector->float (vec)
  (let ((i (u8vector->uint vec)))
    (if (zerop i) 0.0
        (let ((val
               (* (if (zerop (ash i -31)) 1.0 -1.0)
                  (expt 2.0 (- (logand (ash i -23) 255) 127))
                  (logior 8388608 (logand i 8388607)) (expt 2 -23))))
          val))))

(defun u8vector->string (vec)
  (let* ((vec-len (u8vector-length vec)) (str-list '()))
    (do ((i 0 (+ i 1))
         (j nil))
        ((or (= i vec-len) (equal j 0)))
      (setf j (u8vector-ref vec i))
      (unless (= j 0)
        (setf str-list (nconc str-list (list (code-char j))))))
    (coerce str-list 'string)))

(defun u8vector-subseq (vec beg &rest arg)
  (let* ((end (if (null arg) (u8vector-length vec) (car arg)))
         (sub (make-u8vector (- end beg))))
    (do ((i 0 (+ i 1))
         (j beg (+ j 1)))
        ((= j end) sub)
      (u8vector-set! sub i (u8vector-ref vec j)))))
