;;; **********************************************************************
;;; Copyright (C) 2003 Heinrich Taube (taube@uiuc.edu) 
;;; This program is free software; you can redistribute it and
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; **********************************************************************

;;; generated by scheme->cltl from cm-tester.scm on 04-May-2006 22:32:55

(in-package :cm)


(defparameter *cmt-default-input* ())

(defparameter *cmt-default-output* ())

(progn (defclass cmt-stream (rt-stream)
         ((file :initform nil :initarg :file :accessor
           cmt-stream-file)
          (version :initform 0 :accessor event-file-version :initarg
           :version)
          (versioning :initform nil :initarg :versioning :accessor
           event-file-versioning)
          (elt-type :initform :char :accessor file-elt-type :initarg
           :elt-type))
         #+metaclasses
         (:metaclass io-class))
       (defparameter <cmt-stream> (find-class 'cmt-stream))
       (finalize-class <cmt-stream>)
       (values))

(defmethod open-io ((obj cmt-stream) dir &rest args)
  args
  (let ((file nil) (name nil))
    (if (eq dir :output)
        (cond ((event-stream-stream obj)
               (setf file (event-stream-stream obj)))
              (t
               (bump-version obj)
               (setf name (file-output-filename obj))
               (if (probe-file name) (delete-file name))
               (setf file (open-file name dir (file-elt-type obj)))))
        (if (eq dir :input)
            (if (event-stream-stream obj)
                (setf file (event-stream-stream obj))
                (setf file
                      (open-file (object-name obj) dir
                       (file-elt-type obj))))
            (error "Direction not :input or :output: ~s" dir)))
    (setf (io-direction obj) dir)
    (setf (io-open obj) file)
    (initialize-io obj)
    obj))

(defmethod close-io ((io cmt-stream) &rest mode)
  mode
  (when (io-open io)
    (unless (event-stream-stream io)
      (close-file (io-open io) (io-direction io)))
    (setf (io-open io) nil))
  io)

(defmethod write-message (message (io cmt-stream))
  (let ((fd (io-open io))) (format fd message) (values)))

(defmethod initialize-io ((io cmt-stream))
  (when (eq (io-direction io) ':output)
    (write-message (format nil "file opened at ~s ~%" (now)) io)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (progn (defclass cmt-message (event) nil)
         (defparameter <cmt-message> (find-class 'cmt-message))
         (finalize-class <cmt-message>)
         (values)))

(defobject cmt-on (cmt-message) ((args :initform nil))
 (:parameters args) (:event-streams))

(defmethod write-event ((obj cmt-on) (io cmt-stream) time)
  time
  (let ((mess
         (format nil "cmt-on ~s ~s~%" (now) (slot-value obj 'args))))
    (write-message mess io)))

(defobject cmt-off (cmt-message) 
  ((args :initform nil))
  (:parameters args) (:event-streams))

(defmethod write-event ((obj cmt-off) (io cmt-stream) time)
  time
  (let ((mess
         (format nil "cmt-off ~s ~s" (now) (slot-value obj 'args))))
    (write-message mess io)))

(defobject cmt (cmt-message)
 ((duration :initform 1.0) (args :initform nil))
 (:parameters duration args) (:event-streams))


;;think enqueue is wrong
(defmethod write-event ((obj cmt) (io cmt-stream) time)
  time
  (new cmt-on :args (slot-value obj 'args))
  (enqueue *qentry-message*
   (new cmt-off :args (slot-value obj 'args)))
  (values))

(defun string-split (str char)
  (let ((mess (coerce str 'list)))
    (read-delimited-list char mess)))


;;had to change since no string-split in cl
(defun cmt-string->cmt-object (str)
  (let* ((mess (explode-string str )) 
	 (obj nil) 
	 (id (pop mess)))
    (when (equal id "cmt-on")
      (setf obj
            (new cmt-on :time (read-from-string (pop mess)) :args
             mess)))
    (when (equal id "cmt-off")
      (setf obj
            (new cmt-on :time (read-from-string (pop mess)) :args
             mess)))
    obj))

;;changed since eof-object? not in cl
(defun cmt-readline (fd)
  (let ((mess (read-line fd nil nil)))
    (if (not mess)
	'eof
	(cmt-string->cmt-object mess))))

(defmethod import-events ((file cmt-stream) &rest args)
  args
  (with-open-io (obj file :input)
    (do ((str (io-open obj))
	 (seq '())
	 (mess nil)
	 (end nil)
	 (len 0))
	((not (not end))
	 (make-instance 'seq :subobjects (nreverse (cddr seq))))
      (setf mess (cmt-readline str))
      (if (equal 'eof mess)
	  (setf end t)
	  (if mess (push mess seq))))))



