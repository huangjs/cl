;;; **********************************************************************
;;; Copyright (C) 2003 Heinrich Taube (taube@uiuc.edu) 
;;; This program is free software; you can redistribute it and
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; **********************************************************************

;;; generated by scheme->cltl from rt-sc.scm on 04-Feb-2006 21:08:52

(in-package :cm)

(progn (defclass sc-stream (osc-stream)
         ((remote-port :initform 57110)
          (remote-host :initform "127.0.0.1")
          (local-port :initform 57100)
          (latency :initform 0.05 :initarg :latency :accessor
           rt-stream-latency)
          (receive-mode :accessor rt-stream-receive-mode :initform
           :object :initarg :receive-mode)
          (notify :initform nil))
         #+metaclasses
         (:metaclass io-class))
       (defparameter <sc-stream> (find-class 'sc-stream))
       (finalize-class <sc-stream>)
       (setf (io-class-file-types <sc-stream>) '("sc.udp"))
       (values))

(defmethod open-io :after ((io sc-stream) dir &rest args)
  dir args
  (send-bundle 0.0 (list "/g_new" 1 0 0) io))


(defmethod write-event ((obj scsynth) (io sc-stream) time)
  time
  (let* ((node-set-list nil)
         (synthname (symbol-name (class-name (class-of obj))))
         (slots (instance-slots obj))
         (inits (list nil))
         (msg
          (list* "/s_new"
                 (string-downcase synthname)
                 (slot-value obj 'node)
                 (slot-value obj 'add-action)
                 (slot-value obj 'target)
                 (do ((tail slots (cdr tail)) (args inits))
                     ((null tail) (cdr inits))
                   (unless (member (car tail)
                                   '(node add-action target time))
                     (cond ((listp (slot-value obj (car tail)))
                            (progn (setf
                                    node-set-list
                                    (nconc
                                     node-set-list
                                     (list
                                      (string-downcase
                                       (symbol-name (car tail))))))
                                   (let
                                    ((mess-list
                                      (slot-value obj (car tail))))
                                    (setf
                                     node-set-list
                                     (nconc
                                      node-set-list
                                      (list (length mess-list))))
                                    (setf
                                     node-set-list
                                     (nconc
                                      node-set-list
                                      mess-list)))))
                           ((equal (find-class 'sc-env)
                                   (class-of
                                    (slot-value obj (car tail))))
                            (setf node-set-list
                                  (nconc
                                   node-set-list
                                   (list
                                    (string-downcase
                                     (symbol-name (car tail))))))
                            (let ((mess-list
                                   (sc-env->list
                                    (slot-value obj (car tail)))))
                              (setf
                               node-set-list
                               (nconc
                                node-set-list
                                (list (length mess-list))))
                              (setf
                               node-set-list
                               (nconc node-set-list mess-list))))
                           (t
                            (rplacd args
                                    (list
                                     (string-downcase
                                      (symbol-name (car tail)))
                                     (slot-value obj (car tail))))
                            (setf args (cddr args)))))))))
    (if node-set-list
        (send-bundle 0
         (list msg
               (nconc (list "/n_setn" (slot-value obj 'node))
                      node-set-list))
         io)
        (send-msg msg io))))

(defmethod write-event ((obj load-synthdef) (io sc-stream) time)
  time
  (let ((msg (load-synthdef (slot-value obj 'path))))
    (send-msg msg io)))

(defmethod write-event ((obj load-synthdef-dir) (io sc-stream) time)
  time
  (let ((msg (load-synthdef-dir (slot-value obj 'path))))
    (send-msg msg io)))

(defmethod write-event ((obj node-free) (io sc-stream) time)
  time
  (let ((msg (node-free (slot-value obj 'node)))) (send-msg msg io)))

(defmethod write-event ((obj node-run) (io sc-stream) time)
  time
  (let ((msg
         (node-run (slot-value obj 'node) (slot-value obj 'flag))))
    (send-msg msg io)))

(defmethod write-event ((obj node-set) (io sc-stream) time)
  time
  (let ((msg
         (node-set (slot-value obj 'node)
          (slot-value obj 'controls-values))))
    (send-msg msg io)))

(defmethod write-event ((obj node-setn) (io sc-stream) time)
  time
  (let ((msg
         (node-setn (slot-value obj 'node)
          (slot-value obj 'controls-values))))
    (send-msg msg io)))

(defmethod write-event ((obj node-fill) (io sc-stream) time)
  time
  (let ((msg
         (node-fill (slot-value obj 'node) (slot-value obj 'control)
          (slot-value obj 'num-controls) (slot-value obj 'value))))
    (send-msg msg io)))

(defmethod write-event ((obj node-map) (io sc-stream) time)
  time
  (let ((msg
         (node-map (slot-value obj 'node)
          (slot-value obj 'controls-buses))))
    (send-msg msg io)))

(defmethod write-event ((obj node-mapn) (io sc-stream) time)
  time
  (let ((msg
         (node-mapn (slot-value obj 'node) (slot-value obj 'control)
          (slot-value obj 'value) (slot-value obj 'num-controls))))
    (send-msg msg io)))

(defmethod write-event ((obj node-before) (io sc-stream) time)
  time
  (let ((msg
         (node-before (slot-value obj 'node)
          (slot-value obj 'before))))
    (send-msg msg io)))

(defmethod write-event ((obj node-after) (io sc-stream) time)
  time
  (let ((msg
         (node-after (slot-value obj 'node)
          (slot-value obj 'after))))
    (send-msg msg io)))

(defobject node-query (sc-cmd) ((node :initform nil))
 (:parameters node) (:event-streams))

(defmethod write-event ((obj node-query) (io sc-stream) time)
  time
  (let ((node (slot-value obj 'node)) (msg (list "/n_query")))
    (if (consp node)
        (setf msg (nconc msg node))
        (setf msg (nconc msg (list node))))
    (send-msg msg io)))

(defobject synth-get (sc-cmd)
 ((node :initform nil) (controls :initform nil))
 (:parameters node controls) (:event-streams))

(defmethod write-event ((obj synth-get) (io sc-stream) time)
  time
  (let ((controls (slot-value obj 'controls))
        (msg (list "/s_get" (slot-value obj 'node))))
    (if (consp controls)
        (setf msg (nconc msg controls))
        (setf msg (nconc msg (list controls))))
    (send-msg msg io)))

(defobject synth-getn (sc-cmd)
 ((node :initform nil) (controls :initform nil)
  (num-controls :initform nil))
 (:parameters node controls num-controls) (:event-streams))

(defmethod write-event ((obj synth-getn) (io sc-stream) time)
  time
  (let* ((controls (slot-value obj 'controls))
         (controls-len (length controls))
         (num-controls (slot-value obj 'num-controls))
         (msg (list "/s_getn" (slot-value obj 'node))))
    (if (consp controls)
        (do ((i 0 (+ i 1)))
            ((> i controls-len))
          (setf msg
                (nconc msg
                       (list (elt controls i)
                             (elt num-controls i)))))
        (setf msg (nconc msg (list controls num-controls))))
    (send-msg msg io)))

(defmethod write-event ((obj group-new) (io sc-stream) time)
  time
  (let ((msg
         (group-new (slot-value obj 'id) (slot-value obj 'add-action)
          (slot-value obj 'target))))
    (if (> time 0) (send-bundle time msg io) (send-msg msg io))))

(defmethod write-event ((obj group-head) (io sc-stream) time)
  time
  (let ((msg
         (group-head (slot-value obj 'group)
          (slot-value obj 'node))))
    (send-msg msg io)))

(defmethod write-event ((obj group-tail) (io sc-stream) time)
  time
  (let ((msg
         (group-tail (slot-value obj 'group)
          (slot-value obj 'node))))
    (send-msg msg io)))

(defmethod write-event ((obj group-free-all) (io sc-stream) time)
  time
  (let ((msg (group-free-all (slot-value obj 'group))))
    (send-msg msg io)))

(defmethod write-event ((obj group-deep-free) (io sc-stream) time)
  time
  (let ((msg (group-deep-free (slot-value obj 'group))))
    (send-msg msg io)))

(defmethod write-event ((obj ugen-command) (io sc-stream) time)
  time
  (let ((msg
         (ugen-command (slot-value obj 'node)
          (slot-value obj 'ugen-index) (slot-value obj 'command-name)
          (slot-value obj 'args))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-alloc) (io sc-stream) time)
  time
  (let ((msg
         (buffer-alloc (slot-value obj 'bufnum)
          (slot-value obj 'frames) (slot-value obj 'channels))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-alloc-read) (io sc-stream) time)
  time
  (let ((msg
         (buffer-alloc-read (slot-value obj 'bufnum)
          (slot-value obj 'file) (slot-value obj 'start-frame)
          (slot-value obj 'frames))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-read) (io sc-stream) time)
  time
  (let ((msg
         (buffer-read (slot-value obj 'bufnum) (slot-value obj 'file)
          (slot-value obj 'start-frame) (slot-value obj 'frames)
          (slot-value obj 'buffer-start-frame)
          (slot-value obj 'leave-open?))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-write) (io sc-stream) time)
  time
  (let ((msg
         (buffer-write (slot-value obj 'bufnum)
          (slot-value obj 'file) (slot-value obj 'header)
          (slot-value obj 'sample-format) (slot-value obj 'frames)
          (slot-value obj 'start-frame)
          (slot-value obj 'leave-open?))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-free) (io sc-stream) time)
  time
  (let ((msg (buffer-free (slot-value obj 'bufnum))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-zero) (io sc-stream) time)
  time
  (let ((msg (buffer-zero (slot-value obj 'bufnum))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-set) (io sc-stream) time)
  time
  (let ((msg
         (buffer-set (slot-value obj 'bufnum)
          (slot-value obj 'samples-values))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-setn) (io sc-stream) time)
  time
  (let ((msg
         (buffer-setn (slot-value obj 'bufnum)
          (slot-value obj 'samples-values))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-fill) (io sc-stream) time)
  time
  (let ((msg
         (buffer-fill (slot-value obj 'bufnum)
          (slot-value obj 'start-sample)
          (slot-value obj 'num-samples) (slot-value obj 'value))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-close) (io sc-stream) time)
  time
  (let ((msg (buffer-close (slot-value obj 'bufnum))))
    (send-msg msg io)))

(defobject buffer-query (sc-cmd) ((bufnums :initform nil))
 (:parameters bufnums) (:event-streams))

(defmethod write-event ((obj buffer-query) (io sc-stream) time)
  time
  (let ((bufnums (slot-value obj 'bufnums)) (msg (list "/b_query")))
    (if (consp bufnums)
        (setf msg (nconc msg bufnums))
        (setf msg (nconc msg (list bufnums))))
    (send-msg msg io)))

(defobject buffer-get (sc-cmd)
 ((bufnum :initform nil) (samples :initform nil))
 (:parameters bufnum samples) (:event-streams))

(defmethod write-event ((obj buffer-get) (io sc-stream) time)
  time
  (let ((samples (slot-value obj 'samples))
        (msg (list "/b_get" (slot-value obj 'bufnum))))
    (if (consp samples)
        (setf msg (nconc msg (list samples)))
        (setf msg (nconc msg (list samples))))
    (send-msg msg io)))

(defobject buffer-getn (sc-cmd)
 ((bufnum :initform nil) (samples :initform nil)
  (num-samples :initform nil))
 (:parameters bufnum samples num-samples) (:event-streams))

(defmethod write-event ((obj buffer-getn) (io sc-stream) time)
  time
  (let* ((bufnum (slot-value obj 'bufnum))
         (samples (slot-value obj 'samples))
         (samples-len nil)
         (num-samples (slot-value obj 'num-samples))
         (msg (list "/b_getn" bufnum)))
    (if (consp samples)
        (progn (setf samples-len (length samples))
               (do ((i 0 (+ i 1)))
                   ((> i samples-len))
                 (setf msg
                       (nconc msg
                              (list
                               (elt samples i)
                               (elt num-samples i))))))
        (setf msg (nconc msg (list samples num-samples))))
    (send-msg msg io)))

(defmethod write-event ((obj buffer-gen) (io sc-stream) time)
  time
  (let ((msg
         (buffer-gen (slot-value obj 'bufnum)
          (slot-value obj 'command) (slot-value obj 'flags)
          (slot-value obj 'args))))
    (send-msg msg io)))

(defmethod write-event ((obj control-set) (io sc-stream) time)
  time
  (let ((msg
         (control-set (slot-value obj 'bus)
          (slot-value obj 'value))))
    (send-msg msg io)))

(defmethod write-event ((obj control-setn) (io sc-stream) time)
  time
  (let ((msg
         (control-setn (slot-value obj 'bus)
          (slot-value obj 'value))))
    (send-msg msg io)))

(defmethod write-event ((obj control-fill) (io sc-stream) time)
  time
  (let ((msg
         (control-fill (slot-value obj 'bus)
          (slot-value obj 'num-buses) (slot-value obj 'value))))
    (send-msg msg io)))

(defobject control-get (sc-cmd) ((bus :initform nil))
 (:parameters bus) (:event-streams))

(defmethod write-event ((obj control-get) (io sc-stream) time)
  time
  (let ((controls (slot-value obj 'bus)) (msg (list "/c_get")))
    (if (consp controls)
        (setf msg (nconc msg controls))
        (setf msg (nconc msg (list controls))))
    (send-msg msg io)))

(defobject control-getn (sc-cmd)
 ((bus :initform nil) (num-buses :initform nil))
 (:parameters bus num-buses) (:event-streams))

(defmethod write-event ((obj control-getn) (io sc-stream) time)
  time
  (let* ((buses (slot-value obj 'bus))
         (buses-len (length buses))
         (num-buses (slot-value obj 'num-buses))
         (msg (list "/c_getn")))
    (if (consp buses)
        (do ((i 0 (+ i 1)))
            ((> i buses-len))
          (setf msg
                (nconc msg (list (elt buses i) (elt num-buses i)))))
        (setf msg (nconc msg (list buses num-buses))))
    (send-msg msg io)))

(defmethod write-event ((obj sc-buffer) (io sc-stream) time)
  (cond ((slot-value obj 'with-file)
         (write-event
          (make-instance
            <buffer-alloc-read>
            :bufnum
            (slot-value obj 'bufnum)
            :file
            (slot-value obj 'with-file)
            :frames
            (slot-value obj 'frames)
            :start-frame
            (slot-value obj 'starting-at))
          io time))
        ((listp (slot-value obj 'with-values))
         (write-event
          (make-instance
            <buffer-alloc>
            :bufnum
            (slot-value obj 'bufnum)
            :frames
            (slot-value obj 'frames)
            :channels
            1)
          io time)
         (write-event
          (make-instance
            <buffer-setn>
            :bufnum
            (slot-value obj 'bufnum)
            :samples-values
            (list (slot-value obj 'starting-at)
                  (slot-value obj 'with-values)))
          io time))
        ((numberp (slot-value obj 'with-values))
         (write-event
          (make-instance
            <buffer-alloc>
            :bufnum
            (slot-value obj 'bufnum)
            :frames
            (slot-value obj 'frames)
            :channels
            1)
          io time)
         (write-event
          (make-instance
            <buffer-fill>
            :bufnum
            (slot-value obj 'bufnum)
            :num-samples
            (- (slot-value obj 'frames)
               (slot-value obj 'starting-at))
            :value
            (slot-value obj 'with-values))
          io time))
        ((functionp (slot-value obj 'with-values))
         (let ((vals '()))
           (dotimes (i
                     (- (slot-value obj 'frames)
                        (slot-value obj 'starting-at)))
             (setf vals
                   (nconc vals
                          (list (apply
                                 (slot-value obj 'with-values)
                                 '())))))
           (write-event
            (make-instance
              <buffer-alloc>
              :bufnum
              (slot-value obj 'bufnum)
              :frames
              (slot-value obj 'frames)
              :channels
              1)
            io time)
           (write-event
            (make-instance
              <buffer-setn>
              :bufnum
              (slot-value obj 'bufnum)
              :samples-values
              (list (slot-value obj 'starting-at) vals))
            io time)))
        ((slot-value obj 'with-gen)
         (write-event
          (make-instance
            <buffer-alloc>
            :bufnum
            (slot-value obj 'bufnum)
            :frames
            (slot-value obj 'frames)
            :channels
            1)
          io time)
         (write-event
          (make-instance
            <buffer-gen>
            :bufnum
            (slot-value obj 'bufnum)
            :flags
            :wavetable
            :command
            (car (slot-value obj 'with-gen))
            :args
            (car (cdr (slot-value obj 'with-gen))))
          io time))))

(defun sc-quit (&optional out)
  (let ((msg '("/quit")))
    (if out (send-msg msg out) (if *out* (send-msg msg *out*)))))

(defun sc-dumposc (bool &optional out)
  (let ((msg (list "/dumpOSC" (if bool 1 0))))
    (if out (send-msg msg out) (if *out* (send-msg msg *out*)))))

(defun sc-status (&optional out)
  (let ((msg (list "/status")))
    (if out (send-msg msg out) (if *out* (send-msg msg *out*)))))

(defun sc-clearsched (&optional out)
  (let ((msg '("/clearSched")))
    (if out (send-msg msg out) (if *out* (send-msg msg *out*)))))

(defun sc-open (&rest args)
  (setf *out* (apply #'open-io "sc.udp" t args)))

(defun sc-open? ()
  (let ((sc (find-object "sc.udp"))) (and sc (io-open sc) sc)))

(defun sc-close ()
  (if (sc-open?)
      (progn (sc-clearsched) (close-io (find-object "sc.udp")))
      nil))

(defun sc-flush (&optional out)
  (if out
      (progn 
	(write-event (make-instance <group-free-all> :group 1)
		     out 0)
	(sc-clearsched out))
      (progn 
	(write-event (make-instance <group-free-all> :group 1)
		     (sc-open?) 0)
	(sc-clearsched (sc-open?)))))

(defun sc-notify (bool &optional out)
  (let ((msg (list "/notify" (if bool 1 0))))
    (if out (send-msg msg out) (if *out* (send-msg msg *out*)))))

(defmethod reply-set-slots ((obj t) lst) lst obj nil)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (progn (defclass sc-reply () nil)
         (defparameter <sc-reply> (find-class 'sc-reply))
         (finalize-class <sc-reply>)
         (values)))

(defparameter *reply-objects* (quote
                               (/done
                                done-reply
                                /fail
                                fail-reply
                                /status.reply
                                status-reply
                                status.reply
                                status-reply
                                /synced
                                synced-reply
                                /s_set
                                synth-get-reply
                                /s_setn
                                synth-getn-reply
                                /b_set
                                buffer-get-reply
                                /b_setn
                                buffer-getn-reply
                                /b_info
                                buffer-info-reply
                                /c_set
                                control-get-reply
                                /c_setn
                                control-getn-reply
                                /n_go
                                node-go-reply
                                /n_end
                                node-end-reply
                                /n_off
                                node-off-reply
                                /n_on
                                node-on-reply
                                /n_move
                                node-move-reply
                                /n_info
                                node-info-reply
                                /tr
                                trigger-reply)))

(progn (defclass done-reply (sc-reply)
         ((cmd-name :initform nil :accessor done-cmd-name)))
       (defparameter <done-reply> (find-class 'done-reply))
       (finalize-class <done-reply>)
       (values))

(defmethod reply-set-slots ((obj done-reply) lst)
  (setf (slot-value obj 'cmd-name) (pop lst)))

(progn (defclass fail-reply (sc-reply)
         ((cmd-name :initform nil :accessor fail-cmd-name)
          (error :initform nil :accessor fail-error)))
       (defparameter <fail-reply> (find-class 'fail-reply))
       (finalize-class <fail-reply>)
       (values))

(defmethod reply-set-slots ((obj fail-reply) lst)
  (setf (slot-value obj 'cmd-name) (pop lst))
  (setf (slot-value obj 'error) (pop lst)))

(progn (defclass status-reply (sc-reply)
         ((num-ugens :initform nil :accessor status-num-ugens)
          (num-synths :initform nil :accessor status-num-synths)
          (num-groups :initform nil :accessor status-num-groups)
          (num-loaded-synths :initform nil :accessor
           status-num-loaded-synths)
          (avg-cpu :initform nil :accessor status-avg-cpu)
          (peak-cpu :initform nil :accessor status-peak-cpu)
          (sample-rate :initform nil :accessor status-sample-reate)
          (actual-sample-rate :initform nil :accessor
           status-actual-sample-rate)))
       (defparameter <status-reply> (find-class 'status-reply))
       (finalize-class <status-reply>)
       (values))

(defmethod reply-set-slots ((obj status-reply) lst)
  (pop lst)
  (setf (slot-value obj 'num-ugens) (pop lst))
  (setf (slot-value obj 'num-synths) (pop lst))
  (setf (slot-value obj 'num-groups) (pop lst))
  (setf (slot-value obj 'num-loaded-synths) (pop lst))
  (setf (slot-value obj 'avg-cpu) (pop lst))
  (setf (slot-value obj 'peak-cpu) (pop lst))
  (setf (slot-value obj 'sample-rate) (pop lst))
  (setf (slot-value obj 'actual-sample-rate) (pop lst)))

(progn (defclass synced-reply (sc-reply)
         ((id :initform nil :accessor synced-id)))
       (defparameter <synced-reply> (find-class 'synced-reply))
       (finalize-class <synced-reply>)
       (values))

(defmethod reply-set-slots ((obj synced-reply) lst)
  (setf (slot-value obj 'id) (pop lst)))

(progn (defclass synth-get-reply (sc-reply)
         ((node :initform nil :accessor synth-get-node)
          (controls-values :initform nil :accessor
           synth-get-controls-values)))
       (defparameter <synth-get-reply> (find-class 'synth-get-reply))
       (finalize-class <synth-get-reply>)
       (values))

(defmethod reply-set-slots ((obj synth-get-reply) lst)
  (let ((cv (list)))
    (setf (slot-value obj 'node) (pop lst))
    (dolist (i lst)
      (cond ((stringp i)
             (setf cv (nconc cv (list (string->keyword i)))))
            ((and i (symbolp i))
             (setf cv (nconc cv (list (symbol->keyword i)))))
            (t (setf cv (nconc cv (list i))))))
    (setf (slot-value obj 'controls-values) cv)))

(progn (defclass synth-getn-reply (sc-reply)
         ((node :initform nil :accessor synth-getn-node)
          (controls-values :initform nil :accessor
           synth-getn-controls-values)))
       (defparameter <synth-getn-reply> (find-class
                                         'synth-getn-reply))
       (finalize-class <synth-getn-reply>)
       (values))

(defmethod reply-set-slots ((obj synth-getn-reply) lst)
  (let ((cv (list)))
    (setf (slot-value obj 'node) (pop lst))
    (do ((c nil) (n 0) (v nil))
        ((not (consp lst)))
      (setf v (list))
      (setf c (pop lst))
      (cond ((stringp c)
             (setf cv (nconc cv (list (string->keyword c)))))
            ((and c (symbolp c))
             (setf cv (nconc cv (list (symbol->keyword c)))))
            (t (setf cv (nconc cv (list c)))))
      (setf n (pop lst))
      (dotimes (j n) (setf v (nconc v (list (pop lst)))))
      (setf cv (nconc cv (list v))))
    (setf (slot-value obj 'controls-values) cv)))

(progn (defclass buffer-get-reply (sc-reply)
         ((bufnum :initform nil :accessor buffer-get-bufnum)
          (samples-values :initform nil :accessor
           buffer-get-samples-values)))
       (defparameter <buffer-get-reply> (find-class
                                         'buffer-get-reply))
       (finalize-class <buffer-get-reply>)
       (values))

(defmethod reply-set-slots ((obj buffer-get-reply) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'samples-values) lst))

(progn (defclass buffer-getn-reply (sc-reply)
         ((bufnum :initform '() :accessor buffer-getn-bufnum)
          (samples-values :initform '() :accessor
           buffer-getn-samples-values)))
       (defparameter <buffer-getn-reply> (find-class
                                          'buffer-getn-reply))
       (finalize-class <buffer-getn-reply>)
       (values))

(defmethod reply-set-slots ((obj buffer-getn-reply) lst)
  (let ((cv (list)))
    (setf (slot-value obj 'bufnum) (pop lst))
    (do ((n 0) (v nil))
        ((not (consp lst)))
      (setf v (list))
      (setf cv (nconc cv (list (pop lst))))
      (setf n (pop lst))
      (dotimes (j n) (setf v (nconc v (list (pop lst)))))
      (setf cv (append cv (list v))))
    (setf (slot-value obj 'samples-values) cv)))

(progn (defclass buffer-query-reply (sc-reply)
         ((bufnum :initform '() :accessor buffer-query-bufnum)
          (num-frames :initform '() :accessor
           buffer-query-num-frames)
          (num-chans :initform '() :accessor buffer-query-num-chanes)
          (sample-rate :initform '() :accessor
           buffer-query-sample-rate)))
       (defparameter <buffer-query-reply> (find-class
                                           'buffer-query-reply))
       (finalize-class <buffer-query-reply>)
       (values))

(defmethod reply-set-slots ((obj buffer-query-reply) lst)
  (let ((len (length lst)))
    (if (= len 4)
        (progn (setf (slot-value obj 'bufnum) (pop lst))
               (setf (slot-value obj 'num-frames) (pop lst))
               (setf (slot-value obj 'num-chans) (pop lst))
               (setf (slot-value obj 'sample-rate) (pop lst)))
        (do ()
            ((not (consp lst)))
          (setf (slot-value obj 'bufnum)
                (nconc (slot-value obj 'bufnum) (list (pop lst))))
          (setf (slot-value obj 'num-frames)
                (nconc (slot-value obj 'num-frames)
                       (list (pop lst))))
          (setf (slot-value obj 'num-chans)
                (nconc (slot-value obj 'num-chans) (list (pop lst))))
          (setf (slot-value obj 'sample-rate)
                (nconc (slot-value obj 'sample-rate)
                       (list (pop lst))))))))

(progn (defclass control-get-reply (sc-reply)
         ((bus :initform '() :accessor control-get-bus)
          (value :initform '() :accessor control-get-value)))
       (defparameter <control-get-reply> (find-class
                                          'control-get-reply))
       (finalize-class <control-get-reply>)
       (values))

(defmethod reply-set-slots ((obj control-get-reply) lst)
  (if (= (length lst) 2)
      (progn (setf (slot-value obj 'bus) (pop lst))
             (setf (slot-value obj 'value) (pop lst)))
      (do ()
          ((not (consp lst)))
        (setf (slot-value obj 'bus)
              (nconc (slot-value obj 'bus) (list (pop lst))))
        (setf (slot-value obj 'value)
              (nconc (slot-value obj 'value) (list (pop lst)))))))

(progn (defclass control-getn-reply (sc-reply)
         ((bus :initform '() :accessor control-getn-reply)
          (value :initform '() :accessor control-getn-value)))
       (defparameter <control-getn-reply> (find-class
                                           'control-getn-reply))
       (finalize-class <control-getn-reply>)
       (values))

(defmethod reply-set-slots ((obj control-getn-reply) lst)
  (let ((b nil) (n nil) (v (list)))
    (setf b (pop lst))
    (setf n (pop lst))
    (dotimes (i n) (setf v (nconc v (list (pop lst)))))
    (if (> (length lst) n)
        (progn (setf (slot-value obj 'bus)
                     (nconc (slot-value obj 'bus) (list b)))
               (setf (slot-value obj 'value)
                     (nconc (slot-value obj 'value) (list v)))
               (do ()
                   ((not (consp lst)))
                 (setf (slot-value obj 'bus)
                       (nconc (slot-value obj 'bus) (pop lst)))
                 (setf v (list))
                 (setf n (pop lst))
                 (dotimes (i n) (setf v (nconc v (list (pop lst)))))
                 (setf (slot-value obj 'value)
                       (nconc (slot-value obj 'value) (list v)))))
        (progn (setf (slot-value obj 'bus) b)
               (setf (slot-value obj 'value) v)))))

(progn (defclass node-go-reply (sc-reply)
         ((node :initform nil :accessor node-go-node)
          (parent-group :initform nil :accessor node-go-parent-node)
          (previous-node :initform nil :accessor
           node-go-previous-node)
          (next-node :initform nil :accessor node-go-next-node)
          (type :initform nil :accessor node-go-type)
          (head-node :initform nil :accessor node-go-head-node)
          (tail-node :initform nil :accessor node-go-tail-node)))
       (defparameter <node-go-reply> (find-class 'node-go-reply))
       (finalize-class <node-go-reply>)
       (values))

(defmethod reply-set-slots ((obj node-go-reply) lst)
  (let ((n nil))
    (setf (slot-value obj 'node) (pop lst))
    (setf (slot-value obj 'parent-group) (pop lst))
    (setf (slot-value obj 'previous-node) (pop lst))
    (setf (slot-value obj 'next-node) (pop lst))
    (setf n (pop lst))
    (setf (slot-value obj 'type) (if (= n 1) 'group 'synth))
    (if (= n 1)
        (progn (setf (slot-value obj 'head-node) (pop lst))
               (setf (slot-value obj 'tail-node) (pop lst))))))

(progn (defclass node-end-reply (sc-reply)
         ((node :initform nil :accessor node-end-node)
          (parent-group :initform nil :accessor
           node-end-parent-group)
          (previous-node :initform nil :accessor
           node-end-previous-node)
          (next-node :initform nil :accessor node-end-next-node)
          (type :initform nil :accessor node-end-type)
          (head-node :initform nil :accessor node-end-head-node)
          (tail-node :initform nil :accessor node-end-tail-node)))
       (defparameter <node-end-reply> (find-class 'node-end-reply))
       (finalize-class <node-end-reply>)
       (values))

(defmethod reply-set-slots ((obj node-end-reply) lst)
  (let ((n nil))
    (setf (slot-value obj 'node) (pop lst))
    (setf (slot-value obj 'parent-group) (pop lst))
    (setf (slot-value obj 'previous-node) (pop lst))
    (setf (slot-value obj 'next-node) (pop lst))
    (setf n (pop lst))
    (setf (slot-value obj 'type) (if (= n 1) 'group 'synth))
    (if (= n 1)
        (progn (setf (slot-value obj 'head-node) (pop lst))
               (setf (slot-value obj 'tail-node) (pop lst))))))

(progn (defclass node-off-reply (sc-reply)
         ((node :initform nil :accessor node-off-node)
          (parent-group :initform nil :accessor
           node-off-parent-group)
          (previous-node :initform nil :accessor
           node-off-previous-node)
          (next-node :initform nil :accessor node-off-next-node)
          (type :initform nil :accessor node-off-type)
          (head-node :initform nil :accessor node-off-head-node)
          (tail-node :initform nil :accessor node-off-tail-node)))
       (defparameter <node-off-reply> (find-class 'node-off-reply))
       (finalize-class <node-off-reply>)
       (values))

(defmethod reply-set-slots ((obj node-off-reply) lst)
  (let ((n nil))
    (setf (slot-value obj 'node) (pop lst))
    (setf (slot-value obj 'parent-group) (pop lst))
    (setf (slot-value obj 'previous-node) (pop lst))
    (setf (slot-value obj 'next-node) (pop lst))
    (setf n (pop lst))
    (setf (slot-value obj 'type) (if (= n 1) 'group 'synth))
    (if (= n 1)
        (progn (setf (slot-value obj 'head-node) (pop lst))
               (setf (slot-value obj 'tail-node) (pop lst))))))

(progn (defclass node-on-reply (sc-reply)
         ((node :initform nil :accessor node-on-node)
          (parent-group :initform nil :accessor node-on-parent-group)
          (previous-node :initform nil :accessor
           node-on-previous-node)
          (next-node :initform nil :accessor node-on-next-node)
          (type :initform nil :accessor node-on-type)
          (head-node :initform nil :accessor node-on-head-node)
          (tail-node :initform nil :accessor node-on-tail-node)))
       (defparameter <node-on-reply> (find-class 'node-on-reply))
       (finalize-class <node-on-reply>)
       (values))

(defmethod reply-set-slots ((obj node-on-reply) lst)
  (let ((n nil))
    (setf (slot-value obj 'node) (pop lst))
    (setf (slot-value obj 'parent-group) (pop lst))
    (setf (slot-value obj 'previous-node) (pop lst))
    (setf (slot-value obj 'next-node) (pop lst))
    (setf n (pop lst))
    (setf (slot-value obj 'type) (if (= n 1) 'group 'synth))
    (if (= n 1)
        (progn (setf (slot-value obj 'head-node) (pop lst))
               (setf (slot-value obj 'tail-node) (pop lst))))))

(progn (defclass node-move-reply (sc-reply)
         ((node :initform nil :accessor node-move-node)
          (parent-group :initform nil :accessor
           node-move-parent-group)
          (previous-node :initform nil :accessor
           node-move-previous-node)
          (next-node :initform nil :accessor node-move-next-node)
          (type :initform nil :accessor node-move-type)
          (head-node :initform nil :accessor node-head-node)
          (tail-node :initform nil :accessor node-tail-node)))
       (defparameter <node-move-reply> (find-class 'node-move-reply))
       (finalize-class <node-move-reply>)
       (values))

(defmethod reply-set-slots ((obj node-move-reply) lst)
  (let ((n nil))
    (setf (slot-value obj 'node) (pop lst))
    (setf (slot-value obj 'parent-group) (pop lst))
    (setf (slot-value obj 'previous-node) (pop lst))
    (setf (slot-value obj 'next-node) (pop lst))
    (setf n (pop lst))
    (setf (slot-value obj 'type) (if (= n 1) 'group 'synth))
    (if (= n 1)
        (progn (setf (slot-value obj 'head-node) (pop lst))
               (setf (slot-value obj 'tail-node) (pop lst))))))

(progn (defclass node-info-reply (sc-reply)
         ((node :initform nil :accessor node-info-node)
          (parent-group :initform nil :accessor
           node-info-parent-group)
          (previous-node :initform nil :accessor
           node-info-previous-node)
          (next-node :initform nil :accessor node-info-next-node)
          (type :initform nil :accessor node-info-type)
          (head-node :initform nil :accessor node-info-head-node)
          (tail-node :initform nil :accessor node-info-tail-node)))
       (defparameter <node-info-reply> (find-class 'node-info-reply))
       (finalize-class <node-info-reply>)
       (values))

(defmethod reply-set-slots ((obj node-info-reply) lst)
  (let ((n nil))
    (setf (slot-value obj 'node) (pop lst))
    (setf (slot-value obj 'parent-group) (pop lst))
    (setf (slot-value obj 'previous-node) (pop lst))
    (setf (slot-value obj 'next-node) (pop lst))
    (setf n (pop lst))
    (setf (slot-value obj 'type) (if (= n 1) 'group 'synth))
    (if (= n 1)
        (progn (setf (slot-value obj 'head-node) (pop lst))
               (setf (slot-value obj 'tail-node) (pop lst))))))

(progn (defclass trigger-reply (sc-reply)
         ((node :initform nil :accessor trigger-node)
          (id :initform nil :accessor trigger-id)
          (value :initform nil :accessor trigger-value)))
       (defparameter <trigger-reply> (find-class 'trigger-reply))
       (finalize-class <trigger-reply>)
       (values))

(defmethod reply-set-slots ((obj trigger-reply) lst)
  (setf (slot-value obj 'node) (pop lst))
  (setf (slot-value obj 'id) (pop lst))
  (setf (slot-value obj 'value) (pop lst)))

(defmethod set-receive-mode! ((str sc-stream) mode)
  (unless (member mode '(:message :raw :object))
    (error "receive: ~s is not a osc receive mode." mode))
  (setf (slot-value str 'receive-mode) mode))

(defun osc-message->sc-object (lst)
  (let* ((obj? (getf *reply-objects* (pop (car lst))))
	 (obj (if obj? (make obj?) nil)))
    (if obj
	(reply-set-slots obj (car lst)))
    obj))