@menu
* Introduction to Command Line::
* Functions and Variables for Command Line::
@end menu

@node Introduction to Command Line, Functions and Variables for Command Line, Command Line, Command Line
@section Introduction to Command Line

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn {Operator} '
@ifinfo
@fnindex Quote operator
@end ifinfo
The single quote operator @code{'} prevents evaluation.

Applied to a symbol,
the single quote prevents evaluation of the symbol.

Applied to a function call,
the single quote prevents evaluation of the function call,
although the arguments of the function are still evaluated (if evaluation is not otherwise prevented).
The result is the noun form of the function call.

Applied to a parenthesized expression,
the single quote prevents evaluation of all symbols and function calls in the expression.
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
E.g., @code{'(f(x))} means do not evaluate the expression @code{f(x)}.
@code{'f(x)} (with the single quote applied to @code{f} instead of @code{f(x)})
means return the noun form of @code{f} applied to @code{[x]}.

The single quote does not prevent simplification.

When the global flag @code{noundisp} is @code{true},
nouns display with a single quote.
This switch is always @code{true} when displaying function definitions.

See also the quote-quote operator @code{''} and @code{nouns}.

Examples:

Applied to a symbol,
the single quote prevents evaluation of the symbol.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Applied to a function call,
the single quote prevents evaluation of the function call.
The result is the noun form of the function call.

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Applied to a parenthesized expression,
the single quote prevents evaluation of all symbols and function calls in the 
expression.

@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

The single quote does not prevent simplification.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

Maxima considers floating point operations by its in-built mathematical 
functions to be a simplification.

@c ===beg===
@c sin(1.0);
@c '(sin(1.0));
@c ===end===
@example
(%i1) sin(1.0);
(%o1)                          .8414709848078965
(%i2) '(sin(1.0));
(%o2)                          .8414709848078965
@end example

@opencatbox
@category{Evaluation} @category{Operators}
@closecatbox

@end deffn

@deffn {Operator} ''
@ifinfo
@fnindex Quote-quote operator
@end ifinfo
The quote-quote operator @code{'@w{}'} (two single quote marks) modifies evaluation in input expressions.

Applied to a general expression @var{expr}, quote-quote causes the value of @var{expr}
to be substituted for @var{expr} in the input expression.

Applied to the operator of an expression,
quote-quote changes the operator from a noun to a verb (if it is not already a verb).

The quote-quote operator is applied by the input parser;
it is not stored as part of a parsed input expression.
The quote-quote operator is always applied as soon as it is parsed,
and cannot be quoted.
Thus quote-quote causes evaluation when evaluation is otherwise suppressed,
such as in function definitions, lambda expressions, and expressions quoted by single quote @code{'}.

Quote-quote is recognized by @code{batch} and @code{load}.

See also the single-quote operator @code{'} and @code{nouns}.

Examples:

Applied to a general expression @var{expr}, quote-quote causes the value of @var{expr}
to be substituted for @var{expr} in the input expression.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Applied to the operator of an expression,
quote-quote changes the operator from a noun to a verb (if it is not already a 
verb).

@c ===beg==
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end==
@example
(%i1) declare (foo, noun);
(%o1)                         done
(%i2) foo (x) := x - 1729;
(%o2)                 ''foo(x) := x - 1729
(%i3) foo (100);
(%o3)                       foo(100)
(%i4) ''foo (100);
(%o4)                        - 1629
@end example

The quote-quote operator is applied by the input parser;
it is not stored as part of a parsed input expression.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

Quote-quote causes evaluation when evaluation is otherwise suppressed,
such as in function definitions, lambda expressions, and expressions quoted by single quote @code{'}.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@opencatbox
@category{Evaluation} @category{Operators}
@closecatbox

@end deffn

@c end concepts Command Line
@node Functions and Variables for Command Line,  , Introduction to Command Line, Command Line
@section Functions and Variables for Command Line

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Function} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
provides an
alternate name for a (user or system) function, variable, array, etc.
Any even number of arguments may be used.

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@defvr {Option variable} debugmode
Default value: @code{false}

When a Maxima error occurs, Maxima will start the debugger if @code{debugmode} is @code{true}.
The user may enter commands to examine the call stack, set breakpoints, step
through Maxima code, and so on. See @code{debugging} for a list of debugger commands.

Enabling @code{debugmode} will not catch Lisp errors.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@opencatbox
@category{Debugging} @category{Global flags}
@closecatbox

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Function} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Evaluates the expression @var{expr} in the environment
specified by the arguments @var{arg_1}, ..., @var{arg_n}.
The arguments are switches (Boolean flags), assignments, equations, and functions.
@code{ev} returns the result (another expression) of the evaluation.

The evaluation is carried out in steps, as follows.

@enumerate
@item
First the environment is set up by scanning the arguments which may
be any or all of the following.

@itemize @bullet
@item
@code{simp} causes @var{expr} to be simplified regardless of the setting of the
switch @code{simp} which inhibits simplification if @code{false}.
@item
@code{noeval} supresses the evaluation phase of @code{ev} (see step (4) below).
This is useful in conjunction with the other switches and in causing
@var{expr} to be resimplified without being reevaluated.
@item
@code{nouns} causes the evaluation of noun forms
(typically unevaluated functions such as @code{'integrate} or @code{'diff})
in @var{expr}.
@item
@code{expand} causes expansion.
@item
@code{expand (@var{m}, @var{n})} causes expansion, setting the values of @code{maxposex} and
@code{maxnegex} to @var{m} and @var{n} respectively.
@item
@code{detout} causes any matrix inverses computed in @var{expr} to have their
determinant kept outside of the inverse rather than dividing through
each element.
@item
@code{diff} causes all differentiations indicated in @var{expr} to be performed.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} causes only differentiations with respect to
the indicated variables.
@item
@code{risch} causes integrals in @var{expr} to be evaluated using the Risch
algorithm. See @code{risch}. The standard integration routine is invoked when
using the special symbol @code{nouns}.
@item
@code{float} causes non-integral rational numbers to be converted to floating
point.
@item
@code{numer} causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point.  It causes
variables in @var{expr} which have been given numervals to be replaced by
their values.  It also sets the @code{float} switch on.
@item
@code{pred} causes predicates (expressions which evaluate to @code{true} or @code{false})
to be evaluated.
@item
@code{eval} causes an extra post-evaluation of @var{expr} to occur. (See step (5)
below.)
@code{eval} may occur multiple times.
For each instance of @code{eval}, the expression is evaluated again.
@item
@code{A} where @code{A} is an atom declared to be an evaluation flag (see @code{evflag})
causes @code{A} to be bound to
@code{true} during the evaluation of @var{expr}.
@item
@code{V: expression} (or alternately @code{V=expression}) causes @code{V} to be bound to the
value of @code{expression} during the evaluation of @var{expr}.  Note that if @code{V} is a
Maxima option, then @code{expression} is used for its value during the
evaluation of @var{expr}.  If more than one argument to @code{ev} is of this type
then the binding is done in parallel.  If @code{V} is a non-atomic expression
then a substitution rather than a binding is performed.
@item
@code{F} where @code{F}, a function name, has been declared to be an evaluation function (see @code{evfun})
causes @code{F}
to be applied to @var{expr}.
@item
Any other function names (e.g., @code{sum}) cause evaluation of occurrences
of those names in @var{expr} as though they were verbs.
@item
In addition a function occurring in @var{expr} (say @code{F(x)}) may be defined
locally for the purpose of this evaluation of @var{expr} by giving
@code{F(x) := expression} as an argument to @code{ev}.
@item
If an atom not mentioned above or a subscripted variable or
subscripted expression was given as an argument, it is evaluated and
if the result is an equation or assignment then the indicated binding
or substitution is performed.  If the result is a list then the
members of the list are treated as if they were additional arguments
given to @code{ev}. This permits a list of equations to be given (e.g. @code{[X=1, Y=A**2]})
or a list of names of equations (e.g., @code{[%t1, %t2]} where @code{%t1} and
@code{%t2} are equations) such as that returned by @code{solve}.
@end itemize

The arguments of @code{ev} may be given in any order with the exception of
substitution equations which are handled in sequence, left to right,
and evaluation functions which are composed, e.g., @code{ev (@var{expr}, ratsimp, realpart)} is
handled as @code{realpart (ratsimp (@var{expr}))}.

The @code{simp}, @code{numer}, and @code{float} switches may also be set locally
in a block, or globally in Maxima so that they will remain in effect until being
reset.

If @var{expr} is a canonical rational expression (CRE),
then the expression returned by @code{ev} is also a CRE,
provided the @code{numer} and @code{float} switches are not both @code{true}.

@item
During step (1), a list is made of the non-subscripted
variables appearing on the left side of equations in the arguments or in
the value of some arguments if the value is an equation.  The variables
(subscripted variables which do not have associated array
functions as well as non-subscripted variables) in the expression @var{expr} are
replaced by their global values, except for those appearing in this
list.  Usually, @var{expr} is just a label or @code{%}
(as in @code{%i2} in the example below), so this
step simply retrieves the expression named by the label, so that @code{ev}
may work on it.

@item
If any substitutions are indicated by the arguments, they are
carried out now.

@item
The resulting expression is then re-evaluated (unless one of
the arguments was @code{noeval}) and simplified according to the arguments.  Note that
any function calls in @var{expr} will be carried out after the variables in
it are evaluated and that @code{ev(F(x))} thus may behave like @code{F(ev(x))}.

@item
For each instance of @code{eval} in the arguments, steps (3) and (4) are repeated.
@end enumerate

Examples:

@c ===beg===
@c sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
@c ev (%, numer, expand, diff, x=2, y=1);
@c ===end===
@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, numer, expand, diff, x=2, y=1);
                               2
(%o2)                cos(w) + w  + 2 w + 2.449599732693821
@end example

An alternate top level syntax has been provided for @code{ev}, whereby one
may just type in its arguments, without the @code{ev()}.  That is, one may
write simply

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

This is not permitted as part of
another expression, e.g., in functions, blocks, etc.

Notice the parallel binding process in the following example.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@opencatbox
@category{Evaluation}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Special symbol} eval
As an argument in a call to @code{ev (@var{expr})}, @code{eval} causes an extra
evaluation of @var{expr}. See @code{ev}.

Example:

@c ===beg===
@c [a:b,b:c,c:d,d:e];
@c a;
@c ev(a);
@c ev(a),eval;
@c a,eval,eval;
@c ===end===
@example
(%i1) [a:b,b:c,c:d,d:e];
(%o1)                            [b, c, d, e]
(%i2) a;
(%o2)                                  b
(%i3) ev(a);
(%o3)                                  c
(%i4) ev(a),eval;
(%o4)                                  e
(%i5) a,eval,eval;
(%o5)                                  e
@end example

@opencatbox
@category{Evaluation flags}
@closecatbox
@end defvr

@defvr {Property} evflag
When a symbol @var{x} has the @code{evflag} property,
the expressions @code{ev(@var{expr}, @var{x})} and @code{@var{expr}, @var{x}}
(at the interactive prompt) are equivalent to @code{ev(@var{expr}, @var{x} = true)}.
That is, @var{x} is bound to @code{true} while @var{expr} is evaluated.

The expression @code{declare(@var{x}, evflag)}
gives the @code{evflag} property to the variable @var{x}.

The flags which have the @code{evflag} property by default are the following:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@c added 10/2009 (DK)
@code{simpproduct},
@code{simpsum},
@code{sumexpand}, and
@code{trigexpand}.

Examples:

@c ===beg===
@c sin (1/2);
@c sin (1/2), float;
@c sin (1/2), float=true;
@c simp : false;
@c 1 + 1;
@c 1 + 1, simp;
@c simp : true;
@c sum (1/k^2, k, 1, inf);
@c sum (1/k^2, k, 1, inf), simpsum;
@c declare (aa, evflag);
@c if aa = true then YES else NO;
@c if aa = true then YES else NO, aa;
@c ===end===
@example
(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        >    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then YES else NO;
(%o11)                         NO
(%i12) if aa = true then YES else NO, aa;
(%o12)                         YES
@end example

@opencatbox
@category{Evaluation flags} @category{Simplification flags and variables}
@closecatbox

@end defvr

@defvr {Property} evfun
When a function @var{F} has the @code{evfun} property,
the expressions @code{ev(@var{expr}, @var{F})} and @code{@var{expr}, @var{F}}
(at the interactive prompt)
are equivalent to @code{@var{F}(ev(@var{expr}))}.

If two or more @code{evfun} functions @var{F}, @var{G}, etc., are specified,
the functions are applied in the order that they are specified.

The expression @code{declare(@var{F}, evfun)}
gives the @code{evfun} property to the function @var{F}.

The functions which have the @code{evfun} property by default are the following:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, and
@code{trigreduce}.

Examples:

@c ===beg===
@c x^3 - 1;
@c x^3 - 1, factor;
@c factor (x^3 - 1);
@c cos(4 * x) / sin(x)^4;
@c cos(4 * x) / sin(x)^4, trigexpand;
@c cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
@c ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
@c declare ([F, G], evfun);
@c (aa : bb, bb : cc, cc : dd);
@c aa;
@c aa, F;
@c F (aa);
@c F (ev (aa));
@c aa, F, G;
@c G (F (ev (aa)));
@c ===end===
@example
(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
@end example

@opencatbox
@category{Evaluation flags}
@closecatbox
@end defvr
@c NEEDS WORK
@defvr {Option variable} infeval
Enables "infinite evaluation" mode.  @code{ev} repeatedly
evaluates an expression until it stops changing.  To prevent a
variable, say @code{X}, from being evaluated away in this mode, simply
include @code{X='X} as an argument to @code{ev}.  Of course expressions such as
@code{ev (X, X=X+1, infeval)} will generate an infinite loop.

@opencatbox
@category{Evaluation flags}
@closecatbox
@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Function} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Function} kill (labels)
@deffnx {Function} kill (inlabels, outlabels, linelabels)
@deffnx {Function} kill (@var{n})
@deffnx {Function} kill ([@var{m}, @var{n}])
@deffnx {Function} kill (values, functions, arrays, ...)
@deffnx {Function} kill (all)
@deffnx {Function} kill (allbut (@var{a_1}, ..., @var{a_n}))

Removes all bindings (value, function, array, or rule) from the arguments
@var{a_1}, ..., @var{a_n}.
An argument @var{a_k} may be a symbol or a single array element.
When @var{a_k} is a single array element, @code{kill} unbinds that element
without affecting any other elements of the array.

Several special arguments are recognized.
Different kinds of arguments
may be combined, e.g., @code{kill (inlabels, functions, allbut (foo, bar))}.

@code{kill (labels)} unbinds
all input, output, and intermediate expression labels created so far.
@code{kill (inlabels)} unbinds only input labels
which begin with the current value of @code{inchar}.
Likewise,
@code{kill (outlabels)} unbinds only output labels
which begin with the current value of @code{outchar},
and @code{kill (linelabels)} unbinds only intermediate expression labels
which begin with the current value of @code{linechar}.

@code{kill (@var{n})}, where @var{n} is an integer,
unbinds the @var{n} most recent input and output labels.

@code{kill ([@var{m}, @var{n}])} unbinds input and output labels @var{m} through @var{n}.

@code{kill (@var{infolist})}, where @var{infolist} is any item in @code{infolists}
(such as @code{values}, @code{functions}, or @code{arrays})
unbinds all items in @var{infolist}.
See also @code{infolists}.

@code{kill (all)} unbinds all items on all infolists.
@code{kill (all)} does not reset global variables to their default values;
see @code{reset} on this point.

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
unbinds all items on all infolists except for @var{a_1}, ..., @var{a_n}.
@code{kill (allbut (@var{infolist}))} unbinds all items except for the ones on @var{infolist},
where @var{infolist} is @code{values}, @code{functions}, @code{arrays}, etc.

The memory taken up by a bound property is not released until all symbols
are unbound from it.
In particular, to release the memory taken up by the value of a symbol,
one unbinds the output label which shows the bound value, as well as unbinding the symbol itself.

@code{kill} quotes its arguments.
The quote-quote operator @code{'@w{}'} defeats quotation.

@code{kill (@var{symbol})} unbinds all properties of @var{symbol}.
In contrast, @code{remvalue}, @code{remfunction}, @code{remarray}, and @code{remrule}
unbind a specific property.

@code{kill} always returns @code{done}, even if an argument has no binding.

@opencatbox
@category{Evaluation} @category{Console interaction} @category{Session management}
@closecatbox
@end deffn

@deffn {Function} labels (@var{symbol})
@deffnx {System variable} labels
Returns the list of input, output, or intermediate expression labels which begin with @var{symbol}.
Typically @var{symbol} is the value of @code{inchar}, @code{outchar}, or @code{linechar}.
The label character may be given with or without a percent sign,
so, for example, @code{i} and @code{%i} yield the same result.

If no labels begin with @var{symbol}, @code{labels} returns an empty list.

The function @code{labels} quotes its argument.
The quote-quote operator @code{'@w{}'} defeats quotation.
For example,
@code{labels (''inchar)} returns the input labels which begin with the current input label character.

The variable @code{labels} is the list of input, output, and intermediate expression labels,
including all previous labels if @code{inchar}, @code{outchar}, or @code{linechar} were redefined.

By default, Maxima displays the result of each user input expression,
giving the result an output label.
The output display is suppressed by terminating the input with @code{$} (dollar sign)
instead of @code{;} (semicolon).
An output label is constructed and bound to the result, but not displayed,
and the label may be referenced in the same way as displayed output labels.
See also @code{%}, @code{%%}, and @code{%th}.

Intermediate expression labels can be generated by some functions.
The flag @code{programmode} controls whether @code{solve} and some other functions
generate intermediate expression labels instead of returning a list of expressions.
Some other functions, such as @code{ldisplay}, always generate intermediate expression labels.

See also @code{inchar}, @code{outchar}, @code{linechar}, and @code{infolists}.

@opencatbox
@category{Display functions} @category{Display flags and variables} @category{Console interaction}
@closecatbox

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {System variable} linenum
The line number of the current pair of input and output expressions.

@opencatbox
@category{Display flags and variables} @category{Console interaction}
@closecatbox

@end defvr

@c NEEDS WORK
@defvr {System variable} myoptions
Default value: @code{[]}

@code{myoptions} is the list of all options ever reset by the user,
whether or not they get reset to their default value.

@opencatbox
@category{Global variables} @category{Session management} @category{Console interaction}
@closecatbox

@end defvr

@defvr {Option variable} nolabels
Default value: @code{false}

When @code{nolabels} is @code{true},
input and output result labels
(@code{%i} and @code{%o}, respectively)
are displayed,
but the labels are not bound to results,
and the labels are not appended to the @code{labels} list.
Since labels are not bound to results,
garbage collection can recover the memory taken up by the results.

Otherwise input and output result labels are bound to results,
and the labels are appended to the @code{labels} list.

Intermediate expression labels (@code{%t}) are not affected by @code{nolabels};
whether @code{nolabels} is @code{true} or @code{false},
intermediate expression labels are bound and appended to the @code{labels} list.

See also @code{batch}, @code{load}, and @code{labels}.

@opencatbox
@category{Global flags} @category{Session management}
@closecatbox

@end defvr

@c NEEDS WORK
@defvr {Option variable} optionset
Default value: @code{false}

When @code{optionset} is @code{true}, Maxima prints out a
message whenever a Maxima option is reset.  This is useful if the
user is doubtful of the spelling of some option and wants to make sure
that the variable he assigned a value to was truly an option variable.

@opencatbox
@category{Global flags} @category{Session management} @category{Console interaction}
@closecatbox

@end defvr

@deffn {Function} playback ()
@deffnx {Function} playback (@var{n})
@deffnx {Function} playback ([@var{m}, @var{n}])
@deffnx {Function} playback ([@var{m}])
@deffnx {Function} playback (input)
@deffnx {Function} playback (slow)
@deffnx {Function} playback (time)
@deffnx {Function} playback (grind)
Displays input, output, and intermediate expressions,
without recomputing them.
@code{playback} only displays the expressions bound to labels;
any other output (such as text printed by @code{print} or @code{describe}, or error messages)
is not displayed.
See also @code{labels}.

@code{playback} quotes its arguments.
The quote-quote operator @code{'@w{}'} defeats quotation.
@code{playback} always returns @code{done}.

@code{playback ()} (with no arguments) displays all input, output, and intermediate expressions
generated so far.
An output expression is displayed even if it was suppressed by the @code{$} terminator
when it was originally computed.

@code{playback (@var{n})} displays the most recent @var{n} expressions.
Each input, output, and intermediate expression counts as one.

@code{playback ([@var{m}, @var{n}])} displays input, output, and intermediate expressions
with numbers from @var{m} through @var{n}, inclusive.

@code{playback ([@var{m}])} is equivalent to @code{playback ([@var{m}, @var{m}])};
this usually prints one pair of input and output expressions.

@code{playback (input)} displays all input expressions generated so far.

@code{playback (slow)} pauses between expressions
and waits for the user to press @code{enter}.
This behavior is similar to @code{demo}.
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} is useful in conjunction with @code{save} or @code{stringout}
when creating a secondary-storage file in order to pick out useful expressions.

@code{playback (time)} displays the computation time for each expression.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} displays input expressions
in the same format as the @code{grind} function.
Output expressions are not affected by the @code{grind} option.
See @code{grind}.

Arguments may be combined, e.g.,
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@opencatbox
@category{Display functions} @category{Console interaction}
@closecatbox

@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Function} printprops (@var{a}, @var{i})
@deffnx {Function} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Function} printprops (all, @var{i})
Displays the property with the indicator @var{i}
associated with the atom @var{a}. @var{a} may also be a list of atoms or the atom
@code{all} in which case all of the atoms with the given property will be
used.  For example, @code{printprops ([f, g], atvalue)}.  @code{printprops} is for
properties that cannot otherwise be displayed, i.e. for
@code{atvalue}, @code{atomgrad}, @code{gradef}, and @code{matchdeclare}.

@opencatbox
@category{Declarations and inferences} @category{Display functions}
@closecatbox

@end deffn

@defvr {Option variable} prompt
Default value: @code{_}

@code{prompt} is the prompt symbol of the @code{demo} function,
@code{playback (slow)} mode, and the Maxima break loop (as invoked by @code{break}).

@opencatbox
@category{Global variables} @category{Console interaction}
@closecatbox

@end defvr

@deffn {Function} quit ()
Terminates the Maxima session.
Note that the function must be invoked as @code{quit();} or @code{quit()$},
not @code{quit} by itself.

To stop a lengthy computation,
type @code{control-C}.
The default action is to return to the Maxima prompt.
If @code{*debugger-hook*} is @code{nil},
@code{control-C} opens the Lisp debugger.
See also @code{debugging}.

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@deffn {Function} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Function} remfunction (all)
Unbinds the function definitions of the symbols @var{f_1}, ..., @var{f_n}.
The arguments may be the names of ordinary functions (created by @code{:=} or @code{define})
or macro functions (created by @code{::=}).

@code{remfunction (all)} unbinds all function definitions.

@code{remfunction} quotes its arguments.

@code{remfunction} returns a list of the symbols for which the function definition was unbound.
@code{false} is returned in place of any symbol for which there is no function definition.

@code{remfunction} does not apply to array functions or subscripted functions.
@code{remarray} applies to those types of functions.

@opencatbox
@category{Function definition}
@closecatbox
@end deffn

@deffn {Function} reset ()
Resets many global variables and options, and some other variables, to their default values.

@code{reset} processes the variables on the Lisp list @code{*variable-initial-values*}.
The Lisp macro @code{defmvar} puts variables on this list (among other actions).
Many, but not all, global variables and options are defined by @code{defmvar},
and some variables defined by @code{defmvar} are not global variables or options.

@opencatbox
@category{Session management}
@closecatbox

@end deffn

@defvr {Option variable} showtime
Default value: @code{false}

When @code{showtime} is @code{true}, the computation time and elapsed time is
printed with each output expression.

The computation time is always recorded,
so @code{time} and @code{playback} can display the computation time
even when @code{showtime} is @code{false}.

See also @code{timer}.

@opencatbox
@category{Display flags and variables} @category{Debugging}
@closecatbox

@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} to_lisp ()
Enters the Lisp system under Maxima. @code{(to-maxima)} returns to Maxima.

Example:

Define a function and enter the Lisp system under Maxima. The defintion is 
inspected on the property list, then the function definition is extracted, 
factored and stored in the variable $result. The variable can be used in Maxima 
after returning to Maxima.

@example
(%i1) f(x):=x^2+x;
                                         2
(%o1)                           f(x) := x  + x
(%i2) to_lisp();
Type (to-maxima) to restart, ($quit) to quit Maxima.

MAXIMA> (symbol-plist '$f)
(MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X) ((MPLUS) ((MEXPT) $X 2) $X))))
MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
MAXIMA> (to-maxima)
Returning to Maxima
(%o2)                                true
(%i3) result;
(%o3)                              x (x + 1)
@end example

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {System variable} values
Initial value: @code{[]}

@code{values} is a list of all bound user variables (not Maxima options or
switches). The list comprises symbols bound by @code{:}, or @code{::}.

If the value of a variable is removed with the commands @code{kill}, 
@code{remove}, or @code{remvalue} the variable is deleted from @code{values}.

See @code{functions} for a list of user defined functions.

Examples:

First, @code{values} shows the symbols @code{a}, @code{b}, and @code{c}, but 
not @code{d}, it is not bound to a value, and not the user function @code{f}.
The values are removed from the variables. @code{values} is the empty list.

@c ===beg===
@c [a:99, b:: a-90, c:a-b, d, f(x):=x^2];
@c values;
@c [kill(a), remove(b,value), remvalue(c)];
@c values;
@c ===end===
@example
(%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                  2
(%o1)                     [99, 9, 90, d, f(x) := x ]
(%i2) values;
(%o2)                              [a, b, c]
(%i3) [kill(a), remove(b,value), remvalue(c)];
(%o3)                          [done, done, [c]]
(%i4) values;
(%o4)                                 []
@end example

@opencatbox
@category{Evaluation} @category{Global variables}
@closecatbox
@end defvr

