@c Language: German
@c English original: Command.texi CVS 1.41

@menu
* Einf@"uhrung in die Kommandozeile::
* Definitionen f@"ur die Kommandozeile::
@end menu

@node Einf@"uhrung in die Kommandozeile, Definitionen f@"ur die Kommandozeile, Kommandozeile, Kommandozeile
@section Einf@"uhrung in die Kommandozeile

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn {Operator} '
Der Quotierungsoperator @code{'} (Hochkomma, "single quote operator")
verhindert die Auswertung.

Auf ein Symbol angewandt, verhindert das Hochkomma die Auswertung des Symbols.

Auf einen Funktionsaufruf angewandt, verhindert das Hochkomma die Auswertung 
des Funktionsaufrufs, obwohl die Argumente der Funktion nach wie vor ausgewertet werden
(falls deren Auswertung nicht anders verhindert wird).
Das Ergebnis ist die Substantivform des Funktionsaufrufs. 

Auf einen eingeklammerten Ausdruck angewandt, verhindert das Hochkomma die Auswertung
aller Symbole und Funktionsaufrufe in diesem Ausdruck. 
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
Z.B. bedeutet @code{'(f(x))}, dass der Ausdruck @code{f(x)} nicht ausgewertet wird.
@code{'f(x)} (das Hochkomma angewandt auf @code{f} statt auf @code{f(x)}) 
bedeutet, dass die Substantivform von @code{f} angewandt auf @code{[x]} 
(im Sinne von @code{apply}) zur@"uckgegeben wird.

Ein einzelnes Hochkomma verhindert keine Vereinfachungen.

Wenn der globale Schalter @code{noundisp} @code{true} ist, 
werden Substantive mit einem Hochkomma versehen angezeigt.
Dieser Schalter ist stets @code{true}, wenn eine Funktionsdefinition angezeigt wird.

Siehe auch den Quote-Quote-Operator @code{''} und @code{nouns}.

Beispiele:

Auf ein Symbol angewandt, verhindert das Hochkomma die Auswertung des Symbols.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Auf einen Funktionsaufruf angewandt, verhindert das Hochkomma die Auswertung 
des Funktionsaufrufs. Das Ergebnis ist die Substantivform des Funktionsaufrufs. 

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Auf einen eingeklammerten Ausdruck angewandt, verhindert das Hochkomma die 
Auswertung aller Symbole und Funktionsaufrufe in diesem Ausdruck.


@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

Ein einzelnes Hochkomma verhindert keine Vereinfachungen.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

@end deffn

@deffn {Operator} ''
Der Quote-Quote-Operator @code{'@w{}'} (zwei einzelne Hochkommata) ver@"andert 
die Auswertung der eingegebenen Ausdr@"ucke.

Auf einen allgemeinen Ausdruck @var{expr} angewandt, bewirkt Quote-Quote,
dass der Wert von @var{expr} f@"ur @var{expr} in den eingegebenen Ausdruck eingesetzt wird.

Angewandt auf den Operator eines Ausdrucks, @"andert Quote-Quote
den Operator von einem Substantiv in ein Verb (sollte er nicht bereits ein Verb sein).

Der Quote-Quote-Operator wird durch den Eingabeparser angewandt;
er wird nicht als Teil des geparsten Eingabeausdrucks gespeichert.
Quote-Quote wird stets angewandt, sobald er geparst wird, und kann nicht quotiert werden. 
So bewirkt Quote-Quote eine Auswertung, auch wenn die Auswertung auf anderem Wege
unterdr@"uckt wird, so zum Beispiel in Funktionsdefinitionen, Lambda-Ausdr@"ucken
und Ausdr@"ucken, die durch ein Hochkomma (Operator @code{'}) quotiert sind.

Quote-Quote wird von @code{batch} und @code{load} erkannt.

Siehe auch den Quotierungsoperator @code{'} und @code{nouns}.

Beispiele:

Auf einen allgemeinen Ausdruck @var{expr} angewandt, bewirkt Quote-Quote,
dass der Wert von @var{expr} f@"ur @var{expr} in den eingegebenen Ausdruck eingesetzt wird.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Angewandt auf den Operator eines Ausdrucks, @"andert Quote-Quote
den Operator von einem Substantiv in ein Verb (sollte er nicht bereits ein Verb sein).

@c ===beg==
@c sin (1);
@c ''sin (1);
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end==
@example
(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
@end example

Der Quote-Quote-Operator wird durch den Eingabeparser angewandt;
er wird nicht als Teil des geparsten Eingabeausdrucks gespeichert.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

Quote-Quote bewirkt eine Auswertung, auch wenn die Auswertung auf anderem Wege
unterdr@"uckt wird, so zum Beispiel in Funktionsdefinitionen, Lambda-Ausdr@"ucken
und Ausdr@"ucken, die durch ein Hochkomma (Operator @code{'}) quotiert sind.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@end deffn

@c end concepts Command Line
@node Definitionen f@"ur die Kommandozeile,  , Einf@"uhrung in die Kommandozeile, Kommandozeile
@section Definitionen f@"ur die Kommandozeile

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Funktion} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
stellt einen alternativen Namen f@"ur eine (Benutzer- oder System-) Funktion, Variable, Array, etc. zur Verf@"ugung. 
Eine gerade Anzahl an Argumenten muss dabei verwendet werden. 

@end deffn

@defvr {Optionsvariable} debugmode
Standardwert: @code{false}

Wenn in Maxima ein Fehler auftritt, startet Maxima den Debugger, falls @code{debugmode} @code{true} ist. 
Der Benutzer kann dann Kommandos eingeben, um den Stapelspeicher ("call stack") zu untersuchen, 
Haltepunkte ("breakpoints") zu setzen, den Maxima-Quelltext durchzugehen, etc. 
Siehe @code{debugging} f@"ur eine Liste der Kommandos f@"ur den Debugger.
When a Maxima error occurs, Maxima will start the debugger if @code{debugmode} is @code{true}.
The user may enter commands to examine the call stack, set breakpoints, step
through Maxima code, and so on. See @code{debugging} for a list of debugger commands.

@code{debugmode} erm@"oglicht nicht, Lisp-Fehler abzufangen. 
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Funktion} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Wertet den Ausdruck @var{expr} in einer Umgebung, die durch die Argumente @var{arg_1}, ..., @var{arg_n} 
angegeben ist, aus. Die Argumente sind Boolesche Schalter ("Boolean flags"), Zuweisungen, 
Gleichungen und Funktionen. @code{ev} gibt das Ergebnis (einen anderen Ausdruck) 
der Auswertung zur@"uck. 

Die Auswertung wird in den folgenden Schritten durchgef@"uhrt. 

@enumerate
@item
Zuerst wird die Umgebung @"uber eine Abfrage der Argumente eingerichtet, welche eins oder alle der 
folgend genannten sein k@"onnen.

@itemize @bullet
@item
@code{simp} bewirkt, dass @var{expr} vereinfacht wird, unabh@"angig von der 
Einstellung des Schalters @code{simp}, der, wenn @code{false}, Vereinfachungen verhindert.
@item
@code{noeval} unterbindet die Auswertungsphase von @code{ev} (siehe unten Schritt (4)).
Dies ist hilfreich in Verbindung mit anderen Schaltern und dadurch, dass 
@var{expr} erneut vereinfacht wird ohne dabei erneut ausgewertet zu werden.
@item
@code{nouns} bewirkt die Auswertung der Substantivformen
(typischerweise unausgewertete Funktionen wie @code{'integrate} oder @code{'diff})
in @var{expr}.
@item
@code{expand} bewirkt Expansion.
@item
@code{expand (@var{m}, @var{n})} bewirkt Expansion und setzt dabei die Werte von 
@code{maxposex} und @code{maxnegex} zu @var{m} bzw. @var{n}.
@item
@code{detout} bewirkt, dass jede in @var{expr} enthaltende inverse Matrix 
bei der Berechnung ihre Determinante eher als Vorfaktor festh@"alt
als jeden Eintrag hierdurch zu teilen.
@item
@code{diff} bewirkt, dass jede in @var{expr} aufgef@"uhrte Differentiation ausgef@"uhrt wird.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} bewirkt, dass Differentiationen 
nur bez@"uglich der aufgef@"uhrten Variablen ausgef@"uhrt werden.
@item
@code{float} bewirkt, dass nichtganzzahlige rationale Zahlen in Dezimalzahlen 
umgewandelt werden.
@item
@code{numer} bewirkt, dass einige mathematische Funktionen (einschlie@ss{}lich 
der Exponentiation) mit numerischen Argumenten in Dezimalzahlen ausgewertet werden.
Es bewirkt, dass Variablen in @var{expr}, die Zahlenwerte erhalten haben, 
durch ihre Werte ersetzt werden.
Es schaltet auch den Schalter @code{float} an.
@item
@code{pred} bewirkt, dass Pr@"adikate (Ausdr@"ucke, die zu @code{true} oder @code{false} evaluieren)
ausgewertet werden.
@item
@code{eval} bewirkt eine zus@"atzliche Nachauswertung von @var{expr}. (Siehe unten Schritt (5).)
@code{eval} kann mehrfach aufgef@"uhrt werden. Bei jedem Vorkommen von @code{eval} wir der 
Ausdruck erneut ausgewertet.
@item
@code{A}, wobei @code{A} ein als Auswertungsschalter erkl@"artes Atom ist ("evaluation flag", siehe @code{evflag}),
bewirkt, dass @code{A} w@"ahrend der Auswertung von @var{expr} an @code{true} gebunden ist.
@item
@code{V: expression} (oder alternativ @code{V=expression}) bewirkt, dass @code{V} 
w@"ahrend der Auswertung von @var{expr} an den Wert von @code{expression} gebunden ist. 
Beachte, dass wenn @code{V} eine Maxima-Option ist, wird @code{expression} 
w@"ahrend der Auswertung von @var{expr} als Wert der Option verwendet. 
Wenn mehr als ein Argument von @code{ev} von diesem Typ ist, wird diese Bindung parallel durchgef@"uhrt. 
Wenn @code{V} nichtatomarer Ausdruck ist, wird eher eine Substitution als eine Bindung durchgef@"uhrt.
@item
@code{F}, wobei @code{F} ein als Auswertungsfunktion erkl@"arter Funktionsname ist 
("evaluation function", siehe  @code{evfun}), bewirkt, dass @code{F} auf @var{expr} angewandt wird.
@item
Andere Funktionsnamen (z.B., @code{sum}) bewirken die Auswertung jedes Vorkommens dieser Namen 
in @var{expr}, so als w@"aren es Verben.
@item
Zus@"atzlich kann eine Funktion, die in @var{expr} vorkommt (sagen wir @code{F(x)}), 
durch die Eingabe von @code{F(x) := expression} als Argument von @code{ev} 
allein f@"ur diese Auswertung von @var{expr} lokal definiert werden.
@item
Wenn ein oben nicht erw@"ahntes Atom oder eine indizierte Variable oder ein indizierter Ausdruck 
als Argument gegeben ist, wird es ausgewertet und wenn das Ergebnis eine Gleichung oder eine 
Zuweisung ist, wird die aufgef@"uhrte Bindung oder Substitution durchgef@"uhrt. 
Ist das Ergebnis eine Liste, dann werden die Elemente der Liste als zus@"atzliche Argumente 
von @code{ev} angesehen. 
Dies erlaubt, eine Liste von Gleichungen zu verwenden (z.B. @code{[X=1, Y=A**2]}), oder 
eine Liste von Namen von Gleichungen (z.B. @code{[%t1, %t2]}, wobei @code{%t1} und
@code{%t2} an Gleichungen gebunden sind), wie sie beispielsweise von @code{solve} zur@"uckgegeben wird.
@end itemize

Die Argumente von @code{ev} k@"onnen in beliebiger Reihenfolge angegeben werden, mit der Ausnahme, 
dass die Substitution von Gleichungen der Reihe nach von links nach rechts durchgef@"uhrt wird,  
und dass hintereinander aufgef@"uhrte Auswertungsfunktionen entsprechend verkettet werden, 
z.B. wird @code{ev (@var{expr}, ratsimp, realpart)} zu @code{realpart (ratsimp (@var{expr}))} .

Die Schalter @code{simp}, @code{numer}, @code{float} und @code{pred} k@"onnen auch lokal in einem Block 
gesetzt werden, oder global in Maxima, wodurch sie bis zur n@"achsten Setzung wirksam bleiben.

Ist @var{expr} ein kanonischer rationaler Ausdruck (CRE), ist der von @code{ev} zur@"uckgegebene 
Ausdruck ebenfalls CRE, vorausgesetzt dass die Schalter @code{numer} und @code{float} beide nicht 
@code{true} sind.

@item
W@"ahrend des Schritts (1) wird eine Liste der nicht indizierten Variablen erstellt, 
die auf der linken Seite von unter den Argumenten befindlichen Gleichungen auftreten oder in den Werten 
der Argumente, falls diese Werte Gleichungen sind. 
Die Variablen in dem Ausdruck @var{expr} (nicht indizierten Variablen und auch indizierte Variablen, 
die keine assoziierte Arrayfunktionen besitzen) 
werden durch ihre globalen Werte ersetzt, es sei denn, sie sind in der gerade 
genannten Liste aufgef@"uhrt. 
Normalerweise ist @var{expr} eine Marke (Label) oder @code{%} (wie in @code{%i2} in dem Beispiel unten), 
so dass in diesem Schritt einfach nur der durch die Marke benannte Ausdruck abfragt wird, 
damit @code{ev} ihn dann bearbeiten kann.

@item
Wenn in den Argumenten irgendwelche Substitutionen aufgef@"uhrt sind, werden diese nun ausgef@"uhrt.

@item
Der resultierende Ausdruck wird erneut ausgewertet (wenn nicht @code{noeval} unter den Argumente ist) 
und gem@"a@ss{} der Argumente vereinfacht. Beachte, dass jeder Funktionsaufruf in @var{expr} 
erst ausgef@"uhrt wird, nachdem die enthaltenden Variablen ausgewertet wurde und dass sich dadurch 
@code{ev(F(x))} wie @code{F(ev(x))} verhalten wird.

@item
Bei jedem Vorkommen von @code{eval} in den Argumenten werden die Schritte (3) und (4) wiederholt.
@end enumerate

Beispiele:

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)   e        cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Eine alternativ Top-Level-Syntax wird durch @code{ev} bereitgestellt, bei der man einfach nur 
die Argumente ohne @code{ev()} eingeben kann. D.h. man kann einfach schreiben 

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Diese Kurzschreibweise ist als Teil eines anderen Ausdrucks, z.B. in Funktionen, Bl@"ocken, etc., 
nicht gestattet.

Beachte im folgenden Beispiel den parallelen Bindungsprozess.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end deffn

@defvr {Eigenschaft} evflag
Wenn ein Symbol @var{x} die Eigenschaft (@code{properties}) 
@code{evflag} ("evaluation flag", Auswertungsschalter) 
besitzt, sind die Ausdr@"ucke @code{ev(@var{expr}, @var{x})} und @code{@var{expr}, @var{x}}
(in der interaktiven Eingabe) @"aquivalent zu @code{ev(@var{expr}, @var{x} = true)}. 
Das hei@ss{}t, @var{x} ist w@"ahrend der Auswertung von @var{expr} an @code{true} gebunden. 

Der Ausdruck @code{declare(@var{x}, evflag)} verleiht der Variablen @var{x} die @code{evflag}-Eigenschaft.

Schalter, die standardm@"a@ss{}ig die @code{evflag}-Eigenschaft besitzen: 
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand} und
@code{trigexpand}.

Beispiele:

@c ===beg===
@c sin (1/2);
@c sin (1/2), float;
@c sin (1/2), float=true;
@c simp : false;
@c 1 + 1;
@c 1 + 1, simp;
@c simp : true;
@c sum (1/k^2, k, 1, inf);
@c sum (1/k^2, k, 1, inf), simpsum;
@c declare (aa, evflag);
@c if aa = true then YES else NO;
@c if aa = true then YES else NO, aa;
@c ===end===
@example
(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        >    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then YES else NO;
(%o11)                         NO
(%i12) if aa = true then YES else NO, aa;
(%o12)                         YES
@end example

@end defvr

@defvr {Eigenschaft} evfun
Wenn eine Funktion @var{F} die Eigenschaft (@code{properties}) 
@code{evfun} ("evaluation function", Auswertungsfunktion) 
besitzt, sind die Ausdr@"ucke @code{ev(@var{expr}, @var{F})} und @code{@var{expr}, @var{F}}
(in der interaktiven Eingabe) @"aquivalent zu @code{@var{F}(ev(@var{expr}))}. 

Wenn zwei oder mehr @code{evfun}-Funktionen @var{F}, @var{G}, etc. aufgef@"uhrt werden, 
werden die Funktionen in der aufgef@"uhrten Reihenfolge angewandt. 

Der Ausdruck @code{declare(@var{F}, evfun)} verleiht der Funktion @var{F} die @code{evfun}-Eigenschaft.

Funktionen, die standardm@"a@ss{}ig die @code{evfun}-Eigenschaft besitzen: 
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, and
@code{trigreduce}.

Beispiele:

@c ===beg===
@c x^3 - 1;
@c x^3 - 1, factor;
@c factor (x^3 - 1);
@c cos(4 * x) / sin(x)^4;
@c cos(4 * x) / sin(x)^4, trigexpand;
@c cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
@c ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
@c declare ([F, G], evfun);
@c (aa : bb, bb : cc, cc : dd);
@c aa;
@c aa, F;
@c F (aa);
@c F (ev (aa));
@c aa, F, G;
@c G (F (ev (aa)));
@c ===end===
@example
(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
@end example

@end defvr
@c NEEDS WORK
@defvr {Optionsvariable} infeval
Erlaubt den Modus der endlosen Auswertung ("infinite evaluation"). 
@code{ev} wertet einen Ausdruck solange wiederholt aus, bis dieser sich nicht mehr @"andert. 
Um zu verhindern, dass eine Variable, sagen wir @code{X}, in diesem Modus fortw@"ahrend 
ausgewertet wird, kann man einfach @code{X='X} als Argument von @code{ev} einf@"ugen. 
Nat@"urlich werden Ausdr@"ucke wie @code{ev (X, X=X+1, infeval)} Endlosschleifen erzeugen. 

@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Funktion} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Funktion} kill (labels)
@deffnx {Funktion} kill (inlabels, outlabels, linelabels)
@deffnx {Funktion} kill (@var{n})
@deffnx {Funktion} kill ([@var{m}, @var{n}])
@deffnx {Funktion} kill (values, functions, arrays, ...)
@deffnx {Funktion} kill (all)
@deffnx {Funktion} kill (allbut (@var{a_1}, ..., @var{a_n}))

Entfernt alle Bindungen (Werte, Funktionen, Arrays oder Regeln) von den Argumenten 
@var{a_1}, ..., @var{a_n}. Ein Argument @var{a_k} kann ein Symbol oder ein einzelnes Arrayelement sein. 
Ist @var{a_k} ein einzelnes Arrayelement, entbindet @code{kill} dieses Element ohne dabei die 
anderen Elemente des Array zu beeinflussen.

Einige spezielle Argumente werden erkannt. Verschiedene Arten von Argumenten k@"onnen kombiniert werden, 
z.B. @code{kill (inlabels, functions, allbut (foo, bar))}.

@code{kill (labels)} entbindet alle bis dahin erzeugten Eingabe-, Ausgabe- und Zwischenmarken 
("input, output, and intermediate expression labels").
@code{kill (inlabels)} entbindet nur die Eingabemarken, die mit dem aktuellen Wert von @code{inchar} beginnen. 
Entsprechend entbindet @code{kill (outlabels)} nur die Ausgabemarken, 
die mit dem aktuellen Wert von @code{outchar} beginnen und  
@code{kill (linelabels)} entbindet nur die Zwischenmarken, 
die mit dem aktuellen Wert von @code{linechar} beginnen.

@code{kill (@var{n})}, wobei @var{n} eine ganze Zahl ist, 
entbindet die @var{n} letzten Eingabe- und Ausgabemarken

@code{kill ([@var{m}, @var{n}])} entbindet Eingabe- und Ausgabemarken von @var{m} bis @var{n}.

@code{kill (@var{infolist})}, wobei @var{infolist} ein Eintrag aus @code{infolists} ist 
(so wie @code{values}, @code{functions} oder @code{arrays}), 
entbindet alle Eintr@"age in @var{infolist}. Siehe auch @code{infolists}.

@code{kill (all)} entbindet s@"amtliche Eintr@"age in s@"amtlichen Infolisten. 
@code{kill (all)} setzt keine globale Variablen auf ihre Standardwerte zur@"uck; 
siehe @code{reset} zu diesem Punkt. 

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
entbindet au@ss{}er @var{a_1}, ..., @var{a_n} s@"amtliche Eintr@"age in s@"amtlichen Infolisten. 
@code{kill (allbut (@var{infolist}))} entbindet alle Eintr@"age au@ss{}er denen in @var{infolist}, 
wobei @var{infolist} entweder @code{values} oder @code{functions}, @code{arrays}, etc. ist.

Der Speicherplatz, der durch eine bestimmte Bindungseigenschaft beansprucht wird, wird nicht eher  
freigegeben, bevor alle Symbole entbunden sind. Um insbesondere den Speicherplatz, 
der durch den Wert eines Symbols beansprucht wird, wieder freizugeben, wird sowohl die Ausgabemarke, 
die den gebundenen Wert zeigt, als auch das Symbol selbst entbunden.  

@code{kill} quotiert (Operator @code{'}) seine Argumente.
Der Quote-Quote-Operator @code{'@w{}'} verhindert Quotierung. 

@code{kill (@var{symbol})} entbindet @var{symbol} von s@"amtlichen Eigenschaften (@code{properties}). 
Im Kontrast, @code{remvalue}, @code{remfunction}, @code{remarray} und @code{remrule} entbinden 
jeweils eine spezielle Eigenschaft. 

@code{kill} gibt stets @code{done} zur@"uck, sogar wenn das Argument keine Bindung besa@ss{}.

@end deffn

@deffn {Funktion} labels (@var{symbol})
@deffnx {Systemvariable} labels
Gibt die Liste der Eingabe-, Ausgabe- und Zwischenmarken 
("input, output, and intermediate expression labels"), die mit @var{symbol} beginnen, zur@"uck. 
Typischerweise ist @var{symbol} der Wert von @code{inchar}, @code{outchar} oder @code{linechar}. 
Der Markenbuchstabe kann mit oder ohne Prozentzeichen angegeben werden, so ergeben 
zum Beispiel @code{i} und @code{%i} dasselbe Ergebnis. 

Wenn keine Marke mit @var{symbol} beginnt, gibt @code{labels} eine leere Liste zur@"uck. 

Die Funktion @code{labels} quotiert (Operator @code{'}) seine Argumente.
Der Quote-Quote-Operator @code{'@w{}'} verhindert Quotierung. 
Zum Beispiel gibt @code{labels (''inchar)} die Eingabemarken zur@"uck, die mit dem aktuellen 
Eingabemarkenbuchstaben beginnen.

Die Variable @code{labels} ist die Liste der Eingabe-, Ausgabe- und Zwischenmarken, 
einschlie@ss{}lich aller vorherigen Marken, falls @code{inchar}, @code{outchar} oder @code{linechar} 
neu definiert wurde. 

Standardm@"a@ss{}ig zeigt Maxima das Ergebnis jeder Benutzereingabe an, wobei dem Ergebnis eine Ausgabemarke 
hinzugef@"ugt wird. Die Anzeige der Ausgabe wird durch die Eingabe eines abschlie@ss{}enden 
@code{$} (Dollarzeichen) statt eines @code{;} (Semikolon) unterdr@"uckt. 
Dabei wird eine Ausgabemarke erzeugt und an das Ergebnis gebunden, jedoch nicht angezeigt, 
die Marke kann aber in der gleichen Art und Weise wie bei angezeigten Ausgabemarken referenziert werden. 
Siehe auch @code{%}, @code{%%} und @code{%th}.

Zwischenmarken k@"onnen durch einige Funktionen erzeugt werden. Der Schalter @code{programmode} 
bestimmt, ob @code{solve} und einige andere Funktionen Zwischenmarken erzeugen statt eine Liste 
von Ausdr@"ucken zur@"uckzugeben. 
Einige andere Funktionen, wie z.B. @code{ldisplay}, erzeugen stets Zwischenmarken. 

Siehe auch @code{inchar}, @code{outchar}, @code{linechar} und @code{infolists}.

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Systemvariable} linenum
Der Zeilenindex der aktuellen Ein- und Ausgabe. 

@end defvr

@c NEEDS WORK
@defvr {Systemvariable} myoptions
Standardwert: @code{[]}

@code{myoptions} ist die Liste aller Optionen, die durch den Benutzer neu gesetzt 
wurden, unabh@"angig davon, ob sie dabei wieder auf den Standardwert zur@"uckgesetzt wurden, oder nicht. 

@end defvr

@defvr {Optionsvariable} nolabels
Standardwert: @code{false}

Wenn @code{nolabels} @code{true} ist, werden die Eingabe- und Ausgabemarken 
("label" @code{%i} bzw. @code{%o}) 
angezeigt, die Marken jedoch nicht an die Ergebnisse gebunden, 
und die Marken werden auch nicht der Liste @code{labels} hinzugef@"ugt. 
Da in diesem Fall keine Marken an Ergebnisse gebunden sind, kann die Speicherbereinigung 
("garbage collection") den durch die Ergebnisse beanspruchten Speicher wieder frei geben. 

Andernfalls werden die Marken an die Ein- und Ausgabe gebunden und der Liste @code{labels} hinzugef@"ugt. 

Zwischenmarken (@code{%t}) werden durch @code{nolabels} nicht beeinflusst; 
sie werden unabh@"angig davon, ob @code{nolabels} @code{true} ist, oder @code{false}, 
gebunden und der Liste @code{labels} hinzugef@"ugt. 

Siehe auch @code{batch}, @code{load} und @code{labels}.

@end defvr

@c NEEDS WORK
@defvr {Optionsvariable} optionset
Standardwert: @code{false}

Wenn @code{optionset} @code{true} ist, gibt Maxima eine Meldung aus, wenn eine 
Maxima-Option neu gesetzt wird. 
Das kann n@"utzlich sein, wenn der Benutzer Zweifel an der Schreibweise einer Option hat und sicher 
gehen m@"ochte, dass er tats@"achlich einer Optionsvariablen einen Wert zugewiesen hat.

@end defvr

@deffn {Funktion} playback ()
@deffnx {Funktion} playback (@var{n})
@deffnx {Funktion} playback ([@var{m}, @var{n}])
@deffnx {Funktion} playback ([@var{m}])
@deffnx {Funktion} playback (input)
@deffnx {Funktion} playback (slow)
@deffnx {Funktion} playback (time)
@deffnx {Funktion} playback (grind)
Zeigt Eingabe-, Ausgabe- und Zwischenausdr@"ucke ("input, output, and intermediate expressions") 
an, ohne diese dabei neu zu berechnen. @code{playback} zeigt nur die Ausdr@"ucke, 
die an die Marken ("label") gebunden sind; andere Ausgaben 
(so wie z.B. durch @code{print}, @code{describe} oder Fehlermeldungen erzeugten Text) 
werden nicht angezeigt.
Siehe auch @code{labels}.

@code{playback} quotiert (Operator @code{'}) seine Argumente.
Der Quote-Quote-Operator @code{'@w{}'} verhindert Quotierung. 
@code{playback} gibt stets @code{done} zur@"uck.

@code{playback ()} (ohne Argumente) zeigt s@"amtliche Eingabe-, Ausgabe- und Zwischenausdr@"ucke an, 
die bis dahin erzeugt wurden.
Ein bereits berechneter Ausgabeausdruck wird dabei auch dann angezeigt, 
wenn er durch einen Abschluss mit @code{$} unterdr@"uckt wurde.

@code{playback (@var{n})} zeigt die letzten @var{n} Ausdr@"ucke an. 
Jeder Eingabe-, Ausgabe- und Zwischenausdruck z@"ahlt dabei als einer.

@code{playback ([@var{m}, @var{n}])} zeigt die Eingabe-, Ausgabe- und Zwischenausdr@"ucke 
mit den Zahlen von @var{m} bis einschlie@ss{}lich @var{n} an. 

@code{playback ([@var{m}])} ist @"aquivalent zu @code{playback ([@var{m}, @var{m}])}; 
normalerweise gibt dies ein Paar von Ein- und Ausgabeausdr@"ucken aus. 

@code{playback (input)} zeigt s@"amtliche Eingabeausdr@"ucke an, die bis dahin erzeugt wurden.

@code{playback (slow)} pausiert zwischen den Ausdr@"ucken und wartet darauf, dass der Benutzer  
@code{enter} dr@"uckt. Dieses Verhalten ist @code{demo} @"ahnlich. 
@c WHAT DOES THE FOLLOWING MEAN ??? 
@code{playback (slow)} ist in Verbindung mit @code{save} oder @code{stringout} n@"utzlich, 
wenn man bei der Erzeugung einer sekund@"aren Speicherdatei die verwendbaren Ausdr@"ucke herauspicken m@"ochte. 

@code{playback (time)} zeigt f@"ur jeden Ausdruck die Berechnungszeit an.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} zeigt die Eingabeausdr@"ucke in dem gleichen Format an wie
die Funktion @code{grind}. Ausgabeausdr@"ucke werden von der Option @code{grind} nicht beeinflusst. 
Siehe @code{grind}.

Die Argumente k@"onnen kombiniert werden, z.B. @code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Funktion} printprops (@var{a}, @var{i})
@deffnx {Funktion} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Funktion} printprops (all, @var{i})
Zeigt die zum Indikator @var{i} assoziierte Eigenschaft (@code{properties}) des Atoms @var{a} an.
@var{a} kann sowohl eine Liste von Atomen, als auch das Atom @code{all} sein, in welchem Fall 
s@"amtliche Atome mit der gegebenen Eigenschaft aufgef@"uhrt werden. 
Zum Beispiel  @code{printprops ([f, g], atvalue)}.  
@code{printprops} ist f@"ur Eigenschaften gedacht, 
die auf andere Weise nicht angezeigt werden k@"onnen, 
z.B. f@"ur @code{atvalue}, @code{atomgrad}, @code{gradef} und @code{matchdeclare}.

F@"ur Beispiele siehe @code{atvalue}, @code{gradef} und @code{matchdeclare}.

@end deffn

@defvr {Optionsvariable} prompt
Standardwert: @code{_}

@code{prompt} ist das Eingabeaufforderungssymbol der @code{demo}-Funktion, 
des @code{playback (slow)}-Modus und der Maxima-Bruch-Schleife (aufgerufen durch @code{break}).

@end defvr

@deffn {Funktion} quit ()
Beendet in einer Shell oder Eingabeaufforderung eine Maxima-Sitzung. 
Beachte, dass die Funktion als @code{quit();} oder @code{quit()$} eingegeben werden muss, 
nicht nur als @code{quit}. 

Um eine zu lang andauernde Berechnung zu stoppen, gib in der Shell oder Eingabeaufforderung 
@code{control-C} und in XMaxima und wxMaxima @code{control-G} ein. 
Standardm@"a@ss{}ig wird dann wieder eine Eingabezeile bereitgestellt. 
Ist @code{*debugger-hook*} @code{nil}, @"offnet @code{control-C} bzw. @code{control-G} den 
Lisp-Debugger. 
Siehe auch @code{debugging}.

@end deffn

@deffn {Funktion} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} remfunction (all)
Entbindet die Symbole @var{f_1}, ..., @var{f_n} von ihren Funktionsdefinitionen. 
Die Argumente k@"onnen die Namen von gew@"ohnlichen Funktionen (durch @code{:=} oder @code{define} erzeugt) 
oder Makrofunktionen (durch @code{::=} erzeugt) sein.

@code{remfunction (all)} entbindet s@"amtliche Funktionsdefinitionen. 

@code{remfunction} quotiert (Operator @code{'}) seine Argumente.

@code{remfunction} gibt eine Liste mit den Symbolen zur@"uck, die von ihren Funktionsdefinitionen 
entbunden wurden. @code{false} wird statt der Symbole zur@"uckgegeben, f@"ur die es keine Funktionsdefinition 
gibt.

@end deffn

@deffn {Funktion} reset ()
Setzt viele globale Variablen, Optionen und einige andere Variablen auf ihre Standardwerte zur@"uck. 

@code{reset} verarbeitet die Variablen der Lisp-Liste @code{*variable-initial-values*}. 
Das Lisp-Makro @code{defmvar} setzt (unter anderem) Variablen auf diese Liste. 
Viele, aber nicht alle, globalen Variablen und Optionen sind mit Hilfe von @code{defmvar} 
definiert, andere mit @code{defmvar} definierte Variablen sind keine globalen Variablen oder Optionen. 

@end deffn

@defvr {Optionsvariable} showtime
Standardwert: @code{false}

Wenn @code{showtime} @code{true} ist, wird die Berechnungszeit und die verstrichene Zeit 
zusammen mit jedem Ausgabeausdruck angezeigt.

Die Berechnungszeit wird stets festgehalten, so dass @code{time} und @code{playback} 
die Berechnungszeit auch dann anzeigen k@"onnen, wenn @code{showtime} @code{false} ist.

Siehe auch @code{timer}.

@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Funktion} sstatus (@var{feature}, @var{package})
Setzt den Status von @var{feature} in @var{package}. 
Nachdem @code{sstatus (@var{feature}, @var{package})} ausgef@"uhrt wurde, gibt 
@code{status (@var{feature}, @var{package})} @code{true} zur@"uck. 
Dies kann f@"ur das Schreiben eines Pakets n@"utzlich sein, 
um @"uber die geladenen Merkmale (@code{features}) die @"Ubersicht zu behalten. 

@end deffn

@c NEEDS EXPANSION, EXAMPLES
@deffn {Funktion} to_lisp ()

Betritt unter Maxima das Lisp-System. @code{(to-maxima)} geht zu Maxima zur@"uck.

@end deffn

@defvr {Systemvariable} values
Anfangswert: @code{[]}

@code{values} ist eine Liste aller gebundenen Variablen (keine Maxima-Optionen oder Schalter). 
Die Liste umfasst Symbole, die mit Hilfe von @code{:} , @code{::} oder @code{:=} gebunden wurden.

@end defvr
