@c Language: German
@c English original: Function.texi CVS 1.42

@menu
* Einf@"uhrung in Funktionsdefinitionen::  
* Funktionen::                    
* Makros::
* Definitionen f@"ur Funktionsdefinitionen::  
@end menu

@node Einf@"uhrung in Funktionsdefinitionen, Funktionen, , Funktionsdefinitionen
@section Einf@"uhrung in Funktionsdefinitionen

@node Funktionen, Makros, Einf@"uhrung in Funktionsdefinitionen, Funktionsdefinitionen
@c NEEDS WORK, THIS TOPIC IS IMPORTANT
@c MENTION DYNAMIC SCOPE (VS LEXICAL SCOPE)
@section Funktionen
@subsection Gew@"ohnliche Funktionen

Um in Maxima eine Funktion zu definieren, verwendet man 
i.A. den := Operator. Z.B.

@example
f(x) := sin(x)
@end example

@noindent
definiert eine Funktion @code{f}.
Anonyme Funktionen k@"onnen mit Hilfe von @code{lambda} erzeugt werden. 
Zum Beispiel kann 

@example
lambda ([i, j], ...)
@end example

@noindent
anstelle von @code{f} verwendet werden, wenn 

@example
f(i,j) := block ([], ...);
@end example

Bei gegebener Liste @code{l} w@"urde  

@example
map (lambda ([i], i+1), l)
@end example

@noindent
eine Liste zur@"uckgeben, in der jedes Element mit 1 addiert wurde.

Man kann ebenso eine Funktion mit einer variablen Anzahl an Argumenten definieren.  
Dem abschlie@ss{}enden Argument wird auf diese Weise eine Liste mit den 
zus@"atzlichen Argumenten zugewiesen:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

Die rechte Seite einer Funktionsdefinition ist ein Ausdruck. 
M@"ochte man eine Folge von Ausdr@"ucken verwenden, gibt man 

@example
f(x) := (expr1, expr2, ...., exprn);
@end example

ein. Der Wert von @var{exprn} ist dann der R@"uckgabewert der Funktion.

Will man von einem Ausdruck innerhalb der Funktion aus einen R@"ucksprung erzeugen, 
muss man @code{block} und @code{return} verwenden.

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

ist selbst ein Ausdruck, kann also als rechte Seite einer Funktionsdefinition 
dienen. 
In diesem Beispiel kann es vorkommen, dass der R@"ucksprung vor der Auswertung 
des letzten Ausdrucks stattfindet.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES
Die erste @code{[]} in einem @code{block} kann eine Reihe von 
Variablen und Variablenzuweisungen enthalten, so wie @code{[a: 3, b, c: []]}, 
was bewirken w@"urde, dass sich die drei Variablen @code{a}, @code{b} 
und @code{c} nicht auf ihre globalen Werte beziehen (sollte es diese geben), 
sondern spezielle Werte besitzen, solange der Code innerhalb des @code{block} 
oder innerhalb von Funktionen, die innerhalb des @code{block} aufgerufen werden, 
ausgef@"uhrt wird. Man nennt dies @i{dynamische} Bindung, 
da die Variablen nur vom Beginn bis zum Zeitpunkt des Endes des @code{block} 
bestehen. 
Im Falle eines @code{return} oder @code{throw} aus dem @code{block} 
werden die alten Werte der Variablen (sollte es diese geben) wieder eingesetzt.
Es ist sicherlich eine gute Idee, auf diese Weise Variablen zu sch@"utzen. 
Beachte, dass Zuweisungen an die Blockvariablen parallel vorgenommen werden. 
Das bedeutet, dass wenn man oben noch @code{c: a} verwendet h@"atte, der 
Wert von @code{c} der Wert von @code{a} zum Zeitpunkt des Blockbeginns 
sein w@"urde, bevor also @code{a} gebunden wurde. 
So etwas wie 

@example
block ([a: a], expr1, ... a: a+3, ..., exprn)
@end example

wird demnach den externen Wert von @code{a} davor bewahren, 
ver@"andert zu werden, aber erlaubt, diesen Wert zu verwenden.
Dies geschieht, da die rechte Seite der Zuweisungen erst im 
Eingangszusammenhang ausgewertet wird, bevor die Bindung stattfindet.
Einfach @code{block ([x], ...} zu verwenden, w@"urde bewirken, dass
@code{x} sich selbst als Wert hat, gerade so als h@"atte man eine neue
@b{Maxima} Sitzung begonnen.

Die aktuellen Argumente einer Funktion werden in exakt derselben Weise 
behandelt, wie Variablen in einem Block. So h@"atten wir in

@example
f(x) := (expr1, ..., exprn);
@end example

und

@example
f(1);
@end example

den gleichen Auswertungszusammenhang f@"ur die Ausdr@"ucke wie mit

@example
block ([x: 1], expr1, ..., exprn)
@end example

Da bei einer Funktionsdefinition mit := die rechte Seite erst 
zur Laufzeit ausgewertet wird, ist es manchmal ratsam, 
@code{define} oder eventuell auch @code{buildq} zur 
Definition einer Funktion zu verwenden.  

@subsection Array-Funktionen

Eine Array-Funktion speichert bei einem gegebenen Argument 
den Funktionswert beim ersten Aufruf,  
und gibt bei erneutem Aufruf mit dem gleichen Argument 
den gespeicherten Wert zur@"uck, ohne ihn neu zu berechnen. 
So eine Funktion wird tabellenf@"uhrend (@i{memoizing function}) genannt.

Die Namen der Array-Funktionen werden der globalen Liste 
@code{arrays} hinzugef@"ugt (und nicht der globalen Liste 
@code{functions}).
@code{arrayinfo} gibt die Liste der Argumente zur@"uck, f@"ur 
die es gespeicherte Funktionswerte gibt.
@code{dispfun} und @code{fundef} geben die Definition der 
Array-Funktion zur@"uck.

@code{arraymake} erzeugt den Aufruf einer Array-Funktion, 
analog zum Aufruf von @code{funmake} bei gew@"ohnlichen Funktionen. 
@code{arrayapply} wendet eine Array-Funktion auf seine Argumente an, 
so wie @code{apply} bei gew@"ohnlichen Funktionen. 
Es gibt jedoch nicht exakt analoges zu @code{map} f@"ur 
Array-Funktionen, obwohl 
@code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} oder
@code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, wobei @var{L} 
eine Liste ist, nicht weit davon entfernt sind.

@code{remarray} entfernt die Definition einer Array-Funktion 
(einschlie@ss{}lich der gespeicherten Werte), genauso wie 
@code{remfunction} bei gew@"ohnlichen Funktionen. 

@code{kill(@var{a}[@var{x}])} entfernt den f@"ur das Argument 
@var{x} gespeicherten Wert einer Array-Funktion @var{a}; 
beim n@"achsten Aufruf von @var{a} mit dem Argument @var{x} 
wird der Funktionswert neu berechnet.
Es gibt jedoch keine M@"oglichkeit, auf einmal alle gespeicherten 
Werte zu l@"oschen, au@ss{}er durch @code{kill(@var{a})} oder 
@code{remarray(@var{a})}, was gleichzeitig die Funktionsdefinition 
l@"oscht.


@node Makros, Definitionen f@"ur Funktionsdefinitionen, Funktionen, Funktionsdefinitionen
@section Makros

@deffn {Funktion} buildq (@var{L}, @var{expr})
F@"uhrt eine parallele Ersetzung der in der Liste @var{L} 
aufgef@"uhrten Variablen in dem Ausdruck @var{expr} durch, 
ohne dabei @var{expr} auszuwerten.

Der resultierende Ausdruck wird vereinfacht, aber nicht 
ausgewertet, nachdem @code{buildq} die Ersetzung durchgef@"uhrt hat.

Die Elemente in @var{L} sind Symbole oder Zuweisungen 
@code{@var{symbol}: @var{value}}, die parallel ausgewertet werden.

Die Bindung der Variablen auf der rechten Seite der Zuweisung 
ist die Bindung dieser Variablen in dem Zusammenhang, 
in dem @code{buildq} aufgerufen wird, und 
nicht die Bindung dieser Variablen in der Liste @var{L}.
Wenn einer Variable in @var{L} nicht ausdr@"ucklich ein Wert 
zugewiesen wurde, ist seine Bindung in @code{buildq} dieselbe, 
wie in dem Zusammenhang, aus dem @code{buildq} aufgerufen wird.

Die in @var{L} genannten Variablen werden dann parallel in 
@var{expr} ersetzt. Das hei@ss{}t, die Ersetzung ist f@"ur jede 
Variable festgelegt, bevor die Ersetzung ausgef@"uhrt wird, 
so dass die Ersetzung einer Variable auf die andere keinen 
Einfluss hat.

Wenn irgend eine Variable @var{x} in @var{expr} in der Form 
@code{splice (@var{x})} auftritt, dann muss @var{x} an eine Liste 
gebunden sein, und die Liste wird dann in @var{expr} 
verzahnt statt ersetzt.

Variablen in @var{expr}, die nicht in @var{L} auftauchen, 
werden in das Ergebnis w@"ortlich eingetragen, so als ob sie 
in dem Zusammenhang, aus dem @code{buildq} aufgerufen wird, 
gebunden w@"aren.

Beispiele

@code{a} ist ausdr@"ucklich an @code{x} gebunden,
w@"ahrend @code{b} dieselbe Bindung hat (n@"amlich 29) wie 
in dem aufrufenden Zusammenhang, 
und @code{c} wird w@"ortlich @"ubertagen.
Der resultierende Ausdruck wird nicht vor der ausdr@"ucklichen 
Auswertung @code{''%} ausgewertet.

@c ===beg===
@c (a: 17, b: 29, c: 1729)$
@c buildq ([a: x, b], a + b + c);
@c ''%;
@c ===end===
@example
(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
@end example

@code{e} ist an eine Liste gebunden, die als solche auch 
in den Argumenten von @code{foo} auftaucht, aber 
verzahnt in den Argumenten von @code{bar}.

@c ===beg===
@c buildq ([e: [a, b, c]], foo (x, e, y));
@c buildq ([e: [a, b, c]], bar (x, splice (e), y));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
@end example

Das Ergebnis wird nach der Ersetzung vereinfacht.
W@"urde die Vereinfachung vor der Ersetzung stattfinden,
w@"urden diese beiden Ausdr@"ucke dasselbe ergeben.

@c ===beg===
@c buildq ([e: [a, b, c]], splice (e) + splice (e));
@c buildq ([e: [a, b, c]], 2 * splice (e));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
@end example

Die Variablen in @var{L} sind parallel gebunden; 
w@"aren sie nacheinander gebunden, w@"urde das erste 
Ergebnis @code{foo (b, b)} sein.
Auch die Ersetzungen werden parallel ausgef@"uhrt;
vergleiche das zweite Ergebnis mit dem von @code{subst},
welches die Ersetzungen nacheinander ausf@"uhrt.

@c ===beg===
@c buildq ([a: b, b: a], foo (a, b));
@c buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
@c subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
@c ===end===
@example
(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
@end example

Folgend wird eine Liste von Gleichungen konstruiert, 
mit jeweils Variablen oder Ausdr@"ucken auf der linken Seite  
und deren Werte auf der rechten.
@code{macroexpand} zeigt den R@"uckgabewert von @code{show_values}.

@c ===beg===
@c show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
@c (a: 17, b: 29, c: 1729)$
@c show_values (a, b, c - a - b);
@c macroexpand (show_values (a, b, c - a - b));
@c ===end===
@example
(%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
@end example

@end deffn

@deffn {Funktion} macroexpand (@var{expr})
Gibt, wenn @code{expr} ein Makro-Funktionsaufruf ist,
die Makro-Expansion von @var{expr} zur@"uck, ohne den 
Ausdruck dabei auszuwerten.
Andernfalls gibt @code{macroexpand} @var{expr} zur@"uck.

Sollte die Expansion von @var{expr} einen weiteren 
Makro-Funktionsaufruf liefern, wird auch dieser 
Makro-Funktionsaufruf expandiert.

@code{macroexpand} quotiert (Operator @code{'}) seine Argumente.
Wenn jedoch die Expansion der Makrofunktion Seiteneffekte 
bewirkt, werden auch diese Seiteneffekte ausgef@"uhrt.

Siehe auch @code{::=}, @code{macros} und @code{macroexpand1}.

Beispiele

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@deffn {Funktion} macroexpand1 (@var{expr})
Gibt, wenn @code{expr} ein Makro-Funktionsaufruf ist,
die Makro-Expansion von @var{expr} zur@"uck, ohne den 
Ausdruck dabei auszuwerten.
Andernfalls gibt @code{macroexpand1} @var{expr} zur@"uck.

@code{macroexpand1} quotiert (Operator @code{'}) seine Argumente.
Sollte die Expansion der Makrofunktion Seiteneffekte 
bewirken, werden auch diese Seiteneffekte ausgef@"uhrt.

Sollte die Expansion von @var{expr} einen weiteren 
Makro-Funktionsaufruf liefern, wird dieser Makro-Funktionsaufruf 
jedoch nicht expandiert.

Siehe auch @code{::=}, @code{macros} und @code{macroexpand}.

Beispiele

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand1 (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@defvr {Globale Variable} macros
Standardwert: @code{[]}

@code{macros} ist die Liste der benutzerdefinierten Makrofunktionen. 
Der Operator @code{::=} zur Markodefinition setzt neue Makrofunktionen 
auf diese Liste und @code{kill}, @code{remove} und @code{remfunction} 
entfernen Makrofunktionen von dieser Liste.

Siehe auch @code{infolists}.

@end defvr

@deffn {Funktion} splice (@var{a})
Verzahnt die durch das Atom @var{a} benannte Liste in einen Ausdruck, 
aber nur dann, wenn @code{splice} innerhalb von @code{buildq} auftritt; 
andernfalls wird @code{splice} wie eine undefinierte Funktion behandelt. 
Tritt @var{a} innerhalb von @code{buildq} allein auf (ohne @code{splice}), 
dann wird @var{a} als Liste (und nicht verzahnt) in das Ergebnis eingesetzt. 
Das Argument von @code{splice} darf nur ein Atom sein, 
keine buchst@"abliche Liste oder auch kein Ausdruck, der eine Liste 
ergibt.

Typischerweise liefert @code{splice} die Argumente f@"ur eine Funktion 
oder einen Operator.
F@"ur eine Funktion @code{f} expandiert der Ausdruck @code{f (splice (@var{a}))} 
innerhalb von @code{buildq} zu @code{f (@var{a}[1], @var{a}[2], @var{a}[3], ...)}. 
F@"ur einen Operator @code{o} expandiert der Ausdruck @code{"o" (splice (@var{a})}
innerhalb von @code{buildq} zu @code{"o" (@var{a}[1], @var{a}[2], @var{a}[3], ...)},
wobei @code{o} jeder Typ von Operator sein kann 
(typischerweise einer, der mehrere Argumente besitzt). 
Beachte, dass der Operator in Anf@"uhrungszeichen @code{"} eingeschlossen 
sein muss.

Beispiele

@c ===beg===
@c buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
@c buildq ([x: [1, %pi]], "/" (splice (x)));
@c matchfix ("<>", "<>");
@c buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
@c ===end===
@example
(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix ("<>", "<>");
(%o3)                          <>
(%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
(%o4)                   <>1, %pi, z - y<>
@end example

@end deffn


@c end concepts Funktionen
@node Definitionen f@"ur Funktionsdefinitionen,  , Makros, Funktionsdefinitionen
@section Definitionen f@"ur Funktionsdefinitionen

@deffn {Funktion} apply (@var{F}, [@var{x_1}, ..., @var{x_n}])
Erzeugt einen Ausdruck @code{@var{F}(@var{arg_1}, ..., @var{arg_n})} 
und wertet ihn aus.
@code{apply} versucht nicht, zwischen Array-Funktion und gew@"ohnlichen Funktionen 
zu unterscheiden; 
wenn @var{F} der Name einer Array-Funktion ist, wertet @code{apply} 
@code{@var{F}(...)} aus (d.h. ein Funktionsaufruf mit runden statt 
eckigen Klammern).
@code{arrayapply} wertet in diesem Fall einen Funktionsaufruf mit 
eckigen Klammern aus.

Beispiele:

@code{apply} wertet seine Argumente aus.
In diesem Beispiel wird @code{min} auf den Wert von @code{L} angewendet.

@c ===beg===
@c L : [1, 5, -10.2, 4, 3];
@c apply (min, L);
@c ===end===
@example
(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
@end example

@code{apply} wertet die Argumente aus, sogar wenn die Funktion 
(hier @var{dispfun}) sie quotiert (Operator @code{'}).

@c ===beg===
@c F (x) := x / 1729;
@c fname : F;
@c dispfun (F);
@c dispfun (fname);
@c apply (dispfun, [fname]);
@c ===end===
@example
(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
@end example

@code{apply} wertet den Funktionsnamen (hier @var{demoivre}) aus.
Das einfache Hochkomma @code{'} verhindert die Auswertung.
@code{demoivre} ist der Name einer globalen Variable und ebenso eine Funktion.

@c ===beg===
@c demoivre;
@c demoivre (exp (%i * x));
@c apply (demoivre, [exp (%i * x)]);
@c apply ('demoivre, [exp (%i * x)]);
@c ===end===
@example
(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
@end example

@end deffn


@deffn {Funktion} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funktion} block (@var{expr_1}, ..., @var{expr_n})
@code{block} wertet @var{expr_1}, ..., @var{expr_n} der Reihe nach aus 
und gibt den Wert des letzten ausgewerteten Ausdrucks zur@"uck. 
Die Abfolge kann durch die @code{go}-, @code{throw}- und @code{return}-Funktion 
ge@"andert werden. 
Der letzte Ausdruck ist @var{expr_n}, wenn nicht @code{return} 
oder ein Ausdruck, der  @code{throw} enth@"alt, ausgewertet wird.
Die Variablen @var{v_1}, ..., @var{v_m} werden lokal im Block deklariert 
und damit unterschieden von globalen Variablen mit demselben Namen. 
Sollen keine Variablen lokal deklariert werden, kann die Liste entfallen. 
Innerhalb des Blocks ist jede von @var{v_1}, ..., @var{v_m} verschiedene 
Variable global. 

@code{block} speichert beim Eintritt in den Block die aktuellen Werte der 
Variablen @var{v_1}, ..., @var{v_m} (falls vorhanden), und entbindet dann die 
Variablen, so dass diese sich selbst als Wert besitzen. 
Die lokalen Variablen k@"onnen anschlie@ss{}end innerhalb des Blocks an beliebige 
Werte gebunden werden, nach Beenden des Blocks aber werden die zuvor 
gespeicherten Werte zur@"uckgeschrieben und die innerhalb des Blocks 
zugewiesenen Werte sind verloren. 

@code{block} kann in einem anderen @code{block} auftreten.
Jedesmal wenn ein neuer @code{block} ausgewertet wird, 
werden entsprechende lokalen Variablen eingerichtet. 
Lokale Variablen erscheinen jedem eingeschlossenen Block als global. 
Ist eine Variable nichtlokal in einem Block, 
ist ihr Wert gegebenenfalls der durch einen umgebenden Block 
zuletzt zugewiesene oder andernfalls der Wert in der globalen Umgebung. 
Dieses Prinzip stimmt wohl mit dem @"ublichen Verst@"andnis eines 
dynamischen G@"ultigkeitsbereichs ("dynamic scope") @"uberein.

Wenn es gew@"unscht wird, neben @code{value} auch andere lokale Eigenschaften 
(@code{properties}) zu speichern und wiederherzustellen, wie zum Beispiel 
@code{array} (au@ss{}er f@"ur vollst@"andige Arrays),
@code{function}, @code{dependencies}, @code{atvalue}, 
@code{matchdeclare}, @code{atomgrad}, @code{constant} und @code{nonscalar}, 
sollte innerhalb eines Blocks die Funktion @code{local} mit den Namen der 
Variablen als Argumente verwendet werden.

Der Wert eines Blocks ist der Wert seines letzten Ausdrucks 
oder der Wert des Arguments der Funktion @code{return}, 
die verwendet werden kann, um ausdr@"ucklich einen Programmblock
zu verlassen.
Die Funktion @code{go} kann in einem @code{block} verwendet werden, 
um die Programmkontrolle an eine Anweisung zu @"ubergeben, 
die mit dem Argument von @code{go} markiert ist. 
Um eine Anweisung zu markieren, stellt man ihr ein Atom als eine
zus@"atzliche Anweisung in @code{block} voran. Zum Beispiel:
@code{block ([x], x:1, loop, x+1, ..., go(loop), ...)}
Das Argument von @code{go} muss der Name einer Marke ("tag") sein, die im gleichen
@code{block} steht. Man kann @code{go} nicht verwenden, um eine Marke
in einem anderen @code{block} zu erreichen als den, der dieses @code{go}
enth@"alt.

Blocks tauchen typischerweise auf der rechten Seite einer Funktionsdefinition 
auf, k@"onnen aber genauso gut an anderen Stellen verwendet werden.

@end deffn

@c REPHRASE, NEEDS EXAMPLE
@deffn {Funktion} break (@var{expr_1}, ..., @var{expr_n})
Wertet und gibt @var{expr_1}, ..., @var{expr_n} aus 
und bewirkt dann eine Maxima-Bruch-Anweisung an einem Punkt, 
an dem der Benutzer seine Umgebung untersuchen und @"andern kann. 
Nach der Eingabe von @code{exit;} f@"ahrt die Rechnung wieder fort.

@end deffn

@c FOR SOME REASON throw IS IN SOME OTHER FILE. MOVE throw INTO THIS FILE.
@c NEEDS CLARIFICATION
@deffn {Funktion} catch (@var{expr_1}, ..., @var{expr_n})
Wertet die Ausdr@"ucke @var{expr_1}, ..., @var{expr_n} nacheinander aus; 
wenn ein davon zur Auswertung eines Ausdrucks der Form @code{throw (arg)}
f@"uhrt, dann ist der Wert des @code{catch} der Wert des @code{throw (arg)}, 
und kein weiterer Ausdruck wird ausgewertet.
Dieser nichtlokale R@"ucksprung geht durch jede Verschachtelungstiefe 
bis zum n@"achsten umgebenden @code{catch}.
Gibt es kein @code{catch}, das @code{throw} umgibt, wird eine 
Fehlermeldung ausgegeben.

Wenn die Auswertung der Argumente nicht zu der Auswertung eines @code{throw} 
f@"uhrt, ist der Wert von @var{catch} der Wert von @code{expr_n}. 

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

@c REWORD THIS PART.
Die Funktion @code{g} gibt eine Liste von Elementen der Liste @code{l} 
zur@"uck, auf die eine Funktion @code{f} angewandt wurde, falls alle Elemente 
nichtnegativ sind, andernfalls f@"angt ("catches") @code{g} das 
erste negative Element von @code{l} auf und wirft ("throws") es aus.

@end deffn

@deffn {Funktion} compfile (@var{filename}, @var{f_1}, ..., @var{f_n})
@"Ubersetzt Maxima-Funktionen @var{f_1}, ..., @var{f_n} nach Lisp 
und schreibt den @"ubersetzten Code in die Datei @var{filename}.

Die Lisp-@"Ubersetzungen werden weder ausgewertet, noch wird die Datei 
durch den Lisp-Compiler weiterverarbeitet.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} erzeugt und wertet Lisp-@"Ubersetzungen aus.
@code{compile_file} @"ubersetzt von Maxima nach Lisp, und wendet dann den 
Lisp-Compiler an.


Siehe auch @code{translate}, @code{translate_file} und @code{compile_file}.

@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} is @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@deffn {Funktion} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} compile (functions)
@deffnx {Funktion} compile (all)
@"Ubersetzt Maxima-Funktionen @var{f_1}, ..., @var{f_n} nach Lisp, 
wertet die Lisp-@"Ubersetzungen aus und ruft f@"ur jede @"ubersetzte Funktion 
die Lisp-Funktion @code{COMPILE} auf.
@code{compile} gibt eine Liste mit den Namen der kompilierten Funktionen zur@"uck. 

@code{compile (all)} oder @code{compile (functions)} kompiliert 
alle benutzerdefinierten Funktionen.

@code{compile} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.

@end deffn

@deffn {Funktion} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
Definiert eine Funktion namens @var{f} mit den Argumenten @var{x_1}, ..., @var{x_n} 
und dem Funktionsrumpf @var{expr}.

@code{define} quotiert (Operator @code{'}) in den meisten F@"allen 
das erste Argument und wertet das zweites Argument aus, 
wenn dies nicht ausdr@"ucklich quotiert ist. 
Wenn das erste Argument ein Ausdruck der Form 
@code{ev (@var{expr})}, @code{funmake (@var{expr})} oder @code{arraymake (@var{expr})} 
ist, wird das erste Argument ausgewertet;
dies erlaubt es, den Funktionsnamen genauso wie den Rumpf auszuwerten.

@code{define} ist vergleichbar mit dem Funktionsdefinitionsoperator @code{:=},
wenn aber @code{define} innerhalb einer Funktion auftaucht, 
verwendet die erzeugte Definition den Wert von @code{expr} zur Laufzeit und 
nicht den Wert zum Zeitpunkt der Definition der Funktion, 
die dieses @code{define} enth@"alt.

Alle Funktionsdefinitionen finden in demselben Namensraum statt;
die Definition einer Funktion @code{f} innerhalb einer anderen 
Funktion @code{g} beschr@"ankt nicht den G@"ultigkeitsbereich von 
@code{f} in Beziehung zu @code{g}.

@c MAKE THIS SAME POINT IN :=
@code{define} definiert Arrayfunktionen 
(aufgerufen mit Argumenten in eckigen Klammern @code{[ ]})
genauso wie gew@"ohnliche Funktionen.

Beispiele:

@example
(%i1) foo: 2^bar;
                               bar
(%o1)                         2
(%i2) g(x) := (f_1 (y) :=   foo*x*y,
               f_2 (y) := ''foo*x*y,
       define (f_3 (y),     foo*x*y),
       define (f_4 (y),   ''foo*x*y));
                                             bar
(%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y, 
                                                        bar
               define(f_3(y), foo x y), define(f_4(y), 2    x y))
(%i3) functions;
(%o3)                        [g(x)]
(%i4) g(a);
                                    bar
(%o4)                  f_4(y) := a 2    y
(%i5) functions;
(%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
(%i6) dispfun (f_1, f_2, f_3, f_4);
(%t6)                   f_1(y) := foo x y

                                  bar
(%t7)                  f_2(y) := 2    x y

                                    bar
(%t8)                  f_3(y) := a 2    y

                                    bar
(%t9)                  f_4(y) := a 2    y

(%o9)                         done
@end example
@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Funktion} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})
@deffn {Funktion} define_variable (@var{name}, @var{default_value}, @var{mode})

F@"uhrt eine globale Variable in die Maxima-Umgebung ein.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} ist n@"utzlich in benutzerdefinierten Paketen,
die oft @"ubersetzt oder kompiliert werden.

@code{define_variable} f@"uhrt die folgenden Schritte durch:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} deklariert dem @"Ubersetzer 
den Modus (@var{mode}) von @var{name}.
Siehe @code{mode_declare} f@"ur eine Liste der m@"oglichen Modi.

@item
Ist die Variable ungebunden, wird @var{default_value} @var{name} zugewiesen.

@item
@code{declare (@var{name}, special)} deklariert sie als speziell (Lisp: "special"). 
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
@var{name} wird einer Testfunktion zugeordnet, um sicherzustellen, 
dass @var{name} nur Werte im deklarierten Modus zugewiesen werden.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argument is a documentation string.  When
@c @code{translate_file} is used on a package which includes documentation
@c strings, a second file is output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

Die Eigenschaft @code{value_check} kann jeder Variablen zugewiesen werden, 
die durch @code{define_variable} mit einem von @code{any} verschiedenen Modus 
definiert wurde.
Die Eigenschaft @code{value_check} ist ein lambda-Ausdruck oder 
der Name einer Funktion mit einer Variablen, der aufgerufen wird, 
wenn versucht wird, der Variablen einen Wert zuzuweisen.
Das Argument der @code{value_check}-Funktion ist dieser beabsichtigte Wert.

@code{define_variable} wertet @code{default_value} aus 
und quotiert (Operator @code{'}) @code{name} und @code{mode}.
@code{define_variable} gibt den aktuellen Wert von @code{name} zur@"uck, 
der @code{default_value} ist, wenn @code{name} vorher ungebunden war, 
oder andernfalls der vorherige Wert von @code{name}.

Beispiele:

@code{foo} ist eine boolesche Variable mit dem anf@"anglichen Wert @code{true}.
@c GENERATED FROM:
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;

@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} ist eine ganzzahlige Variable, die prim sein soll.
@c GENERATED FROM:
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;

@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} ist eine Variable, der kein Wert zugewiesen werden kann.
Der Modus @code{any_check} ist @code{any} @"ahnlich, 
@code{any_check} erm@"oglicht jedoch den @code{value_check}-Mechanismus, 
w@"ahrend @code{any} dies nicht tut.
@c GENERATED FROM:
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;

@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@end deffn

@deffn {Funktion} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} dispfun (all)
Zeigt die Definitionen der benutzerdefinierten Funktionen @var{f_1}, ..., @var{f_n} an.
Jedes Argument kann der Name eines Makros (definiert durch @code{::=}) sein, 
einer gew@"ohnlichen Funktion (definiert durch @code{:=} oder @code{define}), 
einer Arrayfunktion (definiert durch @code{:=} oder @code{define}, 
aber mit Argumenten, die in eckigen Klammern @code{[ ]} eingeschlossen sind),
einer indizierten Funktion, (definiert durch @code{:=} oder @code{define}, 
aber mit einigen Argumenten in eckigen Klammern @code{[ ]} 
und anderen in runden Klammern @code{( )}),
einer, die durch einen bestimmten Index aus einer Familie von 
indizierten Funktionen ausgew@"ahlt wurde, 
oder einer indizierten Funktion mit einem konstanten Index.

@code{dispfun (all)} zeigt alle benutzerdefinierten Funktionen an, die 
durch die @code{functions}-, @code{arrays}-, and @code{macros}-Listen 
gegeben sind, l@"asst aber indizierte Funktionen mit konstanten Indizes aus.

@code{dispfun} erzeugt Zwischenmarken (@code{%t1}, @code{%t2}, etc.)
f@"ur jede angezeigte Funktion, und weist die Funktionsdefinition den Marken zu.
Im Unterschied hierzu gibt @code{fundef} die Funktionsdefinitionen zur@"uck.

@code{dispfun} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.
@code{dispfun} gibt die Liste mit den Zwischenmarken zur@"uck, 
die den angezeigten Funktionen entsprechen. 

Beispiele:

@c ===beg===
@c m(x, y) ::= x^(-y);
@c f(x, y) :=  x^(-y);
@c g[x, y] :=  x^(-y);
@c h[x](y) :=  x^(-y);
@c i[8](y) :=  8^(-y);
@c dispfun (m, f, g, h, h[5], h[10], i[8]);
@c ''%;
@c ===end===
@example
(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
@end example

@end deffn

@defvr {Systemvariable} functions
Standardwert: @code{[]}

@code{functions} ist die Liste der gew@"ohnlichen Maxima-Funktionen 
der laufenden Sitzung.
Eine gew@"ohnliche Funktion ist eine Funktion, die mit Hilfe von 
@code{define} oder @code{:=} konstruiert wurde und mitsamt der 
Klammern @code{()} aufgerufen wird.
Eine Funktion kann in der Eingabezeile definiert werden 
oder in einer Maxima-Datei, die durch @code{load} oder @code{batch} 
geladen wird.

Arrayfunktionen (aufgerufen mit eckigen Klammern, i.A. @code{F[x]}) 
und indizierte Funktionen (aufgerufen mit eckigen und runden Klammern, 
i.A. @code{F[x](y)}) werden durch die globale Variable @code{arrays}, 
und nicht durch @code{functions} aufgelistet.

Lisp-Funktionen werden in keiner dieser Liste aufgef@"uhrt.

Beispiele:

@c ===beg===
@c F_1 (x) := x - 100;
@c F_2 (x, y) := x / y;
@c define (F_3 (x), sqrt (x));
@c G_1 [x] := x - 100;
@c G_2 [x, y] := x / y;
@c define (G_3 [x], sqrt (x));
@c H_1 [x] (y) := x^y;
@c functions;
@c arrays;
@c ===end===
@example
(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
@end example

@end defvr

@deffn {Funktion} fundef (@var{f})
Gibt die Definition der Funktion @var{f} zur@"uck.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
Das Argument kann der Name eines Makros (definiert durch @code{::=}) sein, 
einer gew@"ohnlichen Funktion (definiert durch @code{:=} oder @code{define}), 
einer Arrayfunktion (definiert durch @code{:=} oder @code{define}, 
aber mit Argumenten, die in eckigen Klammern @code{[ ]} eingeschlossen sind),
einer indizierten Funktion, (definiert durch @code{:=} oder @code{define}, 
aber mit einigen Argumenten in eckigen Klammern @code{[ ]} 
und anderen in runden Klammern @code{( )}),
einer, die durch einen bestimmten Index aus einer Familie von 
indizierten Funktionen ausgew@"ahlt wurde, 
oder einer indizierten Funktion mit einem konstanten Index.

@code{fundef} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.

@code{fundef (@var{f})} gibt die Definition von @var{f} zur@"uck.
Im Unterschied hierzu erzeugt @code{dispfun (@var{f})} Zwischenmarken (@code{%t1}, @code{%t2}, ...)
und weist die Definition den Marken zu.

@c PROBABLY NEED SOME EXAMPLES HERE
@end deffn

@deffn {Funktion} funmake (@var{F}, [@var{arg_1}, ..., @var{arg_n}])
Gibt einen Ausdruck @code{@var{F}(@var{arg_1}, ..., @var{arg_n})} zur@"uck. 
Der R@"uckgabewert wird vereinfacht, aber nicht ausgewertet, 
so dass die Funktion @var{F} nicht aufgerufen wird, selbst wenn sie existiert.

@code{funmake} versucht nicht zwischen Arrayfunktionen und gew@"ohnlichen Funktionen 
zu unterscheiden; wenn @var{F} der Name einer Arrayfunktion ist, 
gibt @code{funmake} @code{@var{F}(...)} zur@"uck 
(d.h. einen Funktionsaufruf mit runden statt eckigen Klammern).
@code{arraymake} gibt in diesem Fall einen Funktionsaufruf mit 
eckigen Klammern zur@"uck. 

@code{funmake} wertet seine Argumente aus.

Beispiele:

@code{funmake} angewandt auf eine gew@"ohnliche Maxima-Funktion.

@c ===beg===
@c F (x, y) := y^2 - x^2;
@c funmake (F, [a + 1, b + 1]);
@c ''%;
@c ===end===
@example
(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
@end example

@code{funmake} angewandt auf ein Makro.

@c ===beg===
@c G (x) ::= (x - 1)/2;
@c funmake (G, [u]);
@c ''%;
@c ===end===
@example
(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
@end example

@code{funmake} angewandt auf eine indizierte Funktion.

@c ===beg===
@c H [a] (x) := (x - 1)^a;
@c funmake (H [n], [%e]);
@c ''%;
@c funmake ('(H [n]), [%e]);
@c ''%;
@c ===end===
@example
(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
@end example

@code{funmake} angewandt auf ein Symbol, dass nicht als Funktion 
irgendeiner Art definiert wurde.

@c ===beg===
@c funmake (A, [u]);
@c ''%;
@c ===end===
@example
(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
@end example

@code{funmake} wertet seine Argumente aus, aber nicht seinen R@"uckgabewert.

@c ===beg===
@c det(a,b,c) := b^2 -4*a*c;
@c (x : 8, y : 10, z : 12);
@c f : det;
@c funmake (f, [x, y, z]);
@c ''%;
@c ===end===
@example
(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
@end example

Maxima vereinfacht @code{funmake}s R@"uckgabewert.

@c ===beg===
@c funmake (sin, [%pi / 2]);
@c ===end===
@example
(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
@end example

@end deffn

@deffn {Funktion} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funktion} lambda ([[@var{L}]], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funktion} lambda ([@var{x_1}, ..., @var{x_m}, [@var{L}]], @var{expr_1}, ..., @var{expr_n})
Definiert und gibt einen lambda-Ausdruck (d.h. eine anonyme Funktion) zur@"uck.
Die Funktion kann erforderliche Argumente @var{x_1}, ..., @var{x_m} besitzen,
und/oder optionale Argumente @var{L}, welche im Funktionsrumpf als Liste 
auftreten. Der R@"uckgabewert der Funktion ist @var{expr_n}. 
Ein lambda-Ausdruck kann einer Variablen zugewiesen werden und
wird wie eine gew@"ohnliche Funktion ausgewertet.
Ein lambda-Ausdruck kann in einem Zusammenhang verwendet werden,
in dem der Name einer Funktion erwartet wird.

Wenn die Funktion ausgewertet wird, werden ungebundene lokale Variablen 
@var{x_1}, ..., @var{x_m} erzeugt.
@code{lambda} kann innerhalb eines @code{block} oder einem anderen 
@code{lambda} auftreten; 
jedesmal wenn ein neuer @code{block} oder ein neues @code{lambda} ausgewertet wird, 
werden entsprechende lokalen Variablen eingerichtet. 
Lokale Variablen erscheinen jedem eingeschlossenen @code{block} 
oder @code{lambda} als global.
Ist eine Variable nicht lokal, 
ist ihr Wert gegebenenfalls der durch einen umgebenden @code{block}
oder ein umgebendes @code{lambda} 
zuletzt zugewiesene oder andernfalls der Wert in der globalen Umgebung. 
Dieses Prinzip stimmt wohl mit dem @"ublichen Verst@"andnis eines 
dynamischen G@"ultigkeitsbereichs ("dynamic scope") @"uberein.

Nachdem lokale Variablen eingerichtet wurden, 
werden @var{expr_1} bis @var{expr_n} der Reihe nach ausgewertet. 
Die spezielle Variable @code{%%}, die den Wert des vorangegangenen 
Ausdrucks repr@"asentiert, wird hierbei erkannt.
@code{throw} und @code{catch} k@"onnen sich ebenso in der Liste der 
Ausdr@"ucke befinden.

@code{return} darf nicht in einem lambda-Ausdruck erscheinen, 
der nicht durch @code{block} eingeschlossen wird,
in diesem Fall definiert @code{return} den R@"uckgabewert des Blocks und 
nicht den des lambda-Ausdrucks, wenn der Block nicht gerade @var{expr_n} ist. 
In @"ahnlicher Weise darf @code{go} nicht in einem lambda-Ausdruck erscheinen, 
der nicht durch @code{block} eingeschlossen wird.

@code{lambda} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.

Beispiele:

@itemize @bullet
@item
Ein lambda-Ausdruck kann einer Variablen zugewiesen werden und
wird wie eine gew@"ohnliche Funktion ausgewertet.
@end itemize
@c ===beg===
@c f: lambda ([x], x^2);
@c f(a);
@c ===end===
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
Ein lambda-Ausdruck kann in einem Zusammenhang verwendet werden,
in dem der Name einer Funktion erwartet wird.
@end itemize
@c ===beg===
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c ===end===
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Argumentvariablen sind lokale Variablen.
Andere Variablen erscheinen als globale Variablen.
Globale Variablen werden zum Zeitpunkt der Auswertung des lambda-Ausdrucks 
ausgewertet, wenn nicht eine spezielle Auswertung mit Hilfe von 
z.B. @code{'@w{}'} erzwungen wird.
@end itemize
@c ===beg===
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c ===end===
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Lambda-Ausdr@"ucke k@"onnen verschachtelt sein.
Lokale Variablen in einem @"au@ss{}eren lambda-Ausdruck erscheinen dem 
inneren Ausdruck als global, solange sie nicht durch lokale Variablen 
gleichen Namens maskiert werden.
@end itemize
@c ===beg===
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c ===end===
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Da @code{lambda} seine Argumente quotiert (Operator @code{'}), 
definiert unten der lambda-Ausdruck @code{i} keine 
"multipliziere mit @code{a}"-Funktion.
So eine Funktion kann via @code{buildq} definiert werden,
wie unten im lambda-Ausdruck @code{i2}.
@end itemize
@c ===beg===
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@c ===end===
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@itemize @bullet
@item
Ein lambda-Ausdruck kann eine variable Anzahl an Argumenten besitzen, 
angezeigt durch @code{[@var{L}]} als das einzige oder letzte Argument.
Die Argumente treten innerhalb des Funktionsrumpfs als Liste auf.
@end itemize
@c ===beg===
@c f : lambda ([aa, bb, [cc]], aa * cc + bb);
@c f (foo, %i, 17, 29, 256);
@c g : lambda ([[aa]], apply ("+", aa));
@c g (17, 29, x, y, z, %e);
@c ===end===
@example
(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply ("+", aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
@end example
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Funktion} local (@var{v_1}, ..., @var{v_n})
Erkl@"art die Variablen @var{v_1}, ..., @var{v_n}  als lokal bez@"uglich 
aller Eigenschaften (@code{properties}) innerhalb der Anweisung, 
in der diese Funktion verwendet wird.

@code{local} quotiert (Operator @code{'}) seine Argumente.
@code{local} gibt @code{done} zur@"uck.

@code{local} kann nur in @code{block} verwendet werden, 
im Rumpf einer Funktionsdefinition oder eines @code{lambda}-Ausdrucks, 
oder in der @code{ev}-Funktion, und nur eine Verwendung ist jeweils erlaubt.

@code{local} ist unabh@"angig von @code{context}.

@end deffn

@defvr {Optionsvariable} macroexpansion
Standardwert: @code{false}

@code{macroexpansion} entscheidet, ob die Expansion (d.h. der R@"uckgabewert) 
einer Makrofunktion den Aufruf der Makrofunktion selbst ersetzt. 
Eine Ersetzung kann nachfolgende Auswertungen beschleunigen, 
kostet dann aber das Speichern der Expansion.

@table @code
@item false
Die Expansion der Makrofunktion ersetzt nicht den Aufruf der Makrofunktion.
@item expand
Wenn der Aufruf der Makrofunktion das erste Mal ausgewertet wird, 
wird die Expansion gespeichert.
Bei nachfolgenden Aufrufen wird die Expansion nicht erneut berechnet; 
Seiteneffekte (wie z.B. @code{print} oder Zuweisungen an globale Variablen) 
ereignen sich nur, wenn der Makrofunktionsaufruf das erste Mal ausgewertet wird.
Die Expansion in einem Ausdruck wirkt sich nicht auf andere Ausdr@"ucke aus, 
die denselben Makrofunktionsaufruf enthalten.
@item displace
Wenn der Aufruf der Makrofunktion das erste Mal ausgewertet wird, 
wird der Aufruf selbst durch die Expansion ersetzt, 
so dass der Ausdruck, aus dem die Makrofunktion aufgerufen wird, 
ver@"andert wird.
Bei nachfolgenden Aufrufen wird die Expansion nicht erneut berechnet; 
Seiteneffekte ereignen sich nur, wenn der Makrofunktionsaufruf 
das erste Mal ausgewertet wird.
Die Expansion in einem Ausdruck wirkt sich nicht auf andere Ausdr@"ucke aus, 
die denselben Makrofunktionsaufruf enthalten.
@end table

Beispiele

Wenn @code{macroexpansion} @code{false} ist, 
wird bei dem Aufruf einer Makrofunktion der aufrufende Ausdruck 
jedesmal ausgewertet und dabei nicht ver@"andert.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: false;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

Wenn @code{macroexpansion} @code{expand} ist,
wird die Makrofunktion nur einmal aufgerufen, 
und der aufrufende Ausdruck wird nicht ge@"andert.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: expand;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

Wenn @code{macroexpansion} @code{displace} ist,
wird die Makrofunktion nur einmal aufgerufen, 
und der aufrufende Ausdruck wird anschlie@ss{}end ge@"andert.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: displace;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

@end defvr

@c I DO NOT OBSERVE ANY EFFECT OF mode_checkp, mode_check_errorp, mode_check_warnp 
@c WHILE TRANSLATING
@c ONLY tr_warn_mode SEEMS TO HAVE EFFECT HERE (VvN)
@defvr {Optionsvariable} mode_checkp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN ??
Wenn @code{mode_checkp} @code{true} ist, @"uberpr@"uft @code{mode_declare} 
die Modi der gebundenen Variablen.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Optionsvariable} mode_check_errorp
Standardwert: @code{false}

@c WHAT DOES THIS MEAN ??
Wenn @code{mode_check_errorp} @code{true} ist, ruft @code{mode_declare} 
@code{error} auf.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Optionsvariable} mode_check_warnp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN ??
Wenn @code{mode_check_warnp} @code{true} ist, werden Modus-Fehler beschrieben.
@c NEED SOME EXAMPLES HERE.

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Funktion} mode_declare (@var{y_1}, @var{mode_1}, ..., @var{y_n}, @var{mode_n})
@code{mode_declare} wird verwendet, um die Modi der Variablen und Funktionen 
f@"ur nachfolgende @"Ubersetzungen oder Kompilationen zu deklarieren.
@code{mode_declare} wird typischerweise an den Anfang einer Funktionsdefinition 
gesetzt, an den Anfang eines Maxima-Skripts oder wird interaktiv in 
der Eingabezeile ausgef@"uhrt. 

Die Argumente von @code{mode_declare} sind Paare, bestehend aus einer 
Variablen und einem Modus, der entweder @code{boolean}, @code{fixnum}, 
@code{number}, @code{rational} oder @code{float} ist. 
Jede Variable kann auch eine Liste von Variablen sein, die dadurch alle im selben 
Modus deklariert werden.

@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Ist eine Variable ein Array, und hat jedes Element des Arrays, 
das referenziert wird, einen Wert, dann sollte eher
@example
array (yi, complete, dim1, dim2, ...)
@end example
als @code{array(yi, dim1, dim2, ...)} bei der ersten Deklaration der Gr@"o@ss{}e 
des Arrays verwendet werden.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Wenn alle Elemente des Arrays im Modus @code{fixnum} (@code{float}) sind, 
sollte man @code{fixnum} (@code{float}) statt @code{complete} verwenden.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Wenn ebenso jedes Element des Arrays im gleichen Modus ist, hier @code{m}, 
dann sollte

@example
mode_declare (completearray (yi), m))
@end example

f@"ur eine effiziente @"Ubersetzung verwendet werden.

Numerischer Code, der Arrays verwendet, wird eventuell durch die 
Deklaration der erwarteten Gr@"o@ss{}e des Arrays schneller laufen, wie in:

@example
mode_declare (completearray (a [10, 10]), float)
@end example

f@"ur ein 10 x 10 Array mit Gleitkommazahlen.

Man kann den Modus des Ergebnisses einer Funktion durch die Verwendung 
des Arguments @code{function (f_1, f_2, ...)} deklarieren; 
hierbei sind @code{f_1}, @code{f_2}, ... die Namen der Funktionen. 
Zum Beispiel deklariert der Ausdruck

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

dass der Wert, der von @code{f_1}, @code{f_2}, ... zur@"uckgegeben wird,
Einfach-Wort-Integer sind.

@code{modedeclare} ist ein Synonym f@"ur @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Funktion} mode_identity (@var{arg_1}, @var{arg_2})
Ist eine spezielle Form, die zusammen mit @code{mode_declare} und
einem Makro verwendet wird, um z.B. eine Liste von Gleitkommazahlen oder 
zusammengesetzte Datenobjekte zu deklarieren. 
Das erste Argument von @code{mode_identity} ist der Name des Modus eines 
elementaren Werts, wie er auch in @code{mode_declare} angegeben wird 
(d.h. @code{float}, @code{fixnum}, @code{number}, @code{list}, oder @code{any}), 
und das zweite Argument ist ein Ausdruck, der ausgewertet und dann als Wert 
von @code{mode_identity} zur@"uckgegeben wird.
Wenn jedoch der R@"uckgabewert nicht durch den deklarierten Modus gestattet ist, 
wird ein Fehler oder eine Warnung ausgegeben. 
Es kommt darauf an, dass der Modus des Ausdrucks, der durch den 
Maxima-Lisp-@"Ubersetzer bestimmt wird, mit dem des ersten Arguments @"ubereinstimmt, 
unabh@"angig davon, was im zweiten Argument vor sich geht. 
Z.B. erzeugt @code{x: 3.3; mode_identity (fixnum, x);} einen Fehler.
@code{mode_identity (flonum, x)} gibt 3.3 zur@"uck. 
Hierf@"ur gibt es eine Anzahl an Verwendungsm@"oglichkeiten, z.B., wenn man 
wei@ss{}, dass @code{first (l)} eine Zahl zur@"uckgibt, kann man 
@code{mode_identity (number, first (l))} schreiben. Ein effizienterer Weg 
hierf@"ur w@"are jedoch die Definition einer neuen elementaren Form, 

@example
firstnumb (x) ::= buildq ([x], mode_identity (number, x));
@end example

und die Verwendung von @code{firstnumb} bei jedem Herausnehmen des 
ersten Elements aus einer Liste von Zahlen.

@end deffn

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM THE DOCUMENTATION.
@defvr {Optionsvariable} transcompile
Standardwert: @code{true}

Wenn @code{transcompile} @code{true} ist, erzeugen @code{translate} 
und @code{translate_file} Deklarationen, die den @"ubersetzten Code 
f@"ur die Kompilation geeigneter machen.
@c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT AGAIN ??

@code{compfile} setzt dauerhaft @code{transcompile: true}.

@end defvr

@deffn {Funktion} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} translate (functions)
@deffnx {Funktion} translate (all)
@"Ubersetzt die benutzerdefinierten Funktionen @var{f_1}, ..., @var{f_n} 
von Maxima nach Lisp und wertet die Lisp-@"Ubersetzungen aus. 
Typischerweise laufen die @"ubersetzten Funktionen schneller als die Originale.

@code{translate (all)} oder @code{translate (functions)} @"ubersetzt alle 
benutzerdefinierten Funktionen.

Zu @"ubersetzende Funktionen sollten, wenn m@"oglich, zu Beginn einen Aufruf von 
@code{mode_declare} enthalten, um effizienten Code zu erzeugen. 
Zum Beispiel:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@noindent

wobei die @var{x_1}, @var{x_2}, ...  die Parameter der Funktion und 
@var{v_1}, @var{v_2}, ... die lokalen Variablen sind.

Die Namen der @"ubersetzten Funktionen werden aus der Liste 
@code{functions} entfernt, wenn @code{savedef} @code{false} ist (siehe unten), 
und dann der @code{props}-Liste hinzugef@"ugt.

Funktionen sollten nicht @"ubersetzt werden, bevor sie nicht vollst@"andig entwanzt sind.

Ausdr@"ucke werden als vereinfacht angenommen; wenn sie es nicht sind, 
wird korrekter, aber nicht optimaler Code erzeugt. 
Der Benutzer sollte deshalb nicht den Schalter @code{simp} auf @code{false} 
setzen, was die Vereinfachung der zu @"ubersetzenden Ausdr@"ucke verhindern w@"urde. 

Der Schalter @code{translate}, falls @code{true}, bewirkt eine automatische 
@"Ubersetzung der Benutzerfunktionen nach Lisp.

Beachte, dass @"ubersetzte Funktionen m@"oglicherweise nicht in identischer 
Weise laufen wie vor der @"Ubersetzung, da es bestimmte Unvereinbarkeiten 
der Lisp- und Maxima-Versionen geben kann. 
Die @code{rat}-Funktion mit mehr als einem Argument und die 
@code{ratvars}-Funktion sollten prinzipiell nicht verwendet werden, 
wenn irgend eine Variable durch @code{mode_declare} als 
Canonical Rational Expression (CRE) deklariert wurde. 
Ebenso wird die Einstellung @code{prederror: false} nicht @"ubersetzt.
@c WHAT ABOUT % AND %% ???

@code{savedef} - falls @code{true}, bewirkt, dass die Maxima-Version einer 
Benutzerfunktion erhalten bleibt, wenn die Funktion via @code{translate} 
@"ubersetzt wurde. Dies erlaubt, dass die Definition von @code{dispfun} 
angezeigt wird und auch, dass die Funktion editiert werden kann.

@code{transrun} - falls @code{false}, bewirkt, dass die interpretierte Version 
aller Funktionen eher l@"auft (vorausgesetzt, es gibt sie noch) als die @"ubersetzte. 

Die R@"uckgabe von @code{translate} ist eine Liste mit den Namen der 
@"ubersetzten Funktionen.

@end deffn

@deffn {Funktion} translate_file (@var{maxima_filename})
@deffnx {Funktion} translate_file (@var{maxima_filename}, @var{lisp_filename})
@"Ubersetzt eine Datei in Maxima-Code in eine Datei in Lisp-Code. 
@code{translate_file} gibt eine Liste mit drei Dateinamen zur@"uck: 
Der Name der Maxima-Datei, der Name der Lisp-Datei und der Name einer 
Datei, die zus@"atzliche Informationen @"uber die @"Ubersetzung enth@"alt.
@code{translate_file} wertet seine Argumente aus.

@code{translate_file ("foo.mac"); load("foo.LISP")} ist dasselbe wie
@code{batch ("foo.mac")}, abgesehen von gewissen Einschr@"ankungen, 
wie zum Beispiel die Verwendung von @code{'@w{}'} und @code{%}. 
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

@code{translate_file (@var{maxima_filename})} @"ubersetzt eine 
Maxima-Datei @var{maxima_filename} in eine @"ahnlich lautende Lisp-Datei. 
@code{foo.mac} wir z.B. @"ubersetzt in @code{foo.LISP}. 

Der Name der Maxima-Datei kann einen Verzeichnisnamen enthalten, 
die Lisp-Ausgabedatei wird dann in das gleiche Verzeichnis 
geschrieben, aus dem der Maxima-Input kommt. 

@code{translate_file (@var{maxima_filename}, @var{lisp_filename})} @"ubersetzt eine 
Maxima-Datei @var{maxima_filename} in eine Lisp-Datei @var{lisp_filename}. 
@code{translate_file} ignoriert Datei-Erweiterungen in @code{lisp_filename};
die Datei-Erweiterung der Lisp-Ausgabedatei ist stets @code{LISP}.
Der Lisp-Dateiname kann einen Verzeichnisnamen enthalten, 
in diesem Fall wird die Lisp-Ausgabedatei in das angegebene Verzeichnis 
geschrieben.
@code{translate_file} schreibt auch eine Datei mit Warnmeldungen des @"Ubersetzers 
in verschiedenen Dringlichkeitsstufen. Die Erweiterung dieser Datei ist @code{UNLISP}.
Diese Datei kann auch, obwohl manchmal schwer verst@"andlich, wertvolle 
Informationen zum Aufsp@"uren von Bugs im @"ubersetzten Code enthalten.
Die @code{UNLISP}-Datei wird immer in das gleiche Verzeichnis geschrieben, 
aus dem der Maxima-Input kommt.

@code{translate_file} gibt Lisp-Code aus, der bewirkt, dass 
einige Deklarationen und Definitionen sich bereits auswirken, 
sobald der Lisp-Code kompiliert ist.
Siehe @code{compile_file} f@"ur mehr Informationen zu diesem Thema. 

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
Siehe auch @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared}, 
@code{tr_warn_undefined_variable},
und @code{tr_windy}.

@end deffn

@defvr {Optionsvariable} transrun
Standardwert: @code{true}

Wenn @code{transrun} @code{false} ist, bewirkt dies, dass eher die 
interpretierte Version einer Funktion verwendet wird (vorausgesetzt, es gibt sie noch) 
als die @"ubersetzte.

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE USEFULNESS HERE.
@c ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR translate_fast_arrays, ANOTHER CONFUSING FLAG ...
@defvr {Optionsvariable} tr_array_as_ref
Standardwert: @code{true}

Wenn @code{translate_fast_arrays} @code{false} ist, 
werden Array-Referenzen in Lisp-Code, ausgegeben durch @code{translate_file}, 
durch @code{tr_array_as_ref} beeinflusst.
Wenn @code{tr_array_as_ref} @code{true} ist, 
werden Array-Namen ausgewertet, andernfalls erscheinen Array-Namen 
als wortgetreue Symbole im @"ubersetzten Code.

@code{tr_array_as_ref} zeigt keine Wirkung, wenn @code{translate_fast_arrays} 
@code{true} ist.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???
@defvr {Optionsvariable} tr_bound_function_applyp
Standardwert: @code{true}

Wenn @code{tr_bound_function_applyp} @code{true} ist, gibt Maxima 
eine Warnung aus, wenn gefunden wird, dass eine gebundene Variable 
(wie z.B. ein Funktionsargument) als Funktion verwendet wird. 
@code{tr_bound_function_applyp} beeinflusst nicht beeinflusst nicht den 
Code, der in diesen F@"allen erzeugt wird.

Ein Ausdruck wie z.B. @code{g (f, x) := f (x+1)} wird eine Warnmeldung ausl@"osen. 

@end defvr

@defvr {Optionsvariable} tr_file_tty_messagesp
Standardwert: @code{false}

Wenn @code{tr_file_tty_messagesp} @code{true} ist, 
werden Mitteilungen, die durch @code{translate_file} w@"ahrend der @"Ubersetzung 
einer Datei erzeugt werden, in der Konsole und in der UNLISP-Datei ausgegeben. 
Wenn @code{false}, werden die Mitteilungen @"uber die @"Ubersetzung der Datei nur 
in der UNLISP-Datei ausgegeben. 

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT. SHOULD CUT OUT THIS ITEM AND RELATED CODE.
@c NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE MODE
@c FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.
@defvr {Optionsvariable} tr_float_can_branch_complex
Standardwert: @code{true}

Bringt den Maxima-nach-Lisp-@"Ubersetzer dazu, davon auszugehen, dass die Funktionen 
@code{acos}, @code{asin}, @code{asec} und @code{acsc} komplexe Resultate 
zur@"uckgeben k@"onnen.

Der scheinbare Effekt von @code{tr_float_can_branch_complex} ist das Folgende. 
Es sieht jedoch so aus, als habe dieser Schalter keine Auswirkung auf die Ausgabe des 
@"Ubersetzers. 

Wenn er @code{true} ist, dann ist @code{acos(x)} im Modus @code{any}, 
sogar wenn @code{x} im Modus @code{float} ist (gesetzt durch @code{mode_declare}).

Wenn @code{false}, ist @code{acos(x)} genau dann im Modus @code{float}, 
wenn @code{x} ebenfalls im Modus @code{float} ist.

@end defvr

@defvr {Optionsvariable} tr_function_call_default
Standardwert: @code{general}

@code{false} bedeutet, gib auf und rufe @code{meval} auf.
@c code{expr} means assume Lisp fixed arg function. 
@c TRANSLATION NOT CLEAR. WHAT IS A Lisp fixed arg function ?? (VvN)
@code{expr} bedeutet, nimm eine Lisp-Funktion mit feststehenden Argumenten an.  
Der Standardwert @code{general} ergibt guten Code f@"ur 
@code{mexprs} und @code{mlexprs}, aber nicht f@"ur @code{macros}.
@code{general} garantiert, dass die Variablenbindungen im kompilierten Code 
korrekt sind. Im @code{general}-Modus wird bei der @"Ubersetzung von 
@code{f(x)}, falls @code{f} eine ungebundene Variable ist, angenommen, 
dass @code{apply (f, [x])} gemeint ist, und @"ubersetzt entsprechend, 
verbunden mit einer Warnung. 
Es gibt keinen Anlass, dies abzustellen. Die Standardeinstellung bedeutet, 
dass bei ausbleibender Warnung volle @"Ubereinstimmung von 
@"ubersetztem und kompiliertem Code mit dem Maxima-Interpretierer besteht.

@end defvr

@defvr {Optionsvariable} tr_numer
Standardwert: @code{false}

Wenn @code{tr_numer} @code{true} ist, wird die Eigenschaft (@code{properties}) 
@code{numer} f@"ur Atome, die diese Eigenschaft haben, z.B. @code{%pi}, verwendet.

@end defvr

@defvr {Optionsvariable} tr_optimize_max_loop
Standardwert: 100

@code{tr_optimize_max_loop} ist die maximale Anzahl der Wiederholungen, 
die der @"Ubersetzer eine Makroexpansion oder Optimierung im 
Hinblick auf eine bestimmte Form durchf@"uhren wird.
Diese ist dazu da, um Fehler bei der Makroexpansion und um 
nichtterminierende Optimierungseigenschaften aufzufangen.

@end defvr

@defvr {Optionsvariable} tr_semicompile
Standardwert: @code{false}

Wenn @code{tr_semicompile} @code{true} ist, 
werden die von @code{translate_file} und @code{compfile} 
ausgegebenen Formen makroexpandiert, aber nicht durch den Lisp-Compiler 
in Maschinencode kompiliert.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??
@defvr {Systemvariable} tr_state_vars
Standardwert:
@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

Die Liste der Schalter, die die Form des @"ubersetzten Outputs beeinflussen.
@c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
Diese Information ist n@"utzlich f@"ur Systemprogrammierer, wenn sie 
versuchen den @"Ubersetzer zu entwanzen. 
Durch den Vergleich des @"ubersetzten Produkts mit dem, was f@"ur einen 
gegebenen Zustand produziert werden sollte, ist es m@"oglich, 
Bugs aufzusp@"uren.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- RETURNS *tr-runtime-warned*
@c WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??
@deffn {Funktion} tr_warnings_get ()
Gibt eine Liste von Warnungen aus, die durch den @"Ubersetzer 
w@"ahrend der aktuellen @"Ubersetzung erzeugt werden.

@end deffn

@defvr {Optionsvariable} tr_warn_bad_function_calls
Standardwert: @code{true}

- Gibt eine Warnung aus,  
wenn Funktionsaufrufe gemacht werden, die aufgrund unzul@"assiger, 
zur @"Ubersetzungszeit erzeugter Deklarationen nicht korrekt sind. 

@end defvr

@c WHAT DOES fexpr MEAN ?? ITEM NOT CLEAR. (VvN)
@defvr {Optionsvariable} tr_warn_fexpr
Standardwert: @code{compfile}

- Gibt eine Warnung aus, 
wenn irgendwelche FEXPRs angetroffen werden. 
FEXPRs sollten normalerweise nicht in @"ubersetztem Code ausgegeben werden, 
alle legitimen speziellen Programmformen sind @"ubersetzt.

@end defvr

@defvr {Optionsvariable} tr_warn_meval
Standardwert: @code{compfile}

- Gibt eine Warnung aus, 
wenn die Funktion @code{meval} aufgerufen wird. 
Wenn @code{meval} aufgerufen wird, weist das auf ein @"Ubersetzungsproblem hin.

@end defvr

@defvr {Optionsvariable} tr_warn_mode
Standardwert: @code{all}

- Gibt eine Warnung aus, 
wenn Variablen f@"ur ihren Modus unzul@"assige Werte zugewiesen werden. 

@end defvr

@defvr {Optionsvariable} tr_warn_undeclared
Standardwert: @code{compile}

- Entscheidet, ob eine Warnung @"uber undeklarierte (@code{mode_declare}) Variablen 
@c TTY = console ??
in der Konsole ausgegeben werden soll.

@end defvr

@defvr {Optionsvariable} tr_warn_undefined_variable
Standardwert: @code{all}

- Gibt eine Warnung aus, 
wenn undefinierte globale Variablen gesichtet werden.

@end defvr

@c $tr_windy IS USED IN EXACTLY ONE PLACE (def%tr $kill IN src/trans1.lisp)
@c WHERE IT CAUSES A WARNING ABOUT USING kill. 
@c HOW ABOUT IF WE PERMANENTLY ENABLE THE WARNING MESSAGE
@c AND CUT OUT tr_windy FROM CODE AND DOCS.
@defvr {Option variable} tr_windy
Default value: @code{true}

- Erzeugt hilfreiche Kommentare und Programmiertipps.

@end defvr

@deffn {Funktion} compile_file (@var{filename})
@deffnx {Funktion} compile_file (@var{filename}, @var{compiled_filename})
@deffnx {Funktion} compile_file (@var{filename}, @var{compiled_filename}, @var{lisp_filename})
@"Ubersetzt die Maxima-Datei @var{filename} nach Lisp, 
f@"uhrt den Lisp-Compiler aus und l@"adt, 
wenn die @"Ubersetzung und Kompilation erfolgreich war, 
den kompilierten Code in Maxima hinein.

@code{compile_file} gibt eine Liste mit den Namen von vier Dateien zur@"uck:
Die Original-Maxima-Datei, die Lisp-@"Ubersetzung, Bemerkungen zur @"Ubersetzung  
und den kompilierten Code. 
Wenn die Kompilation misslang, ist @code{false} der vierte Eintrag.

Einige Deklarationen und Definitionen wirken sich aus, 
sobald der Lisp-Code kompiliert ist (ohne den kompilierten Code zu laden). 
Diese schlie@ss{}en Funktonen ein, die durch den Operator @code{:=} definiert sind, 
Makros, definiert durch den Operator @code{::=}, 
@code{alias}, @code{declare},
@code{define_variable},  @code{mode_declare},
und
@code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix},
und @code{compfile}.

Zuweisungen und Funktionsaufrufe werden nicht ausgewertet, 
bevor der kompilierte Code geladen wird. 
Insbesondere haben innerhalb einer Maxima-Datei Zuweisungen 
an die @"Ubersetzungsschalter (@code{tr_numer}, etc.) 
keine Auswirkung auf die @"Ubersetzung.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded. This is a bug. 
@c REPORTED AS SOURCEFORGE BUG # 1103722.

@var{filename} sollte keine @code{:lisp}-Anweisungen enthalten.

@code{compile_file} wertet seine Argumente aus.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Funktion} declare_translated (@var{f_1}, @var{f_2}, ...)
Beim @"Ubersetzen einer Datei mit Maxima-Code nach Lisp 
ist es f@"ur den @"Ubersetzer wichtig zu wissen, 
welche Funktionen in der Datei als @"ubersetzte oder kompilierte Funktionen 
aufgerufen werden sollen, oder welche nur Maxima-Funktionen sind, 
oder undefiniert.
An den Anfang einer Datei gesetzt, l@"asst diese Deklaration 
wissen, dass ein Symbol, das aktuell noch nicht den Wert einer Lisp-Funktion
hat, zur Laufzeit einen haben wird.
Der Lisp-Code @code{(MFUNCTION-CALL fn arg1 arg2 ...)} wird erzeugt, 
wenn der @"Ubersetzer nicht wei@ss{}, ob @code{fn} den Wert einer Lisp-Funktion 
haben wird.

@end deffn

