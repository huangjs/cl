@c english version 1.55
@menu
* n-arios::
* no-fijos::
* postfijos::
* prefijos::
* Operadores aritm@'eticos::
* Operadores relacionales::
* Operadores generales::
@end menu

@node n-arios, no-fijos, Operadores, Operadores

@section n-arios

Un operador de tipo @code{nary}(@code{n}-ario, en Maxima nary) es usado para denotar una funci@'on cuyo n@'umero de argumentos es arbitrario; los argumentos se separa por el s@'{@dotless{i}}mbolo del operador, como en A+B o A+B+C. La funci@'on @code{nary("x")} es una extensi@'on de la funci@'on @code{Syntax} para declarar a @code{x} como un operador @code{n}-ario. Las funciones pueden ser declaradas para ser @code{nary}. Si se hace @code{declare(J,nary);}, se esta diciendo al simplificador que haga la reducci@'on de @code{j(j(a,b),j(c,d))} a @code{j(a, b, c, d)}.

V@'ease tambi@'en @code{Syntax}.

@node no-fijos, postfijos, n-arios, Operadores

@section no-fijos

Los operadores de tipo @code{nofix} (no-fijos, en Maxima nofix) son usados para denotar funciones que no reciben argumentos. La mera presencia de tal operador en un comando causar@'a que la correspondiente funci@'on sea evaluada. Por ejemplo, cuando se escribe "exit;" para salir de una interrupci@'on de Maxima, "exit" se est@'a comportando de forma similar a un operador no-fijo (@code{nofix}). La funci@'on @code{nofix("x")} es una extensi@'on de la funci@'on @code{Syntax}, la cual declara a @code{x} como un operador @code{nofix}. 

V@'ease tambi@'en @code{Syntax}.


@node postfijos, prefijos, no-fijos, Operadores
@section postfijos

Un operador de tipo @code{postfix} (postfijo), al contrario de los de tipo @code{prefix}, denota funciones de un solo argumento, pero en este caso el argumento precede inmediatamente la ocurrencia del operador en la cadena de entrada, como en @code{3!}. La funci@'on @code{postfix("x")} es una extensi@'on de la funci@'on syntax para declarar a @code{x} como un operador @code{postfix}. 

V@'ease tambi@'en @code{Syntax}.   

@node prefijos, Operadores aritm@'eticos, postfijos, Operadores
@section prefijos
Un operador de tipo @code{prefix} (prefijo, en Maxima prefix) indica una funci@'on de un (1) argumento, dicho argumento viene inmediatamente despu@'es de una ocurrencia del operador. La funci@'on @code{prefix("x")} es una extensi@'on de la funci@'on @code{Syntax} para declarar a @code{x} como un operador de @code{prefix}. 

V@'ease tambi@'en @code{Syntax}.




@node Operadores aritm@'eticos, Operadores relacionales, prefijos, Operadores
@section Operadores aritm@'eticos

@deffn {Operador} +
@ifinfo
@fnindex Suma
@end ifinfo
@deffnx {Operador} -
@ifinfo
@fnindex Resta
@end ifinfo
@deffnx {Operador} *
@ifinfo
@fnindex Multiplicaci@'on
@end ifinfo
@deffnx {Operador} /
@ifinfo
@fnindex Divisi@'on
@end ifinfo
@deffnx {Operador} ^
@ifinfo
@fnindex Exponenciaci@'on
@end ifinfo

Los s@'{@dotless{i}}mbolos @code{+} @code{*} @code{/} y @code{^} representan
la suma, resta, multiplicaci@'on, divisi@'on y exponenciaci@'on, respectivamente.
Los nombres de estos operadores son @code{"+"} @code{"*"} @code{"/"} y @code{"^"},
que pueden aparecer all@'a donde se requiera el nombre de una funci@'on u operador.

Los s@'{@dotless{i}}mbolos @code{+} y @code{-} representan el positivo y negativo unario,
siendo los nombres de estos operadores @code{"+"} y @code{"-"}, respectivamente.

En Maxima, la resta @code{a - b} se representa como la suma @code{a + (- b)}.
Expresiones tales como @code{a + (- b)} se muestran como restas. Maxima
reconoce @code{"-"} tan solo como el operador de negaci@'on unaria, no como
el nombre del operador de resta binaria.

La divisi@'on @code{a / b} se representa en maxima como la multiplicaci@'on
@code{a * b^(- 1)}. Expresiones tales como @code{a * b^(- 1)} se muestran 
como divisiones. Maxima reconoce @code{"/"} como el nombre del operador
de divisi@'on.

La suma y la multiplicaci@'on son operadores conmutativos n-arios. La 
divisi@'on y la exponenciaci@'on son operadores no conmutativos binarios.

Maxima ordena los operandos de los operadores conmutativos para
formar lo que se conoce como representaci@'on can@'onica. A efectos de
almacenamiento interno, la ordenaci@'on viene determinada por @code{orderlessp}.
A efectos de presentaci@'on de las expresiones, la ordenaci@'on de la suma
la determina @code{ordergreatp}, y en el caso de la multiplicaci@'on, la
ordenaci@'on coincide con la del almacenamiento interno.

Los c@'alculos aritm@'eticos se realizan con n@'umeros literales
(enteros, racionales, decimales ordinarios y decimales grandes).
Excepto en el caso de la exponenciaci@'on, todas las operaciones
aritm@'eticas con n@'umeros dan lugar a resultados en forma de
n@'umeros. La exponenciaci@'on da como resultado un n@'umero
si alguno de los operandos es decimal ordinario o grande (@i{bigfloat}),
o si el resultado es un entero o racional; en caso contrario,
la exponenciaci@'on puede expresarse como una ra@'{@dotless{i}}z
cuadrada (@code{sqrt}), como otra potencia, o simplemente no
sufre cambios.

Se produce contagio de los decimales en coma flotante en los
c@'alculos aritm@'eticos: si alg@'un operando es un n@'umero decimal
grande (@i{bigfloat}), el resultado ser@'a tambi@'en un n@'umero
decimal grande; no habiendo decimales grandes, pero s@'{@dotless{i}}
ordinarios, el resultado sr@'a tambi@'en un decimal ordinario; de no
haber operandos decimales, el resultado ser@'a un n@'umero racional o
entero. 

Los c@'alculos aritm@'eticos son simplificaciones, no evaluaciones, por lo
que se realizan en expresiones comentadas.

Las operaciones aritm@'eticas se aplican elemento a elemento en el
caso de las listas cuando la variable global @code{listarith} vale @code{true};
pero en el caso de las matrices, siempre se aplican elemento a elemento.
Cuando un operando es una lista o matriz y otro operando lo es de otro tipo
cualquiera, @'este se combina con cada uno de los elementos de la lista o
matriz.

Ejemplos:

La suma y la multiplicaci@'on son operadores conmutativos n-arios.
Maxima ordena los operandos para formar lo que se conoce como 
representaci@'on can@'onica. Los nombres de estos operadores son
@code{"+"} y @code{"-"}.
@c ===beg===
@c c + g + d + a + b + e + f;
@c [op (%), args (%)];
@c c * g * d * a * b * e * f;
@c [op (%), args (%)];
@c apply ("+", [a, 8, x, 2, 9, x, x, a]);
@c apply ("*", [a, 8, x, 2, 9, x, x, a]);
@c ===end===

@example
(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
@end example

La divisi@'on y la exponenciaci@'on son operadores no conmutativos binarios.
Los nombres de estos operadores son @code{"/"} y @code{"^"}.
@c ===beg===
@c [a / b, a ^ b];
@c [map (op, %), map (args, %)];
@c [apply ("/", [a, b]), apply ("^", [a, b])];
@c ===end===

@example
(%i1) [a / b, a ^ b];
                              a   b
(%o1)                        [-, a ]
                              b
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
@end example

La resta y la divisi@'on se representan internamente en
t@'erminos de la suma y multiplicaci@'on, respectivamente.
@c ===beg===
@c [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
@c [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
@c ===end===

@example
(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
@end example

Los c@'alculos se realizan con n@'umeros literales.
Se produce el contagio de los n@'umeros decimales.
@c ===beg===
@c 17 + b - (1/2)*29 + 11^(2/4);
@c [17 + 29, 17 + 29.0, 17 + 29b0];
@c ===end===

@example
(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
@end example

Los c@'alculos aritm@'eticos son una simplificaci@'on, no una
evaluaci@'on.
@c ===beg===
@c simp : false;
@c '(17 + 29*11/7 - 5^3);
@c simp : true;
@c '(17 + 29*11/7 - 5^3);
@c ===end===

@example
(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
@end example

Los c@'alculos aritm@'eticos se realizan elemento a elemento 
en las listas (seg@'un sea el valor de @code{listarith}) y
matrices.
@c ===beg===
@c matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
@c 5 * matrix ([a, x], [h, u]);
@c listarith : false;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c listarith : true;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c ===end===

@example
(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
(%i2) 5 * matrix ([a, x], [h, u]);
                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
@end example

@end deffn


@deffn {Operador} **

Operador de exponenciaci@'on.
Maxima identifica @code{**} con el operador @code{^} en la entrada
de expresiones, pero se representa como @code{^} en las salidas
no formateadas (@code{display2d=false}), o colocando un 
super@'{@dotless{i}}ndice en la salida formateada (@code{display2d=true}).

La funci@'on @code{fortran} representa el operador de exponenciaci@'on
con @code{**}, tanto si se ha introducido como @code{**} o como @code{^}.

Ejemplos:

@c ===beg===
@c is (a**b = a^b);
@c x**y + x^z;
@c string (x**y + x^z);
@c fortran (x**y + x^z);
@c ===end===
@example
(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
@end example

@end deffn



@node Operadores relacionales, Operadores generales, Operadores aritm@'eticos, Operadores
@section Operadores relacionales

@deffn {Operator} <
@ifinfo
@fnindex Menor que
@end ifinfo
@deffnx {Operator} <=
@ifinfo
@fnindex Menor o igual que
@end ifinfo
@deffnx {Operator} >=
@ifinfo
@fnindex Mayor o igual que
@end ifinfo
@deffnx {Operator} >
@ifinfo
@fnindex Mayor que
@end ifinfo

Los s@'{@dotless{i}}mbolos @code{<}, @code{<=}, @code{>=} y @code{>}
representan menor que, menor o igual que, mayor o igual que y mayor que, respectivamente.
Los nombres de estos operadores son @code{"<"} @code{"<="} @code{">="} y @code{">"},
que pueden aparecer all@'a donde se requiera el nombre de una funci@'on u operador.

Estos operadores relacionales son todos operadores binarios. Maxima
no reconoce expresiones del estilo @code{a < b < c}.

Las expresiones relacionales devuelven valores booleanos haciendo uso 
de las funciones @code{is} o @code{maybe}, as@'{@dotless{i}} como de las
sentencias condicionales @code{if}, @code{while} y @code{unless}.
Las expresiones relacionales no se eval@'uan de otra manera, aunque sus
argumentos s@'{@dotless{i}} sean evaluados.

Cuando una expresi@'on relacional no pueda ser evaluada a @code{true} o @code{false},
el comportamiento de @code{is} y de @code{if} estar@'a controlado por la variable
global @code{prederror}. Si @code{prederror} toma el valor @code{true}, @code{is} y
@code{if} emiten un mensaje de error. Si @code{prederror} toma el valor @code{false},
@code{is} devuelve @code{unknown} y @code{if} devuelve una expresi@'on condicional
parcialmente evaluada.

@code{maybe} se comporta siempre como si @code{prederror} fuese @code{false},
al tiempo que @code{while} y @code{unless} se comportan siempre como si
@code{prederror} fuese @code{true}.

Los operadores relacionales no se distribuyen sobre listas ni sobre cualesquiera
otros tipos de estructuras de datos.

V@'eanse tambi@'en @code{=}, @code{#}, @code{equal} y @code{notequal}.

Ejemplos:

Las expresiones relacionales se reducen a valores booleanos a trav@'es de ciertas
funciones y sentencias condicionales.

@c ===beg===
@c [x, y, z] : [123, 456, 789];
@c is (x < y);
@c maybe (y > z);
@c if x >= z then 1 else 0;
@c block ([S], S : 0, 
@c        for i:1 while i <= 100 do S : S + i, return (S));
@c ===end===
@example
(%i1) [x, y, z] : [123, 456, 789];
(%o1)                    [123, 456, 789]
(%i2) is (x < y);
(%o2)                         true
(%i3) maybe (y > z);
(%o3)                         false
(%i4) if x >= z then 1 else 0;
(%o4)                           0
(%i5) block ([S], S : 0, 
             for i:1 while i <= 100 do S : S + i, return (S));
(%o5)                         5050
@end example

Las expresiones relacionales no se eval@'uan de otra manera, aunque sus
argumentos s@'{@dotless{i}} sean evaluados.

@c ===beg===
@c [x, y, z] : [123, 456, 789];
@c [x < y, y <= z, z >= y, y > z];
@c map (is, %);
@c ===end===
@example
(%o1)                    [123, 456, 789]
(%i2) [x < y, y <= z, z >= y, y > z];
(%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
(%i3) map (is, %);
(%o3)               [true, true, true, false]
@end example

@end deffn



@node Operadores generales, , Operadores relacionales, Operadores
@section Operadores generales


@deffn {Operator} ^^
@ifinfo
@fnindex Exponenciaci@'on no conmutativa
@end ifinfo

Operador de exponenciaci@'on no conmutativa.
Se trata del operador de exponenciaci@'on correspondiente a la
multiplicaci@'on no conmutativa @code{.}, del mismo modo que el
operador de exponenciaci@'on ordinario @code{^} se corresponde 
con la multiplicaci@'on conmutativa @code{*}.

La exponenciaci@'on no conmutativa se representa como @code{^^}
en las salidas no formateadas (@code{display2d=false}), o colocando un 
super@'{@dotless{i}}ndice entre @'angulos (@code{< >}) en la salida 
formateada (@code{display2d=true}).

Ejemplos:

@c ===beg===
@c a . a . b . b . b + a * a * a * b * b;
@c string (a . a . b . b . b + a * a * a * b * b);
@c ===end===
@example
(%i1) a . a . b . b . b + a * a * a * b * b;
                        3  2    <2>    <3>
(%o1)                  a  b  + a    . b
(%i2) string (a . a . b . b . b + a * a * a * b * b);
(%o2)                  a^3*b^2+a^^2 . b^^3
@end example

@end deffn



@deffn {Operador} !
@ifinfo
@fnindex Factorial
@end ifinfo
El operador factorial. 

Para cualquier n@'umero complejo @code{x}, excepto para
enteros negativos, @code{x!} se define como @code{gamma(x+1)}. 

Para un entero @code{x}, @code{x!} se reduce al producto de los enteros
desde 1 hasta @code{x} inclusive. @code{0!} se reduce a 1.
Para un n@'umero real o complejo en formato de coma flotante @code{x}, 
@code{x!} se reduce al valor de @code{gamma(x+1)}. Cuando
@code{x} es igual a @code{n/2}, siendo @code{n} un entero impar, entonces
@code{x!} se reduce a un factor racional multiplicado por @code{sqrt(%pi)}
(pues @code{gamma(1/2)}) es igual a @code{sqrt(%pi)}).

Las variables opcionales @code{factlim} y @code{gammalim} controlan la
evaluaci@'on num@'erica de factoriales de argumentos enteros y racionales.

Las funciones @code{minfactorial} y @code{factcomb} simplifican expresiones
que contiene factoriales.

V@'eanse tambi@'en @code{factlim}, @code{gammalim}, @code{minfactorial} y 
@code{factcomb}.

Las funciones @code{gamma}, @code{bffac} y @code{cbffac} son variaciones de
la funci@'on matem@'atica gamma. Las funciones @code{bffac} y @code{cbffac} 
son llamadas internamente desde @code{gamma} para evaluar la funci@'on gamma 
de n@'umeros reales y complejos decimales con precisi@'on de reales grandes
(bigfloats).

Las funciones @code{makegamma} substituye a @code{gamma} para factoriales 
y funciones relacionadas. 

Maxima reconoce la derivada de la funci@'on factorial y los l@'{@dotless{i}}mites
para ciertos valores espec@'{@dotless{i}}ficos, tales como los enteros negativos.

La variable opcional @code{factorial_expand} controla la simplificaci@'on de
expresiones como @code{(n+x)!}, para @code{n} entero.

V@'ease tambi@'en @code{binomial}.

Ejemplos:

El factorial de un entero se reduce a un n@'umero exacto, a menos que
el argumento sea mayor que @code{factlim}. Los factoriales de n@'umeros
reales o complejos se eval@'uan como decimales de coma flotante.

@c ===beg===
@c factlim : 10;
@c [0!, (7/2)!, 8!, 20!];
@c [4,77!, (1.0+%i)!];
@c [2.86b0!, 1.0b0+%i)!];
@c ===end===
@example
(%i1) factlim:10;
(%o1)                                 10
(%i2) [0!, (7/2)!, 8!, 20!];
                            105 sqrt(%pi)
(%o2)                   [1, -------------, 40320, 20!]
                                 16
(%i3) [4.77!, (1.0+%i)!];
(%o3)    [81.44668037931197, 
          .3430658398165454 %i + .6529654964201665]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 
       3.430658398165454b-1 %i + 6.529654964201667b-1]
@end example

El factorial de una constante conocida o de una expresi@'on general
no se calcula. Pero puede ser posible reducir el factorial despu@'es de
evaluado el argumento.

@c ===beg===
@c [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
@c ev (%, numer, %enumer);
@c ===end===
@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165454 %i + .6529654964201665, 
       7.188082728976031, 
       4.260820476357003, 1.227580202486819]
@end example

Los factoriales son simplificados o reducidos, no evaluados.
As@'{@dotless{i}} @code{x!} puede ser reemplazado en una expresi@'on 
nominal. 

@c ===beg===
@c '([0!, (7/2)!, 4.77!, 8!, 20!]);
@c ===end===
@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                             2432902008176640000]
@end example

Maxima reconoce la derivada de la funci@'on factorial.

@c ===beg===
@c diff(x!,x);
@c ===end===
@example
(%i1) diff(x!,x);
(%o1)                           x! psi (x + 1)
                                      0
@end example

La variable opcional @code{factorial_expand} controla la simplificaci@'on de
expresiones con la funci@'on factorial.

@c ===beg===
@c (n+1)!/n!,factorial_expand:true;
@c ===end===
@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                                n + 1
@end example
@end deffn

@deffn {Operador} !!
@ifinfo
@fnindex Doble factorial
@end ifinfo
El operador doble factorial.

Para un n@'umero entero, de punto flotante o racional @code{n},
@code{n!!} se evaluar@'a como el producto de @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
donde @code{k} es igual a @code{entier(n/2)}, que es, el mayor entero
menor o igual a @code{n/2}. 
Note que esta definici@'on no coincide con otras definciones publicadas para argumentos, los cuales no son enteros. 

@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para un entero par (o impar) @code{n}, @code{n!} se evalua el producto de
todos los enteros pares (o impares) consecutivos desde 2 (o 1) por @code{n} inclusive.  

Para un argumento @code{n} el cual no es un n@'umero entero, punto flotante o racional, @code{n!!} produce una forma de nombre @code{genfact (n, n/2, 2)}. 

@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn

@deffn {Operador} #
@ifinfo
@fnindex Negaci@'on de la igualdad sint@'actica
@end ifinfo
Representa la negaci@'on de la igualdad sint@'actica @code{=}.

N@'otese que debido a las reglas de evaluaci@'on de expresiones
de tipo predicado (en concreto debido a que @code{not @var{expr}}
obliga a la evaluaci@'on previa de @var{expr}), 
@code{not @var{a} = @var{b}} equivale a @code{is(@var{a} # @var{b})}, 
pero no a @code{@var{a} # @var{b}}.

Ejemplos:

@c ===beg===
@c a = b;
@c is (a = b);
@c a # b;
@c not a = b;
@c is (a # b);
@c is (not a = b);
@c ===end===
@example
(%i1) a = b;
(%o1)                         a = b
(%i2) is (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) is (a # b);
(%o5)                         true
(%i6) is (not a = b);
(%o6)                         true
@end example

@end deffn

@deffn {Operador} .
@ifinfo
@fnindex Multiplicaci@'on no conmutativa
@end ifinfo
El operador punto, para multiplicaci@'on de matrices (no-conmutativo). 
Cuando @code{"."} se usa de esta forma, se dejar@'an espacios a
ambos lados de @'este, como en @code{A . B}. As@'{@dotless{i}} se evita que se confunda con el punto decimal de los n@'umeros. 

V@'eanse:
@code{dot},
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident}
y
@code{dotscrules}.

@end deffn

@deffn {Operador} :
@ifinfo
@fnindex Operador de asignaci@'on
@end ifinfo
Operador de asignaci@'on.

Cuando el miembro de la izquierda es una variable simple (no subindicada),
@code{:} eval@'ua la expresi@'on de la derecha y asigna ese
valor a la variable del lado izquierdo.

Cuando en el lado izquierdo hay un elemento subindicado correspondiente a
una lista, matriz, array declarado de Maxima o array de Lisp, la expresi@'on de
la derecha se asigna a ese elemento. El sub@'{@dotless{i}}ndice debe hacer
referencia a un elemento ya existente, ya que los objetos anteriores no 
pueden ampliarse nombrando elementos no existentes.

Cuando en el lado izquierdo hay un elemento subindicado correspondiente a
un array no declarado de Maxima, la expresi@'on de la derecha se asigna a ese elemento
en caso de que ya exista, o a un nuevo elemento, si @'este todav@'{@dotless{i}}a
no existe.

Cuando el miembro de la izquierda es una lista de @'atomos y/o variables subindicadas,
el miembro derecho debe evaluar tambi@'en a una lista, cuyos elementos ser@'an
asignados en paralelo a las variables de la lista de la izquierda.

V@'eanse tambi@'en @code{kill} y @code{remvalue}, que deshacen las asociaciones
hechas por el operador @code{:}.

Ejemplos:

Asignaci@'on a una variable simple.

@c ===beg===
@c a;
@c a : 123;
@c a;
@c ===end===
@example
(%i1) a;
(%o1)                           a
(%i2) a : 123;
(%o2)                          123
(%i3) a;
(%o3)                          123
@end example

Asignaci@'on a un elemento de una lista.

@c ===beg===
@c b : [1, 2, 3];
@c b[3] : 456;
@c b;
@c ===end===
@example
(%i1) b : [1, 2, 3];
(%o1)                       [1, 2, 3]
(%i2) b[3] : 456;
(%o2)                          456
(%i3) b;
(%o3)                      [1, 2, 456]
@end example

La asignaci@'on crea un array no declarado.

@c ===beg===
@c c[99] : 789;
@c c[99];
@c c;
@c arrayinfo (c);
@c listarray (c);
@c ===end===
@example
(%i1) c[99] : 789;
(%o1)                          789
(%i2) c[99];
(%o2)                          789
(%i3) c;
(%o3)                           c
(%i4) arrayinfo (c);
(%o4)                   [hashed, 1, [99]]
(%i5) listarray (c);
(%o5)                         [789]
@end example

Asignaci@'on m@'ultiple.

@c ===beg===
@c [a, b, c] : [45, 67, 89];
@c a;
@c b;
@c c;
@c ===end===
@example
(%i1) [a, b, c] : [45, 67, 89];
(%o1)                     [45, 67, 89]
(%i2) a;
(%o2)                          45
(%i3) b;
(%o3)                          67
(%i4) c;
(%o4)                          89
@end example

La asignaci@'on m@'ultiple se hace en paralelo. Los valores
de @code{a} y @code{b} se intercambian en este ejemplo.

@c ===beg===
@c [a, b] : [33, 55];
@c [a, b] : [b, a];
@c a;
@c b;
@c ===end===
@example
(%i1) [a, b] : [33, 55];
(%o1)                       [33, 55]
(%i2) [a, b] : [b, a];
(%o2)                       [55, 33]
(%i3) a;
(%o3)                          55
(%i4) b;
(%o4)                          33
@end example
@end deffn

@deffn {Operador} ::
@ifinfo
@fnindex Operador de asignaci@'on (eval@'ua el miembro izquierdo)
@end ifinfo
Operador de asignaci@'on.

El operador @code{::} es similar a @code{:}, excepto que @code{::}
eval@'ua ambos miembros, tanto el derecho como el izquierdo.

Ejemplos:

@c ===beg===
@c x : 'foo;
@c x :: 123;
@c foo;
@c x : '[a, b, c];
@c x :: [11, 22, 33];
@c a;
@c b;
@c c;
@c ===end===
@example
(%i1) x : 'foo;
(%o1)                          foo
(%i2) x :: 123;
(%o2)                          123
(%i3) foo;
(%o3)                          123
(%i4) x : '[a, b, c];
(%o4)                       [a, b, c]
(%i5) x :: [11, 22, 33];
(%o5)                     [11, 22, 33]
(%i6) a;
(%o6)                          11
(%i7) b;
(%o7)                          22
(%i8) c;
(%o8)                          33
@end example
@end deffn

@deffn {Operador} ::=
@ifinfo
@fnindex Operador de definici@'on de funciones macro
@end ifinfo
El operador de definici@'on de macros @code{::=} define una funci@'on (llamada macro por razones hist@'oricas) que no eval@'ua sus argumentos, siendo la expresi@'on que retorna (llamada "macroexpansi@'on") evaluada dentro del contexto desde el cual se ha invocado la macro. En cualquier otro sentido, una funci@'on macro es igual que una funci@'on ordinaria.

@code{macroexpand} devuelve la expresi@'on que a su vez fue devuelta por una macro (sin evaluar la expresi@'on);
@code{macroexpand (foo (x))} seguida de @code{''%} es equivalente a @code{foo (x)} si @code{foo} es una funci@'on macro.

@code{::=} coloca el nombre de la nueva funci@'on macro en la lista global @code{macros}. Por otro lado, las funciones 
@code{kill}, @code{remove} y @code{remfunction} borran las definiciones de las funciones macro y eliminan sus nombres de la lista @code{macros}.

Las funciones @code{fundef} y @code{dispfun} devuelven la definici@'on de una funci@'on macro y le asignan una etiqueta, respectivamente.

Las funciones macro normalmente contienen expresiones @code{buildq} y @code{splice} para construir una expresi@'on, que luego ser@'a evaluada.

Ejemplos:

Una funci@'on macro no eval@'ua sus argumentos, por lo que el mensaje (1) muestra @code{y - z}, no el valor de @code{y - z}.
La macroexpansi@'on (es decir, la expresi@'on no evaluada @code{'(print ("(2) x is equal to", x))}) se eval@'ua en el contexto desde el cual se produjo la llamada a la macro, imprimiendo el mensaje (2).

@c ===beg===
@c x: %pi$
@c y: 1234$
@c z: 1729 * w$
@c printq1 (x) ::= block (print ("(1) x is equal to", x), 
@c                                 '(print ("(2) x is equal to", x)))$
@c printq1 (y - z);
@c ===end===
@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
'(print ("(2) x is equal to", x)))$

(%i5) printq1 (y - z);
(1) x is equal to y - z
(2) x is equal to %pi
(%o5)                                 %pi
@end example


Una funci@'on ordinaria eval@'ua sus argumentos, por lo que el mensaje (1) muestra el valor de @code{y - z}.
El valor de retorno no se eval@'ua, por lo que el mensaje (2) no se imprime hasta la evaluaci@'on expl@'{@dotless{i}}cita @code{''%}.

@c ===beg===
@c x: %pi$
@c y: 1234$
@c z: 1729 * w$
@c printe1 (x) := block (print ("(1) x is equal to", x), 
@c       '(print ("(2) x is equal to", x)))$
@c printe1 (y - z);
@c ''%;
@c ===end===
@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) printe1 (x) := block (print ("(1) x is equal to", x),
'(print ("(2) x is equal to", x)))$

(%i5) printe1 (y - z);
(1) x is equal to 1234 - 1729 w
(%o5)                     print((2) x is equal to, x)
(%i6) ''%;
(2) x is equal to %pi
(%o6)                                 %pi
@end example
@end deffn


@code{macroexpand} devuelve la macroexpansi@'on;
@code{macroexpand (foo (x))} seguida de @code{''%} es equivalente a @code{foo (x)} si @code{foo} es una funci@'on macro.

@c ===beg===
@c x: %pi$
@c y: 1234$
@c z: 1729 * w$
@c g (x) ::= buildq ([x], print ("x is equal to", x))$
@c macroexpand (g (y - z));
@c ''%;
@c g (y - z);
@c ===end===
@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$

(%i5) macroexpand (g (y - z));
(%o5)                     print(x is equal to, y - z)
(%i6) ''%;
x is equal to 1234 - 1729 w
(%o6)                            1234 - 1729 w
(%i7) g (y - z);
x is equal to 1234 - 1729 w
(%o7)                            1234 - 1729 w
@end example


@deffn {Operador} :=
@ifinfo
@fnindex Operador de definici@'on de funciones
@end ifinfo

El operador de definici@'on de funciones. 
La expresi@'on @code{@var{f}(@var{x_1}, ..., @var{x_n}) := @var{expr}}
define una funci@'on de nombre @var{f} con argumentos
@var{x_1}, ..., @var{x_n} y cuerpo @var{expr}.
El operador @code{:=} no eval@'ua el cuerpo de la funci@'on (a menos que
se indique lo contrario mediante el operador comilla-comilla @code{'@w{}'}).
La funci@'on as@'{@dotless{i}} definida puede ser una funci@'on ordinaria
de Maxima (con argumentos encerrados entre par@'entesis) o una funci@'on
array (con argumentos encerrados entre corchetes).

Cuando el @'ultimo o @'unico argumento @var{x_n} es una lista de un solo
elemento, la funci@'on definida por @code{:=} acepta un n@'umero variable
de argumentos. Los valores de los argumentos se asignan uno a uno a los
argumentos formales @var{x_1}, ..., @var{x_(n - 1)}, y cualesquiera otros
valores de argumentos, si existen, se asignan a @var{x_n} en forma de lista.

Todas las definiciones de funciones aparecen en el mismo espacio de
nombres; definiendo una funci@'on @code{f} dentro de otra funci@'on @code{g}
no limita autom@'aticamente el alcance de @code{f} a @code{g}.
No obstante, @code{local(f)} hace que la funci@'on @code{f}
sea efectiva solamente dentro del bloque o empaquetado de expresiones en la
que aparece @code{local}.

Si un argumento formal @var{x_k} es un s@'{@dotless{i}}mbolo afectado por el
operador comilla (expresi@'on nominal), la funci@'on definida por @code{:=} no eval@'ua el
correspondiente valor de argumento. 
En cualquier otro caso, los argumentos que se pasan son evaluados.

V@'eanse tambi@'en @code{define} y @code{::=}.

Ejemplos:

@code{:=} no eval@'ua el cuerpo de la funci@'on (a menos que
se indique lo contrario mediante el operador comilla-comilla @code{'@w{}'}).

@c ===beg===
@c expr : cos(y) - sin(x);
@c F1 (x, y) := expr;
@c F1 (a, b);
@c F2 (x, y) := ''expr;
@c F2 (a, b);
@c ===end===
@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) F1 (x, y) := expr;
(%o2)                   F1(x, y) := expr
(%i3) F1 (a, b);
(%o3)                    cos(y) - sin(x)
(%i4) F2 (x, y) := ''expr;
(%o4)              F2(x, y) := cos(y) - sin(x)
(%i5) F2 (a, b);
(%o5)                    cos(b) - sin(a)
@end example

La funci@'on as@'{@dotless{i}} definida puede ser una funci@'on ordinaria
de Maxima o una funci@'on array.

@c ===beg===
@c G1 (x, y) := x.y - y.x;
@c G2 [x, y] := x.y - y.x;
@c ===end===
@example
(%i1) G1 (x, y) := x.y - y.x;
(%o1)               G1(x, y) := x . y - y . x
(%i2) G2 [x, y] := x.y - y.x;
(%o2)                G2     := x . y - y . x
                       x, y
@end example

Cuando el @'ultimo o @'unico argumento @var{x_n} es una lista de un solo
elemento, la funci@'on definida por @code{:=} acepta un n@'umero variable
de argumentos.

@c ===beg===
@c H ([L]) := apply ("+", L);
@c H (a, b, c);
@c ===end===
@example
(%i1) H ([L]) := apply ("+", L);
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

@code{local} define una funci@'on como local.

@c ===beg===
@c foo (x) := 1 - x;
@c foo (100);
@c block (local (foo), foo (x) := 2 * x, foo (100));
@c foo (100);
@c ===end===
@example
(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
@end example
@end deffn


@deffn {Operador} =
@ifinfo
@fnindex Operador de ecuaci@'on
@fnindex Igualdad sint@'actica
@end ifinfo
Operador de ecuaci@'on.

La expresi@'on @code{@var{a} = @var{b}} representa una ecuaci@'on
sin evaluar, la cual puede verificarse o no. Las ecuaciones sin evaluar 
pueden aparecer como argumentos de @code{solve}, @code{algsys}
y de algunas otras funciones.

La funci@'on @code{is} eval@'ua el operador @code{=} a un
resultado booleano; @code{is(@var{a} = @var{b})} asigna un valor
de verdad a @code{@var{a} = @var{b}}, siendo @code{true} si
@var{a} y @var{b} son id@'enticos, lo cual acontece si
ambos @var{a} y @var{b} son @'atomos id@'enticos, o si no
siendo @'atomos, sus operadores y argumentos respectivos
son id@'enticos; en caso contrario, @code{is(@var{a} = @var{b})}
devuelve el valor  @code{false}. Nunca se devuelve el valor @code{unknown}.
Cuando @code{is(@var{a} = @var{b})} toma el valor @code{true}, 
se dice que @var{a} y @var{b} son sint@'acticamente iguales,
no expresiones equivalentes, para las cuales 
@code{is(equal(@var{a}, @var{b}))} devuelve @code{true}.
Las expresiones pueden ser equivalentes, pero no 
sint@'acticamente iguales.

La negaci@'on de @code{=} se representa por @code{#}.
Como en el caso de @code{=}, la expresi@'on 
@code{@var{a} # @var{b}} no est@'a evaluada; sin embargo,
@code{is(@var{a} # @var{b})} eval@'ua @code{@var{a} # @var{b}}
a @code{true} o @code{false}.

Adem@'as de @code{is}, hay otros operadores que eval@'uan 
@code{=} y @code{#} a @code{true} o @code{false};
a saber, @code{if}, @code{and}, @code{or} y @code{not}.

N@'otese que debido a las reglas de evaluaci@'on de expresiones
de tipo predicado (en concreto debido a que @code{not @var{expr}}
obliga a la evaluaci@'on previa de @var{expr}), 
@code{not @var{a} = @var{b}} equivale a @code{is(@var{a} # @var{b})}, 
pero no a @code{@var{a} # @var{b}}.

Las funciones @code{rhs} y @code{lhs} devuelven los miembros
derecho e izquierdo, respectivamente, de una ecuaci@'on o inecuaci@'on.

V@'eanse tambi@'en @code{equal} y @code{notequal}.

Ejemplos:

La expresi@'on @code{@var{a} = @var{b}} representa una ecuaci@'on
sin evaluar, la cual puede verificarse o no.

@c ===beg===
@c eq_1 : a * x - 5 * y = 17;
@c eq_2 : b * x + 3 * y = 29;
@c solve ([eq_1, eq_2], [x, y]);
@c subst (%, [eq_1, eq_2]);
@c ratsimp (%);
@c ===end===
@example
(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
@end example

@code{is(@var{a} = @var{b})} eval@'ua @code{@var{a} = @var{b}} 
a @code{true} si @var{a} y @var{b}
son sint@'acticamente iguales (es decir, id@'enticas).
Las expresiones pueden ser equivalentes, pero no 
sint@'acticamente iguales.

@c ===beg===
@c a : (x + 1) * (x - 1);
@c b : x^2 - 1;
@c [is (a = b), is (a # b)];
@c [is (equal (a, b)), is (notequal (a, b))];
@c ===end===
@example
(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
@end example

Algunos operadores eval@'uan @code{=} y @code{#} a @code{true} o @code{false}.

@c ===beg===
@c if expand ((x + y)^2) = x^2 + 2 * x * y + y^2
@c    then FOO else BAR;
@c eq_3 : 2 * x = 3 * x;
@c eq_4 : exp (2) = %e^2;
@c [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
@c ===end===
@example
(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2
        then FOO else BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
@end example

Debido a que @code{not @var{expr}}
obliga a la evaluaci@'on previa de @var{expr}, 
@code{not @var{a} = @var{b}} equivale a @code{is(@var{a} # @var{b})}.

@c ===beg===
@c [2 * x # 3 * x, not (2 * x = 3 * x)];
@c is (2 * x # 3 * x);
@c ===end===
@example
(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
@end example

@end deffn



@deffn {Operador} and
@ifinfo
@fnindex Conjunci@'on l@'ogica
@end ifinfo
Operador de conjunci@'on l@'ogica.
El operador @code{and} es un operador infijo @code{n}-ario;
sus operandos son expresiones booleanas y su resultado es un valor l@'ogico.

El operador @code{and} impone la evaluaci@'on (igual que @code{is}) de uno o m@'as operandos,
y puede forzar la evaluaci@'on de todos los operandos.

Los operandos se eval@'uan en el orden en el que aparecen; 
s@'olo eval@'ua tantos operandos como sean necesarios para determinar el resultado.
Si alg@'un operando vale @code{false},
el resultado es @code{false} y ya no se eval@'uan m@'as operandos.

La variable global @code{prederror} controla el comportamiento de @code{and}
cuando la evaluaci@'on de un operando no da como resultado @code{true} o @code{false};
@code{and} imprime un mensaje de error cuando @code{prederror} vale @code{true}.
Cuando los operandos devuelven un valor diferente a @code{true} o @code{false}
al ser evaluados, el resultado es una expresi@'on booleana.

El operador @code{and} no es conmutativo:
@code{a and b} puede no ser igual a @code{b and a} debido al tratamiento de operandos indeterminados.

@end deffn



@deffn {Operador} or
@ifinfo
@fnindex Disyunci@'on l@'ogica
@end ifinfo
Operador de disyunci@'on l@'ogica. El operador @code{or} es un operador infijo @code{n}-ario;
sus operandos son expresiones booleanas y su resultado es un valor l@'ogico.

El operador @code{or} impone la evaluaci@'on (igual que @code{is}) de uno o m@'as operandos,
y puede forzar la evaluaci@'on de todos los operandos.

Los operandos se eval@'uan en el orden en el que aparecen; @code{or} s@'olo eval@'ua tantos operandos como sean necesarios para determinar el resultado. Si un operando vale @code{true}, el resultado es @code{true} y ya no se eval@'uan m@'as operandos.

La variable global @code{prederror} controla el comportamiento 
de @code{or} cuando la evaluaci@'on de un operando no da como 
resultado @code{true} o @code{false}; @code{or} imprime un 
mensaje de error cuando @code{prederror} vale @code{true}.
Cuando los operandos devuelven un valor diferente a @code{true} o @code{false}
al ser evaluados, el resultado es una expresi@'on booleana.

El operador @code{or} no es conmutativo: @code{a or b} puede no ser igual a @code{b or a} debido al tratamiento de operandos indeterminados.

@end deffn

@deffn {Operador} not
@ifinfo
@fnindex Negaci@'on l@'ogica
@end ifinfo
Operador de negaci@'on l@'ogica. El operador @code{not} es un operador prefijo;
su operando es una expresi@'on booleana y su resultado es un valor l@'ogico.

El operador @code{not} impone la evaluaci@'on (igual que @code{is}) de su operando.

La variable global @code{prederror} controla el comportamiento de
@code{not} cuando la evaluaci@'on de su operando no da como 
resultado @code{true} o @code{false}; @code{not} imprime un mensaje 
de error cuando @code{prederror} vale @code{true}.
Cuando los operandos devuelven un valor diferente a @code{true} o @code{false}
al ser evaluados, el resultado es una expresi@'on booleana.

@end deffn


@deffn {Funci@'on} abs (@var{expr})
Devuelve el valor absoluto de @var{expr}. Si la expresi@'on es compleja, retorna
el m@'odulo de @var{expr}.

@end deffn

@defvr {Clave} additive
Si @code{declare(f,additive)} ha sido ejecutado, entonces: 

(1) Si @code{f} es univariado, cada vez que el simplificador encuentre
@code{f} aplicada a una suma, @code{f} ser@'a distribuida bajo esta suma. Por ejemplo, @code{f(x+y)} se simplificar@'a a @code{f(x)+f(y)}. 

(2) Si @code{f} es una funci@'on de 2 o m@'as argumentos, aditivamente es definida como aditiva en el primer argumento de @code{f}, como en el caso de @code{sum} o @code{integrate}. Por ejemplo, @code{f(h(x)+g(x),x)} se simplificar@'a a @code{f(h(x),x)+f(g(x),x)}. Esta simplificaci@'on no ocurre cuando @code{f} se aplica a expresiones de la forma @code{sum(x[i],i,lower-limit,upper-limit)}.

@end defvr

@defvr {Clave} allbut
Opera con los comandos @code{part} (como @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart} y @code{lpart}). Por ejemplo:

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, [2, 5]);
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

mientras que: 

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, allbut (2, 5));
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
@end example

La funci@'on @code{kill} tambi@'en reconoce a @code{allbut}.

@c ===beg===
@c [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
@c kill (allbut (cc, dd));
@c [aa, bb, cc, dd];
@c ===end===
@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example

La sentencia @code{kill(allbut(@var{a_1}, @var{a_2}, ...))}
tiene el mismo efecto que @code{kill(all)}, excepto que no
elimina los s@'{@dotless{i}}mbolos @var{a_1}, @var{a_2}, ... .

@end defvr

@defvr {Declaraci@'on} antisymmetric
Si @code{declare(h,antisymmetric)} es ejecutado, esto dice al 
simplificador que @code{h} es antisim@'etrico. E.g. @code{h(x,z,y)} ser@'a simplificado a @code{-h(x,y,z)}. Que es, el producto de (-1)^n por el resultado dado por @code{symmetric} o @code{commutative}, donde n es el n@'umero de intercambios necesarios de dos argumentos para convertirle a esta forma.  

@end defvr

@deffn {Funci@'on} cabs (@var{expr})
Devuelve el valor absoluto complejo (m@'odulo complejo) de @var{expr}.

@end deffn



@deffn {Funci@'on} ceiling (@var{x})

Si @var{x} es un n@'umero real, devuelve el menor entero mayor o igual que @var{x}.  

Si @var{x} es una expresi@'on constante (por ejemplo, @code{10 * %pi}), 
@code{ceiling} eval@'ua @var{x} haciendo uso de n@'umeros grandes en coma flotante (big floats), aplicando a continuaci@'on
 @code{ceiling} al n@'umero decimal obtenido. Puesto que @code{ceiling} hace evaluaciones en coma flotante, es posible, pero improbable, que esta funci@'on devuelva un valor err@'oneo para entradas constantes. Para evitar estos errores, la evaluaci@'on en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{ceiling} intenta devolver un valor simplificado. Aqu@'{@dotless{i}} se presentan algunos ejemplos sobre las simplificaciones que @code{ceiling} es capaz de hacer:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                                false
@end example

La funci@'on @code{ceiling} no se extiende autom@'aticamente a los elementos de listas y matrices.
Por @'ultimo, para todos los argumentos que tengan una forma compleja, @code{ceiling} devuelve una forma nominal.

Si el rango de una funci@'on es subconjunto de los n@'umeros enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta informaci@'on; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn

@deffn {Funci@'on} charfun (@var{p})

Devuelve 0 cuando el predicado @var{p} toma el valor @code{false}, y devuelve
1 cuando vale @code{true}.  Si el predicado toma un valor diferente de @code{true} y @code{false} (desconocido), 
entonces devuelve una forma nominal.

Ejemplos:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun(x<1);
(%o1) charfun(x<1)
(%i2) subst(x=-1,%);
(%o2) 1
(%i3) e : charfun('"and"(-1 < x, x < 1))$
(%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
(%o4) [0,1,0]
@end example

@end deffn


@defvr {Declaraci@'on} commutative
Si @code{declare(h,commutative)} es ejecutado, le dice al simplificador
que @code{h} es una funci@'on conmutaiva. Por ejemplo, @code{h(x,z,y)} se simplificar@'a a @code{h(x,y,z)}. Esto es lo mismo que @code{symmetric}. 

@end defvr


@deffn {Funci@'on} compare (@var{x}, @var{y})

Devuelve un operador de comparaci@'on @var{op}
(@code{<}, @code{<=}, @code{>}, @code{>=}, @code{=} o @code{#}) de manera que
@code{is (@var{x} @var{op} @var{y})} tome el valor @code{true};
cuando tanto @var{x} como @var{y} dependan de @code{%i} y
@code{@var{x} # @var{y}}, devuelve @code{notcomparable};
cuando no exista tal operador o Maxima sea incapaz de determinarlo, devolver@'a @code{unknown}.

Ejemplos:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare(1,2);
(%o1) <
(%i2) compare(1,x);
(%o2) unknown
(%i3) compare(%i,%i);
(%o3) =
(%i4) compare(%i,%i+1);
(%o4) notcomparable
(%i5) compare(1/x,0);
(%o5) #
(%i6) compare(x,abs(x));
(%o6) <=
@end example

La funci@'on @code{compare} no intenta determinar si los dominios reales de sus argumentos son conjuntos no vac@'{@dotless{i}}os; as@'{@dotless{i}},

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
(%o1) <
@end example

Aqu@'{@dotless{i}}, el dominio real de @code{acos (x^2 + 1)} es el conjunto vac@'{@dotless{i}}o.

@end deffn


@deffn {Funci@'on} entier (@var{x})
Devuelve el mayor entero menor o igual a @var{x}, siendo @var{x} num@'erico. La funci@'on  @code{fix} (como en
@code{fixnum}) es un sin@'onimo, de modo que @code{fix(@var{x})} hace justamente lo mismo.

@end deffn

@deffn {Funci@'on} equal (@var{a}, @var{b})
Representa la equivalencia, esto es, la igualdad de los valores.

Por s@'{@dotless{i}} misma, @code{equal} no eval@'ua ni simplifica.
La funci@'on @code{is} intenta evaluar @code{equal} a un resultado
booleano. La instrucci@'on @code{is(equal(@var{a}, @var{b}))}
devuelve @code{true} (o @code{false}) si y s@'olo si
@var{a} y @var{b} son iguales (o no iguales) para todos los posibles
valores de sus variables, tal como lo determina @code{ratsimp(@var{a} - @var{b})};
si @code{ratsimp} devuelve 0, las dos expresiones se consideran
equivalentes. Dos expresiones pueden ser equivalentes  sin
ser sint@'acticamente iguales (es decir, id@'enticas).

Si @code{is} no consigue reducir @code{equal} a @code{true} o @code{false},
el resultado est@'a controlado por la variable global @code{prederror}.
Si @code{prederror} vale @code{true}, @code{is} emite un mensaje
de error; en caso contrario, @code{is} devuelve @code{unknown}.

Adem@'as de @code{is}, otros operadores eval@'uan @code{equal} y @code{notequal}
a  @code{true} o @code{false}; a saber, @code{if}, @code{and}, @code{or} y @code{not}.

La negaci@'on de @code{equal} es @code{notequal}.

Ejemplos:

Por s@'{@dotless{i}} misma, @code{equal} no eval@'ua ni simplifica.

@c ===beg===
@c equal (x^2 - 1, (x + 1) * (x - 1));
@c equal (x, x + 1);
@c equal (x, y);
@c ===end===
@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

La funci@'on @code{is} intenta evaluar @code{equal} a un resultado
booleano. La instrucci@'on @code{is(equal(@var{a}, @var{b}))}
devuelve @code{true} si @code{ratsimp(@var{a} - @var{b})}
devuelve 0. Dos expresiones pueden ser equivalentes  sin
ser sint@'acticamente iguales (es decir, id@'enticas).

@c ===beg===
@c ratsimp (x^2 - 1 - (x + 1) * (x - 1));
@c is (equal (x^2 - 1, (x + 1) * (x - 1)));
@c is (x^2 - 1 = (x + 1) * (x - 1));
@c ratsimp (x - (x + 1));
@c is (equal (x, x + 1));
@c is (x = x + 1);
@c ratsimp (x - y);
@c is (equal (x, y));
@c is (x = y);
@c ===end===
@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
@end example

Si @code{is} no consigue reducir @code{equal} a @code{true} o @code{false},
el resultado est@'a controlado por la variable global @code{prederror}.

@c ===beg===
@c [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
@c ratsimp (aa - bb);
@c prederror : true;
@c is (equal (aa, bb));
@c prederror : false;
@c is (equal (aa, bb));
@c ===end===
@example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

Otros operadores eval@'uan @code{equal} y @code{notequal}
a  @code{true} o @code{false}.

@c ===beg===
@c if equal (y, y - 1) then FOO else BAR;
@c eq_1 : equal (x, x + 1);
@c eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
@c [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
@c ===end===
@example
(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

Debido a que @code{not @var{expr}}
obliga a la evaluaci@'on previa de @var{expr}, 
@code{not equal(@var{a}, @var{b})} equivale a @code{is(notequal(@var{a}, @var{b}))}.

@c ===beg===
@c [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
@c is (notequal (2*z, 2*z - 1));
@c ===end===
@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example
@end deffn


@deffn {Funci@'on} floor (@var{x})

Si @var{x} es un n@'umero real, devuelve el mayor entero menor o igual que @var{x}.

Si @var{x} es una expresi@'on constante (por ejemplo, @code{10 * %pi}), 
@code{floor} eval@'ua @var{x} haciendo uso de n@'umeros grandes en coma flotante (big floats), aplicando a continuaci@'on
 @code{floor} al n@'umero decimal obtenido. Puesto que @code{floor} hace evaluaciones en coma flotante, es posible, pero improbable, que esta funci@'on devuelva un valor err@'oneo para entradas constantes. Para evitar estos errores, la evaluaci@'on en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{floor} intenta devolver un valor simplificado. Aqu@'{@dotless{i}} se presentan algunos ejemplos sobre las simplificaciones que @code{floor} es capaz de hacer:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a));
@c ===end===
@example
(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
@end example

La funci@'on @code{floor} no se extiende autom@'aticamente a los elementos de listas y matrices.
Por @'ultimo, para todos los argumentos que tengan una forma compleja, @code{floor} devuelve una forma nominal.

Si el rango de una funci@'on es subconjunto de los n@'umeros enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta informaci@'on; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn

@deffn {Funci@'on} notequal (@var{a}, @var{b})
Representa la negaci@'on de @code{equal (@var{a}, @var{b})}.

Ejemplos:

@c ===beg===
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c maybe (notequal (a, b));
@c ===end===
@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a > b);
(%o6)                        [a > b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
@end example

@end deffn


@deffn {Funci@'on} evenp (@var{expr})
Devuelve @code{true} si @var{expr} es un entero par y @code{false} en cualquier otro caso.

@end deffn

@deffn {Funci@'on} fix (@var{x})
Es un sin@'onimo de  @code{entier (@var{x})}.

@end deffn

@deffn {Funci@'on} fullmap (@var{f}, @var{expr_1}, ...)
Similar a @code{map}, pero conservar@'a el mapeado
descendente de todas las subexpresiones hasta que los operadores
principales ya no sean los mismos.

La funci@'on @code{fullmap} es utilizada por el simplificador de Maxima
en algunas transformaciones matriciales, por lo que Maxima generar@'a en algunas ocasiones mensajes de error relacionados con @code{fullmap} aunque el usuario no haya invocado expl@'{@dotless{i}}citamente esta funci@'on.

@c ===beg===
@c a + b * c;
@c fullmap (g, %);
@c map (g, %th(2));
@c ===end===
@example
(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@end deffn

@deffn {Funci@'on} fullmapl (@var{f}, @var{list_1}, ...)
Similar a @code{fullmap}, pero @code{fullmapl} s@'olo hace mapeo
sobre listas y matrices.

@c ===beg===
@c fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
@c ===end===
@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@end deffn

@deffn {Funci@'on} is (@var{expr})
Intenta determinar si el predicado @var{expr}  se puede deducir de los hechos almacenados en la base de datos gestionada por @code{assume}.

Si el predicado se reduce a @code{true} o @code{false},
@code{is} devuelve @code{true} o @code{false}, respectivamente.
En otro caso, el valor devuelto est@'a controlado por la variable global @code{prederror}.
Si @code{prederror} vale @code{true}, @code{is} emite un mensaje de error;
en caso contrario, @code{is} devuelve @code{unknown}.

La instrucci@'on @code{ev(@var{expr}, pred)}
(que puede escribirse como @code{@var{expr}, pred} en el
modo interactivo) equivale a @code{is(@var{expr})}.

V@'eanse tambi@'en @code{assume}, @code{facts} y @code{maybe}.

Ejemplos:

@code{is} eval@'ua los predicados,

@c ===beg===
@c %pi > %e;
@c is (%pi > %e);
@c ===end===
@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) is (%pi > %e);
(%o2)                         true
@end example

@code{is} intenta evaluar predicados a partir 
del conocimiento almacenado en la base de datos de @code{assume}.

@c ===beg===
@c assume (a > b);
@c assume (b > c);
@c is (a < b);
@c is (a > c);
@c is (equal (a, c));
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) is (a < b);
(%o3)                         false
(%i4) is (a > c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
@end example

Si @code{is} no puede evaluar el valor l@'ogico del predicado 
a partir de la base de datos gestionada por @code{assume},
la variable global  @code{prederror} controla el comportamiento de @code{is}.

@c ===beg===
@c assume (a > b);
@c prederror: true$
@c is (a > 0);
@c prederror: false$
@c is (a > 0);
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) is (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a > 0);
(%o5)                        unknown
@end example

@end deffn

@deffn {Funci@'on} maybe (@var{expr})
Intenta determinar si el predicado @var{expr}  se puede deducir de los hechos almacenados en la base de datos gestionada por @code{assume}.

Si el predicado se reduce a @code{true} o @code{false},
@code{maybe} devuelve @code{true} o @code{false}, respectivamente.
En otro caso, @code{maybe} devuelve @code{unknown}.

La funci@'on @code{maybe} es funcionalmente equivalente a @code{is} con @code{prederror: false},
pero el resultado se calcula sin asignar valor alguno a @code{prederror}.

V@'eanse tambi@'en @code{assume}, @code{facts} y @code{is}.

Ejemplos:

@c ===beg===
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);
@c ===end===
@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example

@end deffn

@deffn {Funci@'on} isqrt (@var{x})
Devuelve la "ra@'{@dotless{i}}z cuadrada entera"
del valor absoluto de @var{x},
el cual debe ser un entero.

@end deffn

@deffn {Funci@'on} lmax (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('max, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, env@'{@dotless{i}}a un mensaje de error.
@end deffn

@deffn {Funci@'on} lmin (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('min, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, env@'{@dotless{i}}a un mensaje de error.
@end deffn


@deffn {Funci@'on} max (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la mayor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o m@'as, @code{max} aplica la simplificaci@'on 
@code{max (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o m@'as, @var{max} intenta
eliminar las expresiones que est@'en entre otros dos de los argumentos dados; por ejemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Funci@'on} min (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la menor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o m@'as, @code{min} aplica la simplificaci@'on 
@code{min (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o m@'as, @var{min} intenta
eliminar las expresiones que est@'en entre otros dos de los argumentos dados; por ejemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Funci@'on} polymod (@var{p})
@deffnx {Funci@'on} polymod (@var{p}, @var{m})
Convierte el polinomio @var{p} a una representaci@'on modular respecto del m@'odulo actual, que es el valor almacenado en la variable @code{modulus}.  

La llamada @code{polymod (@var{p}, @var{m})} especifica un m@'odulo @var{m} para ser utilizado en lugar de valor almacenado en @code{modulus}.

V@'ease @code{modulus}.
@end deffn

@deffn {Funci@'on} mod (@var{x}, @var{y})

Si @var{x} e @var{y} son n@'umeros reales e @var{y} es distinto de cero,
devuelve @code{@var{x} - @var{y} * floor(@var{x} / @var{y})}.
Para todos los reales @var{x}, se tiene @code{mod (@var{x}, 0) = @var{x}}. Para informaci@'on sobre la definici@'on de  @code{mod (@var{x}, 0) = @var{x}}, v@'ease la secci@'on 3.4 de "Concrete Mathematics", 
by Graham, Knuth, and Patashnik. La funci@'on @code{mod (@var{x}, 1)} es de diente de sierra con periodo unidad y con @code{mod (1, 1) = 0} y @code{mod (0, 1) = 0}.

Para encontrar el argumento principal (un n@'umero del intervalo @code{(-%pi, %pi]}) de un n@'umero complejo, h@'agase uso de la funci@'on @code{@var{x} |-> %pi - mod (%pi - @var{x}, 2*%pi)}, donde @var{x} es un argumento.

Si @var{x} e @var{y} son expresiones constantes (por ejemplo, @code{10 * %pi}), @code{mod} utiliza el mismo esquema de evaluaci@'on basado en n@'umeros grandes en coma flotante (big floats) que @code{floor} y @code{ceiling}. Tambi@'en es posible, pero improbable, que @code{mod} pueda retornar un valor err@'oneo en tales casos.

Para argumentos no num@'ericos @var{x} o @var{y}, @code{mod} aplica algunas reglas de simplificaci@'on:

@c ===beg===
@c mod (x, 0);
@c mod (a*x, a*y);
@c mod (0, x);
@c ===end===
@example
(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
@end example
@end deffn

@deffn {Funci@'on} oddp (@var{expr})
Devuelve @code{true} si @var{expr} es un entero impar y @code{false} en caso contrario.

@end deffn


@deffn {Funci@'on} make_random_state (@var{n})
@deffnx {Funci@'on} make_random_state (@var{s})
@deffnx {Funci@'on} make_random_state (true)
@deffnx {Funci@'on} make_random_state (false)

Un objeto de estado aleatorio representa el estado del generador de n@'umeros aleatorios. El estado consiste en 627 cadenas binarias de 32 bits.

La llamada @code{make_random_state (@var{n})} devuelve un nuevo objeto de estado aleatorio creado a partir de una semilla entera igual a @var{n} m@'odulo 2^32. El argumento @var{n} puede ser negativo.

La llamada @code{make_random_state (@var{s})} devuelve una copia del estado aleatorio @var{s}.

La llamada @code{make_random_state (true)} devuelve un nuevo objeto de estado aleatorio, cuya semilla se genera a partir de la hora actual del reloj del sistema como semilla.

La llamada @code{make_random_state (false)} devuelve una copia del estado actual del generador de n@'umeros aleatorios.

@end deffn

@deffn {Funci@'on} set_random_state (@var{s})
Establece @var{s} como estado del generador de n@'umeros aleatorios.

La funci@'on @code{set_random_state} devuelve @code{done} en todo caso.

@end deffn

@deffn {Funci@'on} random (@var{x})
Devuelve un n@'umero seudoaleatorio. Si @var{x} es un entero, @code{random (@var{x})} devuelve un
entero entre 0 y @code{@var{x} - 1}, ambos inclusive. Si @var{x} es un decimal en punto flotante,
@code{random (@var{x})} devuelve un decimal no negativo en punto flotante menor que @var{x}.
La funci@'on @code{random} emite un mensaje de error si @var{x} no es ni entero ni de punto flotante,
o si @var{x} no es positivo.

Las funciones @code{make_random_state} y @code{set_random_state}
permiten controlar el estado del generador de n@'umeros aleatorios.

El generador de n@'umeros aleatorios de Maxima implementa el algoritmo de Mersenne twister MT 19937.

Ejemplos:

@c ===beg===
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c ===end===
@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn


@deffn {Funci@'on} rationalize (@var{expr})
Convierte todos los n@'umeros en coma flotante de doble precisi@'on y grandes (big float) presentes en una expresi@'on @var{expr} de Maxima a sus formas racionales exactas equivalentes. Si el usuario no est@'a familiarizado con la representaci@'on binaria de n@'umeros en coma flotante, le puede extra@~nar que @code{rationalize (0.1)} no sea igual que 1/10.  Este comportamiento no es @'unico de Maxima, ya que el n@'umero 1/10 en su forma binaria es peri@'odico y no exacto.

@c ===beg===
@c rationalize (0.5);
@c rationalize (0.1);
@c fpprec : 5$
@c rationalize (0.1b0);
@c fpprec : 20$
@c rationalize (0.1b0);
@c rationalize (sin (0.1*x + 5.6));
@c ===end===
@example
(%i1) rationalize (0.5);
                                1
(%o1)                           -
                                2
(%i2) rationalize (0.1);
                               1
(%o2)                          --
                               10
(%i3) fpprec : 5$
(%i4) rationalize (0.1b0);
                             209715
(%o4)                        -------
                             2097152
(%i5) fpprec : 20$
(%i6) rationalize (0.1b0);
                     236118324143482260685
(%o6)                ----------------------
                     2361183241434822606848
(%i7) rationalize (sin (0.1*x + 5.6));
                              x    28
(%o7)                     sin(-- + --)
                              10   5
@end example

Ejemplo de uso:

@c ===beg===
@c unitfrac(r) := block([uf : [], q],
@c     if not(ratnump(r)) then
@c       error("The input to 'unitfrac' must be a rational number"),
@c     while r # 0 do (
@c         uf : cons(q : 1/ceiling(1/r), uf),
@c         r : r - q),
@c     reverse(uf)); 
@c unitfrac (9/10);
@c apply ("+", %);
@c unitfrac (-9/10);
@c apply ("+", %);
@c unitfrac (36/37);
@c apply ("+", %);
@c ===end===
@example
(%i1) unitfrac(r) := block([uf : [], q],
    if not(ratnump(r)) then
      error("The input to 'unitfrac' must be a rational number"),
    while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
    reverse(uf)); 
(%o1) unitfrac(r) := block([uf : [], q], 
if not ratnump(r) then 
  error("The input to 'unitfrac' must be a rational number"),
                                     1
while r # 0 do (uf : cons(q : ----------, uf), r : r - q), 
                                         1
                                 ceiling(-)
                                         r
reverse(uf))
                            1  1  1
(%o2)                      [-, -, --]
                            2  3  15
(%i3) unitfrac (9/10);
                               9
(%o3)                          --
                               10
(%i4) apply ("+", %);
                                  1
(%o4)                       [- 1, --]
                                  10
(%i5) unitfrac (-9/10);
                                9
(%o5)                         - --
                                10
(%i6) apply ("+", %);
                        1  1  1  1    1
(%o6)                  [-, -, -, --, ----]
                        2  3  8  69  6808
(%i7) unitfrac (36/37);
                               36
(%o7)                          --
                               37
(%i8) apply ("+", %);
@end example

@end deffn


@deffn {Funci@'on} round (@var{x})
Si @var{x} es un n@'umero real, la funci@'on devuelve el entero m@'as 
pr@'oximo a @var{x}. Los m@'ultiplos de 1/2 se redondean al entero par m@'as pr@'oximo.
La evaluaci@'on de @var{x} es similar a @code{floor} y @code{ceiling}.

@end deffn


@deffn {Funci@'on} sign (@var{expr})
Intenta determinar el signo de @var{expr} en base a los hechos almacenados en la base de datos. Devuelve una de las siguientes respuestas: @code{pos} (positivo), @code{neg} (negativo), @code{zero} (cero), @code{pz}
(positivo o cero), @code{nz} (negativo o cero), @code{pn} (positivo o negativo),
o @code{pnz} (positivo, negativo o cero, lo que significa que el signo es desconocido).

@end deffn

@deffn {Funci@'on} signum (@var{x})
Para @var{x} num@'erico, devuelve 0 si @var{x} es 0, en caso contrario devuelve -1 o +1, seg@'un que @var{x} sea menor o mayor que 0, respectivamente.

Si @var{x} no es num@'erico, entonces se devuelve una forma simplificada equivalente.
Por ejemplo, @code{signum(-x)} devuelve @code{-signum(x)}.
@c UMM, THIS ISN'T THE WHOLE STORY, AS IT APPEARS signum CONSULTS THE assume DATABASE FOR SYMBOLIC ARGUMENT

@end deffn

@deffn {Funci@'on} sort (@var{L}, @var{P})
@deffnx {Funci@'on} sort (@var{L})
Ordena la lista @var{L} de acuerdo con el predicado @code{P} de dos argumentos,
de tal manera que @code{@var{P} (@var{L}[k], @var{L}[k + 1])} es @code{true} (verdadero)
para cualesquiera dos elementos sucesivos.
El predicado se puede especificar como nombre de una funci@'on o de un operador
infijo binario, o como una expresi@'on @code{lambda}.
Si se especifica con el nombre de un operador, este nombre debe
encerrarse con "comillas dobles".

La lista ordenada se devuelve como un objeto nuevo, de manera que
el argumento @var{L} no se ve alterado.
A fin de construir el valor de retorno, @code{sort} hace una copia previa
de los elementos de @var{L}.

@c MIGHT CONSIDER A REF FOR TOTAL ORDER HERE
Si el predicado @var{P} no ordena totalmente los elementos de @var{L},
entonces @code{sort} puede seguir ejecut@'andose hasta el final sin emitir
errores, pero el resultado no es predecible.
La funci@'on muestra un mensaje de error en caso de que el predicado
devuelva algo diferente de @code{true} o @code{false}.

La llamada @code{sort (@var{L})} equivale a @code{sort (@var{L}, orderlessp)};
esto es, el orden por defecto es el ascendente, tal como queda definido por 
@code{orderlessp}. Todos los @'atomos y expresiones de Maxima son comparables
para @code{orderlessp}, aunque existen ejemplos aislados de expresiones para las
cuales @code{orderlessp} deja de ser transitivo; se trata de un fallo de Maxima.

Ejemplos:

@c ===beg===
@c sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
@c sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x],
@c       ordergreatp);
@c sort ([%pi, 3, 4, %e, %gamma]);
@c sort ([%pi, 3, 4, %e, %gamma], "<");
@c my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
@c sort (my_list);
@c sort (my_list, lambda ([a, b],
@c                        orderlessp (reverse (a), reverse (b))));
@c ===end===
@example
(%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
               5
(%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
               2
(%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x],
          ordergreatp);
                                                   5
(%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                   2
(%i3) sort ([%pi, 3, 4, %e, %gamma]);
(%o3)                [3, 4, %e, %gamma, %pi]
(%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
(%o4)                [%gamma, %e, 3, %pi, 4]
(%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
(%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
(%i6) sort (my_list);
(%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
(%i7) sort (my_list, lambda ([a, b], 
                             orderlessp (reverse (a), reverse (b))));
(%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]
@end example

@end deffn

@deffn {Funci@'on} sqrt (@var{x})
Ra@'{@dotless{i}}z cuadrada de @var{x}. Se representa internamente por @code{@var{x}^(1/2)}.  V@'ease tambi@'en @code{rootscontract}.

Si la variable @code{radexpand} vale @code{true} har@'a que las ra@'{@dotless{i}}ces @code{n}-@'esimas de los factores de un producto que sean potencias de @code{n} sean extra@'{@dotless{i}}das del radical; por ejemplo, @code{sqrt(16*x^2)} se convertir@'a en @code{4*x} s@'olo si @code{radexpand} vale @code{true}.

@end deffn

@defvr {Variable opcional} sqrtdispflag
Valor por defecto: @code{true}

Si @code{sqrtdispflag} vale @code{false}, har@'a que @code{sqrt} se muestre con el exponente 1/2.
@c AND OTHERWISE ... ??

@end defvr

@deffn {Funci@'on} sublis (@var{list}, @var{expr})
Realiza sustituciones  m@'ultiples en paralelo en una expresi@'on.

La variable @code{sublis_apply_lambda} controla la simplificaci@'on despu@'es de @code{sublis}.

Ejemplo:

@c ===beg===
@c sublis ([a=b, b=a], sin(a) + cos(b));
@c ===end===
@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example

@end deffn

@deffn {Funci@'on} sublist (@var{list}, @var{p})
Devuelve la lista de elementos de @var{list} para los cuales el predicado @code{p} retorna @code{true}.

Ejemplo:

@c ===beg===
@c L: [1, 2, 3, 4, 5, 6];
@c sublist (L, evenp);
@c ===end===
@example
(%i1) L: [1, 2, 3, 4, 5, 6];
(%o1)                  [1, 2, 3, 4, 5, 6]
(%i2) sublist (L, evenp);
(%o2)                       [2, 4, 6]
@end example

@end deffn

@defvr {Variable opcional} sublis_apply_lambda
Valor por defecto: @code{true}

Controla si los @code{lambda} sustituidos son aplicados en la simplificaci@'on despu@'es de invocar a @code{sublis}, o si se tiene que hacer un @code{ev} para hacerlo. Si @code{sublis_apply_lambda} vale @code{true}, significa que se ejecute la aplicaci@'on.

@end defvr

@deffn {Funci@'on} subst (@var{a}, @var{b}, @var{c})
Sustituye @var{a} por @var{b} en @var{c}. El argumento  @var{b} debe ser un @'atomo o una subexpresi@'on completa de @var{c}.  Por ejemplo, @code{x+y+z} es una subexpresi@'on completa de  @code{2*(x+y+z)/w} mientras que @code{x+y} no lo es. Cuando @var{b} no cumple esta caracter@'{@dotless{i}}stica, se puede utilizar en algunos casos @code{substpart} o @code{ratsubst}
(ver m@'as abajo).  Alternativamente, si @var{b} no es de la forma @code{e/f} entonces se puede usar @code{subst (a*f, e, c)}, pero si @var{b} es de la forma @code{e^(1/f)} se debe usar @code{subst (a^f, e, c)}.  La instrucci@'on @code{subst} tambi@'en reconoce @code{x^y} en @code{x^-y}, de manera que  @code{subst (a, sqrt(x), 1/sqrt(x))} da @code{1/a}. Los argumentos @var{a} y @var{b} tambi@'en pueden ser operadores de una expresi@'on acotados por comillas dobles @code{"} o nombres de funciones.  Si se quiere sustituir la variable independiente en expresiones con derivadas se debe utilizar la funci@'on @code{at} (ver m@'as abajo).

La funci@'on @code{subst} es sin@'onimo de @code{substitute}.

La llamada @code{subst (@var{eq_1}, @var{expr})} o @code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
est@'an permitidas.  Las @var{eq_i} son ecuaciones que indican las sustituciones a realizar.
Para cada ecuaci@'on, el miembro derecho ser@'a sustituida por la expresi@'on del miembro izquierdo en @var{expr}.

Si la variable @code{exptsubst} vale @code{true} se permiten ciertas sustituciones de exponentes; por ejemplo, sustituir @code{y} por @code{%e^x} en @code{%e^(a*x)}.

Si @code{opsubst} vale @code{false},
@code{subst} no intentar@'a sustituir un operador de una expresi@'on. Por ejemplo, 
@code{(opsubst: false, subst (x^2, r, r+r[0]))} trabajar@'a sin problemas.

Ejemplos:

@c ===beg===
@c subst (a, x+y, x + (x+y)^2 + y);
@c subst (-%i, %i, a + b*%i);
@c ===end===
@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
Para m@'as ejemplos, ejec@'utese @code{example (subst)}.

@end deffn

@deffn {Funci@'on} substinpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Es similar a @code{substpart}, pero @code{substinpart} trabaja con la representaci@'on interna de @var{expr}.

@c ===beg===
@c x . 'diff (f(x), x, 2);
@c substinpart (d^2, %, 2);
@c substinpart (f1, f[1](x + 1), 0);
@c ===end===
@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example

Si el @'ultimo argumento de la funci@'on @code{part} es una lista de @'{@dotless{i}}ndices, entonces se toman varias subexpresiones, cada una de las cuales en correspondencia con un @'{@dotless{i}}ndice de la lista. As@'{@dotless{i}}, 

@c ===beg===
@c part (x + y + z, [1, 3]);
@c ===end===
@example
(%i1) part (x+y+z, [1, 3]);
(%o1)                         z + x
@end example

@code{piece} guarda el valor de la @'ultima expresi@'on seleccionada cada vez que se utiliza la funci@'on @code{part}. Esta asignaci@'on se se hace durante la ejecuci@'on de la funci@'on, con lo que puede ser referenciada en la propia funci@'on tal como se muestra m@'as abajo. Si @code{partswitch} vale @code{true} entonces se devuelve @code{end} cuando la parte seleccionada de una expresi@'on no existe, en caso contrario se muestra un mensaje de error.

@c ===beg===
@c expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
@c part (expr, 2, [1, 3]);
@c sqrt (piece/54);
@c substpart (factor (piece), expr, [1, 2, 3, 5]);
@c expr: 1/x + y/x - 1/z;
@c substpart (xthru (piece), expr, [2, 3]);
@c ===end===
@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Adem@'as, darle a la opci@'on @code{inflag} el valor @code{true} y llamar a @code{part} o a @code{substpart} es 
lo mismo que llamar a @code{inpart} o a @code{substinpart}.

@end deffn

@deffn {Funci@'on} substpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Sustituye @var{x} por la subexpresi@'on determinada por el resto de argumentos, seg@'un el esquema de @code{part}.  Devuelve el nuevo valor de @var{expr}. El argumento  @var{x} puede ser un operador a ser sustituido por un operador de @var{expr}. En algunos casos @var{x} necesita estar acotado por comillas dobles @code{"}, como en @code{substpart ("+", a*b, 0)} para que retorne @code{b + a}.

@c ===beg===
@c 1/(x^2 + 2);
@c substpart (3/2, %, 2, 1, 2);
@c a*x + f(b, y);
@c substpart ("+", %, 1, 0);
@c ===end===
@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Adem@'as, darle a la opci@'on @code{inflag} el valor @code{true} y llamar a @code{part} o a @code{substpart} es 
lo mismo que llamar a @code{inpart} o a @code{substinpart}.

@end deffn

@deffn {Funci@'on} subvarp (@var{expr})
Devuelve @code{true} si @var{expr} es una variable subindicada, como @code{a[i]}.

@end deffn

@deffn {Funci@'on} symbolp (@var{expr})
Devuelve @code{true} si @var{expr} es un s@'{@dotless{i}}mbolo y @code{false} en caso contrario.
La llamada @code{symbolp(x)} equivale al predicado @code{atom(x) and not numberp(x)}.

V@'ease tambi@'en @code{Identifiers}.

@end deffn

@deffn {Funci@'on} unorder ()
Desactiva las asociaciones creadas por la @'ultima utilizaci@'on de los comandos de ordenaci@'on @code{ordergreat} y @code{orderless}, los cuales no pueden ser utilizados m@'as de una vez sin invocar a @code{unorder}. 
V@'ease tambi@'en @code{ordergreat} y @code{orderless}.

@c HMM, IN THIS EXAMPLE, WHY ISN'T %o5 EQUAL TO ZERO ???
@c ===beg===
@c unorder();
@c b*x + a^2;
@c ordergreat (a);
@c b*x + a^2;
@c  %th(1) - %th(3);
@c unorder();
@c ===end===
@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
 %th(1) - %th(3);
                             2
(%o4)                       a  + b x
(%i5) unorder();
                              2    2
(%o5)                        a  - a
@end example

@end deffn

@deffn {Funci@'on} vectorpotential (@var{givencurl})
Devuelve el vector potencial de un vector rotacional en el sistema
de coordenadas actual. 
@code{potentialzeroloc} tiene un rol similar al de @code{potential}, 
pero el orden del miembro izquierdo de las ecuaciones debe ser una
permutaci@'on c@'{@dotless{i}}clica de las coordenadas. 

@end deffn

@deffn {Funci@'on} xthru (@var{expr})
Combina todos los t@'erminos de @var{expr} (la cual debe ser una suma) sobre un com@'un denominador sin expandir productos ni sumas elevadas a exponentes al modo que lo hace @code{ratsimp}. La funci@'on @code{xthru} cancela factores comunes en el numerador y denominador de expresiones racionales, pero s@'olo si los factores son expl@'{@dotless{i}}citos.

En ocasiones puede ser @'util el uso de @code{xthru} antes de la llamada a @code{ratsimp} a fin de cancelar factores expl@'{@dotless{i}}citos del m@'aximo com@'un divisor del numerador y denominador y as@'{@dotless{i}} simplificar la expresi@'on a la que se va a aplicar @code{ratsimp}.

@c ===beg===
@c ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
@c xthru (%);
@c ===end===
@example
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
 xthru (%);
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
@end example

@end deffn

@deffn {Funci@'on} zeroequiv (@var{expr}, @var{v})
Analiza si la expresi@'on @var{expr} de variable @var{v} equivale a cero, devolviendo @code{true}, @code{false} o
@code{dontknow}.

La funci@'on @code{zeroequiv} tiene estas restricciones:
@enumerate
@item
No utilizar funciones que Maxima no sepa derivar y evaluar.
@item
Si la expresi@'on tiene polos en la recta real, pueden aparecer errores en el resultado, aunque es poco probable.
@item
Si la expresi@'on contiene funciones que no son soluciones de ecuaciones diferenciales ordinarias de primer orden (como las funciones de Bessel) pueden presentarse resultados incorrectos.
@item
El algoritmo utiliza evaluaciones en puntos aleatoriamente seleccionados. Esto conlleva un riesgo,aunque el algoritmo intenta minimizar el error.
@end enumerate

Por ejemplo, @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} devuelve
@code{true} y @code{zeroequiv (%e^x + x, x)} devuelve @code{false}.
Por otro lado @code{zeroequiv (log(a*b) - log(a) - log(b), a)} devuelve @code{dontknow} debido a la presencia del par@'ametro @code{b}.

@end deffn
