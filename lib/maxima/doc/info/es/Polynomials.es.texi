@c version 1.29
@menu
* Introducci@'on a los polinomios::  
* Funciones y variables para polinomios::  
@end menu

@node Introducci@'on a los polinomios, Funciones y variables para polinomios, Polinomios, Polinomios
@section Introducci@'on a los polinomios

Los polinomios se almacenan en Maxima, bien en un formato general, bien en una forma conocida como can@'onica (Cannonical Rational Expressions, CRE). La @'ultima corresponde al formato est@'andar y se utiliza internamente para realizar operaciones como @code{factor}, @code{ratsimp} y dem@'as.

Las Expresiones Racionales Can@'onicas (CRE) constituyen un tipo de representaci@'on
que es especialmente apropiado para expandir polinomios y funciones racionales
(as@'{@dotless{i}} como para polinomios parcialmente factorizados y funciones racionales cuando a la variable @code{ratfac} se le asigna el valor @code{true}). En esta forma CRE las variables se ordenan de mayor a menor. Los polinomios se representan recursivamente como una lista compuesta por la variable principal seguida por una serie de pares de expresiones,
una por cada t@'ermino del polinomio. El primer miembro
de cada par es el exponente de la variable principal en ese t@'ermino y el
segundo miembro es el coeficiente de ese t@'ermino, el cual puede ser un n@'umero o
un polinomio en otra variable representado tambi@'en de esta forma. As@'{@dotless{i}},
la parte principal de la forma CRE de 3*X^2-1 es (X 2 3 0 -1) y la de
2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0 -3)) asumiendo que Y es la variable principal, y ser@'a (X 1 (Y 1 2 0 1) 0 -3) si se asume que la variable principal es X. Qu@'e variable se considera "principal" se determinada en orden alfab@'etico inverso.
Las "variables" de la expresi@'on CRE no son necesariamente at@'omicas. De hecho
cualquier subexpresi@'on cuyo operador principal no es + - * / ni ^ con potencia entera
puede ser considerada como una "variable" de la expresi@'on (en forma CRE) en 
el cual aparezca. Por ejemplo las variables CRE de la expresi@'on
X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).  Si el usuario no
especifica una ordenaci@'on de las variables mediante la funci@'on @code{ratvars} 
Maxima escoger@'a una alfab@'eticamente. En general, laa CRE representan expresiones
racionales, esto es, fracciones de polinomios, donde el numerador y
el denominador  no tienen factores comunes, siendo el denominador es
positivo. La forma interna es esencialmente un par de polinomios (el
numerador y el denominador) precedida por la lista de variables ordenadas. Si
una expresi@'on a ser mostrada est@'a en la forma CRE o contiene alguna
subexpresi@'on en forma de CRE, el simbolo /R/ ser@'a seguido por la etiqueta de la l@'{@dotless{i}}nea de comando.
V@'ease la funci@'on @code{rat} para convertir una expresi@'on a la forma CRE. Una
extensi@'on de la forma CRE se utiliza para la representaci@'on de las series de Taylor. La
noci@'on de una expresi@'on racional se extiende de manera que los exponentes de las
variables pueden ser n@'umeros racionales positivos o negativos y no s@'olo
enteros positivos y los coeficientes pueden ser tambi@'en expresiones
racionales y no s@'olo polinomios. Estas expresiones se representan internamente por una forma polinomial recursiva que es similar a la forma CRE, pero que la generaliza, aportando informaci@'on adicional como el grado de truncamiento. Como con la forma CRE, el s@'{@dotless{i}}mbolo /T/ sigue la etiqueta de l@'{@dotless{i}}nea de comando en la que se encuentra dicha expresi@'on.

@node Funciones y variables para polinomios,  , Introducci@'on a los polinomios, Polinomios
@section Funciones y variables para polinomios

@defvr {Variable opcional} algebraic
Valor por defecto: @code{false}

La variable @code{algebraic} debe valer @code{true} para que se pueda hacer la simplificaci@'on de enteros algebraicos.

@end defvr

@defvr {Variable opcional} berlefact
Valor por defecto: @code{true}

Si @code{berlefact} vale @code{false} entonces se utiliza el algoritmo de factorizaci@'on de Kronecker, en caso contrario se utilizar@'a el algoritmo de Berlekamp, que es el que se aplica por defecto.

@end defvr

@deffn {Funci@'on} bezout (@var{p1}, @var{p2}, @var{x})
Es una alternativa a la funci@'on @code{resultant}.  Devuelve una matriz.

@end deffn

@deffn {Funci@'on} bothcoef (@var{expr}, @var{x})
Devuelve una lista cuyo primer miembro es el coeficiente de @var{x} en @var{expr} (que coincide con el que devuelve @code{ratcoef} si @var{expr} est@'a en formato CRE, o el que devuelve @code{coeff} si no est@'a en este formato) y cuyo segundo miembro es la parte restante de @var{expr}. Esto es, @code{[A, B]} donde @code{@var{expr} = A*@var{x} + B}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         is (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);

@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end deffn

@deffn {Funci@'on} coeff (@var{expr}, @var{x}, @var{n})
Devuelve el coeficiente de @code{@var{x}^@var{n}} en @var{expr}. El argumento @var{n} puede omitirse si es igual a la unidad. El argumento @var{x} puede ser un @'atomo  o una subexpresi@'on completa de @var{expr}, por ejemplo @code{sin(x)}, @code{a[i+1]}, @code{x + y}, etc. (En este @'ultimo caso, la expresi@'on @code{(x + y)} debe aparecer en @var{expr}).  En ocasiones puede ser necesario expandir o factorizar @var{expr} para hacer @code{@var{x}^@var{n}} expl@'{@dotless{i}}cito, lo cual no hace @code{coeff} autom@'aticamente.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
@c coeff (y + x*%e^x + 1, x, 0);

@example
(%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
(%o1)                      2 a + 1 = 5
(%i2) coeff (y + x*%e^x + 1, x, 0);
(%o2)                         y + 1
@end example

@end deffn

@deffn {Funci@'on} combine (@var{expr})
Simplifica la suma @var{expr} combinando t@'erminos de con igual denominador reduci@'endolos a un @'unico t@'ermino.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Funci@'on} content (@var{p_1}, @var{x_1}, ..., @var{x_n})
Devuelve una lista cuyo primer miembro es el m@'aximo com@'un divisor de los coeficientes de los t@'erminos del polinomio @var{p_1} de variable @var{x_n} (este es el contenido) y cuyo segundo miembro es el polinomio @var{p_1} dividido por el contenido.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c content (2*x*y + 4*x^2*y^2, y);

@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end deffn

@deffn {Funci@'on} denom (@var{expr})
Devuelve el denominador de la expresi@'on racional @var{expr}.

@end deffn

@deffn {Funci@'on} divide (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Calcula el cociente y el resto del polinomio @var{p_1} dividido por el polinomio @var{p_2}, siendo la variable principal @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
Las otras funciones son como en la funci@'on @code{ratvars}. El resultado es una lista cuyo primer miembro es el cociente y el segundo miembro el resto.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@noindent
N@'otese que @code{y} es la variable principal en el segundo ejemplo.

@end deffn

@deffn {Funci@'on} eliminate ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_k}])
Elimina variables de ecuaciones (o de expresiones que se supone valen cero) tomando resultantes sucesivas. Devuelve una lista con @code{@var{n} - @var{k}} expresiones y @var{k} variables @var{x_1}, ..., @var{x_k} eliminadas.  Primero se elimina  @var{x_1} dando @code{@var{n} - 1} expresiones, despu@'es se elimina @code{x_2}, etc.  Si @code{@var{k} = @var{n}} entonces se devuelve una lista con una @'unica expresi@'on, libre de las variables @var{x_1}, ..., @var{x_k}. En este caso se llama a @code{solve} para resolver la @'ultima resultante para la @'ultima variable.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);

@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end deffn

@deffn {Funci@'on} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, ...)
Devuelve una lista cuyo primer elemento es el m@'aximo com@'un divisor (mcd) de los polinomios @var{p_1}, @var{p_2}, @var{p_3}, ...  siendo los miembros restantes los mismos polinomios divididos por el mcd. Se utiliza siempre el algoritmo @code{ezgcd}.

@end deffn

@defvr {Variable opcional} facexpand
Valor por defecto: @code{true}

La variable @code{facexpand} controla si los factores irreducibles devueltos por @code{factor} est@'an en formato expandido (por defecto) o recursivo  (CRE normal).

@end defvr

@deffn {Funci@'on} factcomb (@var{expr})
Trata de combinar los coeficientes de los factoriales de @var{expr} con los mismos factoriales, convirtiendo, por ejemplo, @code{(n + 1)*n!} en @code{(n + 1)!}.

Si la variable @code{sumsplitfact} vale @code{false} har@'a que @code{minfactorial} se aplique despu@'es de @code{factcomb}.

@end deffn

@deffn {Funci@'on} factor (@var{expr})
@deffnx {Funci@'on} factor (@var{expr}, @var{p})

Factoriza la expresi@'on @var{expr}, que puede contener
cualquier n@'umero de variables o funciones, en factores 
irreducibles respecto de los enteros. La llamada 
@code{factor (@var{expr}, @var{p})} factoriza @var{expr} 
en el campo de los racionales con un elemento a@~nadido cuyo 
polinomio m@'{@dotless{i}}nimo es @var{p}.

La funci@'on @code{factor} utiliza a @code{ifactors} 
para factorizar enteros.

Si la variable @code{factorflag} vale @code{false} suprime 
la factorizaci@'on de los factores enteros en las expresiones racionales.

La variable @code{dontfactor} puede contener una lista 
de variables con respecto a las cuales no se factorizar@'a 
(inicialmente est@'a vac@'{@dotless{i}}a). Tampoco se 
factorizar@'a respecto de cualesquiera otra variables que sean menos importantes (seg@'un la ordenaci@'on que se sigue en el formato CRE) que aquellas que se encuentran en la lista @code{dontfactor}.

Si la variable @code{savefactors} vale @code{true}, los 
factores de una expresi@'on en forma de producto se guardar@'an 
por ciertas funciones a fin de acelerar posteriores factorizaciones 
de expresiones que contengan algunos de estos mismos factores.

Si @code{berlefact} vale @code{false} entonces se utiliza el 
algoritmo de factorizaci@'on de Kronecker, en caso contrario se 
utilizar@'a el algoritmo de Berlekamp, que es el que se aplica por defecto.

Si la variable @code{intfaclim} vale @code{true}, Maxima desistir@'a de
factorizar enteros si no encuentra ning@'un factor despu@'es de las
divisiones tentativas y de aplicar el m@'etodo rho de Pollard. Si vale
@code{false} (este es el caso cuando el usuario invoca expl@'{@dotless{i}}citamente
a @code{factor}), se intentar@'a la factorizaci@'on completa del entero. El valor
asignado a @code{intfaclim} se utiliza en llamadas internas a @code{factor}. As@'{@dotless{i}},
se puede cambiar el valor de @code{intfaclim} para evitar que Maxima dedique
un tiempo prohibitivo a factorizar n@'umeros enteros grandes.

Ejemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end deffn

@defvr {Variable opcional} factorflag
Valor por defecto: @code{false}

@c WHAT IS THIS ABOUT EXACTLY ??
Si @code{factorflag} vale @code{false} se evita la factorizaci@'on de factores enteros de expresiones racionales.

@end defvr

@deffn {Funci@'on} factorout (@var{expr}, @var{x_1}, @var{x_2}, ...)
Reorganiza la suma @var{expr} como una suma de t@'erminos de la forma @code{f (@var{x_1}, @var{x_2}, ...)*g} donde @code{g} es un producto de expresiones que no contienen ning@'un @var{x_i} y @code{f} se factoriza.
@c NEED EXAMPLE HERE

@end deffn

@deffn {Funci@'on} factorsum (@var{expr})
Intenta agrupar t@'erminos en los factores de @var{expr} que son sumas en grupos de t@'erminos tales que su suma sea factorizable. La funci@'on @code{factorsum} puede restablecer el recuperar de @code{expand ((x + y)^2 + (z + w)^2)} pero no puede recuperar @code{expand ((x + 1)^2 + (x + y)^2)} porque los t@'erminos tienen variables comunes.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end deffn

@deffn {Funci@'on} fasttimes (@var{p_1}, @var{p_2})
Calcula el producto de los polinomios @var{p_1} y @var{p_2} utilizando un algoritmo especial. Los polinomios @code{p_1} y @code{p_2} deben ser multivariantes, densos y aproximadamente del mismo tama@~no. La multiplicaci@'on cl@'asica es de orden @code{n_1 n_2} donde @code{n_1} es el grado de  @code{p_1} y  @code{n_2} el grado de @code{p_2}. La funci@'on @code{fasttimes} es de orden @code{max (n_1, n_2)^1.585}.

@end deffn

@deffn {Funci@'on} fullratsimp (@var{expr})
Aplica repetidamente @code{ratsimp} a una expresi@'on, seguida de simplificaciones no racionales, hasta que no se obtienen m@'as transformaciones; entonces devuelve el resultado.

En presencia de expresiones no racionales, una llamada a @code{ratsimp} seguida de una simplificaci@'on no racional ("general") puede no ser suficiente para conseguir un resultado simplificado. En ocasiones ser@'an necesarias m@'as de una llamada a @code{ratsimp}, que es lo que hace precisamente @code{fullratsimp}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end deffn

@deffn {Funci@'on} fullratsubst (@var{a}, @var{b}, @var{c})
Similar a @code{ratsubst} excepto por el hecho de que se llama a @'{@dotless{i}} misma recursivamente hasta que el resultado deja de cambiar. Esta funci@'on es @'util cuando la expresi@'on a sustituir y la que la sustituye tienen variables comunes.

La funci@'on @code{fullratsubst} tambi@'en acepta sus argumentos en el formato de @code{lratsubst}.

Es necesario ejecutar @code{load ("lrats")} para cargar @code{fullratsubst} y @code{lratsubst}.

Ejemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c CAN PROBABLY CUT OUT THE lratsubst STUFF (lratsubst HAS ITS OWN DESCRIPTION)
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c errcatch (fullratsubst (b*a^2, a^2, a^3));

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} puede hacer sustituciones m@'ultiples;
@code{lratsubst} es an@'aloga a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Si s@'olo se quiere una sustituci@'on, entonces se puede dar una @'unica ecuaci@'on como primer argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@itemize @bullet
@item
@code{fullratsubst} equivale a @code{ratsubst}, 
excepto por el hecho de que se llama a @'{@dotless{i}} misma recursivamente hasta que el resultado deja de cambiar.
@end itemize
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example
@itemize @bullet
@item
@code{fullratsubst} tambi@'en acepta una lista de ecuaciones o una s@'ola ecuaci@'on como primer argumento.
@end itemize
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example
@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} puede caer en una recursi@'on infinita.
@end itemize
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end deffn

@deffn {Funci@'on} gcd (@var{p_1}, @var{p_2}, @var{x_1}, ...)
Devuelve el m@'aximo com@'un divisor de @var{p_1} y @var{p_2}.
La variable @code{gcd} determiona qu@'e algoritmo se va a utilizar.
Asign@'andole a @code{gcd} los valores @code{ez}, @code{subres}, @code{red}
o @code{spmod}, se seleccionan los algoritmos @code{ezgcd}, 
subresultante @code{prs}, reducido o modular, respectivamente.
Si @code{gcd} vale @code{false} entonces @code{gcd(@var{p_1}, 
@var{p_2}, @var{x})} devolver@'a siempre 1 para cualquier @var{x}.
Muchas funciones (por ejemplo,  @code{ratsimp}, @code{factor}, etc.)
hacen uso de @code{gcd} impl@'{@dotless{i}}citamente.  
En caso de polinomios homog@'eneos se recomienda darle a 
@code{gcd} el valor @code{subres}.  Para calcular un m@'aximo 
com@'un divisor en presencia de ra@'{@dotless{i}}ces, como en
 @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))},
la variable @code{algebraic} debe igualarse
a @code{true} y @code{gcd} no puede ser @code{ez}.

Se recomienda utilizar el algoritmo @code{subres} en lugar de @code{red},
por ser aqu@'el m@'as moderno.

Si la variable @code{gcd}, cuyo valor por defecto es @code{spmod},
vale @code{false}, no se calcular@'a el m@'aximo com@'un divisor 
cuando las expresiones se conviertan a su forma can@'onica (CRE),
lo que redundar@'a en ocasiones en mayor rapidez de c@'alculo.


@end deffn

@deffn {Funci@'on} gcdex (@var{f}, @var{g})
@deffnx {Funci@'on} gcdex (@var{f}, @var{g}, @var{x})
Devuelve una lista @code{[@var{a}, @var{b}, @var{u}]} en la que @var{u} es el m@'aximo com@'un divisor (mcd) de @var{f} y @var{g}, e igual a @code{@var{a} @var{f} + @var{b} @var{g}}.
Los argumentos @var{f} y @var{g} deben ser polinomios univariantes, o indicarles la variable principal @var{x} en caso de ser multivariantes. 

La funci@'on @code{gcdex} implementa el algoritmo de Euclides, en el que tenemos una secuencia de @code{L[i]: [a[i], b[i], r[i]]} todos ellos ortogonales a @code{[f, g, -1]} siendo el siguiente calculado a partir de @code{q = quotient(r[i]/r[i+1])} y @code{L[i+2]: L[i] - q L[i+1]}; el proceso termina en @code{L[i+1]} cuando el resto @code{r[i+2]} se anula.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

@c AQUI FALTA PARRAFO

@end deffn


@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Funci@'on} gcfactor (@var{n})
Factoriza el entero gaussiano @var{n} como producto, a su vez, de enteros gaussianos, (un entero gaussiano es de la forma@code{@var{a} + @var{b} @code{%i}} donde @var{a} y @var{b} son n@'umeros enteros). Los factores se normalizan de manera que tanto la parte real como imaginaria sean no negativas.
@c NEED EXAMPLES HERE

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Funci@'on} gfactor (@var{expr})
Factoriza el polinomio @var{expr} sobre los enteros gaussianos (un entero gaussiano es de la forma@code{@var{a} + @var{b} @code{%i}} donde @var{a} y @var{b} son n@'umeros enteros).
@c "This is like" -- IS IT THE SAME OR NOT ??
Es como @code{factor (@var{expr}, @var{a}^2+1)} donde @var{a} vale @code{%i}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@end deffn

@deffn {Funci@'on} gfactorsum (@var{expr})
Esta funci@'on es similar a @code{factorsum} pero aplica @code{gfactor} en lugar de @code{factor}.

@end deffn

@deffn {Funci@'on} hipow (@var{expr}, @var{x})
Devuelve el mayor exponente expl@'{@dotless{i}}cito de  @var{x} en @var{expr}.
El argumento@var{x} puede ser una variable o una expresi@'on general.
Si @var{x} no aparece en @var{expr}, @code{hipow} devuelve @code{0}.

La funci@'on @code{hipow} no tiene en cuenta expresiones equivalentes a @code{expr}.
En particular, @code{hipow} no expande @code{expr}, de manera que @code{hipow (@var{expr}, @var{x})} y @code{hipow (expand (@var{expr}, @var{x}))} pueden dar resultados diferentes.

Ejemplos:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@end deffn

@defvr {Variable opcional} intfaclim
Valor por defecto: @code{true}

Si vale @code{true}, Maxima  desistir@'a de
factorizar enteros si no encuentra ning@'un factor despu@'es de las
divisiones tentativas y de aplicar el m@'etodo rho de Pollard, por lo que 
la factorizaci@'on puede quedar incompleta.

Si vale @code{false} (este es el caso cuando el usuario invoca expl@'{@dotless{i}}citamente
a @code{factor}), se intentar@'a la factorizaci@'on completa del entero. El valor
asignado a @code{intfaclim} se utiliza en llamadas internas a @code{factor}. A la variable
@code{intfaclim} se le asigna el valor @code{false} cuando se calculan factores desde las
funciones @code{divisors}, @code{divsum} y @code{totient}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Las llamadas internas a @code{factor} respetan el valor dado por el usuario a @code{intfaclim}.
Asignando a @code{intfaclim} el valor @code{true} se puede reducir  el tiempo que Maxima dedica a
factorizar enteros grandes.
@c NEED EXAMPLES HERE

@end defvr


@defvr {Variable opcional} keepfloat
Valor por defecto: @code{false}

Si @code{keepfloat} vale @code{true}, los n@'umeros decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato can@'onico racional (CRE).
@c NEED EXAMPLES HERE

@end defvr

@deffn {Funci@'on} lratsubst (@var{L}, @var{expr})
Esta funci@'on es similar a @code{subst (@var{L}, @var{expr})}, excepto por el hecho de que utiliza @code{ratsubst} en lugar de @code{subst}.

El primer argumento de @code{lratsubst} es una ecuaci@'on o lista de ecuaciones id@'enticas en formato a las aceptadas por @code{subst}.  Las sustituciones se hacen en el orden dado por la lista de ecuaciones, esto es, de izquierda a derecha.

La instrucci@'on @code{load ("lrats")} carga @code{fullratsubst} y @code{lratsubst}.

Ejemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} can carry out multiple substitutions.
@code{lratsubst} is analogous to @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
If only one substitution is desired, then a single
equation may be given as first argument.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@end deffn


@defvr {Variable opcional} modulus
Valor por defecto: @code{false}

Si @code{modulus} es un n@'umero positivo @var{p}, las operaciones con n@'umeros racionales (como los devueltos por @code{rat} y funciones asociadas) se realizan m@'odulo @var{p}, utilizando el llamado sistema de m@'odulo balanceado, en el que @code{@var{n} m@'odulo @var{p}} se define como un entero @var{k} de @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
si @var{p} es impar, o de @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} si @var{p} es par, de tal manera que @code{@var{a} @var{p} + @var{k}} es igual a @var{n} para alg@'un entero @var{a}.
@c NEED EXAMPLES OF "BALANCED MODULUS" HERE

@c FALTA PARRAFO POCO LEGIBLE

Normalmente a @code{modulus} se le asigna un n@'umero primo. Se acepta que a @code{modulus} se le asigne un entero positivo no primo, pero se obtendr@'a un mensaje de aviso. Maxima permitir@'a que a @code{modulus} se le asigne cero o un entero negativo, aunque no est@'e clara su utilidad.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Funci@'on} num (@var{expr})
Devuelve el numerador de @var{expr} si se trata de una fracci@'on. Si @var{expr} no es una fracci@'on, se devuelve @var{expr}.

La funci@'on @code{num} eval@'ua su argumento.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Funci@'on} polydecomp (@var{p}, @var{x})

Descompone el polinomio @var{p} de variable @var{x} en una composici@'on funcional de polinomios en @var{x}. 
La funci@'on @code{polydecomp} devuelve una lista @code{[@var{p_1}, ..., @var{p_n}]} tal que 

@example
lambda([x],p_1)(lambda ([x],p_2)(...(lambda([x],p_n)(x))...))
@end example

es igual a  @var{p}.
El grado de @var{p_i} es mayor que 1 para @var{i} menor que @var{n}.

Esta descomposici@'on no es @'unica.

Ejemplos:

@c ===beg===
@c polydecomp (x^210, x);
@c p : expand (subst (x^3 - x - 1, x, x^2 - a));
@c polydecomp (p, x);
@c ===end===
@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

La siguiente funci@'on compone @code{L = [e_1, ..., e_n]} como funciones de @code{x};
se trata de la inversa de @code{polydecomp}:

@c ===beg===
@c compose (L, x) :=
@c   block ([r : x], for e in L do r : subst (e, x, r), r) $
@c ===end===
@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

Se vuelve a obtener el resultado del ejemplo de m@'as arriba haciendo uso de @code{compose}:

@c ===beg===
@c polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
@c ===end===
@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

N@'otese que aunque @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
devuelve siempre @var{p} (sin expandir),
@code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})}  @i{no}
devuelve necesariamente @code{[@var{p_1}, ..., @var{p_n}]}:

@c ===beg===
@c polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
@c polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@c ===end===
@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end example

@end deffn

@deffn {Funci@'on} quotient (@var{p_1}, @var{p_2})
@deffnx {Funci@'on} quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Devuelve el polinomio @var{p_1} dividido por el polinomio @var{p_2}. Los argumentos @var{x_1}, ..., @var{x_n} se interpretan como en la funci@'on @code{ratvars}.

La funci@'on @code{quotient} devuelve el primer elemento de la lista devuelta por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn


@deffn {Funci@'on} rat (@var{expr})
@deffnx {Funci@'on} rat (@var{expr}, @var{x_1}, ..., @var{x_n})
Convierte @var{expr} al formato can@'onico racional (canonical rational expression o CRE) expandiendo y combinando todos los t@'erminos sobre un denominador com@'un y cancelando el m@'aximo com@'un divisor del numerador y denominador, as@'{@dotless{i}} como convirtiendo n@'umeros decimales en coma flotante a n@'umeros racionales dentro de la tolerancia indicada por @code{ratepsilon}. Las variables se ordenan de acuerdo a @var{x_1}, ..., @var{x_n} si se han especificado, como en la funci@'on @code{ratvars}.

En general, @code{rat} no simplifica otras funciones que no sean la suma @code{+}, resta @code{-}, multiplicaci@'on @code{*}, divisi@'on @code{/} y exponenciaci@'on de exponente entero, mientras que @code{ratsimp} s@'{@dotless{i}} lo hace.
N@'otese que los @'atomos (n@'umeros y variables) en expresiones en formato CRE no son los mismos que en el formato general.
Por ejemplo, @code{rat(x)- x} devuelve @code{rat(0)}, que tiene una representaci@'on interna diferente de 0.

@c FALTA PARRAFO QUE NECESITA CLARIFICACION EN VERSION INGLESA

Si @code{ratprint} vale @code{false} no aparecer@'an mensajes informando al usuario sobre la conversi@'on de n@'umeros decimales en coma flotante a n@'umeros racionales.

Si @code{keepfloat} vale @code{true} no se convertir@'an n@'umeros decimales en coma flotante a n@'umeros racionales.

V@'eanse tambi@'en @code{ratexpand} y  @code{ratsimp}.

Ejemplos:
@c ===beg===
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
@c         / (4*y^2 + x^2);
@c rat (%, y, a, x);
@c ===end===
@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
         / (4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@end deffn

@defvr {Variable opcional} ratalgdenom
Valor por defecto: @code{true}

Si @code{ratalgdenom} vale @code{true}, se permite la racionalizaci@'on de denominadores eliminando radicales.
La variable @code{ratalgdenom} s@'olo tiene efecto cuando expresiones en formato can@'onico (CRE) est@'an siendo utilizadas en modo algebraico.

@end defvr

@deffn {Funci@'on} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Funci@'on} ratcoef (@var{expr}, @var{x})
Devuelve el coeficiente de la expresi@'on @code{@var{x}^@var{n}} dentro de la expresi@'on @var{expr}. Si se omite, @var{n} se considera igual a 1.

El valor devuelto est@'a libre de las variables en @var{x}, excepto quiz@'as en un sentido no racional. Si no existe un coeficiente de este tipo se devuelve 0.

La funci@'on @code{ratcoef} expande y simplifica racionalmente su primer argumento, por lo que puede dar una respuesta diferente a la dada por la funci@'on @code{coeff}, la cual tiene un car@'acter puramente sint@'actico.
As@'{@dotless{i}}, @code{ratcoef ((x + 1)/y + x, x)} devuelve @code{(y + 1)/y}, 
mientras que @code{coeff} devuelve 1.

La llamada @code{ratcoef (@var{expr}, @var{x}, 0)}, siendo @var{expr} una suma, devuelve una suma formada por los t@'erminos que no contienen @var{x}.

Puesto que @var{expr} se simplifica racionalmente antes de ser examinada, algunos coeficientes puede que no aparezcan como en la expresi@'on original.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@end deffn

@deffn {Funci@'on} ratdenom (@var{expr})
Devuelve el denominador de @var{expr}, despu@'es de transformar @var{expr} al formato can@'onico (CRE). El valor retornado est@'a tambi@'en en formato CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
El argumento @var{expr} se transforma al formato CRE por la funci@'on @code{rat}, a menos que ya est@'e en este formato.
Esta conversi@'on puede cambiar la forma de @var{expr} colocando todos sus t@'erminos sobre un denominador com@'un.

La funci@'on @code{denom} es parecida, pero devuelve una expresi@'on general en lugar de una CRE. Tampoco @code{denom} intenta colocar todos sus t@'erminos sobre un denominador com@'un, de manera que algunas expresiones que son consideradas como divisiones por @code{ratdenom}, no son tales para @code{denom}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@defvr {Variable opcional} ratdenomdivide
Valor por defecto: @code{true}

Si @code{ratdenomdivide} vale @code{true}, la funci@'on @code{ratexpand} expande una fracci@'on en la que el numerador es una suma en una suma de divisiones. En otro caso, @code{ratexpand} reduce una suma de divisiones a una @'unica fracci@'on, cuyo numerador es la suma de los denominadores de cada fracci@'on.

Examples:
@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example

@end defvr


@deffn {Funci@'on} ratdiff (@var{expr}, @var{x})
Deriva la expresi@'on racional @var{expr} con respecto a @var{x}.
El argumento @var{expr} debe ser una fracci@'on algebraica o un polinomio en @var{x}.
El argumento @var{x} puede ser una variable o una subexpresi@'on de @var{expr}.
@c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
@c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
@c HOW TO DESCRIBE THAT ??

El resultado equivale al devuelto por @code{diff}, aunque es posible que se obtenga en una forma diferente.
La funci@'on @code{ratdiff} puede ser m@'as r@'apida que @code{diff} en expresiones racionales.

La funci@'on @code{ratdiff} devuelve una expresi@'on en formato can@'onico o CRE si @code{expr} es tambi@'en una expresi@'on CRE. En otro caso, @code{ratdiff} devuelve una expresi@'on general.

La funci@'on @code{ratdiff} considera @'unicamente la dependencia de @var{expr} respecto de @var{x}, ignorando cualquier dependencia establecida por @code{depends}.

Ejemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c ratdiff (expr, x);
@c expr: f(x)^3 - f(x)^2 + 7;
@c ratdiff (expr, f(x));
@c expr: (a + b)^3 + (a + b)^2;
@c ratdiff (expr, a + b);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end example

@end deffn

@deffn {Funci@'on} ratdisrep (@var{expr})
Devuelve su argumento como una expresi@'on general.
Si @var{expr} es una expresi@'on general, se devuelve sin cambios.

Normalmente se invoca a @code{ratdisrep} a fin de convertir una expresi@'on en formato can@'onico (CRE) al formato general, lo que puede ser utilizado si se quiere parar el contagio que produce el formato CRE, o para utilizar funciones racionales en contextos no racionales.

V@'ease tambi@'en @code{totaldisrep}.

@end deffn


@defvr {Variable opcional} ratepsilon
Valor por defecto: 2.0e-8

La variable @code{ratepsilon} guarda la tolerancia utilizada en la conversi@'on de n@'umeros decimales en coma flotante a n@'umeros racionales.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Funci@'on} ratexpand (@var{expr})
@deffnx {Variable opcional} ratexpand
Expande @var{expr} multiplicando productos de sumas y sumas con exponentes, combinando fracciones con com@'un denominador, cancelando el m@'aximo com@'un divisor del numerador y del denominador y luego dividiendo los sumandos del numerador por el denominador.

El valor que devuelve @code{ratexpand} es una expresi@'on general, incluso cuando @var{expr} est@'a en formato can@'onico o CRE.

Si la variable @code{ratexpand} vale @code{true} har@'a que las expresiones CRE se expandan completamente cuando se conviertan al formato general o se muestren en el terminal, mientras que si vale @code{false} se mostrar@'an de forma recursiva. V@'ease tambi@'en @code{ratsimp}.

Si @code{ratdenomdivide} vale @code{true},
@code{ratexpand} expande una fracci@'on en la que el numerador es una suma en una suma de fracciones, todas ellas con denominador com@'un. En otro caso, @code{ratexpand} reduce una suma de fracciones en una @'unica fracci@'on, cuyo numerador es la suma de los numeradores de cada fracci@'on.

Si @code{keepfloat} vale @code{true}, los n@'umeros decimales en coma flotante no se racionalizan cuando las expresiones que los contienen se convierten al formato can@'onico racional (CRE).

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@end deffn


@defvr {Variable opcional} ratfac
Valor por defecto: @code{false}

Si @code{ratfac} vale @code{true}, las expresiones can@'onicas (CRE) se manipulan en una forma parcialmente factorizada.

Durante las operaciones racionales, las expresiones se mantienen completamente factorizadas tanto como sea posible sin llamar a @code{factor}. Esto deber@'{@dotless{i}}a ahorrar espacio y tiempo en algunos c@'alculos. El numerador y denominador se hacen primos relativos, por ejemplo @code{rat ((x^2 - 1)^4/(x + 1)^2)} devuelve @code{(x - 1)^4 (x + 1)^2)}, pero los factores dentro de cada parte pueden no ser primos relativos.

En el paquete @code{ctensr} sobre manipulaci@'on de tensores por componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la curvatura escalar se factorizan autom@'aticamente si @code{ratfac} vale @code{true}; 
@i{@code{ratfac} debe activarse @'unicamente en aquellos casos en los que se sabe que el n@'umero de t@'erminos de las componentes tensoriales es pequ@~no.}

Nota: Los esquemas de comportamiento basados en @code{ratfac} y @code{ratweight} son incompatibles y no se debe  pretender usarlos al mismo tiempo.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Funci@'on} ratnumer (@var{expr})
Devuelve el numerador de @var{expr}, despu@'es de reducir @var{expr} a su forma can@'onica (CRE).
El valor retornado est@'a tambi@'en en formato CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
El argumento @var{expr} se transforma al formato CRE por la funci@'on @code{rat}, a menos que ya est@'e en este formato.
Esta conversi@'on puede cambiar la forma de @var{expr} colocando todos sus t@'erminos sobre un denominador com@'un.

Es parecida a la funci@'on @code{num}, pero devuelve una expresi@'on general en lugar de una CRE.
Adem@'as, @code{num} no intenta colocar todos los t@'erminos sobre un denominador com@'un, de manera que algunas expresiones que son consideradas fracciones por @code{ratnumer} no se consideran como tales por @code{num}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@deffn {Funci@'on} ratnump (@var{expr})
Devuelve @code{true} si @var{expr} es un entero literal o una fracci@'on de enteros literales, en caso contrario devuelve @code{false}.

@end deffn

@deffn {Funci@'on} ratp (@var{expr})
Devuelve @code{true} si @var{expr} es una expresi@'on can@'onica racional (canonical rational expression o CRE) o una CRE extendida, en caso contrario devuelve @code{false}.

Las expresiones CRE son creadas por @code{rat} y funciones asociadas. Las CRE extendidas son creadas por @code{taylor} y funciones asociadas.

@end deffn

@defvr {Variable opcional} ratprint
Valor por defecto: @code{true}

Si @code{ratprint} vale @code{true}, se muestra al usuario un mensaje dando cuenta de la conversi@'on de n@'umeros decimales en coma flotante a formato racional.

@end defvr

@deffn {Funci@'on} ratsimp (@var{expr})
@deffnx {Funci@'on} ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})
Simplifica la expresi@'on @var{expr} y todas sus subexpresiones, incluyendo los argumentos de funciones no racionales. El resultado es un cociente de dos polinomios en una forma recursiva, esto es, los coeficientes de la variable principal son polinomios respecto de las otras variables. Las variables pueden incluir funciones no racionales, como @code{sin (x^2 + 1)}, y los argumentos de tales funciones son tambi@'en racionalmente simplificados.

La llamada @code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} permite la simplificaci@'on racional con la especificaci@'on del orden de las variables, como en @code{ratvars}.

Si @code{ratsimpexpons} vale @code{true}, @code{ratsimp} se aplica a los exponentes de las expresiones durante la simplificaci@'on.

V@'ease tambi@'en @code{ratexpand}. N@'otese que @code{ratsimp} se ve afectada por algunas de las variables globales que controlan a @code{ratexpand}.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@end deffn


@defvr {Variable opcional} ratsimpexpons
Valor por defecto: @code{false}

Si @code{ratsimpexpons} vale @code{true}, @code{ratsimp} se aplica a los exponentes de las expresiones durante la simplificaci@'on.

@c NEED AN EXAMPLE HERE -- RECYCLE THE ratsimpexpons EXAMPLE FROM ratsimp ABOVE
@end defvr


@deffn {Funci@'on} ratsubst (@var{a}, @var{b}, @var{c})
Sustituye @var{b} por @var{a} en @var{c} y devuelve la expresi@'on resultante.
@c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE -- NOT LIKELY THE CASE
El argumento @var{b} puede ser una suma, un producto, una potencia, etc.

@c WHAT, EXACTLY, DOES ratsubst KNOW ??
La funci@'on @code{ratsubst} reconoce el significado de las expresiones, mientras que @code{subst} tan solo realiza sustituciones sint@'acticas. As@'{@dotless{i}} por ejemplo, @code{subst (a, x + y, x + y + z)} devuelve @code{x + y + z}
cuando @code{ratsubst} devuelve @code{z + a}.

Si @code{radsubstflag} vale @code{true},
@code{ratsubst} sustituye radicales en expresiones que no los contienen expl@'{@dotless{i}}citamente.

Ejemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c WITH SOME ADDITIONAL STUFF
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@c radsubstflag: false$
@c ratsubst (u, sqrt(x), x);
@c radsubstflag: true$
@c ratsubst (u, sqrt(x), x);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example

@end deffn

@deffn {Funci@'on} ratvars (@var{x_1}, ..., @var{x_n})
@deffnx {Funci@'on} ratvars ()
@deffnx {Variable del sistema} ratvars
Declara como variables principales @var{x_1}, ..., @var{x_n} en expresiones racionales. Si @var{x_n} est@'a presente en una expresi@'on racional, se considerar@'a como variable principal. Si no est@'a presente, entonces se considerar@'a principal a la variable @var{x_[n-1]} si aparece en la expresi@'on, se contin@'ua as@'{@dotless{i}} hasta @var{x_1}, que se considerar@'a como variable principal s@'olo si ninguna de las variables que le siguen est@'a presente en la expresi@'on.

Si una variable de la expresi@'on racional no est@'a presente en la lista @code{ratvars}, se le dar@'a una prioridad inferior a la de @var{x_1}.

Los argumentos de @code{ratvars} pueden ser tanto variables como funciones no racionales como @code{sin(x)}.

La variable @code{ratvars} es una lista que contiene los argumentos pasados a la funci@'on @code{ratvars} la @'ultima vez que fue invocada. Cada llamada a la funci@'on @code{ratvars} reinicializa la lista. La llamada @code{ratvars ()} vac@'{@dotless{i}}a la lista.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Funci@'on} ratweight (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})
@deffnx {Funci@'on} ratweight ()
Asigna un peso @var{w_i} a la variable @var{x_i}. Un t@'ermino ser@'a reemplazado por 0 si su peso excede el valor de la variable @code{ratwtlvl} (por defecto no se realiza el truncamiento). El peso de un t@'ermino es la suma de los productos de los pesos de las variables que lo forman multiplicados por sus exponentes. Por ejemplo, el peso de @code{3 x_1^2 x_2} es @code{2 w_1 + w_2}. El truncamiento basado en @code{ratwtlvl} solamente se lleva a cabo cuando se multiplican o se elevan a potencias expresiones can@'onicas (CRE).

La llamada @code{ratweight ()} devuelve la lista acumulada de asignaciones de pesos.

Nota: Los esquemas de comportamiento basados en @code{ratfac} y @code{ratweight} son incompatibles y no se debe  pretender usarlos al mismo tiempo.

Ejemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

@end deffn

@defvr {Variable del sistema} ratweights
Valor por defecto: @code{[]}

La variable @code{ratweights} es una lista que contiene los pesos asignados por @code{ratweight}.
Las lista es acumulativa, en el sentido de que cada llamada a @code{ratweight} a@~nade nuevos elementos a la lista.

@end defvr

@defvr {Variable opcional} ratwtlvl
Valor por defecto: @code{false}

La variable @code{ratwtlvl} se utiliza en combinaci@'on con la funci@'on @code{ratweight} para controlar el truncamiento de expresiones racionales can@'onicas (CRE). Con el valor por defecto, @code{false}, no se produce truncamiento alguno.

@end defvr

@deffn {Funci@'on} remainder (@var{p_1}, @var{p_2})
@deffnx {Funci@'on} remainder (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Devuelve el resto de la divisi@'on del polinomio @var{p_1} entre @var{p_2}. Los argumentos @var{x_1}, ..., @var{x_n} se interpretan como en @code{ratvars}.

La funci@'on @code{remainder} devuelve el segundo elemento de la lista retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Funci@'on} resultant (@var{p_1}, @var{p_2}, @var{x})
@deffnx {Variable} resultant
Calcula la resultante de los dos polinomios @var{p_1} y @var{p_2}, eliminando la variable @var{x}.
La resultante es un determinante de los coeficientes de @var{x} en @var{p_1} y @var{p_2}, que es igual a cero si s@'olo si @var{p_1} y @var{p_2} tienen un factor com@'un no constante.

Si @var{p_1} o @var{p_2} pueden ser factorizados, puede ser necesario llamar a @code{factor} antes que invocar a @code{resultant}.

La variable @code{resultant} controla qu@'e algoritmo ser@'a utilizado para calcular la resultante.
@c  FALTA COMPLETAR PARRAFO

La funci@'on @code{bezout} toma los mismos argumentos que @code{resultant} y devuelve una matriz. El determinante del valor retornado es la resultante buscada.

@c NEED AN EXAMPLE HERE
@end deffn

@defvr {Variable opcional} savefactors
Valor por defecto: @code{false}

@c "certain functions" -- WHICH ONES ??
Si @code{savefactors} vale @code{true}, los factores de una expresi@'on producto se almacenan por ciertas funciones a fin de acelerar posteriores factorizaciones de expresiones que contengan algunos de estos factores.

@end defvr

@c FALTA DEFINICION DE sqfr


@deffn {Funci@'on} tellrat (@var{p_1}, ..., @var{p_n})
@deffnx {Funci@'on} tellrat ()
A@~nade al anillo de enteros algebraicos conocidos por Maxima los elementos que son soluciones de los polinomios @var{p_1}, ..., @var{p_n}. Cada argumento @var{p_i} es un polinomio de coeficientes enteros.

La llamada @code{tellrat (@var{x})} hace que se sustituya 0 por @var{x} en las funciones racionales.

La llamada @code{tellrat ()} devuelve una lista con las sustituciones actuales.

A la variable @code{algebraic} se le debe asignar el valor @code{true} a fin de poder realizar la simplificaci@'on de enteros algebraicos.

Maxima reconoce la unidad imaginaria @code{%i} y todas las ra@'{@dotless{i}}ces de los enteros.

La instrucci@'on @code{untellrat} borra todas las propiedades de @code{tellrat}.

Es ambiguo aplicar @code{tellrat} a un polinomio multivariante tal como @code{tellrat (x^2 - y^2)}, pues no se sabe si sustituir @code{@var{y}^2} por @code{@var{x}^2} o al rev@'es. Maxima sigue un cierto orden, pero si el usuario quiere especificar uno en concreto, puede hacerlo mediante la sintaxis @code{tellrat (y^2 = x^2)}, que indica que se ponga @code{@var{x}^2} en lugar de @code{@var{y}^2}.

Ejemplos:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end deffn

@deffn {Funci@'on} totaldisrep (@var{expr})
Convierte cada subexpresi@'on  de @var{expr} del formato can@'onico (CRE) al general y devuelve el resultado.
Si @var{expr} est@'a en formato CRE entonces @code{totaldisrep} es id@'entico a @code{ratdisrep}.

La funci@'on @code{totaldisrep} puede ser @'util para modificar expresiones como las ecuaciones, listas, matrices, etc., que tienen algunas subexpresiones en formato CRE.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Funci@'on} untellrat (@var{x_1}, ..., @var{x_n})
Elimina de @var{x_1}, ..., @var{x_n} las propiedades relacionadas con @code{tellrat}.

@c NEED EXAMPLES HERE
@end deffn
