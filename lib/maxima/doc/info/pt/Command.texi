@c Language: Portuguese
@c Source: Command.texi (en) 1.43
@iftex
@hyphenation{si-na-li-za-do-res}
@hyphenation{de-mo-ra-da-men-te}
@hyphenation{va-lo-res}
@end iftex
@menu
* Introdu@value{cedilha}@~ao a Linha de Comandos::  
* Defini@value{cedilha}@~oes para Linha de Comandos::  
@end menu

@node Introdu@value{cedilha}@~ao a Linha de Comandos, Defini@value{cedilha}@~oes para Linha de Comandos, Linha de Comandos, Linha de Comandos
@section Introdu@value{cedilha}@~ao a Linha de Comandos

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn {Operador} '
@ifinfo
@fnindex Operador Ap@'ostrofo
@end ifinfo
O operador ap@'ostrofo @code{'} evita avalia@,{c}@~ao.

Aplicado a um s@'{@dotless{i}}mbolo,
o ap@'ostrofo evita avalia@,{c}@~ao do s@'{@dotless{i}}mbolo.

Aplicado a uma chamada de fun@,{c}@~ao,
o ap@'ostrofo evita avalia@,{c}@~ao da chamada de fun@,{c}@~ao,
embora os argumentos da fun@,{c}@~ao sejam ainda avaliados (se a avalia@,{c}@~ao n@~ao for de outra forma evitada).
O resultado @'e a forma substantiva da chamada de fun@,{c}@~ao.

Aplicada a uma espress@~ao com par@^entesis,
o ap@'ostrofo evita avalia@,{c}@~ao de todos os s@'{@dotless{i}}mbolos e chamadas de fun@,{c}@~ao na express@~ao.
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
E.g., @code{'(f(x))} significa n@~ao avalie a express@~ao @code{f(x)}.
@code{'f(x)} (com ap@'ostrofo aplicado a @code{f} em lugar de @code{f(x)})
retorna a forma substantiva de @code{f} aplicada a @code{[x]}.

O ap@'ostrofo nao evita simplifica@,{c}@~ao.

Quando o sinalizador global @code{noundisp} for @code{true},
substantivos s@~ao mostrados com um ap@'ostrofo.
Esse comutador @'e sempre @code{true} quando mostrando defini@,{c}@~oes de fun@,{c}@~oes.

Veja tamb@'em operador ap@'ostrofo-ap@'ostrofo @code{''} e @code{nouns}.

Exemplos:

Aplicado a um s@'{@dotless{i}}mbolo,
o ap@'ostrofo evita avalia@,{c}@~ao do s@'{@dotless{i}}mbolo.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Aplicado a uma chamada de fun@,{c}@~ao,
o ap@'ostrofo evita avalia@,{c}@~ao da chamada de fun@,{c}@~ao.
O resultado @'e a forma substantiva da chamada de fun@,{c}@~ao.

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Aplicado a uma express@~ao com par@^entesis,
o ap@'ostrofo evita avalia@,{c}@~ao de todos os s@'{@dotless{i}}mbolos e chamadas de fun@,{c}@~ao na express@~ao.

@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

O ap@'ostrofo n@~ao evita simplifica@,{c}@~ao.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

@end deffn

@deffn {Operador} ''
@ifinfo
@fnindex Operador ap@'ostrofo-ap@'ostrofo
@end ifinfo
O operador ap@'ostrofo-ap@'ostrofo @code{'@w{}'} (dois ap@'ostrofost) modifica avalia@,{c}@~ao em express@~oes de entrada.

Aplicado a uma express@~ao geral @var{expr}, ap@'ostrofo-ap@'ostrofo faz com que o valor de @var{expr}
seja substitu@'{@dotless{i}}do por @var{expr} na express@~ao de entrada.

Aplicado ao operadro de uma express@~ao,
ap@'ostrofo-ap@'ostrofo modifica o operadro de um susbstantivo para um verbo (se esse operador n@~ao for j@'a um verbo).

O operador ap@'ostrofo-ap@'ostrofo @'e aplicado atrav@'es do passador de entrada;
o ap@'ostrofo-ap@'ostrofo n@~ao @'e armazenado como parte de uma express@~ao de entrada passada.
O operador ap@'ostrofo-ap@'ostrofo @'e sempre aplicado t@~ao rapidamente quanto for passado,
e n@~ao pode receber um terceiro ap@'ostrofo.
Dessa forma faz com que ocorra avalia@,{c}@~ao quando essa avalia@,{c}@~ao for de outra forma suprimida,
da mesma forma que em defini@,{c}@~oes de fun@,{c}@~ao, defini@,{c}@~oes de express@~aoes lambda, e express@~oes que recebem um ap@'ostrofo simples @code{'}.

Ap@'ostrofo-ap@'ostrofo @'e reconhecido por @code{batch} e @code{load}.

Veja tamb@'em o operador ap@'ostrofo @code{'} e @code{nouns}.

Exemplos:

Aplicado a uma express@~ao geral @var{expr}, ap@'ostrofo-ap@'ostrofo fazem com que o valor de @var{expr}
seja substituido por @var{expr} na express@~ao de entrada.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Aplicado ao operador de uma express@~ao,
ap@'ostrofo-ap@'ostrofo muda o operadro de um substantivo para um verbo (se esse operadro n@~ao for j@'a um verbo).

@c ===beg==
@c sin (1);
@c ''sin (1);
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end==
@example
(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
@end example

O operador ap@'ostrofo-ap@'ostrofo @'e aplicado por meio de um passador de entrada;
operador-ap@'ostrofo n@~ao @'e armazenado como parte da express@~ao de entrada.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

Ap@'ostrofo ap@'ostrofo faz com que ocorra avalia@,{c}@~ao quando a avalia@,{c}@~ao tiver sido de outra forma suprimida,
da mesma forma que em defini@,{c}@~oes de fun@,{c}@~ao, da mesma forma que em defini@,{c}@~oes de fun@,{c}@~ao lambda expressions, E express@~oes que recebem o ap@'ostrofo simples @code{'}.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@end deffn

@node Defini@value{cedilha}@~oes para Linha de Comandos,  , Introdu@value{cedilha}@~ao a Linha de Comandos, Linha de Comandos
@section Defini@value{cedilha}@~oes para Linha de Comandos

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Fun@,{c}@~ao} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
prov@^e um
nome alternativo para uma fun@,{c}@~ao (de utilizador ou de sistema), vari@'avel, array, etc.
Qualquer n@'umero de argumentos pode ser usado.

@end deffn

@defvr {Vari@'avel de op@,{c}@~ao} debugmode
Valor por omiss@~ao: @code{false}

Quando um erro do Maxima ocorre, Maxima iniciar@'a o depurador se @code{debugmode} for @code{true}.
O utilizador pode informar comandos para examinar o hist@'orico de chamadas, marcar pontos de parada, percorrer uma linha por vez
o c@'odigo do Maxima, e assim por diante.  Veja @code{debugging} para uma lista de op@,{c}@~oes do depurador.

Habilitando @code{debugmode} por meio da altera@value{cedilha}@~ao de seu valor para @code{true}, n@~ao ser@~ao capturados erros do Lisp.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Fun@,{c}@~ao} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Avalia a express@~ao @var{expr} no ambiente
especificado pelos argumentos @var{arg_1}, ..., @var{arg_n}.
Os argumentos s@~ao comutadores (sinalizadores Booleanos), atribui@,{c}@~oes, equa@,{c}@~oes, e fun@,{c}@~oes.
@code{ev} retorna o resultado (outra express@~ao) da avalia@,{c}@~ao.

A avalia@,{c}@~ao @'e realizada em passos, como segue.

@enumerate
@item
Primeiro o ambiente @'e preparado examinando os argumentos que podem
ser quaisquer ou todos os seguintes.

@itemize @bullet
@item
@code{simp} faz com que @var{expr} seja simplificado independentemente da posi@,{c}@~ao do
comutador @code{simp} que inibe simplifica@,{c}@~ao se @code{false}.
@item
@code{noeval} suprime a fase de avalia@,{c}@~ao de @code{ev} (veja passo (4) adiante).
Isso @'e @'util juntamente com outros comutadores e faz com que
@var{expr} seja simplificado novamente sem ser reavaliado.
@item
@code{nouns} causa a avalia@,{c}@~ao de formas substantivas
(tipicamente fun@,{c}@~oes n@~ao avaliadas tais como @code{'integrate} ou @code{'diff})
em @var{expr}.
@item
@code{expand} causa expans@~ao.
@item
@code{expand (@var{m}, @var{n})} causa expans@~ao, alterando os valores de @code{maxposex} e
@code{maxnegex} para @var{m} e @var{n} respectivamente.
@item
@code{detout} faz com que qualquer matriz inversa calculada em @var{expr} tenha seu
determinante mantido fora da inversa ao inv@'es de dividindo a
cada elemento.
@item
@code{diff} faz com que todas as diferencia@,{c}@~oes indicadas em @var{expr} sejam executadas.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} causa somente diferencia@,{c}@~oes referentes @`as
vari@'aveis indicadas.
@item
@code{float} faz com que n@'umeros racionais n@~ao inteiros sejam convertidos para ponto 
flutuante.
@item
@code{numer} faz com que algumas fun@,{c}@~oes matem@'aticas (incluindo a exponencia@,{c}@~ao)
com argumentos sejam valiadas em ponto flutuante.  Isso faz com que
vari@'avels em @var{expr} que tenham sido dados numervals (valores num@'ericos) sejam substitu@'{@dotless{i}}das por
seus valores.  Isso tamb@'em modifica o comutador @code{float} para activado.
@item
@code{pred} faz com que predicados (express@~oes que podem ser avaliados em @code{true} ou @code{false})
sejam avaliadas.
@item
@code{eval} faz com que uma avalia@,{c}@~ao posterior de @var{expr} ocorra.  (Veja passo (5)
adiante.)
@code{eval} pode ocorrer m@'ultiplas vezes.
Para cada inst@^ancia de @code{eval}, a express@~ao @'e avaliada novamente.
@item
@code{A} onde @code{A} @'e um @'atomo declarado seja um sinalizador de avalia@,{c}@~ao (veja @code{evflag})
faz com que @code{A} seja associado a
@code{true} durante a avalia@,{c}@~ao de @var{expr}.
@item
@code{V: expres@~ao} (ou alternativamente @code{V=express@~ao}) faz com que @code{V} seja associado ao
valor de @code{express@~ao} durante a avalia@,{c}@~ao de @var{expr}.  Note que se @code{V} @'e uma
op@,{c}@~ao do Maxima, ent@~ao @code{expression} @'e usada para seu valor durante a
avalia@,{c}@~ao de @var{expr}.  Se mais que um argumento para @code{ev} @'e desse tipo
ent@~ao a associa@value{cedilha}@~ao termina em paralelo.  Se @code{V} @'e uma express@~ao n@~ao at@^omica
ent@~ao a substitui@,{c}@~ao, ao inv@'es de uma associa@,{c}@~ao, @'e executada.
@item
@code{F} onde @code{F}, um nome de fun@,{c}@~ao, tenha sido declarado para ser uma fun@,{c}@~ao de avalia@,{c}@~ao (veja @code{evfun})
faz com que @code{F}
seja aplicado a @var{expr}.
@item
Qualquer outro nome de fun@,{c}@~ao (e.g., @code{sum}) causa a avalia@,{c}@~ao de ocorr@^encias
desses nomes em @var{expr} mesmo que eles tenham sido verbos.
@item
De forma adicional uma fun@,{c}@~ao ocorrendo em @var{expr} (digamos @code{F(x)}) pode ser definida
localmente para o prop@'osito dessa avalia@,{c}@~ao de @var{expr} dando
@code{F(x) := express@~ao} como um argumento para @code{ev}.
@item
Se um @'atomo n@~ao mensionado acima ou uma vari@'avel subscrita ou
express@~ao subscrita for dada como um argumento, isso @'e avaliado e
se o resultado for uma equa@,{c}@~ao ou uma atribui@,{c}@~ao ent@~ao a associa@,{c}@~ao indicada
ou substitui@,{c}@~ao @'e executada.  Se o resultado for uma lista ent@~ao os
membros da lista ser@~ao tratados  como se eles fossem argumentos adicionais
dados para @code{ev}.  Isso permite que uma lista de equa@,{c}@~oes seja dada (e.g. @code{[X=1, Y=A**2]})
ou que seja dado uma lista de nomes de equa@,{c}@~oes (e.g., @code{[%t1, %t2]} onde @code{%t1} e
@code{%t2} s@~ao equa@,{c}@~oes) tais como aquelas listas retornadas por @code{solve}.
@end itemize

Os argumentos de @code{ev} podem ser dados em qualquer ordem com exce@,{c}@~ao de
substitui@,{c}@~oes de equa@,{c}@~oes que s@~ao manuseadas em sequ@^encia, da esquerda para a direita,
e fun@,{c}@~oes de avalia@,{c}@~ao que s@~ao compostas, e.g., @code{ev (@var{expr}, ratsimp, realpart)} s@~ao
manuseadas como @code{realpart (ratsimp (@var{expr}))}.

Os comutadores @code{simp}, @code{numer}, @code{float}, e @code{pred} podem tamb@'em ser alterados localmente em um
bloco, ou globalmente no Maxima dessa forma eles ir@~a
permanecer em efeito at@'e serem resetados ao t@'ermino da execu@value{cedilha}@~ao do bloco.

Se @var{expr} for uma express@~ao racional can@'onica (CRE),
ent@~ao a express@~ao retornada por @code{ev} @'e tamb@'em uma CRE,
contanto que os comutadores @code{numer} e @code{float} n@~ao sejam ambos @code{true}.

@item
Durante o passo (1), @'e feito uma lista  de vari@'aveis n@~ao subscritas
aparecendo do lado esquerdo das equa@,{c}@~oes nos argumentos ou nos
valores de alguns argumentos se o valor for uma equa@,{c}@~ao.  As vari@'aveis
(vari@'aveis subscritas que n@~ao possuem fun@,{c}@~oes array
associadas bem como vari@'aveis n@~ao subscritas) na express@~ao @var{expr} s@~ao
substitu@'{@dotless{i}}das por seus valores globais, excepto para esse aparecendo nessa 
lista.  Usualmente, @var{expr} @'e apenas um r@'otulo ou @code{%}
(como em @code{%i2} no exemplo adiante), ent@~ao esse 
passo simplesmente repete a express@~ao nomeada pelo r@'otulo, de modo que @code{ev}
possa trabalhar sobre isso.

@item
Se quaisquer substitui@,{c}@~oes tiveem sido indicadas pelos argumentos, elas ser@~ao
realizadas agora.

@item
A express@~ao resultante @'e ent@~ao reavaliada (a menos que um dos
argumentos seja @code{noeval}) e simplificada conforme os argumentos.  Note que
qualquer chamada de fun@,{c}@~ao em @var{expr} ser@'a completada depois das vari@'aveis
nela serem avalidas e que @code{ev(F(x))} dessa forma possa comportar-se como @code{F(ev(x))}.

@item
Para cada inst@^ancia de @code{eval} nos argumentos, os passos (3) e (4) s@~ao repetidos.
@end enumerate

                     Exemplos

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Uma sintaxe alternativa de alto n@'{@dotless{i}}vel tem sido provida por @code{ev}, por meio da qual
se pode apenas digitar seus argumentos, sem o @code{ev()}.  Isto @'e, se pode
escrever simplesmente

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Isso n@~ao @'e permitido como parte de
outra express@~ao, e.g., em fun@,{c}@~oes, blocos, etc.

Observe o processo de associa@,{c}@~ao paralela no seguinte exemplo.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end deffn

@defvr {Propriedade} evflag
Quando um s@'{@dotless{i}}mbolo @var{x} tem a propriedade @code{evflag},
as express@~oes @code{ev(@var{expr}, @var{x})} e @code{@var{expr}, @var{x}}
(na linha de comando interativa) s@~ao equivalentes a @code{ev(@var{expr}, @var{x} = true)}.
Isto @'e, @var{x} est@'a associada a @code{true} enquanto @var{expr} for avaliada.

A express@~ao @code{declare(@var{x}, evflag)}
fornece a propriedade @code{evflag} para a vari@'avel @var{x}.

Os sinalizadores que possuem a propriedade @code{evflag} por padr@~ao s@~ao os seguintes:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand}, e
@code{trigexpand}.

Exemplos:

@c ===beg===
@c sin (1/2);
@c sin (1/2), float;
@c sin (1/2), float=true;
@c simp : false;
@c 1 + 1;
@c 1 + 1, simp;
@c simp : true;
@c sum (1/k^2, k, 1, inf);
@c sum (1/k^2, k, 1, inf), simpsum;
@c declare (aa, evflag);
@c if aa = true then YES else NO;
@c if aa = true then YES else NO, aa;
@c ===end===
@example
(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        >    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then SIM else N@~AO;
(%o11)                         N@~AO
(%i12) if aa = true then SIM else N@~AO, aa;
(%o12)                         SIM
@end example

@end defvr

@defvr {Propriedade}  evfun
Quando uma fun@,{c}@~ao @var{F} tem a propriedade @code{evfun},
as express@~oes @code{ev(@var{expr}, @var{F})} e @code{@var{expr}, @var{F}}
(na linha de comando interativa)
s@~ao equivalentes a @code{@var{F}(ev(@var{expr}))}.

Se duas ou mais fun@,{c}@~oes @var{F}, @var{G}, etc., que possuem a propriedade @code{evfun} forem especificadas,
as fun@,{c}@~oes ser@~ao aplicadas na ordem em que forem especificadas.

A express@~ao @code{declare(@var{F}, evfun)}
fornece a propriedade @code{evfun} para a fun@,{c}@~ao @var{F}.

As fun@,{c}@~oes que possuem a propriedade @code{evfun} por padr@~ao s@~ao as seguintes:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, e
@code{trigreduce}.

Exemplos:
 
@c ===beg===
@c x^3 - 1;
@c x^3 - 1, factor;
@c factor (x^3 - 1);
@c cos(4 * x) / sin(x)^4;
@c cos(4 * x) / sin(x)^4, trigexpand;
@c cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
@c ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
@c declare ([F, G], evfun);
@c (aa : bb, bb : cc, cc : dd);
@c aa;
@c aa, F;
@c F (aa);
@c F (ev (aa));
@c aa, F, G;
@c G (F (ev (aa)));
@c ===end===
@example
(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
@end example

@end defvr

@c NEEDS WORK
@defvr {Vari@'avel de op@,{c}@~ao} infeval
Habilita o modo "avalia@,{c}@~ao infinita".  @code{ev} repetidamente avalia
uma express@~ao at@'e que ela permane@,{c}a invariante.  Para prevenir uma
vari@'avel, digamos @code{X}, seja demoradamente avaliada nesso modo, simplesmente
inclua @code{X='X} como um argumento para @code{ev}.  Certamente express@~oes tais como
@code{ev (X, X=X+1, infeval)} ir@~ao gerar um ciclo infinito.

@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Fun@,{c}@~ao} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Fun@,{c}@~ao} kill (labels)
@deffnx {Fun@,{c}@~ao} kill (inlabels, outlabels, linelabels)
@deffnx {Fun@,{c}@~ao} kill (@var{n})
@deffnx {Fun@,{c}@~ao} kill ([@var{m}, @var{n}])
@deffnx {Fun@,{c}@~ao} kill (values, functions, arrays, ...)
@deffnx {Fun@,{c}@~ao} kill (all)
@deffnx {Fun@,{c}@~ao} kill (allbut (@var{a_1}, ..., @var{a_n}))

Remove todas as associa@,{c}@~oes (valor, fun@,{c}@~oes, array, ou regra) dos argumentos
@var{a_1}, ..., @var{a_n}.
Um argumento @var{a_k} pode ser um s@'{@dotless{i}}mbolo ou um elemento de array simples.
Quando @var{a_k} for um elemento de array simples, @code{kill} remove a associa@,{c}@~ao daquele elemento
sem afectar qualquer outro elemento do array.

Muitos argumentos especiais s@~ao reconhecidos.  
Diferentes fam@'{@dotless{i}}lias de argumentos 
podem ser combinadas, e.g., @code{kill (inlabels, functions, allbut (foo, bar))}

todos os r@'otulos de entrada, de sa@'{@dotless{i}}da, e de express@~oes interm@'edias criados at@'e ent@~ao.
@code{kill (inlabels)} libera somente r@'otudos de entrada 
que come@,{c}am com o valor corrente de @code{inchar}.
De forma semelhante,
@code{kill (outlabels)} libera somente r@'otulos de sa@'{@dotless{i}}da
que come@,{c}am com o valor corrente de @code{outchar},
e @code{kill (linelabels)} libera somente r@'otulos de express@~oes interm@'edias
que come@,{c}am com o valor corrente de @code{linechar}.

@code{kill (@var{n})}, onde @var{n} @'e um inteiro,
libera os @var{n} mais recentes r@'otulos de entrada e sa@'{@dotless{i}}da.

@code{kill ([@var{m}, @var{n}])} libera r@'otulos de entrada e sa@'{@dotless{i}}da de @var{m} at@'e @var{n}.

@code{kill (@var{infolist})}, onde @var{infolist} @'e um item em @code{infolists}
(tais como @code{values}, @code{functions}, ou @code{arrays})
libera todos os @'{@dotless{i}}tens em @var{infolist}.
Veja tamb@'em @code{infolists}.

@code{kill (all)} liberar todos os @'{@dotless{i}}tens em todas as infolists.
@code{kill (all)} n@~ao retorna vari@'aveis globais para seus valores padr@~oes;
Veja @code{reset} sobre esse ponto.

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
remove a associa@,{c}@~ao de todos os itens sobre todas as infolistas excepto para @var{a_1}, ..., @var{a_n}.
@code{kill (allbut (@var{infolist}))} libera todos os @'{@dotless{i}}tens excepto para si pr@'oprio em @var{infolist},
onde @var{infolist} @'e @code{values}, @code{functions}, @code{arrays}, etc.

A mem@'oria usada por uma propriedade de associa@,{c}@~ao n@~ao ser@'a liberada at@'e que todos os s@'{@dotless{i}}mbolos
sejam liberados disso.
Em particular, para liberar a mem@'oria usada pelo valor de um s@'{@dotless{i}}mbolo,
deve-se liberar o r@'otulo de sa@'{@dotless{i}}da que mosta o valor associado, bem como liberando o pr@'oprio s@'{@dotless{i}}mbolo.

@code{kill} coloca um ap@'ostro em seus argumentos (n@~ao os avalia).
O operador ap@'ostrofo-ap@'ostrofo, @code{'@w{}'}, faz com que ocorra avalia@,{c}@~ao.

@code{kill (@var{s@'{@dotless{i}}mbolo})} libera todas as propriedades de @var{s@'{@dotless{i}}mbolo}.
Em oposi@,{c}@~ao, @code{remvalue}, @code{remfunction}, @code{remarray}, e @code{remrule}
liberam uma propriedade espec@'{@dotless{i}}fica.

@code{kill} sempre retorna @code{done}, igualmente se um argumento n@~ao tem associa@,{c}@~oes.

@end deffn

@deffn {Fun@,{c}@~ao} labels (@var{s@'{@dotless{i}}mbolo})
@deffnx {Vari@'avel de sistema} labels
Retorna a lista de r@'otulos de entradas, de sa@'{@dotless{i}}da, de express@~oes interm@'edias que come@,{c}am com @var{s@'{@dotless{i}}mbolo}.
Tipicamente @var{s@'{@dotless{i}}mbolo} @'e o valor de @code{inchar}, @code{outchar}, ou @code{linechar}.
O caracter r@'otulo pode ser dado com ou sem o sinal de porcentagem,
ent@~ao, por exemplo, @code{i} e @code{%i} retornam o mesmo resultado.

Se nenhum r@'otulo come@,{c}a com @var{s@'{@dotless{i}}mbolo}, @code{labels} retorna uma lista vazia.

A fun@,{c}@~ao @code{labels} n@~ao avalia seu argumento.
O operador ap@'ostrofo-ap@'ostrofo @code{'@w{}'} faz com que ocorra avalia@,{c}@~ao.
Por exemplo,
@code{labels (''inchar)} retorna os r@'otulos de entrada que come@,{c}am com o caractere corrente do r@'otulo de entrada.

A vari@'avel @code{labels} @'e uma lista de r@'otulos de entrada, sa@'{@dotless{i}}da, e de express@~oes interm@'edias,
incluindo todos os r@'otulos anteriores se @code{inchar}, @code{outchar}, ou @code{linechar} que tiverem sido redefinidos.

Por padr@~ao, Maxima mostra o resultado de cada express@~ao de entrada do utilizador,
dando ao resultado um r@'otulo de sa@'{@dotless{i}}da.
A exibi@,{c}@~ao da sa@'{@dotless{i}}da @'e suprimida pelo encerramento da entrada com @code{$} (sinal de dolar)
em lugar de @code{;} (ponto e v@'{@dotless{i}}rgula).
Um r@'otulo de sa@'{@dotless{i}}da @'e construido e associado ao resultado, mas n@~ao @'e mostrado, 
e o r@'otulo pode ser referenciado da mesma forma que r@'otulos de sa@'{@dotless{i}}da mostrados.
Veja tamb@'em @code{%}, @code{%%}, e @code{%th}.

R@'otulos de express@~oes interm@'edias podem ser gerados por algumas fun@,{c}@~oes.
O sinalizador @code{programmode} controla se @code{solve} e algumas outras fun@,{c}@~oes
geram r@'otulos de express@~oes interm@'edias em lugar de retornar uma lista de express@~oes.
Algumas outras fun@,{c}@~oes, tais como @code{ldisplay}, sempre geram r@'otulos de express@~oes interm@'edias.

Veja tamb@'em @code{inchar}, @code{outchar}, @code{linechar}, e @code{infolists}.

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Vari@'avel de sistema} linenum
Retorna o n@'umero da linha do par corrente de express@~oes de entrada e sa@'{@dotless{i}}da.

@end defvr

@c NEEDS WORK
@defvr {Vari@'avel de sistema} myoptions
Valor por omiss@~ao: @code{[]}

@code{myoptions} @'e a lista de todas as op@,{c}@~oes alguma vez alteradas pelo utilizador,
tenha ou n@~ao ele retornado a altera@,{c}@~ao para o seu valor padr@~ao.

@end defvr

@defvr {Vari@'avel de op@,{c}@~ao} nolabels
Valor por omiss@~ao: @code{false}

@c PREVIOUS DESCRIPTION OF nolabels: THIS IS OUT OF DATE
@c When @code{nolabels} is @code{true}, then no labels will be bound
@c except for intermediate expression lines generated by the solve functions.  This is most
@c useful in the batch mode where it eliminates the need to do
@c @code{kill (labels)} in order to free up storage.

Quando @code{nolabels} for @code{true},
r@'otulos de entrada e sa@'{@dotless{i}}da
(@code{%i} e @code{%o}, respectivamente)
s@~ao mostrados,
mas os r@'otulos n@~ao s@~ao associados aos resultados,
e os r@'otulos n@~ao s@~ao anexados ao final da lista @code{labels}.
Uma vez que r@'otulos n@~ao s@~ao associados aos resultados,
a reciclagem pode recuperar a mem@'oria tomada pelos resultados.

De outra forma r@'otulos de entrada e sa@'{@dotless{i}}da s@~ao associados aos resultados,
e os r@'otulos s@~ao anexados ao final da lista @code{labels}.

Veja tamb@'em @code{batch}, @code{batchload}, e @code{labels}.

@end defvr

@c NEEDS WORK
@defvr {Vari@'avel de op@,{c}@~ao} optionset
Valor por omiss@~ao: @code{false}

Quando @code{optionset} for @code{true}, Maxima mostrar@'a uma
mensagem sempre que uma op@,{c}@~ao do Maxima for alterada.  Isso @'e @'util se o
utilizador est@'a incerto sobre a ortografia de alguma op@,{c}@~ao e quer ter certeza
que a vari@'avel por ele atribu@'{@dotless{i}}do um valor foi realmente uma vari@'avel de op@,{c}@~ao.

@end defvr

@deffn {Fun@,{c}@~ao} playback ()
@deffnx {Fun@,{c}@~ao} playback (@var{n})
@deffnx {Fun@,{c}@~ao} playback ([@var{m}, @var{n}])
@deffnx {Fun@,{c}@~ao} playback ([@var{m}])
@deffnx {Fun@,{c}@~ao} playback (input)
@deffnx {Fun@,{c}@~ao} playback (slow)
@deffnx {Fun@,{c}@~ao} playback (time)
@deffnx {Fun@,{c}@~ao} playback (grind)
Mostra express@~oes de entrada, de sa@'{@dotless{i}}da, e express@~oes interm@'edias,
sem refazer os c@'alculos.
@code{playback} somente mostra as express@~oes associadas a r@'otulos;
qualquer outra sa@'{@dotless{i}}da (tais como textos impressos por @code{print} ou @code{describe}, ou messagens de erro)
n@~ao @'e mostrada.
Veja tamb@'em @code{labels}.

@code{playback} n@~ao avalia seus argumentos.
O operador ap@'ostrofo-ap@'ostrofo, @code{'@w{}'}, sobrep@~oe-se @`as aspas.
@code{playback} sempre retorna @code{done}.

@code{playback ()} (sem argumentos) mostra todas as entradas, sa@'{@dotless{i}}das e express@~oes interm@'edias
geradas at@'e ent@~ao.
Uma express@~ao de sa@'{@dotless{i}}da @'e mostrada mesmo se for suprimida pelo terminador @code{$}
quando ela tiver sido originalmente calculada.

@code{playback (@var{n})} mostra as mais recentes @var{n} express@~oes.
Cada entrada, sa@'{@dotless{i}}da e express@~ao interm@'edia
conta como um.

@code{playback ([@var{m}, @var{n}])} mostra entradas, sa@'{@dotless{i}}das e express@~oes interm@'edias
com os n@'umeros de @var{m} at@'e @var{n}, inclusive.

@code{playback ([@var{m}])} @'e equivalente a @code{playback ([@var{m}, @var{m}])};
isso usualmente imprime um par de express@~oes de entrada e sa@'{@dotless{i}}da.

@code{playback (input)} mostra todas as express@~oes de entrada geradas at@'e ent@~ao.

@code{playback (slow)} insere pausas entre express@~oes
e espera que o utilizador pressione @code{enter}.
Esse comportamento @'e similar a @code{demo}.
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} @'e @'util juntamente com @code{save} ou @code{stringout}
quando criamos um ficheiro secund@'ario de armazenagem com a finalidade de capturar express@~oes @'uteis.

@code{playback (time)} mostra o tempo de computa@,{c}@~ao de cada express@~ao.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} e @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} mostra express@~oes de entrada
no mesmo formato da fun@,{c}@~ao @code{grind}.
Express@~oes de sa@'{@dotless{i}}da n@~ao s@~ao afectadas pela op@,{c}@~ao @code{grind}.
Veja @code{grind}.

Argumentos podem ser combinados, e.g., 
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS).  CORRECT ???

@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Fun@,{c}@~ao} printprops (@var{a}, @var{i})
@deffnx {Fun@,{c}@~ao} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Fun@,{c}@~ao} printprops (all, @var{i})
Mostra a propriedade como o indicador @var{i}
associada com o @'atomo @var{a}.  @var{a} pode tamb@'em ser uma lista de @'atomos ou o @'atomo
@code{all} nesse caso todos os @'atomos com a propriedade dada ser@~ao
usados.  Por exemplo, @code{printprops ([f, g], atvalue)}.  @code{printprops} @'e para
propriedades que n@~ao podem  ser mostradas de outra forma, i.e. para
@code{atvalue}, @code{atomgrad}, @code{gradef}, e @code{matchdeclare}.

@end deffn

@defvr {Vari@'avel de op@,{c}@~ao} prompt
Valor por omiss@~ao: @code{_}

@code{prompt} @'e o s@'{@dotless{i}}mbolo de linha de comando da fun@,{c}@~ao @code{demo},
modo @code{playback (slow)}, e da interrup@,{c}@~ao de ciclos do Maxima (como invocado por @code{break}).

@end defvr

@deffn {Fun@,{c}@~ao} quit ()
Encerra a sess@~ao do Maxima.
Note que a fun@,{c}@~ao pode ser invocada como @code{quit();} ou @code{quit()$},
n@~ao por s@'{@dotless{i}} mesma @code{quit}.

Para parar um c@'alculo muito longo,
digite @code{control-C}.
A a@,{c}@~ao padr@~ao @'e retornar @`a linha de comando do Maxima.
Se @code{*debugger-hook*} @'e @code{nil},
@code{control-C} abre o depurador Lisp.
Veja tamb@'em @code{debugging}.

@end deffn

@deffn {Fun@,{c}@~ao} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@,{c}@~ao} remfunction (all)
Desassocia as defini@,{c}@~oes de fun@,{c}@~ao dos s@'{@dotless{i}}bolos @var{f_1}, ..., @var{f_n}.
Os argumentos podem ser os nomes de fun@,{c}@~oes comuns (criadas por meio de @code{:=} ou @code{define})
ou fun@,{c}@~oes macro (criadas por meio de @code{::=}).

@code{remfunction (all)} desassocia todas as defini@,{c}@~oes de func@,{c}@~ao.

@code{remfunction} coloca um ap'ostrofo em seus argumentos (n@~ao os avalia).

@code{remfunction} retorna uma lista de s@'{@dotless{i}}mbolos para a qual a defini@,{c}@~ao de fun@,{c}@~ao foi desassociada.
@code{false} @'e retornado em lugar de qualquer s@'{@dotless{i}}mbolo para o qual n@~ao exista defini@,{c}@~ao de fun@,{c}@~ao.

@end deffn

@deffn {Fun@,{c}@~ao} reset ()
Retorna muitas vari@'aveis globais e op@,{c}@~oes, e algumas outras vari@'aveis, para seus valores padr@~oes.

@code{reset} processa as vari@'aveis na lista Lisp @code{*variable-initial-values*}.
A macro Lisp @code{defmvar} coloca vari@'aveis nessa lista (entre outras a@,{c}@~oes).
Muitas, mas n@~ao todas, vari@'aveis globais e op@,{c}@~oes s@~ao definidas por @code{defmvar},
 e algumas vari@'aveis definidas por @code{defmvar} n@~ao s@~ao vari@'aveis globais ou vari@'aveis de op@,{c}@~ao.

@end deffn

@defvr {Vari@'avel de op@,{c}@~ao} showtime
Valor por omiss@~ao: @code{false}

Quando @code{showtime} for @code{true}, o tempo de computa@,{c}@~ao e o tempo decorrido s@~ao
impressos na tela com cada express@~ao de sa@'{@dotless{i}}da.

O tempo de c@'alculo @'e sempre gravado,
ent@~ao @code{time} e @code{playback} podem mostrar o tempo de c@'alculo
mesmo quando @code{showtime} for @code{false}.

Veja tamb@'em @code{timer}.

@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Fun@,{c}@~ao} sstatus (@var{recurso}, @var{pacote})
Altera o status de @var{recurso} em @var{pacote}.
Ap@'os @code{sstatus (@var{recurso}, @var{pacote})} ser executado,
@code{status (@var{recurso}, @var{pacote})} retorna @code{true}.
Isso pode ser @'util para quem escreve pacotes, para
manter um registro de quais recursos os pacotes usam.

@end deffn

@c NEEDS EXPANSION, EXAMPLES
@deffn {Fun@,{c}@~ao} to_lisp ()
Insere o sistema Lisp dentro do Maxima.  @code{(to-maxima)} retorna para o Maxima.

@end deffn

@defvr {Vari@'avel de sistema} values
Valor inicial: @code{[]}

@code{values} @'e uma lista de todas as var@'aveis de utilizador associadas (n@~ao op@,{c}@~oes Maxima ou comutadores).
A lista compreende s@'{@dotless{i}}mbolos associados por @code{:} , @code{::}, ou @code{:=}.

@end defvr
