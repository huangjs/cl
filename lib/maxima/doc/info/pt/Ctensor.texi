@c /Ctensor.texi/1.31/Sun Jul 30 08:49:51 2006/-ko/
@menu
* Introdu@value{cedilha}@~ao a ctensor::     
* Defini@value{cedilha}@~oes para ctensor::     
@end menu

@node Introdu@value{cedilha}@~ao a ctensor, Defini@value{cedilha}@~oes para ctensor, ctensor, ctensor
@section Introdu@value{cedilha}@~ao a ctensor

@code{ctensor} @'e um pacote de manipula@value{cedilha}@~ao de
componentes.  Para usar o pacote @code{ctensor}, digite
@code{load(ctensor)}.  Para come@value{cedilha}ar uma sess@~ao iterativa
com @code{ctensor}, digite @code{csetup()}. O primeiro que ser@'a pedido
pelo pacote @'e a dimens@~ao a ser manipulada. Se a dimens@~ao for 2, 3
ou 4 ent@~ao a lista de coordenadas padr@~ao @'e @code{[x,y]},
@code{[x,y,z]} ou @code{[x,y,z,t]} respectivamente.  Esses nomes podem
ser mudados atrav@'es da atribui@value{cedilha}@~ao de uma nova lista de
coordenadas para a vari@'avel @code{ct_coords} (descrita abaixo) e o
utilizador @'e questionado sobre isso. Deve ter o cuidado de evitar
conflitos de nomes de coordenadas com outras defini@value{cedilha}@~oes
de objectos.

No pr@'oximo passo, o utilizador informa a m@'etrica ou directamente ou
de um ficheiro especificando sua posi@value{cedilha}@~ao ordinal. Como
um exemplo de um ficheiro de m@'etrica comum, veja
@file{share/tensor/metrics.mac}. A m@'etrica @'e armazenada na matriz
LG. Finalmente, o inverso da m@'etrica @'e calculado e armazenado na
matriz UG. Se tem a op@value{cedilha}@~ao de realizar todos os
c@'alculos em s@'eries de pot@^encia.

A seguir, mostramos um exemplo de protocolo para a m@'etrica est@'atica,
esfericamente sim@'etrica (coordenadas padr@~ao) que ser@'a aplicada ao
problema de deriva@value{cedilha}@~ao das equa@value{cedilha}@~oes de
v@'acuo de Einstein (que levam @`a solu@value{cedilha}@~ao de
Schwarzschild). Muitas das fun@value{cedilha}@~oes em @code{ctensor}
ir@~ao ser mostradas como exemplos para a m@'etrica padr@~ao.

@example
(%i1) load(ctensor);
(%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system: 
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none 
depends([a,d],x);
Do you wish to see the metric? 
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done

@end example

@c end concepts ctensor
@node Defini@value{cedilha}@~oes para ctensor,  , Introdu@value{cedilha}@~ao a ctensor, ctensor

@section Defini@value{cedilha}@~oes para ctensor

@subsection Inicializa@value{cedilha}@~ao e configura@value{cedilha}@~ao

@deffn {Fun@value{cedilha}@~ao} csetup ()
@'E uma fun@value{cedilha}@~ao no pacote @code{ctensor} (component
tensor) que inicializa o pacote e permite ao utilizador inserir uma
m@'etrica interativamente. Veja @code{ctensor} para mais detalhes.
@end deffn

@deffn {Fun@value{cedilha}@~ao} cmetric (@var{dis})
@deffnx {Fun@value{cedilha}@~ao} cmetric ()
@'E uma fun@value{cedilha}@~ao no pacote @code{ctensor} que calcula o
inverso da m@'etrica e prepara o pacote para c@'alculos adiante.

Se @code{cframe_flag} for @code{false}, a fun@value{cedilha}@~ao calcula
a m@'etrica inversa @code{ug} a partir da matriz @code{lg} (definida
pelo utilizador). O determinante da m@'etrica @'e tamb@'em calculado e
armazenado na vari@'avel @code{gdet}. Mais adiante, o pacote determina
se a m@'etrica @'e diagonal e escolhe o valor de @code{diagmetric}
conforme a determina@value{cedilha}@~ao. Se o argumento opcional
@var{dis} estiver presente e n@~ao for @code{false}, a
sa@'{@dotless{i}}da @'e mostrada ao utilizador pela linha de comando
para que ele possa ver o inverso da m@'etrica.

Se @code{cframe_flag} for @code{true}, a fun@value{cedilha}@~ao espera
que o valor de @code{fri} (a matriz referencial inversa) e @code{lfg} (a
m@'etrica do referencial) sejam definidas. A partir dessas, a matriz do
referencial @code{fr} e a m@'etrica do referencial inverso @code{ufg}
s@~ao calculadas.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ct_coordsys (@var{sistema_de_coordenadas}, @var{extra_arg})
@deffnx {Fun@value{cedilha}@~ao} ct_coordsys (@var{sistema_de_coordenadas})
Escolhe um sistema de coordenadas predefinido e uma m@'etrica. O
argumento @var{sistema_de_coordenadas} pode ser um dos seguintes
s@'{@dotless{i}}mbolos:

@example

  SYMBOL               Dim Coordenadas       Descri@value{cedilha}@~ao/coment@'arios
  --------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
  polar                 2  [r,phi]           Sist. de coord. Polare
  elliptic              2  [u,v]
  confocalelliptic      2  [u,v]
  bipolar               2  [u,v]
  parabolic             2  [u,v]
  cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
  polarcylindrical      3  [r,theta,z]
  ellipticcylindrical   3  [u,v,z]           El@'{@dotless{i}}ptica 2D com Z cil@'{@dotless{i}}ndrico
  confocalellipsoidal   3  [u,v,w]
  bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cil@'{@dotless{i}}ndrico
  paraboliccylindrical  3  [u,v,z]           Parab@'olico 2D com Z cil@'{@dotless{i}}ndrico
  paraboloidal          3  [u,v,phi]
  conical               3  [u,v,w]
  toroidal              3  [u,v,phi]
  spherical             3  [r,theta,phi]     Sist. de coord. Esf@'ericas
  oblatespheroidal      3  [u,v,phi]
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]
  cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
  spherical4d           4  [r,theta,eta,phi]
  exteriorschwarzschild 4  [t,r,theta,phi]   M@'etrica de Schwarzschild
  interiorschwarzschild 4  [t,z,u,v]        M@'etrica de Schwarzschild Interior
  kerr_newman           4  [t,r,theta,phi]   M@'etrica sim@'etrica axialmente alterada

@end example

@code{sistema_de_coordenadas} pode tamb@'em ser uma lista de fun@value{cedilha}@~oes de transforma@value{cedilha}@~ao,
seguida por uma lista contendo as var@'aveis coordenadas. Por exemplo,
pode especificar uma m@'etrica esf@'erica como segue:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

@end example

Fun@value{cedilha}@~oes de transforma@value{cedilha}@~ao podem tamb@'em
serem usadas quando @code{cframe_flag} for @code{true}:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

@end example

O argumento opcional @var{extra_arg} pode ser qualquer um dos seguintes:
@c LOOKING AT share/tensor/ctensor.mac CIRCA LINE 837, misner IS RECOGNIZED ALSO; WHAT EFFECT DOES IT HAVE ??

@code{cylindrical} diz a @code{ct_coordsys} para anexar uma coordenada
adicional cil@'{@dotless{i}}ndrica.

@code{minkowski} diz a @code{ct_coordsys} para anexar uma coordenada com
assinatura m@'etrica negativa.

@code{all} diz a @code{ct_coordsys} para chamar @code{cmetric} e
@code{christof(false)} ap@'os escolher a m@'etrica.

@c GLOBAL VARIABLE verbose IS USED IN ctensor.mac IN JUST THIS ONE CONTEXT
Se a vari@'avel global @code{verbose} for escolhida para @code{true},
@code{ct_coordsys} mostra os valores de @code{dim}, @code{ct_coords}, e
ou @code{lg} ou @code{lfg} e @code{fri}, dependendo do valor de
@code{cframe_flag}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} init_ctensor ()
Inicializa o pacote @code{ctensor}.

A fun@value{cedilha}@~ao @code{init_ctensor} reinicializa o pacote
@code{ctensor}. Essa fun@value{cedilha}@~ao remove todos os arrays e
matrizes usados por @code{ctensor}, coloca todos os sinalizadores de
volta a seus valores padr@~ao, retorna @code{dim} para 4, e retorna a
m@'etrica do referencial para a m@'etrica do referencial de Lorentz.

@end deffn


@subsection Os tensores do espa@value{cedilha}o curvo

O principal prop@'osito do pacote @code{ctensor} @'e calcular os
tensores do espa@value{cedilha}(tempo) curvo, mais notavelmente os
tensores usados na relatividade geral.

Quando uma base m@'etrica @'e usada, @code{ctensor} pode calcular os
seguintes tensores:

@example

 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric 
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


@end example

@code{ctensor} pode tamb@'em usar referenciais m@'oveis. Quando
@code{cframe_flag} for escolhida para @code{true}, os seguintes tensores
podem ser calculados:

@example

 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

@end example

@deffn {Fun@value{cedilha}@~ao} christof (@var{dis})
Uma fun@value{cedilha}@~ao no pacote @code{ctensor}.  Essa
fun@value{cedilha}@~ao calcula os s@'{@dotless{i}}mbolos de Christoffel
de ambos os tipos.  O argumento @var{dis} determina quais resultados
s@~ao para serem imediatamente mostrados.  Os s@'{@dotless{i}}mbolos de
Christoffel de primeiro e de segundo tipo s@~ao armazenados nos arrays
@code{lcs[i,j,k]} e @code{mcs[i,j,k]} respectivamente e definidos para
serem sim@'etricos nos primeiros dois @'{@dotless{i}}ndices. Se o
argumento para @code{christof} for @code{lcs} ou for @code{mcs} ent@~ao
o @'unico valor n@~ao nulo de @code{lcs[i,j,k]} ou de @code{mcs[i,j,k]},
respectivamente, ser@'a mostrado. Se o argumento for @code{all} ent@~ao
o @'unico valor n@~ao nulo de @code{lcs[i,j,k]} e o @'unico valor n@~ao
nulo de @code{mcs[i,j,k]} ser@~ao mostrados.  Se o argumento for
@code{false} ent@~ao a exibi@value{cedilha}@~ao dos elementos n@~ao
acontecer@'a. Os elementos do array @code{mcs[i,j,k]} s@~ao definidos de
uma tal maneira que o @'{@dotless{i}}ndice final @'e contravariante.
@end deffn

@deffn {Fun@value{cedilha}@~ao} ricci (@var{dis})
Uma fun@value{cedilha}@~ao no pacote @code{ctensor}.  @code{ricci}
calcula as componentes contravariantes (sim@'etricas) @code{ric[i,j]} do
tensor de Ricci.  Se o argumento @var{dis} for @code{true}, ent@~ao as
componentes n@~ao nulas s@~ao mostradas.
@end deffn

@deffn {Fun@value{cedilha}@~ao} uricci (@var{dis})
Essa fun@value{cedilha}@~ao primeiro calcula as componentes
contravariantes @code{ric[i,j]} do tensor de Ricci.  Ent@~ao o tensor
misto de Ricci @'e calculado usando o tensor m@'etrico contravariante.
Se o valor do argumento @var{dis} for @code{true}, ent@~ao essas
componentes mistas, @code{uric[i,j]} (o @'{@dotless{i}}ndice "i" @'e
covariante e o @'{@dotless{i}}ndice "j" @'e contravariante), ser@~ao
mostradas directamente.  De outra forma, @code{ricci(false)} ir@'a
simplesmente calcular as entradas do array @code{uric[i,j]} sem mostrar
os resultados.

@end deffn
@deffn {Fun@value{cedilha}@~ao} scurvature ()

Retorna a curvatura escalar (obtida atrav@'es da
contra@value{cedilha}@~ao do tensor de Ricci) do Riemaniano multiplicado
com a m@'etrica dada.

@end deffn
@deffn {Fun@value{cedilha}@~ao} einstein (@var{dis})
Uma fun@value{cedilha}@~ao no pacote @code{ctensor}.  @code{einstein}
calcula o tensor misto de Einstein ap@'os os s@'{@dotless{i}}mbolos de
Christoffel e o tensor de Ricci terem sido obtidos (com as
fun@value{cedilha}@~oes @code{christof} e @code{ricci}).  Se o argumento
@var{dis} for @code{true}, ent@~ao os valores n@~ao nulos do tensor
misto de Einstein @code{ein[i,j]} ser@~ao mostrados quando @code{j} for
o @'{@dotless{i}}ndice contravariante.  A vari@'avel @code{rateinstein}
far@'a com que a simplifica@value{cedilha}@~ao racional ocorra sobre
esses componentes. Se @code{ratfac} for @code{true} ent@~ao as
componentes ir@~ao tamb@'em ser factoradas.

@end deffn
@deffn {Fun@value{cedilha}@~ao} leinstein (@var{dis})
Tensor covariante de Einstein. @code{leinstein} armazena o valor do
tensor covariante de Einstein no array @code{lein}. O tensor covariante
de Einstein @'e calculado a partir tensor misto de Einstein @code{ein}
atrav@'es da multiplica@value{cedilha}@~ao desse pelo tensor
m@'etrico. Se o argumento @var{dis} for @code{true}, ent@~ao os valores
n@~ao nulos do tensor covariante de Einstein s@~ao mostrados.

@end deffn

@deffn {Fun@value{cedilha}@~ao} riemann (@var{dis})
Uma fun@value{cedilha}@~ao no pacote @code{ctensor}.  @code{riemann}
calcula o tensor de curvatura de Riemann a partir da m@'etrica dada e
correspondendo aos s@'{@dotless{i}}mbolos de Christoffel. As seguintes
conven@value{cedilha}@~oes de @'{@dotless{i}}ndice s@~ao usadas:

@example
                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
@end example

Essa nota@value{cedilha}@~ao @'e consistente com a
nota@value{cedilha}@~ao usada por no pacote @code{itensor} e sua
fun@value{cedilha}@~ao @code{icurvature}.  Se o argumento opcional
@var{dis} for @code{true}, as componentes n@~ao nulas
@code{riem[i,j,k,l]} ser@~ao mostradas.  Como com o tensor de Einstein,
v@'arios comutadores escolhidos pelo utilizador controlam a
simplifica@value{cedilha}@~ao de componentes do tensor de Riemann.  Se
@code{ratriemann} for @code{true}, ent@~ao simplifica@value{cedilha}@~ao
racional ser@'a feita. Se @code{ratfac} for @code{true} ent@~ao cada uma
das componentes ir@'a tamb@'em ser factorada.

Se a vari@'avel @code{cframe_flag} for @code{false}, o tensor de Riemann
@'e calculado directamente dos s@'{@dotless{i}}mbolos de Christoffel. Se
@code{cframe_flag} for @code{true}, o tensor covariante de Riemann @'e
calculado primeiro dos coeficientes de campo do referencial.

@end deffn

@deffn {Fun@value{cedilha}@~ao} lriemann (@var{dis})
Tensor covariante de Riemann (@code{lriem[]}).

Calcula o tensor covariante de Riemann como o array @code{lriem}. Se o
argumento @var{dis} for @code{true}, @'unicos valores n@~ao nulos s@~ao
mostrados.

Se a vari@'avel @code{cframe_flag} for @code{true}, o tensor covariante
de Riemann @'e calculado directamente dos coeficientes de campo do
referencial. De outra forma, o tensor (3,1) de Riemann @'e calculado
primeiro.

Para informa@value{cedilha}@~ao sobre a ordena@value{cedilha}@~ao de
@'{@dotless{i}}ndice, veja @code{riemann}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} uriemann (@var{dis})
Calcula as componentes contravariantes do tensor de curvatura
 de Riemann como elementos do array @code{uriem[i,j,k,l]}.  Esses s@~ao
mostrados se @var{dis} for @code{true}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} rinvariant ()
Comp@~oe o invariante de Kretchmann (@code{kinvariant}) obtido atrav@'es
da contra@value{cedilha}@~ao dos tensores

@example
lriem[i,j,k,l]*uriem[i,j,k,l].
@end example

Esse objecto n@~ao @'e automaticamente simplificado devido ao facto de
poder ser muito largo.

@end deffn

@deffn {Fun@value{cedilha}@~ao} weyl (@var{dis})
Calcula o tensor conformal de Weyl.  Se o argumento @var{dis} for
@code{true}, as componentes n@~ao nulas @code{weyl[i,j,k,l]} ir@~ao ser
mostradas para o utilizador.  De outra forma, essas componentes ir@~ao
simplesmente serem calculadas e armazenadas.  Se o comutador
@code{ratweyl} @'e escolhido para @code{true}, ent@~ao as componentes
ir@~ao ser racionalmente simplificadas; se @code{ratfac} for @code{true}
ent@~ao os resultados ir@~ao ser factorados tamb@'em.

@end deffn

@subsection Expans@~ao das s@'eries de Taylor

O pacote @code{ctensor} possui a habilidade para truncar resultados
assumindo que eles s@~ao aproxima@value{cedilha}@~oes das s@'eries de
Taylor. Esse comportamenteo @'e controlado atrav@'es da vari@'avel
@code{ctayswitch}; quando escolhida para @code{true}, @code{ctensor} faz
uso internamente da fun@value{cedilha}@~ao @code{ctaylor} quando
simplifica resultados.

A fun@value{cedilha}@~ao @code{ctaylor} @'e invocada pelas seguintes fun@value{cedilha}@~oes de @code{ctensor}:

@example

    Function     Comments
    ---------------------------------
    christof()   s@'o para mcs
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
@end example

@deffn {Fun@value{cedilha}@~ao} ctaylor ()

A fun@value{cedilha}@~ao @code{ctaylor} trunca seus argumentos atrav@'es
da convers@~ao destes para uma s@'erie de Taylor usando @code{taylor}, e
ent@~ao chamando @code{ratdisrep}. Isso tem efeito combinado de
abandonar termos de ordem mais alta na vari@'avel de expans@~ao
@code{ctayvar}. A ordem dos termos que podem ser abandonados @'e
definida atrav@'es de @code{ctaypov}; o ponto em torno do qual a
expans@~ao da s@'erie @'e realizada est@'a especificado em
@code{ctaypt}.

Como um exemplo, considere uma m@'etrica simples que @'e uma
perturba@value{cedilha}@~ao da m@'etrica de Minkowski. Sem
restri@value{cedilha}@~oes adicionais, mesmo uma m@'etrica diagonal
produz express@~oes para o tensor de Einstein que s@~ao de longe muito
complexas:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
         [ h11 l - 1      0          0                 0            ]
         [                                                          ]
         [     0      h22 l + 1      0                 0            ]
         [                                                          ]
(%o8)    [                        2                                 ]
         [     0          0      r  + h33 l            0            ]
         [                                                          ]
         [                                    2    2                ]
         [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 24] 
[[2, 3], 0] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 0] 
[[3, 3], 46] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 46] 
(%o12)                               done

@end example

Todavia, se n@'os recalcularmos esse exemplo como uma
aproxima@value{cedilha}@~ao que @'e linear na vari@'avel @code{l},
pegamos express@~oes muito simples:

@example

(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 13] 
[[2, 3], 2] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 2] 
[[3, 3], 9] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 9] 
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                                2               2      4    2
                  - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                           r r                r



@end example

Essa compatibilidade pode ser @'util, por exemplo, quando trabalhamos no
limite do campo fraco longe de uma fonte gravitacional.

@end deffn
    

@subsection Campos de referencial

Quando a vari@'avel @code{cframe_flag} for escolhida para @code{true}, o
pacote @code{ctensor} executa seus c@'alculos usando um referencial
m@'ovel.

@deffn {Fun@value{cedilha}@~ao} frame_bracket (@var{fr}, @var{fri}, @var{diagframe})
O delimitador do referencial (@code{fb[]}).

Calcula o delimitador do referencial conforme a seguinte
defini@value{cedilha}@~ao:

@example
   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
@end example

@end deffn

@subsection Classifica@value{cedilha}@~ao Alg@'ebrica

Um novo recurso (a partir de November de 2004) de @code{ctensor} @'e sua habilidade para
calcular a classifica@value{cedilha}@~ao de Petrov de uma m@'etrica espa@value{cedilha}o tempo tetradimensional.
Para uma demonstra@value{cedilha}@~ao dessa compatibilidade, veja o ficheiro
@code{share/tensor/petrov.dem}.

@deffn {Fun@value{cedilha}@~ao} nptetrad ()
Calcula um tetrad nulo de Newman-Penrose (@code{np}) e seus @'{@dotless{i}}ndices ascendentes
em contrapartida (@code{npi}). Veja @code{petrov} para um exemplo.

O tetrad nulo @'e constru@'{@dotless{i}}do assumindo que um referencial
m@'etrico ortonormal tetradimensional com assinatura m@'etrica (-,+,+,+)
est@'a sendo usada.  As componentes do tetrad nulo s@~ao relacionadas
para a matriz referencial inversa como segue:

@example

np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} psi (@var{dis})
Calcula os cinco coeficientes de Newman-Penrose @code{psi[0]}...@code{psi[4]}.
Se @code{psi} for escolhida para @code{true}, os coeficientes s@~ao mostrados.
Veja @code{petrov} para um exemplo.

Esses coeficientes s@~ao calculados a partir do tensor de Weyl em uma
base de coordenada.  Se uma base de referencial for usada, o tensor de Weyl
@'e primeiro convertido para a base de coordenada, que pode ser um
procedimento computacional expans@'{@dotless{i}}vel. Por essa raz@~ao,
em alguns casos pode ser mais vantajoso usar uma base de coordenada em
primeiro lugar antes que o tensor de Weyl seja calculado. Note todavia,
que para a constru@value{cedilha}@~ao de um tetrad nulo de
Newman-Penrose @'e necess@'ario uma base de referencial. Portanto, uma
sequ@^encia de c@'alculo expressiva pode come@value{cedilha}ar com uma
base de referencial, que @'e ent@~ao usada para calcular @code{lg}
(calculada automaticamente atrav@'es de @code{cmetric}) e em seguida
calcula @code{ug}. Nesse ponto, pode comutar de volta para uma base de
coordenada escolhendo @code{cframe_flag} para @code{false} antes de
come@value{cedilha}ar a calcular os s@'{@dotless{i}}mbolos de
Christoffel. Mudando para uma base de referencial num est@'agio posterior
pode retornar resultados inconsistentes, j@'a que pode terminar com uma
grande mistura de tensores, alguns calculados numa base de referencial, e
outros numa base de coordenada, sem nenhum modo para distinguir entre os
dois tipos.

@end deffn

@deffn {Fun@value{cedilha}@~ao} petrov ()
Calcula a classifica@value{cedilha}@~ao de petrov da m@'etrica caracterizada atrav@'es de @code{psi[0]}...@code{psi[4]}.

Por exemplo, o seguinte demonstra como obter a classifica@value{cedilha}@~ao de Petrov
da m@'etrica de Kerr:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np = 

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0], 
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0], 
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------], 
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

@end example

A fun@value{cedilha}@~ao de classifica@value{cedilha}@~ao Petrov @'e baseada no algoritmo publicado em
"Classifying geometries in general relativity: III Classification in practice"
por Pollney, Skea, e d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Exceto para alguns casos de teste simples, a implementa@value{cedilha}@~ao n@~ao est@'a testada at@'e
19 de Dezembro de 2004, e @'e prov@'avel que contenha erros.

@end deffn


@subsection Tors@~ao e n@~ao metricidade

@code{ctensor} possui a habilidade de calcular e incluir coeficientes de tors@~ao e n@~ao
metricidade nos coeficientes de conec@value{cedilha}@~ao.

Os coeficientes de tors@~ao s@~ao calculados a partir de um tensor fornecido pelo utilizador
@code{tr}, que pode ser um tensor de categoria (2,1).  A partir disso, os coeficientes de
tors@~ao @code{kt} s@~ao calculados de acordo com a seguinte f@'ormula:

@example

              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

@end example

Note que somente o tensor de @'{@dotless{i}}ndice misto @'e calculao e armazenado no
array @code{kt}.

Os coeficientes de n@~ao metricidade s@~ao calculados a partir  do vector de n@~ao metricidade
fornecido pelo utilizador @code{nm}. A partir disso, os coeficientes de n@~ao metricidade
@code{nmc} s@~ao calculados como segue:

@example

             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

@end example

onde D simboliza o delta de Kronecker.

Quando @code{ctorsion_flag} for escolhida para @code{true}, os valores de @code{kt}
s@~ao subtra@'{@dotless{i}}dos dos coeficientes de conec@value{cedilha}@~ao indexados mistos calculados atrav@'es de
@code{christof} e armazenados em @code{mcs}. Similarmente, se @code{cnonmet_flag}
for escolhida para @code{true}, os valores de @code{nmc} s@~ao subtra@'{@dotless{i}}dos dos
coeficientes de conec@value{cedilha}@~ao indexados mistos.

Se necess@'ario, @code{christof} chama as fun@value{cedilha}@~oes @code{contortion} e
@code{nonmetricity} com o objectivo de calcular @code{kt} e @code{nm}.

@deffn {Fun@value{cedilha}@~ao} contortion (@var{tr})

Calcula os coeficientes de contors@~ao de categoria (2,1) a partir do tensor de tors@~ao @var{tr}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} nonmetricity (@var{nm})

Calcula o coeficiente de n@~ao metricidade de categoria (2,1) a partir do vector de
n@~ao metricidade @var{nm}.

@end deffn



@subsection Recursos diversos

@deffn {Fun@value{cedilha}@~ao} ctransform (@var{M})
Uma fun@value{cedilha}@~ao no pacote @code{ctensor}
que ir@'a executar uma transforma@value{cedilha}@~ao de coordenadas
sobre uma matriz sim@'etrica quadrada arbitr@'aria @var{M}. O utilizador deve informar as
fun@value{cedilha}@~aoes que definem a transforma@value{cedilha}@~ao.  (Formalmente chamada @code{transform}.)

@end deffn

@deffn {Fun@value{cedilha}@~ao} findde (@var{A}, @var{n})

Retorna uma lista de equa@value{cedilha}@~oes diferenciais @'unicas (express@~oes)
correspondendo aos elementos do array quadrado @var{n} dimensional
@var{A}. Actualmente, @var{n} pode ser 2 ou 3. @code{deindex} @'e uma lista global
contendo os @'{@dotless{i}}ndices de @var{A} correspondendo a essas @'unicas
equa@value{cedilha}@~oes diferenciais. Para o tensor de Einstein (@code{ein}), que
@'e um array dimensional, se calculado para a m@'etrica no exemplo
abaixo, @code{findde} fornece as seguintes equa@value{cedilha}@~oes diferenciais independentes:


@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]

@end example


@end deffn
@deffn {Fun@value{cedilha}@~ao} cograd ()
Calcula o gradiente covariante de uma fun@value{cedilha}@~ao escalar permitindo ao
utilizador escolher o nome do vector correspondente como o exemplo sob
@code{contragrad} ilustra.
@end deffn
@deffn {Fun@value{cedilha}@~ao} contragrad ()

Calcula o gradiente contravariante de uma fun@value{cedilha}@~ao escalar permitindo
@c "vector^F2name^F*" LOOKS LIKE IT NEEDS TO BE FIXED UP, NOT SURE HOW THOUGH
ao utilizador escolher o nome do vector correspondente como o exemplo
abaixo como ilustra a m@'etrica de Schwarzschild:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

@end example

@end deffn
@deffn {Fun@value{cedilha}@~ao} dscalar ()
Calcula o tensor d'Alembertiano da fun@value{cedilha}@~ao escalar assim que
as depend@^encias tiverem sido declaradas sobre a fun@value{cedilha}@~ao. Po exemplo:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
@end example

@end deffn
@deffn {Fun@value{cedilha}@~ao} checkdiv ()

Calcula a diverg@^encia covariante do tensor de segunda categoria misto
(cujo primeiro @'{@dotless{i}}ndice deve ser covariante) imprimindo as
correspondentes n componentes do campo do vector (a diverg@^encia) onde
n = @code{dim}. Se o argumento para a fun@value{cedilha}@~ao for @code{g} ent@~ao a
diverg@^encia do tensor de Einstein ser@'a formada e pode ser zero.
Adicionalmente, a diverg@^encia (vector) @'e dada no array chamado @code{div}.
@end deffn

@deffn {Fun@value{cedilha}@~ao} cgeodesic (@var{dis})
Uma fun@value{cedilha}@~ao no pacote @code{ctensor}.
@code{cgeodesic} calcula as equa@value{cedilha}@~oes geod@'esicas de
movimento para uma dada m@'etrica.  Elas s@~ao armazenadas no array @code{geod[i]}.  Se
o argumento @var{dis} for @code{true} ent@~ao essas equa@value{cedilha}@~oes s@~ao mostradas.

@end deffn


@deffn {Fun@value{cedilha}@~ao} bdvac (@var{f})

Gera as componentes covariantes das equa@value{cedilha}@~oes de campo de v@'acuo da
teoria de gravita@value{cedilha}@~ao de Brans-Dicke. O campo escalar @'e especificado
atrav@'es do argumento @var{f}, que pode ser um nome de fun@value{cedilha}@~ao (com ap@'ostrofo)
com depend@^encias funcionais, e.g., @code{'p(x)}.

As componentes de segunda categoria do tensor campo covariante s@~ao as componentes de segunda categoria
representadas pelo array @code{bd}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} invariant1 ()

Gera o tensor misto de Euler-Lagrange (equa@value{cedilha}@~oes de campo) para a
densidade invariante de R^2. As equa@value{cedilha}@~oes de campo s@~ao componentes de um
array chamado @code{inv1}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} invariant2 ()

*** NOT YET IMPLEMENTED ***

Gera o tensor misto de Euler-Lagrange (equa@value{cedilha}@~oes de campo) para a
densidade invariante de @code{ric[i,j]*uriem[i,j]}. As equa@value{cedilha}@~oes de campo s@~ao as
componentes de um array chamado @code{inv2}.


@end deffn
@deffn {Fun@value{cedilha}@~ao} bimetric ()

*** NOT YET IMPLEMENTED ***

Gera as euaua@value{cedilha}@~oes de campo da teoria bim@'etrica de Rosen. As equa@value{cedilha}@~oes
de campo s@~ao as componentes de um array chamado @code{rosen}.

@end deffn

@subsection Fun@value{cedilha}@~oes utilit@'arias

@deffn {Fun@value{cedilha}@~ao} diagmatrixp (@var{M})

Retorna @code{true} se @var{M} for uma matriz diagonal ou um array (2D).

@end deffn

@deffn {Fun@value{cedilha}@~ao} symmetricp (@var{M})

Retorna @code{true} se @var{M} for uma matriz sim@'etrica ou um array (2D).

@end deffn

@deffn {Fun@value{cedilha}@~ao} ntermst (@var{f})
Fornece ao utilizador um r@'apido quadro do "tamanho" do tensor duplamente
subscrito (array) @var{f}.  Imprime uma lista de dois elementos onde o segundo
elemento corresponde a N-TERMOS de componentes especificadas atrav@'es dos primeiros
elementos.  Nesse caminho, @'e poss@'{@dotless{i}}vel rapidamente encontrar as express@~oes
n@~ao nulas e tentar simplifica@value{cedilha}@~ao.

@end deffn

@deffn {Fun@value{cedilha}@~ao} cdisplay (@var{ten})
Mostra todos os elementos do tensor @var{ten}, como representados por
um array multidimensional. Tensores de categoria 0 e 1, assim como outros tipos de
vari@'aveis, s@~ao mostrados com @code{ldisplay}. Tensores de categoria 2 s@~ao
mostrados como matrizes bidimensionais, enquanto tensores de alta categoria s@~ao mostrados
como uma lista de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
m@'etrica de Schwarzschild pode ser visto como:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

@end example
@end deffn

@deffn {Fun@value{cedilha}@~ao} deleten (@var{L}, @var{n})
Retorna uma nova lista consistindo de @var{L} com o @var{n}'@'esimo elemento
apagado.
@end deffn

@subsection Vari@'aveis usadas por @code{ctensor}


@defvr {Vari@'avel de op@value{cedilha}@~ao} dim
Valor por omiss@~ao: 4

Uma op@value{cedilha}@~ao no pacote @code{ctensor}.
@code{dim} @'e a dimens@~ao de multiplica@value{cedilha}@~ao com o
padr@~ao 4. O comando @code{dim: n} ir@'a escolher a dimens@~ao para qualquer outro
valor @code{n}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} diagmetric
Valor por omiss@~ao: @code{false}

Uma op@value{cedilha}@~ao no pacote @code{ctensor}.
Se @code{diagmetric} for @code{true} rotinas especiais calculam
todos os objectos geom@'etricos (que possuem o tensor m@'etrico explicitamente)
levando em considera@value{cedilha}@~ao a diagonalidade da m@'etrica. Tempo de
execu@value{cedilha}@`ao reduzido ir@'a, com certeza, resultar dessa escolha. Nota: essa op@value{cedilha}@~ao @'e escolhida
automaticamente por @code{csetup} se uma m@'etrica diagonal for especificada.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ctrgsimp

Faz com que simplifica@value{cedilha}@~oes trigonom@'etricas sejam usadas quando tensores forem calculados. Actualmente,
@code{ctrgsimp} afecta somente c@'alculos envolvendo um referencial m@'ovel.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} cframe_flag

Faz com que c@'alculos sejam executados relativamente a um referencial
m@'ovel em oposi@value{cedilha}@~ao a uma m@'etrica holon@'omica. O
referencial @'e definido atrav@'es do array do referencial inverso
@code{fri} e da m@'etrica do referencial @code{lfg}. Para c@'alculos
usando um referencial Cartesiano, @code{lfg} pode ser a matriz
unit@'aria de dimens@~ao apropriada; para c@'alculos num referencial
de Lorentz, @code{lfg} pode ter a assinatura apropriada.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ctorsion_flag

Faz com que o tensor de contors@~ao seja inclu@'{@dotless{i}}do no c@'alculo dos
coeficientes de conec@value{cedilha}@~ao. O tensor de contors@~ao por si mesmo @'e calculado atrav@'es de
@code{contortion} a partir do tensor @code{tr} fornecido pelo utilizador.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} cnonmet_flag

Faz com que os coeficientes de n@~ao metricidade sejam inclu@'{@dotless{i}}dos no c@'alculo dos
coeficientes de conec@value{cedilha}@~ao. Os coeficientes de n@~ao metricidade s@~ao calculados
a partir do vector de n@~ao metricidade @code{nm} fornecido pelo utilizador atrav@'es da fun@value{cedilha}@~ao
@code{nonmetricity}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ctayswitch

Se escolhida para @code{true}, faz com que alguns c@'alculos de @code{ctensor} sejam realizados usando
expans@~oes das s@'eries de Taylor. actualmente, @code{christof}, @code{ricci},
@code{uricci}, @code{einstein}, e @code{weyl} levam em conta essa
escolha.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ctayvar

Vari@'avel usada pela expans@~ao de s@'eries de Taylor se @code{ctayswitch} @'e escolhida para
@code{true}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ctaypov

Maximo expoente usado em expans@~oes de s@'eries de Taylor quando @code{ctayswitch} for
escolhida para @code{true}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ctaypt

Ponto em torno do qual expans@~oes de s@'eries de Taylor sao realizadas quando
@code{ctayswitch} for escolhida para @code{true}.

@end defvr

@defvr {Vari@'avel de sistema} gdet

O determinante do tensor m@'etrico @code{lg}. Calculado atrav@'es de @code{cmetric} quando
@code{cframe_flag} for escolhido para @code{false}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratchristof

Faz com que simplifica@value{cedilha}@~oes racionais sejam aplicadas atrav@'es de @code{christof}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} rateinstein
Valor por omiss@~ao: @code{true}

Se @code{true} simplifica@value{cedilha}@~ao racional ser@'a
executada sobre as componentes n@~ao nulas de tensores de Einstein; se
@code{ratfac} for @code{true} ent@~ao as componentes ir@~ao tamb@'em ser factoradas.

@end defvr
@defvr {Vari@'avel de op@value{cedilha}@~ao} ratriemann
Valor por omiss@~ao: @code{true}

Um dos comutadores que controlam
simplifica@value{cedilha}@~oes dos tensores de Riemann; se @code{true}, ent@~ao simplifica@value{cedilha}@~oes
racionais ir@~ao ser conclu@'{@dotless{i}}das; se @code{ratfac} for @code{true} ent@~ao cada uma das
componentes ir@'a tamb@'em ser factorada.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratweyl
Valor por omiss@~ao: @code{true}

Se @code{true}, esse comutador faz com que a fun@value{cedilha}@~ao de @code{weyl}
aplique simplifica@value{cedilha}@~oes racionais aos valores do tensor de Weyl. Se
@code{ratfac} for @code{true}, ent@~ao as componentes ir@~ao tamb@'em ser factoradas.
@end defvr

@defvr {Vari@'avel} lfg
O referencial m@'etrico covariante. Por padr@~ao, @'e inicializado para
o referencial tetradimensional de Lorentz com assinatura
(+,+,+,-). Usada quando @code{cframe_flag} for @code{true}.
@end defvr

@defvr {Vari@'avel} ufg
A m@'etrica do referencial inverso. Calculada de @code{lfg} quando @code{cmetric} for chamada enquanto @code{cframe_flag} for escolhida para @code{true}.
@end defvr

@defvr {Vari@'avel} riem
O tensor de categoria (3,1) de Riemann. Calculado quando a fun@value{cedilha}@~ao @code{riemann} @'e invocada. Para informa@value{cedilha}@~ao sobre ordena@value{cedilha}@~ao de @'{@dotless{i}}ndices, veja a descri@value{cedilha}@~ao de @code{riemann}.

Se @code{cframe_flag} for @code{true}, @code{riem} @'e calculado a partir do tensor covariante de Riemann @code{lriem}.

@end defvr

@defvr {Vari@'avel} lriem

O tensor covariante de Riemann. Calculado atrav@'es de @code{lriemann}.

@end defvr

@defvr {Vari@'avel} uriem

O tensor contravariante de Riemann. Calculado atrav@'es de @code{uriemann}.

@end defvr

@defvr {Vari@'avel} ric

O tensor misto de Ricci. Calculado atrav@'es de @code{ricci}.

@end defvr

@defvr {Vari@'avel} uric

O tensor contravariante de Ricci. Calculado atrav@'es de @code{uricci}.

@end defvr

@defvr {Vari@'avel} lg

O tensor m@'etrico. Esse tensor deve ser especificado (como uma @code{dim} atrav@'es da matriz @code{dim})
antes que outro c@'alculo possa ser executado.

@end defvr

@defvr {Vari@'avel} ug

O inverso do tensor m@'etrico. Calculado atrav@'es de @code{cmetric}.

@end defvr

@defvr {Vari@'avel} weyl

O tensor de Weyl. Calculado atrav@'es de @code{weyl}.

@end defvr

@defvr {Vari@'avel} fb

Coeficientes delimitadores do referencial, como calculado atrav@'es de @code{frame_bracket}.

@end defvr

@defvr {Vari@'avel} kinvariant

O invariante de Kretchmann. Calculado atrav@'es de @code{rinvariant}.

@end defvr

@defvr {Vari@'avel} np

Um tetrad nulo de Newman-Penrose. Calculado atrav@'es de @code{nptetrad}.

@end defvr

@defvr {Vari@'avel} npi

O @'{@dotless{i}}ndice ascendente do tetrad nulo de Newman-Penrose. Calculado atrav@'es de @code{nptetrad}.
Definido como @code{ug.np}. O produto @code{np.transpose(npi)} @'e constante:

@example
(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
@end example

@end defvr

@defvr {Vari@'avel} tr

Tensor de categoria 3 fornecido pelo utilizador representando tors@~ao. Usado por @code{contortion}.
@end defvr

@defvr {Vari@'avel} kt

O tensor de contors@~ao, calculado a partir de @code{tr} atrav@'es de @code{contortion}.
@end defvr

@defvr {Vari@'avel} nm

Vetor de n@~ao metrcidade fornecido pelo utilizador. Usado por @code{nonmetricity}.
@end defvr

@defvr {Vari@'avel} nmc

Os coeficientes de n@~ao metricidade, calculados a partir de @code{nm} por @code{nonmetricity}.

@end defvr

@defvr {Vari@'avel de sistema} tensorkill

Vari@'avel indicando se o pacote tensor foi inicializado. Escolhida e usada por
@code{csetup}, retornada ao seu valor original atrav@'es de @code{init_ctensor}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ct_coords
Valor por omiss@~ao: @code{[]}

Uma op@value{cedilha}@~ao no pacote @code{ctensor}.
@code{ct_coords} cont@'em uma lista de coordenadas.
Enquanto normalmente definida quando a fun@value{cedilha}@~ao @code{csetup} for chamada,
se pode redefinir as coordenadas com a atribui@value{cedilha}@~ao
@code{ct_coords: [j1, j2, ..., jn]} onde os j's s@~ao os novos nomes de coordenadas.
Veja tamb@'em @code{csetup}.

@end defvr

@subsection Nomes reservados

Os seguintes nomes s@~ao usados internamente pelo pacote @code{ctensor} e
n@~ao devem ser redefinidos:

@example
  Name         Description
  ---------------------------------------
  _lg()        Avalia para @code{lfg} se for usado o referencial m@'etrico,
                    para @code{lg} de outra forma
  _ug()        Avalia para @code{ufg} se for usado o referencial m@'etrico,
                    para @code{ug} de outra forma
  cleanup()    Remove @'{@dotless{i}}tens da lista @code{deindex}
  contract4()  Usado por psi()
  filemet()    Usado por csetup() quando lendo a m@'etrica de um ficheiro
  findde1()    Usado por findde()
  findde2()    Usado por findde()
  findde3()    Usado por findde()
  kdelt()      Delta de Kronecker (n@~ao generalizado)
  newmet()     Usado por csetup() para escolher uma m@'etrica
                    interativamente
  setflags()   Usado por init_ctensor()
  readvalue()
  resimp()
  sermet()     Usado por csetup() para informar uma m@'etricacom s@'erie
                    de Taylor
  txyzsum()
  tmetric()    Referencial m@'etrico, usado por cmetric() quando
                    cframe_flag:true
  triemann()   Tensor de Riemann na base do referencial, usado quando
                    cframe_flag:true
  tricci()     Tensor de Ricci na base do referencial, usado quando
                    cframe_flag:true
  trrc()       Coeficientes de rota@value{cedilha}@~ao de Ricci, usado por
                    christof()
  yesp()
@end example


@subsection Modifica@value{cedilha}@~oes

Em Novembro de 2004, o pacote @code{ctensor} foi extensivamente reescrito.
Muitas fun@value{cedilha}@~oes e vari@'aveis foram renomeadas com o objectivo de tornar o
pacote com a vers@~ao comercial do Macsyma.


@example
  Novo Nome    Nome Antigo     Descri@value{cedilha}@~ao
  --------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Expans@~ao da s@'erie de Taylor de uma
  -----------------------------express@~ao
  lgeod[]      EM              Equa@value{cedilha}@~oes geod@'esicas
  ein[]        G[]             Tensor misto de Einstein
  ric[]        LR[]            Tensor misto de Ricci
  ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
  ctaypov      MINP            Maximo expoente em expans@~oes de s@'eries de
  -----------------------------Taylor
  cgeodesic()  MOTION          Calcula as equa@value{cedilha}@~oes geod@'esicas
  ct_coords    OMEGA           Coordenadas m@'etricas
  ctayvar      PARAM           Vari@'avel de expans@~ao de s@'eries de
  -----------------------------Taylor
  lriem[]      R[]             Tensor covariante de Riemann
  uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
  -----------------------------Riemann
  ratriemann   RATRIEMAN       Simplifica@value{cedilha}@~ao racional do tensor de
  -----------------------------Riemann
  uric[]       RICCI[]         Tensor de Ricci contravariante
  uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
  cmetric()    SETMETRIC()     Escolhe a m@'etrica
  ctaypt       TAYPT           Ponto para expans@~oes de s@'eries de Taylor
  ctayswitch   TAYSWITCH       Escolhe o comutador de s@'eries de Taylor
  csetup()     TSETUP()        Inicia sess@~ao interativa de configura@value{cedilha}@~ao
  ctransform() TTRANSFORM()    Transforma@value{cedilha}@~ao de coordenadas interativa
  uriem[]      UR[]            Tensor contravariante de Riemann 
  weyl[]       W[]             Tensor (3,1) de Weyl

@end example

