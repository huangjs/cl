@c /Equations.texi/1.24/Thu Nov  2 05:46:56 2006/-ko/
@c end concepts Equations
@menu
* Defini@value{cedilha}@~oes para Equa@value{cedilha}@~oes::   
@end menu

@node Defini@value{cedilha}@~oes para Equa@value{cedilha}@~oes,  , Equa@value{cedilha}@~oes, Equa@value{cedilha}@~oes
@section Defini@value{cedilha}@~oes para Equa@value{cedilha}@~oes

@c NEED A DESCRIPTION OF %rnum AS WELL
@defvr {Vari@'avel} %rnum_list
Valor por omiss@~ao: @code{[]}

@code{%rnum_list} @'e a lista de vari@'aveis introduzidas em solu@value{cedilha}@~oes
por @code{algsys}.
@code{%r} vari@'aveis S@~ao adicionadas a @code{%rnum_list} na ordem em que
forem criadas.
Isso @'e conveniente para fazer substitui@value{cedilha}@~oes dentro da
solu@value{cedilha}@~ao mais tarde.
@c WHAT DOES THIS STATEMENT MEAN ??
@'E recomendado usar essa lista em lugar de
fazer @code{concat ('%r, j)}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel} algexact
Valor por omiss@~ao: @code{false}

@code{algexact} afecta o comportamento de @code{algsys} como segue:

Se @code{algexact} @'e @code{true},
@code{algsys} sempre chama @code{solve} e ent@~ao usa @code{realroots}
sobre falhas de @code{solve}.

Se @code{algexact} @'e @code{false}, @code{solve} @'e chamada somente se
o eliminante n@~ao for de uma vari@'avel, ou se for uma quadr@'atica ou uma
biquadrada.

Dessa forma @code{algexact: true} n@~ao garante solu@value{cedilha}@~oes
exactas, apenas que @code{algsys} tentar@'a primeiro pegar
solu@value{cedilha}@~oes exactas, e somente retorna aproxima@value{cedilha}@~oes quando tudo mais falha.

@c ABOVE DESCRIPTION NOT TOO CLEAR -- MAYBE EXAMPLES WILL HELP
@end defvr

@deffn {Fun@value{cedilha}@~ao} algsys ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
@deffnx {Fun@value{cedilha}@~ao} algsys ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Resolve polin@'omios simult@^aneos @var{expr_1}, ..., @var{expr_m}
ou equa@value{cedilha}@~oes polin@^omiais @var{eqn_1}, ..., @var{eqn_m}
para as vari@'aveis @var{x_1}, ..., @var{x_n}.
Uma express@~ao @var{expr} @'e equivalente a uma equa@value{cedilha}@~ao @code{@var{expr} = 0}.
Pode existir mais equa@value{cedilha}@~oes que vari@'aveis ou vice-versa.

@code{algsys} retorna uma lista de solu@value{cedilha}@~oes,
com cada solu@value{cedilha}@~ao dada com uma lista de valores de estado das equa@value{cedilha}@~oes
das vari@'aveis @var{x_1}, ..., @var{x_n} que satisfazem o sistema de equa@value{cedilha}@~oes.
Se @code{algsys} n@~ao pode achar uma solu@value{cedilha}@~ao, uma lista vazia @code{[]} @'e retornada.

Os s@'{@dotless{i}}mbolos @code{%r1}, @code{%r2}, ...,
s@~ao introduzidos tantos quantos forem necess@'arios para representar par@^ametros arbitr@'arios na solu@value{cedilha}@~ao;
essas vari@'aveis s@~ao tamb@'em anexadas @`a lista @code{%rnum_list}.

O m@'etodo usado @'e o seguinte:

(1) Primeiro as equa@value{cedilha}@~oes s@~ao factorizaadas e quebradas
em subsistemas.

(2) Para cada subsistema @var{S_i}, uma equa@value{cedilha}@~ao @var{E} e uma vari@'avel @var{x} s@~ao
seleccionados.
A vari@'avel @'e escolhida para ter o menor grau n@~ao zero.
Ent@~ao a resultante de @var{E} e @var{E_j} em rela@value{cedilha}@~ao a @var{x} @'e calculada para cada um das
equa@value{cedilha}@~oes restantes @var{E_j} nos subsistemas @var{S_i}.
Isso retorna um novo subsistema @var{S_i'} em umas poucas vari@'aveis, como @var{x} tenha sido eliminada.
O processo agora retorna ao passo (1).

(3) Eventualmente, um subsistema consistindo de uma equa@value{cedilha}@~ao simples @'e
obtido.  Se a equa@value{cedilha}@~ao @'e de v@'arias vari@'aveis e aproxima@value{cedilha}@~oes na
forma de n@'umeros em ponto flutuante n@~a tenham sido introduzidas, ent@~ao @code{solve} @'e
chamada para achar uma solu@value{cedilha}@~ao exacta.

Em alguns casos, @code{solve} n@~ao est@'a habilitada a achar uma solu@value{cedilha}@~ao,
ou se isso @'e feito a solu@value{cedilha}@~ao pode ser uma express@~ao express@~ao muito larga.

@c REMAINDER OF (3) IS PRETTY COMPLEX.  HOW CAN IT BE CLARIFIED ??
Se a equa@value{cedilha}@~ao @'e de uma @'unica vari@'avel e @'e ou linear, ou quadr@'atica, ou
biquadrada, ent@~ao novamente @code{solve} @'e chamada se aproxima@value{cedilha}@~oes n@~ao tiverem
sido introduzidas.  Se aproxima@value{cedilha}@~oes tiverem sido introduzidas ou a
equa@value{cedilha}@~ao n@~ao @'e de uma @'unica vari@'avel e nem t@~ao pouco linear, quadratica, ou
biquadrada, ent@~ao o comutador @code{realonly} @'e @code{true}, A fun@value{cedilha}@~ao
@code{realroots} @'e chamada para achar o valor real das solu@value{cedilha}@~oes.  Se
@code{realonly} @'e @code{false}, ent@~ao @code{allroots} @'e chamada a qual procura por
solu@value{cedilha}@~oes reais e complexas.

Se @code{algsys} produz uma solu@value{cedilha}@~ao que tem
poucos digitos significativos que o requerido, o utilizador pode escolher o valor
de @code{algepsilon} para um valor maior.

Se @code{algexact} @'e escolhido para
@code{true}, @code{solve} ser@'a sempre chamada.
@c algepsilon IS IN Floating.texi -- MAY WANT TO BRING IT INTO THIS FILE

(4) Finalmente, as solu@value{cedilha}@~oes obtidas no passo (3) s@~ao substitu@'{@dotless{i}}das dentro
dos n@'{@dotless{i}}veis pr@'evios e o processo de solu@value{cedilha}@~ao retorna para (1).
@c "PREVIOUS LEVELS" -- WHAT ARE THOSE ??

Quando @code{algsys} encontrar uma equa@value{cedilha}@~ao de v@'arias vari@'aveis que cont@'em
aproxima@value{cedilha}@~oes em ponto flutuante (usualmente devido a suas falhas em achar
solu@value{cedilha}@~oes exactas por um est@'agio mais f@'acil), ent@~ao n@~ao tentar@'a
aplicar m@'etodos exatos para tais equa@value{cedilha}@~oes e em lugar disso imprime a mensagem:
"@code{algsys} cannot solve - system too complicated."

Intera@value{cedilha}@~oes com @code{radcan} podem produzir express@~oes largas ou
complicadas.
Naquele caso, pode ser poss@'{@dotless{i}}vel isolar partes do resultado
com @code{pickapart} ou @code{reveal}.

Ocasionalmente, @code{radcan} pode introduzir uma unidade imagin@'aria
@code{%i} dentro de uma solu@value{cedilha}@~ao que @'e actualmente avaliada como real.

Exemplos:

@c ===beg===
@c e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
+@c e2: a2 - a1;
+@c e3: a1*(-y - x^2 + 1);
@c e4: a2*(y - (x - 1)^2);
@c algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
@c e1: x^2 - y^2;
@c e2: -1 - y + 2*y^2 - x + x^2;
@c algsys ([e1, e2], [x, y]);
@c ===end===
@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} allroots (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} allroots (@var{eqn})
Calcula aproxima@value{cedilha}@~oes num@'ericas de ra@'{@dotless{i}}zes reais e complexas do
polin@'omio @var{expr} ou equa@value{cedilha}@~ao polin@^omial @var{eqn} de uma vari@'avel.

@c polyfactor IS NOT OTHERWISE DOCUMENTED
O sinalizador @code{polyfactor} quando @code{true} faz com que
@code{allroots} factore o polin@'omio sobre os n@'umeros reais se o
polin@'omio for real, ou sobre os n@'umeros complexos, se o polin@'omio for
complexo.

@code{allroots} pode retornar resultados imprecisos no caso de m@'ultiplas ra@'{@dotless{i}}zes.
Se o polin@'omio for real, @code{allroots (%i*@var{p})}) pode retornar
aproxima@value{cedilha}@~oes mais precisas que @code{allroots (@var{p})},
como @code{allroots} invoca um algoritmo diferente naquele caso.

@code{allroots} rejeita expresso@~oes que n@~ao sejam polin@'omios.
Isso requer que o numerador ap@'os a classifica@value{cedilha}@~ao
(@code{rat}'ing) poder@'a ser um polin@'omio, e isso requer que o
denominador seja quando muito um n@'umero complexo.  Com esse tipo
resultado @code{allroots} ir@'a sempre produzir uma express@~ao
equivalente (mas factorizada), se @code{polyfactor} for @code{true}.

Para polin@'omios complexos um algoritmo por Jenkins e Traub @'e
usado (Algorithm 419, @i{Comm.  ACM}, vol.  15, (1972), p.  97).
Para polin@'omios reais o algoritmo usado @'e devido a Jenkins (Algorithm 493, @i{ACM TOMS},
vol.  1, (1975), p.178).

Exemplos:
@c EXAMPLES GENERATED BY THESE INPUTS:
@c eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@c soln: allroots (eqn);
@c for e in soln
@c         do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
@c polyfactor: true$
@c allroots (eqn);

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example

@end deffn

@defvr {Vari@'avel} backsubst
Valor por omiss@~ao: @code{true}

@c WHAT IS THE CONTEXT HERE ?? (TO WHICH OTHER FUNCTION DOES THIS APPLY ??)
Quando @code{backsubst} @'e @code{false}, evita substitui@value{cedilha}@~oes
em express@~oes anteriores ap@'os as equa@value{cedilha}@~oes terem sido triangularizadas.  Isso pode
ser de grande ajuda em problemas muito grandes onde substitui@value{cedilha}@~ao em express@~oes anteriores pode vir a causar
a gera@value{cedilha}@~ao de express@~oes extremamente largas.

@end defvr

@defvr {Vari@'avel} breakup
Valor por omiss@~ao: @code{true}

Quando @code{breakup} @'e @code{true}, @code{solve} expressa solu@value{cedilha}@~oes
de equa@value{cedilha}@~oes c@'ubicas e qu@'articas em termos de subexpress@~oes comuns,
que s@~ao atribu@'{@dotless{i}}das a r@'otulos de express@~oes interm@'edias (@code{%t1}, @code{%t2}, etc.).
De outra forma, subexpress@~oes comuns n@~ao s@~ao identificadas.

@code{breakup: true} tem efeito somente quando @code{programmode} @'e @code{false}.

Exemplos:

@example
(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
@end example

@end defvr

@deffn {Fun@value{cedilha}@~ao} dimension (@var{eqn})
@deffnx {Fun@value{cedilha}@~ao} dimension (@var{eqn_1}, ..., @var{eqn_n})
@code{dimen} @'e um pacote de an@'alise dimensional.
@code{load ("dimen")} chama esse pacote.
@code{demo ("dimen")} mostra uma cura demostra@value{cedilha}@~ao.
@c I GUESS THIS SHOULD BE EXPANDED TO COVER EACH FUNCTION IN THE PACKAGE

@end deffn

@defvr {Vari@'avel} dispflag
Valor por omiss@~ao: @code{true}

@c WHAT DOES THIS MEAN ??
Se escolhida para @code{false} dentro de um @code{block} inibir@'a
a visualiza@value{cedilha}@~ao da sa@'{@dotless{i}}da gerada pelas fun@value{cedilha}@~oes solve chamadas de
dentro de @code{block}.  Terminando @code{block} com um sinal de dolar, $, escolhe
@code{dispflag} para @code{false}.

@end defvr

@c THIS COULD BENEFIT FROM REPHRASING
@deffn {Fun@value{cedilha}@~ao} funcsolve (@var{eqn}, @var{g}(@var{t}))
Retorna @code{[@var{g}(@var{t}) = ...]}  ou @code{[]}, dependendo de existir
ou n@~ao uma fun@value{cedilha}@~ao racional @code{@var{g}(@var{t})} satisfazendo @var{eqn},
que deve ser de primeira ordem, polin@'omio linear em (para esse caso) 
@code{@var{g}(@var{t})} e @code{@var{g}(@var{t}+1)}

@example
(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Equa@value{cedilha}@~oes dependentes eliminadas:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
@end example

Aten@value{cedilha}@~ao: essa @'e uma implementa@value{cedilha}@~ao muito rudimentar -- muitas verifica@value{cedilha}@~oes de seguran@value{cedilha}a
e obviamente generaliza@value{cedilha}@~oes est@~ao aus@^entes.

@end deffn

@defvr {Vari@'avel} globalsolve
Valor por omiss@~ao: @code{false}

When @code{globalsolve} for @code{true},
vari@'aveis para as quais as equa@value{cedilha}@~oes s@~ao resolvidas s@~ao atribuidas aos valores da solu@value{cedilha}@~ao encontrados por @code{linsolve},
e por @code{solve} quando resolvendo duas ou mais equa@value{cedilha}@~oes lineares.
Quando @code{globalsolve} for @code{false},
solu@value{cedilha}@~oes encontradas por @code{linsolve} e por @code{solve} quando resolvendo duas ou mais equa@value{cedilha}@~oes lineares
s@~ao espressas como equa@value{cedilha}@~oes,
e as vari@'aveis para as quais a equa@value{cedilha}@~ao foi resolvida n@~ao s@~ao atribuidas.

Quando resolvendo qualquer coisa outra que n@~ao duas equa@value{cedilha}@~oes lineares ou mais,
@code{solve} ignora @code{globalsolve}.
Outras fun@value{cedilha}@~oes que resolvem equa@value{cedilha}@~oes (e.g., @code{algsys}) sempre ignoram @code{globalsolve}.
    
Exemplos:

@example
(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
@end example

@end defvr

@c THIS DESCRIPTION NEEDS WORK AND EXAMPLES
@c MERGE IN TEXT FROM share/integequations/inteqn.usg
@c AND EXAMPLES FROM .../intexs.mac
@deffn {Fun@value{cedilha}@~ao} ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})
@code{inteqn} @'e um pacote para resolver equa@value{cedilha}@~oes integrais.
@code{load ("inteqn")} carrega esse pacote.

@var{ie} @'e a equa@value{cedilha}@~ao integral; @var{unk} @'e a fun@value{cedilha}@~ao desconhecida; @var{tech} @'e a
t@'ecnica a ser tentada nesses dados acima (@var{tech} = @code{first} significa: tente
a primeira t@'ecnica que achar uma solu@value{cedilha}@~ao; @var{tech} = @code{all} significa: tente todas a
t@'ecnicas aplic@'aveis); @var{n} @'e o n@'umero m@'aximo de termos a serem usados de
@code{taylor}, @code{neumann}, @code{firstkindseries}, ou @code{fredseries} (isso @'e tamb@'em o
n@'umero m@'aximo de ciclos de recurss@~ao para o m@'etodo de diferencia@value{cedilha}@~ao); @var{guess} @'e
o inicial suposto para @code{neumann} ou @code{firstkindseries}.

Valores padr@~ao do segundo at@'e o quinto par@^ametro s@~ao:

@var{unk}: @code{@var{p}(@var{x})}, onde @var{p} @'e a primeira fun@value{cedilha}@~ao encontrada em um integrando
que @'e desconhecida para Maxima e @var{x} @'e a vari@'avel que ocorre como um
argumento para a primeira ocorr@^encia de @var{p} achada fora de uma integral no
caso de equa@value{cedilha}@~oes @code{secondkind} , ou @'e somente outra vari@'avel
ao lado da vari@'avel de integra@value{cedilha}@~ao em equa@value{cedilha}@~oes @code{firstkind}.  Se uma
tentativa de procurar por @var{x} falha, o utilizador ser@'a perguntado para suprir a
vari@'avel independente.

tech: @code{first}

n: 1

guess: @code{none} o que far@'a com que @code{neumann} e @code{firstkindseries} use
@code{@var{f}(@var{x})} como uma suposi@value{cedilha}@~ao inicial.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ieqnprint
Valor por omiss@~ao: @code{true}

@code{ieqnprint} governa o comportamento do resultado
retornado pelo comando @code{ieqn}.  Quando @code{ieqnprint} @'e
@code{false}, as listas retornadas pela fun@value{cedilha}@~ao @code{ieqn} s@~ao da forma

   [@var{solu@value{cedilha}@~ao}, @var{tecnica usada}, @var{nterms}, @var{sinalizador}]

onde @var{sinalizador} @'e retirado se a solu@value{cedilha}@~ao for exacta.

De outra forma, isso @'e a
palavra @code{approximate} ou @code{incomplete} correspondendo @`a forma inexacta ou
forma aberta de solu@value{cedilha}@~ao, respectivamente.  Se um m@'etodo de s@'erie foi usado,
@var{nterms} fornece o n@'umero de termos usados (que poder@'a ser menor que os n
dados para @code{ieqn} se ocorrer um erro evita a gera@value{cedilha}@~ao de termos adicionais).

@end defvr

@deffn {Fun@value{cedilha}@~ao} lhs (@var{expr})
Retorna o lado esquerdo (isto @'e, o primeiro argumento)
da express@~ao @var{expr},
quando o operador de @var{expr}
for um dos operadores relacionais @code{< <= = # equal notequal >= >},
@c MENTION -> (MARROW) IN THIS LIST IF/WHEN THE PARSER RECOGNIZES IT
um dos operadores de atribui@value{cedilha}@~ao @code{:= ::= : ::},
ou um operadro infixo definido pelo utilizador, como declarado por meio de @code{infix}.

Quando @var{expr} for um @'atomo ou
seu operador for alguma coisa que n@~ao esses listados acima,
@code{lhs} retorna @var{expr}.

Veja tamb@'em @code{rhs}.

Exemplos:

@c ===beg===
@c e: aa + bb = cc;
@c lhs (e);
@c rhs (e);
@c [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
@c [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
@c e1: '(foo(x) := 2*x);
@c e2: '(bar(y) ::= 3*y);
@c e3: '(x : y);
@c e4: '(x :: y);
@c [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
@c infix ("][");
@c lhs (aa ][ bb);
@c ===end===
@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix ("][");
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
@end example

@end deffn

@c REVISIT -- THERE'S PROBABLY MORE TO SAY HERE
@deffn {Fun@value{cedilha}@~ao} linsolve ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
Resolve a lista de
equa@value{cedilha}@~oes lineares simult@^aneas para a lista de vari@'aveis.  As express@~oes
devem ser cada uma polin@'omios nas vari@'aveis e podem ser equa@value{cedilha}@~oes.

Quando @code{globalsolve} @'e @code{true} ent@~ao vari@'aveis que foram resolvidas
ser@~ao escolhidas para a solu@value{cedilha}@~ao do conjunto de equa@value{cedilha}@~oes simult@^aneas.

Quando @code{backsubst} @'e @code{false}, @code{linsolve}
n@~ao realiza substitui@value{cedilha}@~ao em equa@value{cedilha}@~oes anteriores ap@'os
as equa@value{cedilha}@~oes terem sido triangularizadas.  Isso pode ser necess@'ario em problemas
muito grandes onde substitui@value{cedilha}@~ao em equa@value{cedilha}@~oes anteriores poder@'a causar a gera@value{cedilha}@~ao de
express@~oes extremamente largas.

Quando @code{linsolve_params} for @code{true},
@code{linsolve} tamb@'em gera s@'{@dotless{i}}mbolos @code{%r}
usados para representar par@^ametros arbitr@'arios descritos no manual sob
@code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equa@value{cedilha}@~oes com algumas vari@'aveis expressas em termos de outras.

Quando @code{programmode} for @code{false},
@code{linsolve} mostra a solu@value{cedilha}@~ao com express@~oes interm@'edias com r@'otulos (@code{%t}),
e retorna a lista de r@'otulos.

@c ===beg===
@c e1: x + z = y;
@c e2: 2*a*x - y = 2*a^2;
@c e3: y - 2*z = 2;
@c [globalsolve: false, programmode: true];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c [globalsolve: false, programmode: false];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c ''%;
@c [globalsolve: true, programmode: false];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c ''%;
@c [x, y, z];
@c [globalsolve: true, programmode: true];
@c linsolve ([e1, e2, e3], '[x, y, z]);
@c [x, y, z];
@c ===end===
@example
(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
@end example

@end deffn

@c DO ANY FUNCTIONS OTHER THAN linsolve RESPECT linsolvewarn ??
@defvr {Vari@'avel} linsolvewarn
Valor por omiss@~ao: @code{true}

Quando @code{linsolvewarn} @'e @code{true},
@code{linsolve} imprime uma mensagem "Dependent equa@value{cedilha}@~oes eliminated".

@end defvr

@defvr {Vari@'avel} linsolve_params
Valor por omiss@~ao: @code{true}

Quando @code{linsolve_params} @'e @code{true}, @code{linsolve} tamb@'em gera
os s@'{@dotless{i}}mbolos @code{%r} usados para representar par@^ametros arbitr@'arios descritos no
manual sob @code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equa@value{cedilha}@~oes com algumas vari@'aveis expressas em termos e outras.

@end defvr

@defvr {Vari@'avel} multiplicities
Valor por omiss@~ao: @code{not_set_yet}

@code{multiplicities} @'e escolhida para uma lista de
multiplicidades das solu@value{cedilha}@~oes individuais retornadas por @code{solve} ou
@code{realroots}.
@c NEED AN EXAMPLE HERE

@end defvr

@deffn {Fun@value{cedilha}@~ao} nroots (@var{p}, @var{low}, @var{high})
Retorna o n@'umero de ra@'{@dotless{i}}zes reais do polin@'omio 
real de uma @'unica vari@'avel @var{p} no intervalo semi-aberto
@code{(@var{low}, @var{high}]}.
Uma extremidade do intervalo podem ser @code{minf} ou @code{inf}.
infinito e mais infinito.

@code{nroots} usa o m@'etodo das sequu@^encias de Sturm.

@example
(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} nthroot (@var{p}, @var{n})
Onde p @'e um polin@'omio com coeficientes inteiros e
n @'e um inteiro positivo retorna q, um polin@'omio sobre os inteiros, tal
que q^n=p ou imprime uma mensagem de erro indicando que p n@~ao @'e uma pot@^encia n-@'esima
perfeita.  Essa rotina @'e mais r@'apida que @code{factor} ou mesmo @code{sqfr}.

@end deffn

@defvr {Vari@'avel} programmode
Valor por omiss@~ao: @code{true}

Quando @code{programmode} @'e @code{true},
@code{solve}, @code{realroots}, @code{allroots}, e @code{linsolve}
retornam solu@value{cedilha}@~oes como elementos em uma lista.
@c WHAT DOES BACKSUBSTITUTION HAVE TO DO WITH RETURN VALUES ??
(Exceto quando @code{backsubst} @'e escolhido para @code{false}, nesse caso
@code{programmode: false} @'e assumido.)

Quando @code{programmode} @'e @code{false}, @code{solve}, etc.
cria r@'otulos de express@~oes interm@'edias
@code{%t1}, @code{t2}, etc., e atribui as solu@value{cedilha}@~oes para eles.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel} realonly
Valor por omiss@~ao: @code{false}

Quando @code{realonly} @'e @code{true}, @code{algsys} retorna somente
aquelas solu@value{cedilha}@~oes que est@~ao livres de @code{%i}.

@end defvr

@deffn {Fun@value{cedilha}@~ao} realroots (@var{expr}, @var{bound})
@deffnx {Fun@value{cedilha}@~ao} realroots (@var{eqn}, @var{bound})
@deffnx {Fun@value{cedilha}@~ao} realroots (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} realroots (@var{eqn})
Calcula aproxima@value{cedilha}@~oes racionais das ra@'{@dotless{i}}zes reais da express@~ao polinomial @var{expr}
ou da equa@value{cedilha}@~ao polinomial @var{eqn} de uma vari@'avel,
dentro de uma toler@^ancia de @var{bound}.
coeficientes de @var{expr} ou de @var{eqn} devem ser n@'umeros literais;
constantes s@'{@dotless{i}}mbolo tais como @code{%pi} s@~ao rejeitadas.

@code{realroots} atribui as multiplicidades das ra@'{@dotless{i}}zes que encontrar
para a vari@'avel global @code{multiplicities}.

@code{realroots} constr@'oi uma sequ@^encia de Sturm para delimitar cada ra@'{@dotless{i}}z,
e ent@~ao palica a bisec@value{cedilha}@~ao para redefinir as aproxima@value{cedilha}@~oes.
Todos os coeficientes s@~ao convertidos para os equivalentes racionais antes da busca por ra@'{@dotless{i}}zes,
e c@'alculos s@~ao realizados por meio de aritm@'etica racional exacta.
Mesmo se alguns coeficientes forem n@'umeros em ponto flutuante,
os resultados s@~ao racionais (a menos que for@value{cedilha}ados a n@'umeros em ponto flutuante por @code{float} ou por @code{numer} flags).

Quando @var{bound} for menor que 1, todas as ra@'{@dotless{i}}zes inteiras s@~ao encontradas exactamente.
Quando @var{bound} n@~ao for especificado, ser@'a assumido como sendo igual @`a vari@'avel globa @code{rootsepsilon}.

Quando a var@'avel global @code{programmode} for @code{true},
@code{realroots} retorna uma lista da forma @code{[x = @var{x_1}, x = @var{x_2}, ...]}.
Quando @code{programmode} for @code{false},
@code{realroots} cria r@'otulos de express@~oes interm@'edias @code{%t1}, @code{%t2}, ...,
atribui os resultados a eles, e retorna a lista de r@'otulos.

Exemplos:
@c ===beg===
@c realroots (-1 - x + x^5, 5e-6);
@c ev (%[1], float);
@c ev (-1 - x + x^5, %);
@c ===end===

@example
(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
@end example

@c ===beg===
@c realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
@c multiplicities;
@c ===end===

@example
(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} rhs (@var{expr})
Retorna o lado direito (isto @'e, o segundo argumento)
da express@~ao @var{expr},
quando o operador de @var{expr}
for um dos operadores relacionais @code{< <= = # equal notequal >= >},
@c MENTION -> (MARROW) IN THIS LIST IF/WHEN THE PARSER RECOGNIZES IT
um dos operadores de atribui@value{cedilha}@~ao @code{:= ::= : ::},
ou um operador bin@'ario infixo definido pelo utilizador, como declarado por meio de @code{infix}.

Quando @var{expr} for um @'etomo ou
seu operadro for alguma coisa que n@~ao esses listados acima,
@code{rhs} retorna 0.

Veja tamb@'em @code{lhs}.

Exemplos:

@c ===beg===
@c e: aa + bb = cc;
@c lhs (e);
@c rhs (e);
@c [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
@c [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
@c e1: '(foo(x) := 2*x);
@c e2: '(bar(y) ::= 3*y);
@c e3: '(x : y);
@c e4: '(x :: y);
@c [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
@c infix ("][");
@c rhs (aa ][ bb);
@c ===end===
@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix ("][");
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} rootsconmode
Valor por omiss@~ao: @code{true}

@code{rootsconmode} governa o comportamento do comando
@code{rootscontract}.  Veja @code{rootscontract} para detalhes.

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} rootscontract (@var{expr})
Converte produtos de ra@'{@dotless{i}}zes em ra@'{@dotless{i}}zes de produtos.
Por exemplo,
@code{rootscontract (sqrt(x)*y^(3/2))} retorna @code{sqrt(x*y^3)}.

Quando @code{radexpand} @'e @code{true} e @code{domain} @'e @code{real},
@code{rootscontract} converte @code{abs} em @code{sqrt}, e.g.,
@code{rootscontract (abs(x)*sqrt(y))} retorna @code{sqrt(x^2*y)}.

Existe uma op@value{cedilha}@~ao @code{rootsconmode}
afectando @code{rootscontract} como segue:

@example
Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
@end example

Quando @code{rootsconmode} @'e @code{false}, @code{rootscontract} contrai somente como rela@value{cedilha}@~ao a expoentes
de n@'umero racional cujos denominadores s@~ao os mesmos.  A chave para os exemplos
@code{rootsconmode: true} @'e simplesmente que 2 divides 4 mas n@~ao 
divide 3.  @code{rootsconmode: all} envolve pegar o menor m@'ultiplo comum
dos denominadores dos expoentes.

@code{rootscontract} usa @code{ratsimp} em uma maneira similar a @code{logcontract}.

Exemplos:
@c FOLLOWING ADAPTED FROM example (rootscontract)
@c rootsconmode: false$
@c rootscontract (x^(1/2)*y^(3/2));
@c rootscontract (x^(1/2)*y^(1/4));
@c rootsconmode: true$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: all$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: false$
@c rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
@c                     *sqrt(sqrt(1 + x) - sqrt(x)));
@c rootsconmode: true$
@c rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));

@example
(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} rootsepsilon
Valor por omiss@~ao: 1.0e-7

@code{rootsepsilon} @'e a toler@^ancia que estabelece o
intervalo de confic@^encia para as ra@'{@dotless{i}}zes achadas pela fun@value{cedilha}@~ao @code{realroots}.
@c IS IT GUARANTEED THAT |ACTUAL - ESTIMATE| < rootepsilon OR IS IT SOME OTHER NOTION ??
@c NEED EXAMPLE HERE

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} solve (@var{expr}, @var{x})
@deffnx {Fun@value{cedilha}@~ao} solve (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])
Resolve a equa@value{cedilha}@~ao alg@'ebrica @var{expr} para a vari@'avel
@var{x} e retorna uma lista de equa@value{cedilha}@~oes solu@value{cedilha}@~ao em @var{x}.  Se @var{expr} n@~ao @'e uma
equa@value{cedilha}@~ao, a equa@value{cedilha}@~ao @code{@var{expr} = 0} @'e assumida em seu lugar.
@var{x} pode ser uma fun@value{cedilha}@~ao (e.g. @code{f(x)}), ou outra express@~ao n@~ao at@^omica
excepto uma adi@value{cedilha}@~ao ou um produto.  @var{x} pode ser omitido se @var{expr} cont@'em somente uma
vari@'avel.  @var{expr} pode ser uma express@~ao racional, e pode conter
fun@value{cedilha}@~oes trigonom@'etricas, exponenciais, etc.

O seguinte m@'etodo @'e usado:

Tome @var{E} sendo a express@~ao e @var{X} sendo a vari@'avel.  Se @var{E} @'e linear em @var{X}
ent@~ao isso @'e trivialmente resolvido para @var{X}.  De outra forma se @var{E} @'e da forma
@code{A*X^N + B} ent@~ao o resultado @'e @code{(-B/A)^1/N)} vezes as @code{N}'@'esimas ra@'{@dotless{i}}zes da
unidade.

Se @var{E} n@~ao @'e linear em @var{X} ent@~ao o m@'aximo divisor comum (mdc) dos expoentes de @var{X} em @var{E} (digamos
@var{N}) @'e dividido dentro dos expoentes e a multiplicidade das ra@'{@dotless{i}}zes @'e
multiplicada por @var{N}.  Ent@~ao @code{solve} @'e chamada novamente sobre o resultado.
Se @var{E} for dada em factores ent@~ao @code{solve} @'e chamada sobre cada um dos factores.  Finalmente
@code{solve} usar@'a as f@'ormulas quadr@'aticas, c@'ubicas, ou qu@'articas onde
necess@'ario.

No caso onde @var{E} for um polin@'omio em alguma fun@value{cedilha}@~ao de vari@'avel a ser
resolvida, digamos @code{F(X)}, ent@~ao isso @'e primeiro resolvida para @code{F(X)} (chama o
resultado @var{C}), ent@~ao a equa@value{cedilha}@~ao @code{F(X)=C} pode ser resolvida para @var{X} fornecendo o
inverso da fun@value{cedilha}@~ao @var{F} que @'e conhecida.

@code{breakup} se @code{false} far@'a com que @code{solve} expresse as solu@value{cedilha}@~oes de
equa@value{cedilha}@~oes c@'ubicas ou qu@'articas como express@~oes simples ao inv@'es de como feito
em cima de v@'arias subexpress@~oes comuns que @'e o padr@~ao.

@code{multiplicities} - ser@'a escolhido para uma lista de multiplicidades de
solu@value{cedilha}@~oes individuais retornadas por @code{solve}, @code{realroots}, ou @code{allroots}.
Tente @code{apropos (solve)} para os comutadores que afectam @code{solve}.  @code{describe} pode
ent@~ao ser usada sobre o nome do comutador individual se seu propr@'osito n@~ao @'e
claro.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
resolve um sistema de equa@value{cedilha}@~oes polinomiais
(lineares ou n@~ao-lineares) simult@^aneas por chamada a @code{linsolve} ou
@code{algsys} e retorna uma lista de listas solu@value{cedilha}@~ao nas vari@'aveis.  No
caso de @code{linsolve} essa lista conter@'a uma lista simples de
solu@value{cedilha}@~oes.  Isso pega duas listas como argumentos.  A primeira lista
representa as equa@value{cedilha}@~oes a serem resolvidas; a segunda lista @'e a
lista de desconhecidos a ser determinada.  Se o n@'umero total de
vari@'aveis nas equa@value{cedilha}@~oes @'e igual ao n@'umero de equa@value{cedilha}@~oes, a
segunda lista-argumento pode ser omitida.  Para sistemas lineares se as dadas
equa@value{cedilha}@~oes n@~ao s@~ao compat@'{@dotless{i}}veis, a mensagem @code{inconsistent} ser@'a
mostrada (veja o comutador @code{solve_inconsistent_error} ); se n@~ao existe
solu@value{cedilha}@~ao @'unica, ent@~ao @code{singular} ser@'a mostrado.

Exemplos:
@c FOLLOWING ADAPTED FROM example (solve)
@c solve (asin (cos (3*x))*(f(x) - 1), x);
@c ev (solve (5^f(x) = 125, f(x)), solveradcan);
@c [4*x^2 - y^2 = 12, x*y - x = 2];
@c solve (%, [x, y]);
@c solve (1 + a*x + x^3, x);
@c solve (x^3 - 1);
@c solve (x^6 - 1);
@c ev (x^6 - 1, %[1]);
@c expand (%);
@c x^2 - 1;
@c solve (%, x);
@c ev (%th(2), %[1]);

@example
(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solu@value{cedilha}@~oes will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} solvedecomposes
Valor por omiss@~ao: @code{true}

Quando @code{solvedecomposes} @'e @code{true}, @code{solve} chama
@code{polydecomp} se perguntado para resolver polin@'omios.
@c OTHERWISE WHAT HAPPENS -- CAN'T SOLVE POLYNOMIALS, OR SOME OTHER METHOD IS USED ??

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} solveexplicit
Valor por omiss@~ao: @code{false}

Quando @code{solveexplicit} @'e @code{true}, inibe @code{solve} de
retornar solu@value{cedilha}@~oes impl@'{@dotless{i}}citas, isto @'e, solu@value{cedilha}@~oes da forma @code{F(x) = 0}
onde @code{F} @'e alguma fun@value{cedilha}@~ao.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} solvefactors
Valor por omiss@~ao: @code{true}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{solvefactors} @'e @code{false}, @code{solve} n@~ao tenta
factorizar a express@~ao. A escolha do @code{false} poder@'a ser @'util
em alguns casos onde a factoriza@value{cedilha}@~ao n@~ao @'e
necess@'aria.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} solvenullwarn
Valor por omiss@~ao: @code{true}

Quando @code{solvenullwarn} @'e @code{true}, 
@code{solve} imprime uma mensagem de alerta se chamada com ou uma lista equa@value{cedilha}@~ao ou uma vari@'avel lista nula.
Por exemplo, @code{solve ([], [])} imprimir@'a duas mensagens de alerta e retorna @code{[]}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} solveradcan
Valor por omiss@~ao: @code{false}

Quando @code{solveradcan} @'e @code{true}, @code{solve} chama @code{radcan}
que faz @code{solve} lento mas permitir@'a certamente que problemas
contendo exponeniais e logaritmos sejam resolvidos.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} solvetrigwarn
Valor por omiss@~ao: @code{true}

@c MAYBE THIS CAN BE CLARIFIED
Quando @code{solvetrigwarn} @'e @code{true},
@code{solve} pode imprimir uma mensagem dizendo que est@'a usando fun@value{cedilha}@~oes
trigonom@'etricas inversas para resolver a equa@value{cedilha}@~ao, e desse modo perdendo
solu@value{cedilha}@~oes.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} solve_inconsistent_error
Valor por omiss@~ao: @code{true}

Quando @code{solve_inconsistent_error} @'e 
@code{true}, @code{solve} e
@code{linsolve} resultam em erro se as equa@value{cedilha}@~oes a serem resolvidas s@~ao inconsistentes.

Se @code{false}, @code{solve} e @code{linsolve} retornam uma lista vazia @code{[]} 
se as equa@value{cedilha}@~oes forem inconsistentes.

Exemplo:

@example
(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equa@value{cedilha}@~oes:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
@end example

@end defvr
