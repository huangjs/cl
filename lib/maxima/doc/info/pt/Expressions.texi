@c /Expressions.texi/1.52/Sun Mar 11 02:32:14 2007/-ko/
@menu
* Introdu@value{cedilha}@~ao a Express@~oes::  
* Complexo::                     
* Substantivos e Verbos::
* Identificadores::
* Sequ@^encias de caracteres::
* Desigualdade::                  
* Sintaxe::                      
* Defini@value{cedilha}@~oes para Express@~oes::  
@end menu

@node Introdu@value{cedilha}@~ao a Express@~oes, Complexo, Express@~oes, Express@~oes
@section Introdu@value{cedilha}@~ao a Express@~oes

Existe um conjunto de palavras reservadas que n@~ao pode ser usado como
nome de vari@'avel.   Seu uso pode causar um poss@'{@dotless{i}}vel erro cr@'{@dotless{i}}tico de sintaxe.

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

Muitas coisas em Maxima s@~ao express@~oes.   Uma sequ@^encia de express@~oes
pode ser feita dentro de uma express@~ao maior atrav@'es da separa@value{cedilha}@~ao dessas atrav@'es de v@'{@dotless{i}}rgulas e
colocando par@^entesis em torno dela.   Isso @'e similar ao @b{C}
@i{express@~ao com v@'{@dotless{i}}rgula}.

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Mesmo ciclos em Maxima s@~ao express@~oes, embora o valor de retorno desses
ciclos n@~ao seja muito @'util (eles retornam sempre @code{done}).

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

enquanto que o que realmente queira seja provavelmente incluir um
terceiro termo na @i{express@~ao com v@'{@dotless{i}}rgula} que fornece
de volta o valor actualizado.

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example



@c THIS REALLY NEEDS EXPANSION
@node Complexo, Substantivos e Verbos, Introdu@value{cedilha}@~ao a Express@~oes, Express@~oes
@section Complexo
Uma express@~ao complexa @'e especificada no Maxima atrav@'es da adi@value{cedilha}@~ao da
parte real da express@~ao a @code{%i} vezes a parte imagin@'aria.  Dessa forma as
ra@'{@dotless{i}}zes da equa@value{cedilha}@~ao @code{x^2 - 4*x + 13 = 0} s@~ao @code{2 + 3*%i} e @code{2 - 3*%i}.  Note que
produtos de simplifica@value{cedilha}@~ao de express@~oes complexas podem ser efetuadas atrav@'es da
expans@~ao do produto.  Simplifica@value{cedilha}@~ao de quocientes, ra@'{@dotless{i}}zes, e outras
fun@value{cedilha}@~oes de express@~oes complexas podem usualmente serem realizadas atrav@'es do uso
das fun@value{cedilha}@~oes @code{realpart}, @code{imagpart}, @code{rectform}, @code{polarform}, @code{abs}, @code{carg}.

@node Substantivos e Verbos, Identificadores, Complexo, Express@~oes
@section Substantivos e Verbos
Maxima distingue entre operadores que s@~ao "substantivos" e operadores que s@~ao "verbos".
Um verbo @'e um operador que pode ser executado.
Um substantivo @'e um operador que aparece como um s@'{@dotless{i}}mbolo em uma express@~ao, sem ser executado.
Por padr@~ao, nomes de fun@value{cedilha}@~ao s@~ao verbos.
Um verbo pode ser mudado em um substantivo atrav@'es da adi@value{cedilha}@~ao de um ap@'ostrofo no in@'{@dotless{i}}cio do nome da fun@value{cedilha}@~ao
ou aplicando a fun@value{cedilha}@~ao @code{nounify}.
Um substantivo pode ser mudado em um verbo atrav@'es da aplica@value{cedilha}@~ao da fun@value{cedilha}@~ao @code{verbify}.
O sinalizador de avalia@value{cedilha}@~ao @code{nouns} faz com que @code{ev} avalie substantivos em uma express@~ao.

A forma verbal @'e distinguida atrav@'es de
um sinal de d@'olar @code{$} no in@'{@dotless{i}}cio do s@'{@dotless{i}}mbolo Lisp correspondente.
De forma oposta,
a forma substantiva @'e distinguida atrav@'es de 
um sinal de @code{%} no in@'{@dotless{i}}cio do s@'{@dotless{i}}mbolo Lisp correspondente.
Alguns substantivos possuem propriedades especiais de exibi@value{cedilha}@~ao, tais como @code{'integrate} e @code{'derivative}
(retornado por @code{diff}), mas muitos n@~ao.
Por padr@~ao, as formas substantiva e verbal de uma fun@value{cedilha}@~ao s@~ao id@^enticas quando mostradas.
O sinalizador global @code{noundisp} faz com que Maxima mostre substantivos com um ap@'ostrofo no in@'{@dotless{i}}cio @code{'}.

Veja tamb@'em @code{noun}, @code{nouns}, @code{nounify}, e @code{verbify}.

Exemplos:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example

@node Identificadores, Sequ@^encias de caracteres, Substantivos e Verbos, Express@~oes
@section Identificadores
Identificadores do Maxima podem compreender caracteres alfab@'eticos,
mais os numerais de 0 a 9,
mais qualquer caractere especial precedido por um caractere contra-barra @code{\}.

Um numeral pode ser o primeiro caractere de um identificador
se esse numeral for precedido por uma contra-barra.
Numerais que forem o segundo ou o @'ultimo caractere n@~ao precisam ser precedidos por uma contra barra.

Caracteres podem ser declarados para serem alfab@'eticos por meio da fun@value{cedilha}@~ao @code{declare}.
Se ent@~ao declarados alfab@'eticos, eles n@~ao precisam serem precedidos de uma contrabarra em um identificador.
Os caracteres alfab@'eticos v@~ao inicialmente 
de @code{A} a @code{Z}, de @code{a} a @code{z}, @code{%}, e @code{_}.

Maxima @'e sens@'{@dotless{i}}vel @`a caixa . Os identificadores @code{algumacoisa}, @code{ALGUMACOISA}, e @code{Algumacoisa} s@~ao distintos.
Veja @emph{Lisp e Maxima} para mais sobre esse ponto.

Um identificador Maxima @'e um s@'{@dotless{i}}mbolo Lisp que come@value{cedilha}a com um sinal de d@'olar @code{$}.
Qualquer outro s@'{@dotless{i}}mbolo Lisp @'e precedido por um ponto de interroga@value{cedilha}@~ao @code{?} quando aparecer no Maxima.
Veja @emph{Lisp e Maxima} para maiores detalhes sobre esse ponto.

Exemplos:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example

@node Sequ@^encias de caracteres, Desigualdade, Identificadores, Express@~oes
@section Sequ@^encias de caracteres

Strings (sequ@^encias de caracteres) s@~ao contidas entre aspas duplas @code{"} em entradas de dados usados pelo Maxima,
e mostradas com ou sem as aspas duplas, 
dependendo do valor escolhido para a vari@'avel global @code{stringdisp}.

Sequ@^encias de caracteres podem conter quaisquer caracteres,
incluindo tabula@value{cedilha}@~oes (tab), nova linha (ou fim de linha), e caracteres de retorno da cabe@value{cedilha}a de impress@~ao (carriage return).
A sequ@^encia @code{\"} @'e reconhecida com uma aspa dupla literal,
e @code{\\} como uma contrabarra literal.
Quando a contrabarra aparecer no final de uma linha,
a contrabarra e a termina@value{cedilha}@~ao de linha
(ou nova linha ou retorno de carro e nova linha)
s@~ao ignorados,
de forma que a sequ@^encia de caracteres continue na pr@'oxima linha.
Nenhuma outra combina@value{cedilha}@~ao especial de contrabarra com outro caractere @'e reconhecida;
quando a contrabarra aparecer antes de qualquer outro caractere que n@~ao seja @code{"}, @code{\},
ou um fim de linha, a contrabarra @'e ignorada.
N@~ao exite caminho para representar um caractere especial
(tal como uma tabula@value{cedilha}@~ao, nova linha, ou retorno da cabe@value{cedilha}a de impress@~ao)
excepto atrav@'es de encaixar o caractere literal na sequ@^encia de caracteres.

N@~ao existe tipo de caractere no Maxima;
um caractere simples @'e representado como uma sequ@^encia de caracteres de um @'unico caractere.

Sequ@^encias de caracteres no Maxima s@~ao implementadas como s@'{@dotless{i}}mbolos do Lisp, n@~ao como sequencias de caracteres do not Lisp;
o que pode mudar em futuras vers@~oes do Maxima.
Maxima pode mostrar sequ@^encias de caracteres do Lisp e caracteres do Lisp,
embora algumas outras opera@value{cedilha}@~oes (por exemplo, testes de igualdade) possam falhar.
@c DISCOMFORT WITH LISP STRINGS AND CHARACTERS IS A BUG.

O pacote adicional @code{stringproc} cont@'em muitas fun@value{cedilha}@~oes que trabalham com sequ@^encias de caracteres.

Exemplos:

@c ===beg===
@c s_1 : "Isso @'e uma sequ@^encia de caracteres  do Maxima.";
@c s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma sequ@^encia de caracteres.";
@c s_3 : "Caractere de fim de linha encaixado
@c nessa sequ@^encia de caracteres.";
@c s_4 : "Ignore o \
@c caractere de \
@c fim de linha nessa \
@c sequ@^encia de caracteres.";
@c stringdisp : false;
@c s_1;
@c stringdisp : true;
@c s_1;
@c ===end===
@example
(%i1) s_1 : "Isso @'e uma sequ@^encia de caracteres  do Maxima.";
(%o1)               Isso @'e uma sequ@^encia de caracteres  do Maxima.
(%i2) s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma sequ@^encia de caracteres.";
(%o2) Caracteres "aspas duplas" e contrabarra \ encaixados em uma sequ@^encia de caracteres.
(%i3) s_3 : "Caractere de fim de linha encaixado
nessa sequ@^encia de caracteres.";
(%o3) Caractere de fim de linha encaixado
nessa sequ@^encia de caracteres.
(%i4) s_4 : "Ignore o \
caractere de \
fim de linha nessa \
sequ@^encia de caracteres.";
(%o4) Ignore o caractere de fim de linha nessa sequ@^encia de caracteres.
(%i5) stringdisp : false;
(%o5)                         false
(%i6) s_1;
(%o6)               Isso @'e uma sequ@^encia de caracteres  do Maxima.
(%i7) stringdisp : true;
(%o7)                         true
(%i8) s_1;
(%o8)              "Isso @'e uma sequ@^encia de caracteres  do Maxima."
@end example

@node Desigualdade, Sintaxe, Sequ@^encias de caracteres, Express@~oes
@section Desigualdade
Maxima tem os operadores de desigualdade @code{<}, @code{<=}, @code{>=}, @code{>}, @code{#}, e @code{notequal}.
Veja @code{if} para uma descri@value{cedilha}@~ao de express@~oes condicionais.

@node Sintaxe, Defini@value{cedilha}@~oes para Express@~oes, Desigualdade, Express@~oes
@section Sintaxe
@'E poss@'{@dotless{i}}vel definir novos operadores com preced@^encia especificada,
remover a defini@value{cedilha}@~ao de operadores existentes,
ou redefinir a preced@^encia de operadores existentes.  
Um operador pode ser un@'ario prefixado ou un@'ario p@'osfixado, binario infixado, n-@'ario infixado, matchfix, ou nofix.
"Matchfix" significa um par de s@'{@dotless{i}}mbolos que abra@value{cedilha}am seu argumento ou seus argumentos,
e "nofix" significa um operador que n@~ao precisa de argumentos.
Como exemplos dos diferentes tipos de operadores, existe o seguinte.

@table @asis
@item un@'ario prefixado
nega@value{cedilha}@~ao @code{- a}
@item un@'ario posfixado
factorial @code{a!}
@item bin@'ario infixado
exponencia@value{cedilha}@~ao @code{a^b}
@item n-@'ario infixado
adi@value{cedilha}@~ao @code{a + b}
@item matchfix
constru@value{cedilha}@~ao de lista @code{[a, b]}
@end table

(N@~ao existe operadores internos nofix;
para um exemplo de tal operador, veja @code{nofix}.)

O mecanismo para definir um novo operador @'e directo.
Somente @'e necess@'ario declarar uma fun@value{cedilha}@~ao como um operador;
a fun@value{cedilha}@~ao operador pode ou n@~ao estar definida previamente.

Um exemplo de operadores definidos pelo utilizador @'e o seguinte.
Note que a chamada expl@'{@dotless{i}}cita de fun@value{cedilha}@~ao @code{"dd" (a)} @'e equivalente a @code{dd a},
da mesma forma @code{"<-" (a, b)} @'e equivalente a @code{a <- b}.
Note tamb@'em que as fun@value{cedilha}@~oes @code{"dd"} e @code{"<-"} s@~ao indefinidas nesse exemplo.

@c ===beg===
@c prefix ("dd");
@c dd a;
@c "dd" (a);
@c infix ("<-");
@c a <- dd b;
@c "<-" (a, "dd" (b));
@c ===end===
@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

As fun@value{cedilha}@~oes m@'axima que definem novos operadores est@~ao sumarizadas nessa tabela,
equilibrando expoente associado esquerdo (padr@~ao) e o expoente associado direito ("eae" e "ead", respectivamente).
@c REWORK FOLLOWING COMMENT. IT'S NOT CLEAR ENOUGH, GIVEN THAT IT'S FAIRLY IMPORTANT
(Associa@value{cedilha}@~ao de expoentes determina a preced@^encia do operador. todavia, uma vez que os expoentes
esquerdo e direito podem ser diferentes, associa@value{cedilha}@~ao de expoentes @'e at@'e certo ponto mais complicado que preced@^encia.)
Alguma das fun@value{cedilha}@~oes de defini@value{cedilha}@~ao de opera@value{cedilha}@~oes tomam argumentos adicionais;
veja as descri@value{cedilha}@~oes de fun@value{cedilha}@~ao para maiores detalhes.

@c MAKE ANCHORS FOR ALL 6 FUNCTIONS AND CHANGE @code TO @emph ACCORDINGLY
@table @code
@item prefixado
ead=180
@item posfixado
eae=180
@item infixado
eae=180, ead=180
@item n@'ario
eae=180, ead=180
@item matchfix
(associa@value{cedilha}@~ao de expoentes n@~ao @'e aplic@'avel)
@item nofix
(associa@value{cedilha}@~ao de expoentes n@~ao @'e aplic@'avel)
@end table

Para compara@value{cedilha}@~ao,
aqui est@'a alguns operadores internos e seus expoentes associados esquerdo e direito.

@example
Operador   eae     ead

  :        180     20 
  ::       180     20 
  :=       180     20 
  ::=      180     20 
  !        160
  !!       160
  ^        140     139 
  .        130     129 
  *        120
  /        120     120 
  +        100     100 
  -        100     134 
  =        80      80 
  #        80      80 
  >        80      80 
  >=       80      80 
  <        80      80 
  <=       80      80 
  not              70 
  and      65
  or       60
  ,        10
  $        -1
  ;        -1
@end example

@code{remove} e @code{kill} removem propriedades de operador de um @'atomo.
@code{remove ("@var{a}", op)} remove somente as propriedades de operador de @var{a}.
@code{kill ("@var{a}")} remove todas as propriedades de @var{a}, incluindo as propriedades de operador.
Note que o nome do operador dever estar abra@value{cedilha}ado por aspas duplas.

@c MAYBE COPY THIS EXAMPLE TO remove AND/OR kill
@c ===beg===
@c infix ("##");
@c "##" (a, b) := a^b;
@c 5 ## 3;
@c remove ("##", op);
@c 5 ## 3;
@c "##" (5, 3);
@c infix ("##");
@c 5 ## 3;
@c kill ("##");
@c 5 ## 3;
@c "##" (5, 3);
@c ===end===
@example
(%i1) infix ("##");
(%o1)                          ##
(%i2) "##" (a, b) := a^b;
                                     b
(%o2)                     a ## b := a
(%i3) 5 ## 3;
(%o3)                          125
(%i4) remove ("##", op);
(%o4)                         done
(%i5) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i5) "##" (5, 3);
(%o5)                          125
(%i6) infix ("##");
(%o6)                          ##
(%i7) 5 ## 3;
(%o7)                          125
(%i8) kill ("##");
(%o8)                         done
(%i9) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i9) "##" (5, 3);
(%o9)                       ##(5, 3)
@end example

@node Defini@value{cedilha}@~oes para Express@~oes,  , Sintaxe, Express@~oes
@section Defini@value{cedilha}@~oes para Express@~oes

@deffn {Fun@value{cedilha}@~ao} at (@var{expr}, [@var{eqn_1}, ..., @var{eqn_n}])
@deffnx {Fun@value{cedilha}@~ao} at (@var{expr}, @var{eqn})
Avalia a express@~ao @var{expr} com
as vari@'aveis assumindo os valores como especificado para elas na lista de
equa@value{cedilha}@~oes @code{[@var{eqn_1}, ..., @var{eqn_n}]} ou a equa@value{cedilha}@~ao simples @var{eqn}.

Se uma subexpress@~ao depender de qualquer das vari@'aveis para a qual um valor foi especificado
mas n@~ao existe @code{atvalue} especificado e essa subexpress@~ao n@~ao pode ser avaliada de outra forma,
ent@~ao uma forma substantiva de @code{at} @'e retornada que mostra em uma forma bidimensional.

@code{at} realiza m@'ultiplas substitui@value{cedilha}@~oes em s@'erie, n@~ao em paralelo.

Veja tamb@'em @code{atvalue}.
Para outras fun@value{cedilha}@~oes que realizam substitui@value{cedilha}@~oes,
veja tamb@'em @code{subst} e @code{ev}.

Exemplos:
@c COPIED FROM example(at)

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x, y)^2 - u(x, y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} box (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} box (@var{expr}, @var{a})
Retorna @var{expr} dentro de uma caixa.
O valor de retorno @'e uma express@~ao com @code{box} como o operador e @var{expr} como o argumento.
Uma caixa @'e desenhada sobre a tela quando @code{display2d} for @code{true}.

@code{box (@var{expr}, @var{a})}
Empacota @var{expr} em uma caixa rotulada pelo s@'{@dotless{i}}mbolo @var{a}.
O r@'otulo @'e truncado se for maior que a largura da caixa.

@code{box} avalia seu argumento.
Todavia, uma express@~ao dentro de uma caixa n@~ao avalia para seu conte@'udo,
ent@~ao express@~oes dentro de caixas s@~ao efectivamente exclu@'{@dotless{i}}das de c@'alculos.

@code{boxchar} @'e o caractere usado para desenhar a caixa em @code{box}
e nas fun@value{cedilha}@~oes @code{dpart} e @code{lpart}.

Exemplos:

@c ===beg===
@c box (a^2 + b^2);
@c a : 1234;
@c b : c - d;
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
(%i7) boxchar: "-";
(%o7)                           -
(%i8) box (sin(x) + cos(y));
                        -----------------
(%o8)                   -cos(y) + sin(x)-
                        -----------------
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} boxchar
Valor por omiss@~ao: @code{"}

@code{boxchar} @'e o caractere usado para desenhar a caixa por @code{box}
e nas fun@value{cedilha}@~oes @code{dpart} e @code{lpart}.

Todas as caixas em uma express@~ao s@~ao desenhadas com o valor actual
de @code{boxchar}; o caractere de desenho n@~ao @'e armazenado com a
express@~ao de caixa. Isso quer dizer que se desenhar uma caixa e em
seguida mudar o caracter de desenho a caixa anteriormente desenhada
ser@'a redesenhada com o caracter mudado caso isso seja solicitado.

@end defvr

@deffn {Fun@value{cedilha}@~ao} carg (@var{z})
Retorna o argumento complexo de @var{z}.
O argumento complexo @'e um @^angulo @code{theta} no intervalo de @code{(-%pi, %pi]}
tal que @code{r exp (theta %i) = @var{z}} onde @code{r} @'e o m@'odulo de @var{z}.
@c ACTUALLY carg DOESN'T ALWAYS RETURN A VALUE IN (-%pi, %pi]; SEE SF BUG REPORT # 816166

@code{carg} @'e uma fun@value{cedilha}@~ao computacional,
n@~ao uma fun@value{cedilha}@~ao de simplifica@value{cedilha}@~ao.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

@code{carg} ignora a declara@value{cedilha}@~ao @code{declare (@var{x}, complex)},
e trata @var{x} como uma vari@'avel real.
Isso @'e um erro. @c SEE SF BUG REPORT # 620246

Veja tamb@'em @code{abs} (m@'odulo de n@'umero complexo), @code{polarform}, @code{rectform},
@code{realpart}, e @code{imagpart}.

Exemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c CROSS REF declare, properties, ETC
@deffn {Opereador especial} constant
@code{declare (@var{a}, constant)} declara @var{a} para ser uma constante.
Veja @code{declare}.
@c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@end deffn

@deffn {Fun@value{cedilha}@~ao} constantp (@var{expr})
Retorna @code{true} se @var{expr} for uma express@~ao constante,
de outra forma retorna @code{false}.
@c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

Uma express@~ao @'e considerada uma express@~ao constante se seus argumentos forem
n@'umeros (incluindo n@'umeros racionais, como mostrado com @code{/R/}),
constantes simb@'olicas como @code{%pi}, @code{%e}, e @code{%i},
vari@'aveis associadas a uma constante ou constante declarada atrav@'es de @code{declare},
ou fun@value{cedilha}@~oes cujos argumentos forem constantes.

@code{constantp} avalia seus argumentos.

Exemplos:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===

@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c THIS ITEM IS EXTREMELY IMPORTANT
@c ENSURE THAT ALL KEYWORDS RECOGNIZED BY declare HAVE THEIR OWN DOCUMENTATION ITEMS !!
@c ALSO: HOW TO FIND THE LIST OF ALL SYMBOLS WHICH HAVE A GIVEN PROPERTY ??
@deffn {Fun@value{cedilha}@~ao} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, ...)
Atribui aos @'atomos ou lista de @'atomos @var{a_i} a propriedade ou lista de propriedades @var{p_i}.
Quando @var{a_i} e/ou @var{p_i} forem listas,
cada um dos @'atomos recebe todas as propriedades.

@code{declare} n@~ao avalia seus argumentos.
@code{declare} sempre retorna @code{done}.

Como colocado na descri@value{cedilha}@~ao para cada sinalizador de declara@value{cedilha}@~ao,
para alguns sinalizadores
@code{featurep(@var{objecto}, @var{recurso})}
retorna @code{true} se @var{objecto} tiver sido declarado para ter @var{recurso}.
Todavia, @code{featurep} n@~ao reconhece alguns sinalizadores; isso @'e um erro.

Veja tamb@'em @code{features}.

@code{declare} reconhece as seguintes propriedades:

@table @asis
@item @code{evfun}
Torna @var{a_i} conhecido para @code{ev} de forma que a fun@value{cedilha}@~ao nomeada por @var{a_i}
@'e aplicada quando @var{a_i} aparece como um sinalizador argumento de @code{ev}.
Veja @code{evfun}.

@item @code{evflag}
Torna @var{a_i} conhecido para a fun@value{cedilha}@~ao @code{ev} de forma que @var{a_i} @'e associado a @code{true}
durante a execu@value{cedilha}@~ao de @code{ev} quando @var{a_i} aparece como um sinalizador argumento de @code{ev}.
Veja @code{evflag}.

@c OBSOLETE @code{special} (RECONHECIDA POR DECLARE MAS NUNCA USADA EM LUGAR ALGUM)
 
@c OBSOLETE @code{nonarray} (RECONHECIDA POR DECLARE MAS NUNCA USADA EM LUGAR ALGUM)

@item @code{bindtest}
Diz ao Maxima para disparar um erro quando @var{a_i} for avaliado como sendo livre de associa@value{cedilha}@~ao.

@item @code{noun}
Diz ao Maxima para passar @var{a_i} como um substantivo. 
O efeito disso @'e substituir int@^ancias de @var{a_i} com @code{'@var{a_i}}
ou @code{nounify(@var{a_i})}, ependendo do contexto.

@item @code{constant}
Diz ao Maxima para considerar @var{a_i} uma constante simb@'olica.
@c WHAT MAXIMA KNOWS ABOUT SYMBOLIC CONSTANTS IS PRETTY LIMITED
@c DUNNO IF WE WANT TO GET INTO DETAILS HERE. 
@c MAYBE IN THE DOCUMENTATION FOR CONSTANT (IF THERE IS SUCH)

@item @code{scalar}
Diz ao Maxima para considerar @var{a_i} uma vari@'avel escalar.

@item @code{nonscalar}
Diz ao Maxima para considerar @var{a_i} uma vari@'avel n@~ao escalar.
The usual application is to declare a variable as a symbolic vector or matrix.

@item @code{mainvar}
Diz ao Maxima para considerar @var{a_i} uma "vari@'avel principal" (@code{mainvar}).
@code{ordergreatp} determina a ordena@value{cedilha}@~ao de @'atomos como segue:

(vari@'aveis principais) > (outras vari@'aveis) > (vari@'aveis escalares) > (constantes) > (n@'umeros)

@item @code{alphabetic}
Diz ao Maxima para reconhecer todos os caracteres em @var{a_i} (que deve ser uma sequ@^encia de caracteres) como caractere alfab@'etico.

@item @code{feature}
Diz ao Maxima para reconhecer @var{a_i} como nome de um recurso.
Other atoms may then be declared to have the @var{a_i} property.

@item @code{rassociative}, @code{lassociative}
Diz ao Maxima para reconhecer @var{a_i} como uma func@~ao associativa a direita ou associativa a esquerda.

@item @code{nary}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~ao n-@'aria (com muitos argumentos).

A declara@value{cedilha}@~ao @code{nary} n@~ao tem o mesmo objectivo que uma chamada @`a fun@value{cedilha}@~ao @code{nary}.
O @'unico efeito de @code{declare(foo, nary)} @'e para instruir o simplificador do Maxima
a melhorar as pr@'oximas express@~oes,
por exemplo, para simplificar @code{foo(x, foo(y, z))} para @code{foo(x, y, z)}.

@item @code{symmetric}, @code{antisymmetric}, @code{commutative}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~ao sim@'etrica ou antisim@'etrica.
@code{commutative} @'e o mesmo que @code{symmetric}.

@item
@code{oddfun}, @code{evenfun}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~ao par ou uma fun@value{cedilha}@~ao @'{@dotless{i}}mpar.
 
@item @code{outative}
Diz ao Maxima para simplificar express@~oes @var{a_i}
colocando factores constantes em evid@^encia no primeiro argumento.

Quando @var{a_i} tiver um argumento,
um factor @'e onsiderado constante se for um literal ou se for declarado como sendo constante.

Quando @var{a_i} tiver dois ou mais argumentos,
um factor @'e considerado constante
se o segundo argumento for um s@'{@dotless{i}}mbolo
e o factor estiver livre do segundo argumento.

@item @code{multiplicative}
Diz ao Maxima para simplificar express@~oes do tipo @var{a_i}
atrav@'es da substitui@value{cedilha}@~ao @code{@var{a_i}(x * y * z * ...)} @code{-->}
@code{@var{a_i}(x) * @var{a_i}(y) * @var{a_i}(z) * ...}.
A substitui@value{cedilha}@~ao @'e realizada no primeiro argumento somente.

@item @code{additive}
Diz ao Maxima para simplificar express@~oes do tipo @var{a_i}
atrav@'es da substitui@value{cedilha}@~ao @code{@var{a_i}(x + y + z + ...)} @code{-->}
@code{@var{a_i}(x) + @var{a_i}(y) + @var{a_i}(z) + ...}.
A substitui@value{cedilha}@~ao @'e realizada no primeiro argumento somente.

@item @code{linear}
Equivalente a declarar @var{a_i} ao mesmo tempo @code{outative} e @code{additive}.

@c OBSOLETE @code{analytic} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)
 
@item @code{integer}, @code{noninteger}
Diz ao Maxima para reconhecer @var{a_i} como como uma vari@'avel inteira ou como uma vari@'avel n@~ao inteira.
 
Maxima reconhece os seguintes recursos de objectos:

@item @code{even}, @code{odd}
Diz ao Maxima para reconhecer @var{a_i} como uma vari@'avel inteira par ou como uma vari@'avel inteira @'{@dotless{i}}mpar.

@item @code{rational}, @code{irrational}
Diz ao Maxima para reconhecer @var{a_i} como uma vari@'avel real e racional ou como uma vari@'avel real e irracional.

@item @code{real}, @code{imaginary}, @code{complex}
Dia ao Maxima para reconhecer @var{a_i} como uma vari@'avel real, imagin@'aria pura ou complexa.
 
@item @code{increasing}, @code{decreasing}
Dia ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~ao de incremento ou decremento.
@c MAXIMA FAILS TO DEDUCE F(2) > F(1) FOR INCREASING FUNCTION F
@c AND FAILS TO DEDUCE ANYTHING AT ALL ABOUT DECREASING FUNCTIONS
@c REPORTED AS SF BUG # 1483194

@item @code{posfun}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~ao positiva.

@item @code{integervalued}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~ao de valores inteiros.

@end table

Exemplos:

Declara@value{cedilha}@~oes @code{evfun} e @code{evflag}.
@c ===beg===
@c declare (expand, evfun);
@c (a + b)^3;
@c (a + b)^3, expand;
@c declare (demoivre, evflag);
@c exp (a + b*%i);
@c exp (a + b*%i), demoivre;
@c ===end===
@example
(%i1) declare (expand, evfun);
(%o1)                         done
(%i2) (a + b)^3;
                                   3
(%o2)                       (b + a)
(%i3) (a + b)^3, expand;
                     3        2      2      3
(%o3)               b  + 3 a b  + 3 a  b + a
(%i4) declare (demoivre, evflag);
(%o4)                         done
(%i5) exp (a + b*%i);
                             %i b + a
(%o5)                      %e
(%i6) exp (a + b*%i), demoivre;
                      a
(%o6)               %e  (%i sin(b) + cos(b))
@end example

Declara@value{cedilha}@~ao @code{bindtest}.
@c ===beg===
@c aa + bb;
@c declare (aa, bindtest);
@c aa + bb;
@c aa : 1234;
@c aa + bb;
@c ===end===
@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example

Declara@value{cedilha}@~ao @code{noun}.
@c ===beg===
@c factor (12345678);
@c declare (factor, noun);
@c factor (12345678);
@c ''%, nouns;
@c ===end===
@example
(%i1) factor (12345678);
                             2
(%o1)                     2 3  47 14593
(%i2) declare (factor, noun);
(%o2)                         done
(%i3) factor (12345678);
(%o3)                   factor(12345678)
(%i4) ''%, nouns;
                             2
(%o4)                     2 3  47 14593
@end example

Declara@value{cedilha}@~oes @code{constant}, @code{scalar}, @code{nonscalar}, e @code{mainvar}.
@c ===beg===
@c declare (bb, constant);
@c declare (cc, scalar);
@c declare (dd, nonscalar);
@c declare (ee, mainvar);
@c ===end===
@example
@end example

Declara@value{cedilha}@~ao @code{alphabetic}.
@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example

Declara@value{cedilha}@~ao @code{feature}.
@c ===beg===
@c declare (FOO, feature);
@c declare (x, FOO);
@c featurep (x, FOO);
@c ===end===
@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example

Declara@value{cedilha}@~oes @code{rassociative} e @code{lassociative}.
@c ===beg===
@c declare (F, rassociative);
@c declare (G, lassociative);
@c ===end===
@example
@end example

Declara@value{cedilha}@~ao @code{nary}.
@c ===beg===
@c H (H (a, b), H (c, H (d, e)));
@c declare (H, nary);
@c H (H (a, b), H (c, H (d, e)));
@c ===end===
@example
(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
@end example

Declara@value{cedilha}@~oes @code{symmetric} e @code{antisymmetric}.
@c ===beg===
@c S (b, a);
@c declare (S, symmetric);
@c S (b, a);
@c S (a, c, e, d, b);
@c T (b, a);
@c declare (T, antisymmetric);
@c T (b, a);
@c T (a, c, e, d, b);
@c ===end===
@example
(%i1) S (b, a);
(%o1)                        S(b, a)
(%i2) declare (S, symmetric);
(%o2)                         done
(%i3) S (b, a);
(%o3)                        S(a, b)
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
(%i5) T (b, a);
(%o5)                        T(b, a)
(%i6) declare (T, antisymmetric);
(%o6)                         done
(%i7) T (b, a);
(%o7)                       - T(a, b)
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
@end example

Declara@value{cedilha}@~oes @code{oddfun} e @code{evenfun}.
@c ===beg===
@c o (- u) + o (u);
@c declare (o, oddfun);
@c o (- u) + o (u);
@c e (- u) - e (u);
@c declare (e, evenfun);
@c e (- u) - e (u);
@c ===end===
@example
(%i1) o (- u) + o (u);
(%o1)                     o(u) + o(- u)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- u) + o (u);
(%o3)                           0
(%i4) e (- u) - e (u);
(%o4)                     e(- u) - e(u)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- u) - e (u);
(%o6)                           0
@end example

Declara@value{cedilha}@~ao @code{outative}.
@c ===beg===
@c F1 (100 * x);
@c declare (F1, outative);
@c F1 (100 * x);
@c declare (zz, constant);
@c F1 (zz * y);
@c ===end===
@example
(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
(%i2) declare (F1, outative);
(%o2)                         done
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
(%i4) declare (zz, constant);
(%o4)                         done
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
@end example

Declara@value{cedilha}@~ao @code{multiplicative}.
@c ===beg===
@c F2 (a * b * c);
@c declare (F2, multiplicative);
@c F2 (a * b * c);
@c ===end===
@example
(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
(%i2) declare (F2, multiplicative);
(%o2)                         done
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
@end example

Declara@value{cedilha}@~ao @code{additive}.
@c ===beg===
@c F3 (a + b + c);
@c declare (F3, additive);
@c F3 (a + b + c);
@c ===end===
@example
(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
(%i2) declare (F3, additive);
(%o2)                         done
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
@end example

Declara@value{cedilha}@~ao @code{linear}.
@c ===beg===
@c 'sum (F(k) + G(k), k, 1, inf);
@c declare (nounify (sum), linear);
@c 'sum (F(k) + G(k), k, 1, inf);
@c ===end===
@example
(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   >    (G(k) + F(k))
                       /
                       ====
                       k = 1
(%i2) declare (nounify (sum), linear);
(%o2)                         done
(%i3) 'sum (F(k) + G(k), k, 1, inf);
                     inf          inf
                     ====         ====
                     \            \
(%o3)                 >    G(k) +  >    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} disolate (@var{expr}, @var{x_1}, ..., @var{x_n})
@'e similar a @code{isolate (@var{expr}, @var{x})}
excepto que essa fun@value{cedilha}@~ao habilita ao utilizador isolar
mais que uma vari@'avel simult@^aneamente.  Isso pode ser @'util, por
exemplo, se se tiver tentado mudar vari@'aveis em uma integra@value{cedilha}@~ao
m@'ultipla, e em mudan@value{cedilha}a de vari@'avel envolvendo duas ou mais das
vari@'aveis de integra@value{cedilha}@~ao.  Essa fun@value{cedilha}@~ao @'e chamada automaticamente de
@file{simplification/disol.mac}.  Uma demostra@value{cedilha}@~ao est@'a dispon@'{@dotless{i}}vel atrav@'es de
@code{demo("disol")$}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} dispform (@var{expr})
Retorna a representa@value{cedilha}@~ao externa de @var{expr} com rela@value{cedilha}@~ao a seu
principal operador.  Isso pode ser @'util em conjun@value{cedilha}@~ao com @code{part} que
tamb@'em lida com a representa@value{cedilha}@~ao externa.  Suponha que @var{expr} seja -A .
Ent@~ao a representa@value{cedilha}@~ao interna de @var{expr} @'e  "*"(-1,A), enquanto que
a representa@value{cedilha}@~ao externa @'e "-"(A). @code{dispform (@var{expr}, all)} converte a
express@~ao inteira (n@~ao apenas o n@'{@dotless{i}}vel mais alto) para o formato externo.  Por
exemplo, se @code{expr: sin (sqrt (x))}, ent@~ao @code{freeof (sqrt, expr)} e
@code{freeof (sqrt, dispform (expr))} fornece @code{true}, enquanto
@code{freeof (sqrt, dispform (expr, all))} fornece @code{false}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} distrib (@var{expr})
Distribue adi@value{cedilha}@~oes sobre produtos.  @code{distrib} difere de @code{expand}
no facto de que @code{distrib} trabalha em somente no n@'{@dotless{i}}vel mais alto de uma express@~ao, i.e., @code{distrib} n@~ao
@'e recursiva e @code{distrib} @'e mais r@'apida que @code{expand}.  @code{distrib} difere de @code{multthru} no
que @code{distrib} expande todas as adi@value{cedilha}@~oes naquele n@'{@dotless{i}}vel.

Exemplos:

@example
(%i1) distrib ((a+b) * (c+d));
(%o1)                 b d + a d + b c + a c
(%i2) multthru ((a+b) * (c+d));
(%o2)                 (b + a) d + (b + a) c
(%i3) distrib (1/((a+b) * (c+d)));
                                1
(%o3)                    ---------------
                         (b + a) (d + c)
(%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                1
(%o4)                 ---------------------
                      b d + a d + b c + a c
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} dpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Selecciona a mesma subexpress@~ao que @code{part}, mas
em lugar de apenas retornar aquela subexpress@~ao como seu valor, isso retorna
a express@~ao completa com a subexpress@~ao seleccionada mostrada dentro
de uma caixa.  A caixa @'e actualmente parte da express@~ao.

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example

@end deffn

@c PROBABLY MORE TO BE SAID HERE
@deffn {Fun@value{cedilha}@~ao} exp (@var{x})
Representa fun@value{cedilha}@~ao exponencial.  
Inst@^ancias de @code{exp (@var{x})} em uma entrada s@~ao simplificadas para @code{%e^@var{x}};
@code{exp} n@~ao aparece em express@~oes simplificadas.

@code{demoivre} se @code{true} faz com que @code{%e^(a + b %i)} simplificar para
@code{%e^(a (cos(b) + %i sin(b)))} se @code{b} for livre de @code{%i}. veja @code{demoivre}.

@code{%emode}, quando @code{true}, 
faz com que @code{%e^(%pi %i x)} seja simplificado. Veja @code{%emode}.

@code{%enumer}, quando @code{true} faz com que @code{%e} seja substitu@'{@dotless{i}}do por
2.718...  quando @code{numer} for @code{true}. Veja @code{%enumer}.

@c NEED EXAMPLES HERE
@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} %emode
Valor por omiss@~ao: @code{true}

Quando @code{%emode} for @code{true},
@code{%e^(%pi %i x)} @'e simplificado como
segue.

@code{%e^(%pi %i x)} simplifica para @code{cos (%pi x) + %i sin (%pi x)} se @code{x} for um inteiro ou
um m@'ultiplo de 1/2, 1/3, 1/4, ou 1/6, e ent@~ao @'e adicionalmente simplificado.

Para outro @code{x} num@'erico,
@code{%e^(%pi %i x)} simplifica para @code{%e^(%pi %i y)} onde @code{y} @'e @code{x - 2 k}
para algum inteiro @code{k} tal que @code{abs(y) < 1}.  

Quando @code{%emode} for @code{false}, nenhuma
simplifica@value{cedilha}@~ao adicional de @code{%e^(%pi %i x)} @'e realizada.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} %enumer
Valor por omiss@~ao: @code{false}

Quando @code{%enumer} for @code{true},
@code{%e} @'e substituido por seu valor num@'erico
2.718...  mesmo que @code{numer} seja @code{true}. 

Quando @code{%enumer} for @code{false}, essa substitui@value{cedilha}@~ao @'e realizada
somente se o expoente em @code{%e^x} avaliar para um n@'umero.

Veja tamb@'em @code{ev} e @code{numer}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} exptisolate
Valor por omiss@~ao: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
@code{exptisolate}, quando @code{true}, faz com que @code{isolate (expr, var)}
examine expoentes de @'atomos (tais como @code{%e}) que contenham @code{var}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} exptsubst
Valor por omiss@~ao: @code{false}

@code{exptsubst}, quando @code{true}, permite substitui@value{cedilha}@~oes tais como @code{y}
para @code{%e^x} em @code{%e^(a x)}.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~ao} freeof (@var{x_1}, ..., @var{x_n}, @var{expr})
@code{freeof (@var{x_1}, @var{expr})}
Retorna @code{true}
se nenhuma subexpress@~ao de @var{expr} for igual a @var{x_1}
ou se @var{x_1} ocorrer somente uma vari@'avel que n@~ao tenha associa@value{cedilha}@~ao fora da express@~ao @var{expr},
e retorna @code{false} de outra forma.

@code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}
@'e equivalente a @code{freeof (@var{x_1}, @var{expr}) and ... and freeof (@var{x_n}, @var{expr})}.

Os argumentos @var{x_1}, ..., @var{x_n} 
podem ser nomes de fun@value{cedilha}@~oes e vari@'aveis, nomes subscritos,
operadores (empacotados em aspas duplas), ou express@~oes gerais.
@code{freeof} avalia seus argumentos.

@code{freeof} opera somente sobre @var{expr} como isso representa (ap@'os simplifica@value{cedilha}@~ao e avalia@value{cedilha}@~ao) e
n@~ao tenta determinar se alguma express@~ao equivalente pode fornecer um resultado diferente.
Em particular, simplifica@value{cedilha}@~ao pode retornar uma express@~ao equivalente mas diferente que compreende
alguns diferentes elementos da forma original de @var{expr}.

Uma vari@'avel @'e uma vari@'avel dummy em uma express@~ao se n@~ao tiver associa@value{cedilha}@~ao fora da express@~ao.
Vari@'aveis dummy recoreconhecidas atrav@'es de @code{freeof} s@~ao
o @'{@dotless{i}}ndice de um somat@'orio ou produt@'orio, o limite da vari@'avel em @code{limit},
a vari@'avel de integra@value{cedilha}@~ao na forma de integral definida de @code{integrate},
a vari@'avel original em @code{laplace},
vari@'aveis formais em expressoes @code{at},
e argumentos em express@~oes @code{lambda}.
Vari@'aveis locais em @code{block} n@~ao s@~ao reconhecidas por @code{freeof} como vari@'aveis dummy;
isso @'e um bug.

A forma indefinida de @code{integrate} @i{not} @'e livre de suas vari@'aveis de integra@value{cedilha}@~ao.

@itemize @bullet
@item
Argumentos s@~ao nomes de fun@value{cedilha}@~oes, vari@'aveis, nomes subscritos, operadores, e express@~oes.
@code{freeof (a, b, expr)} @'e equivalente a
@code{freeof (a, expr) and freeof (b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@item
@code{freeof} avalia seus argumentos.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@item
@code{freeof} n@~ao considera express@~oes equivalentes.
Simplifica@value{cedilha}@~ao pode retornar uma express@~ao equivalente mas diferente.

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

@item Um somat@'orio ou uma integral definida est@'a livre de uma vari@'avel dummy.
Uma integral indefinida n@~ao @'e livre de suas vari@'aveis de integra@value{cedilha}@~ao.

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end itemize

@end deffn

@c IS THIS DEFINITION CORRECT ??
@deffn {Fun@value{cedilha}@~ao} genfact (@var{x}, @var{y}, @var{z})
Retorna o factorial generalizado, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Dessa forma, para integral @var{x},
@code{genfact (x, x, 1) = x!} e @code{genfact (x, x/2, 2) = x!!}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} imagpart (@var{expr})
Retorna a parte imagin@'aria da express@~ao @var{expr}.

@code{imagpart} @'e uma fun@value{cedilha}@~ao computacional,
n@~ao uma fun@value{cedilha}@~ao de simplifica@value{cedilha}@~ao.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

Veja tamb@'em @code{abs}, @code{carg}, @code{polarform}, @code{rectform},
e @code{realpart}.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} infix (@var{op})
@deffnx {Fun@value{cedilha}@~ao} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {Fun@value{cedilha}@~ao} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})
Declara @var{op} para ser um operador infixo.
Um operador infixo @'e uma fun@value{cedilha}@~ao de dois argumentos,
com o nome da fun@value{cedilha}@~ao escrito entre os argumentos.
Por exemplo, o operador de subtra@value{cedilha}@~ao @code{-} @'e um operador infixo.

@code{infix (@var{op})} declara @var{op} para ser um operador infixo
com expoentes associados padr@~ao (esquerdo e direito ambos iguais a 180)
e podendo ser qualquer entre prefixado, infixado, posfixado, n@'ario, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).
@c HOW IS pos DIFFERENT FROM lpos AND rpos ??

@code{infix (@var{op}, @var{lbp}, @var{rbp})} declara @var{op} para ser um operador infixo
com expoentes associados esquerdo e directio equilibrados
e podendo ser qualquer entre prefixado, infixado, posfixado, n@'ario, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).

@code{infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}
declara @var{op} para ser um operdor infixo
com expoentes associados padr@~ao e podendo ser um entre 
prefixado, infixado, posfixado, n@'ario, matchfix e nofix.

A preced@^encia de @var{op} com rela@value{cedilha}@~ao a outros operadores
derivam dos expoentes associados directiro e esquerdo dos operadores em quest@~ao.
Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que o expoente associado esquerdo e o direito de algum outro operador,
ent@~ao @var{op} tem preded@^encia sobre o outro operador.
Se os expoentes associados n@~ao forem ambos maior ou menor,
alguma rela@value{cedilha}@~ao mais complicada ocorre.

A associatividade de @var{op} depende de seus expoentes associados.
Maior expoente associado esquerdo (@var{eae}) implica uma inst@^ancia de
@var{op} @'e avaliadas antes de outros operadores para sua esquerda em uma express@~ao,
enquanto maior expoente associado direito (@var{ead}) implica uma inst@^ancia de
@var{op} @'e avaliada antes de outros operadores para sua direita em uma express@~ao.
Dessa forma maior @var{eae} torna @var{op} associativo @`a direita,
enquanto maior @var{ead} torna @var{op} associativa @`a esquerda.
Se @var{eae} for igual a @var{ead}, @var{op} @'e associativa @`a esquerda.

Veja tamb@'em @code{Syntax}.

Exemplos:

Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que os expoentes associados @`a direita e @`a esquerda de algum outro operador,
ent@~ao @var{op} tem preced@^encia sobre o outro operador.

@c ===beg===
@c :lisp (get '$+ 'lbp)
@c :lisp (get '$+ 'rbp)
@c infix ("##", 101, 101);
@c "##"(a, b) := sconcat("(", a, ",", b, ")");
@c 1 + a ## b + 2;
@c infix ("##", 99, 99);
@c 1 + a ## b + 2;
@c ===end===
@example
(%i1) :lisp (get '$+ 'lbp)
100
(%i1) :lisp (get '$+ 'rbp)
100
(%i1) infix ("##", 101, 101);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
(%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
(%i3) 1 + a ## b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("##", 99, 99);
(%o4)                          ##
(%i5) 1 + a ## b + 2;
(%o5)                       (a+1,b+2)
@end example

grande @var{eae} torna @var{op} associativa @`a direita,
enquanto grande @var{ead} torna @var{op} associativa @`a esquerda.

@c ===beg===
@c infix ("##", 100, 99);
@c "##"(a, b) := sconcat("(", a, ",", b, ")")$
@c foo ## bar ## baz;
@c infix ("##", 100, 101);
@c foo ## bar ## baz;
@c ===end===
@example
(%i1) infix ("##", 100, 99);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
(%i3) foo ## bar ## baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("##", 100, 101);
(%o4)                          ##
(%i5) foo ## bar ## baz;
(%o5)                    ((foo,bar),baz)
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} inflag
Velor padr@~ao: @code{false}

Quando @code{inflag} for @code{true}, fun@value{cedilha}@~oes para extra@value{cedilha}@~ao de
partes inspecionam a forma interna de @code{expr}.

Note que o simplificador re-organiza express@~oes.
Dessa forma @code{first (x + y)} retorna @code{x} se @code{inflag}
for @code{true} e @code{y} se @code{inflag} for @code{false}.
(@code{first (y + x)} fornece os mesmos resultados.)

Tamb@'em, escolhendo @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} @'e
o mesmo que chamar @code{inpart} ou @code{substinpart}.

As fun@value{cedilha}@~oes afectadas pela posi@value{cedilha}@~ao do sinalizador @code{inflag} s@~ao:
@code{part}, @code{substpart}, @code{first}, @code{rest}, @code{last}, @code{length},
a estrutura @code{for} ... @code{in},
@code{map}, @code{fullmap}, @code{maplist}, @code{reveal} e @code{pickapart}.

@c NEED EXAMPLES HERE
@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})
@'E similar a @code{part} mas trabalha sobre a representa@value{cedilha}@~ao
interna da express@~ao em lugar da forma de exibi@value{cedilha}@~ao e
dessa forma pode ser mais r@'apida uma vez que nenhuma formata@value{cedilha}@~ao @'e realizada.  Cuidado deve ser tomado
com rela@value{cedilha}@~ao @`a ordem de subexpress@~oes em adi@value{cedilha}@~oes e produtos
(uma vez que a ordem das vari@'aveis na forma interna @'e muitas vezes diferente
daquela na forma mostrada) e no manuseio com menos un@'ario,
subtra@value{cedilha}@~ao, e divis@~ao (uma vez que esses operadores s@~ao removidos da
express@~ao). @code{part (x+y, 0)} ou @code{inpart (x+y, 0)} retorna @code{+}, embora com o objectivo de
referirse ao operador isso deva ser abra@value{cedilha}ado por aspas duplas.  Por exemplo
@code{... if inpart (%o9,0) = "+" then ...}.

Exemplos:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} isolate (@var{expr}, @var{x})
Retorna @var{expr} com subexpress@~oes que s@~ao adi@value{cedilha}@~oes e
que n@~ao possuem @var{x} substituido por r@'otulos de express@~ao interm@'edia
(esses sendo s@'{@dotless{i}}mbolos at@^omicos como @code{%t1}, @code{%t2}, ...).  Isso @'e muitas vezes @'util
para evitar expans@~oes desnecess@'arias de subexpress@~oes que n@~ao possuam
a vari@'avel de interesse.  Uma vez que os r@'otulos interm@'edios s@~ao associados @`as
subexpress@~oes eles podem todos ser substitu@'{@dotless{i}}dos de volta por avalia@value{cedilha}@~ao da
express@~ao em que ocorrerem.

@code{exptisolate} (valor padr@~ao: @code{false}) se @code{true} far@'a com que @code{isolate} examine expoentes de
@'atomos (como @code{%e}) que contenham @var{x}.

@code{isolate_wrt_times} se @code{true}, ent@~ao @code{isolate} ir@'a tamb@'em isolar com rela@value{cedilha}@~ao a 
produtos. Veja @code{isolate_wrt_times}.

Fa@value{cedilha}a @code{example (isolate)} para exemplos.

@end deffn

@c NEEDS WORK
@defvr {Vari@'avel de op@value{cedilha}@~ao} isolate_wrt_times
Valor por omiss@~ao: @code{false}

Quando @code{isolate_wrt_times} for @code{true}, @code{isolate}
ir@'a tamb@'em isolar com rela@value{cedilha}@~ao a produtos.  E.g. compare ambas as escolhas do
comutador em

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@end defvr

@c NEEDS EXAMPLES
@defvr {Vari@'avel de op@value{cedilha}@~ao} listconstvars
Valor por omiss@~ao: @code{false}

Quando @code{listconstvars} for @code{true}, isso far@'a com que @code{listofvars}
inclua @code{%e}, @code{%pi}, @code{%i}, e quaisquer vari@'aveis declaradas contantes na lista
seja retornado se aparecer na express@~ao que chamar @code{listofvars}.
O comportamento padr@~ao @'e omitir isso.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} listdummyvars
Valor por omiss@~ao: @code{true}

Quando @code{listdummyvars} for @code{false}, "vari@'aveis dummy" na
express@~ao n@~ao ser@~ao inclu@'{@dotless{i}}das na lista retornada por @code{listofvars}.
(O significado de "vari@'avel dummy" @'e o mesmo que em @code{freeof}.
"Vari@'aveis dummy" s@~ao conceitos matem@'aticos como o @'{@dotless{i}}ndice de um somat@'orio ou
produt@'orio, a vari@'avel limite, e a vari@'avel da integral definida.)
Exemplo:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} listofvars (@var{expr})
Retorna uma lista de vari@'aveis em @var{expr}.

@code{listconstvars} se @code{true} faz com que @code{listofvars} inclua @code{%e}, @code{%pi},
@code{%i}, e quaisquer vari@'aveis declaradas constantes na lista @'e retornada se
aparecer em @var{expr}.  O comportamento padr@~ao @'e omitir isso.

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} lfreeof (@var{lista}, @var{expr})
Para cada um dos membros @var{m} de lista, chama @code{freeof (@var{m}, @var{expr})}.
Retorna @code{false} se qualquer chamada a @code{freeof} for feita e @code{true} de outra forma.
@end deffn

@deffn {Fun@value{cedilha}@~ao} lopow (@var{expr}, @var{x})
Retorna o menor expoente de @var{x} que explicitamente aparecer em
@var{expr}.  Dessa forma

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} lpart (@var{r@'otulo}, @var{expr}, @var{n_1}, ..., @var{n_k})
@'e similar a @code{dpart} mas usa uma caixa rotulada. Uma caixa
rotulada @'e similar @`a que @'e produzida por @code{dpart} mas a
produzida por @code{lpart} tem o nome na linha do topo.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} multthru (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} multthru (@var{expr_1}, @var{expr_2})
Multiplica um factor (que pode ser uma adi@value{cedilha}@~ao) de @var{expr} pelos
outros factores de @var{expr}.  Isto @'e, @var{expr} @'e @code{@var{f_1} @var{f_2} ... @var{f_n}}
onde ao menos
um factor, digamos @var{f_i}, @'e uma soma de termos.  Cada termo naquela soma @'e
multiplicado por outros factores no produto.  (A saber todos os
factores excepto @var{f_i}).  @code{multthru} n@~ao expande somas exponenciais.
Essa fun@value{cedilha}@~ao @'e o caminho mais r@'apido para distribuir produtos (comutativos
ou n@~ao) sobre adi@value{cedilha}@~oes.  Uma vez que quocientes s@~ao representados como
produtos @code{multthru} podem ser usados para dividir adi@value{cedilha}@~oes por produtos tamb@'em.

@code{multthru (@var{expr_1}, @var{expr_2})} multiplica cada termo em @var{expr_2} (que pode ser uma
adi@value{cedilha}@~ao ou uma equ@value{cedilha}@~ao) por @var{expr_1}.  Se @var{expr_1} n@~ao for por si mesmo uma adi@value{cedilha}@~ao ent@~ao essa
forma @'e equivalente a @code{multthru (@var{expr_1}*@var{expr_2})}.

@example
(%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                      1        x         f(x)
(%o1)             - ----- + -------- - --------
                    x - y          2          3
                            (x - y)    (x - y)
(%i2) multthru ((x-y)^3, %);
                           2
(%o2)             - (x - y)  + x (x - y) - f(x)
(%i3) ratexpand (%);
                           2
(%o3)                   - y  + x y - f(x)
(%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                        10  2              2  2
                 (b + a)   s  + 2 a b s + a  b
(%o4)            ------------------------------
                                  2
                             a b s
(%i5) multthru (%);  /* note que isso n@~ao expande (b+a)^10 */
                                        10
                       2   a b   (b + a)
(%o5)                  - + --- + ---------
                       s    2       a b
                           s
(%i6) multthru (a.(b+c.(d+e)+f));
(%o6)            a . f + a . c . (e + d) + a . b
(%i7) expand (a.(b+c.(d+e)+f));
(%o7)         a . f + a . c . e + a . c . d + a . b
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} nounify (@var{f})
Retorna a forma substantiva do nome da fun@value{cedilha}@~ao @var{f}.  Isso @'e
necess@'ario se se quer referir ao nome de uma fun@value{cedilha}@~ao verbo como se esse nome
fosse um substantivo.  Note que algumas fun@value{cedilha}@~oes verbos ir@~ao retornar sua forma
substantiva sen@~ao puderem ser avaliadas para certos argumentos.  A forma substantiva @'e tamb@'em
a forma retornada se uma chamada de fun@value{cedilha}@~ao @'e precedida por um ap@'ostrofo.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} nterms (@var{expr})
Retorna o n@'umero de termos que @var{expr} pode ter se for
completamente expandida e nenhum cancelamento ou combina@value{cedilha}@~ao de termos
acontecer.
Note express@~oes como @code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})}, etc.
contam como apenas um termo independentemente de quantos termos @var{expr} tenha (se @var{expr} for uma
adi@value{cedilha}@~ao).

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} op (@var{expr})
Retorna o operador principal da express@~ao @var{expr}.
@code{op (@var{expr})} @'e equivalente a @code{part (@var{expr}, 0)}. 

@code{op} retorna uma sequ@^encia de caracteres se o operador principal for uma
operador interno ou definido pelo utilizador como
prefixado, bin@'ario ou n-@'ario infixo, posfixado, matchfix ou nofix.
De outra forma, se @var{expr} for uma express@~ao de fun@value{cedilha}@~ao subscrita,
@code{op} retorna uma fun@value{cedilha}@~ao subscrita;
nesse caso o valor de retorno n@~ao @'e um @'atomo.
De outro modo, @var{expr} @'e uma fun@value{cedilha}@~ao de array ou uma express@~ao de fun@value{cedilha}@~ao comum,
e @code{op} retorna um s@'imbolo.

@code{op} observa o valor do sinalizador global @code{inflag}.

@code{op} avalia seus argumentos.

Veja tamb@'em @code{args}.

Exemplos:

@c ===beg===
@c stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c op (F [x, y] (a, b, c));
@c op (G [u, v, w]);
@c ===end===

@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} operatorp (@var{expr}, @var{op})
@deffnx {Fun@value{cedilha}@~ao} operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])

@code{operatorp (@var{expr}, @var{op})} retorna @code{true}
se @var{op} for igual ao operador de @var{expr}.

@code{operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])} retorna @code{true}
se algum elementos de @var{op_1}, ..., @var{op_n} for igual ao operador de @var{expr}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} optimize (@var{expr})
Retorna uma express@~ao que produz o mesmo valor e
efeito que @var{expr} mas faz de forma mais eficientemente por evitar a
recomputa@value{cedilha}@~ao de subexpress@~oes comuns.  @code{optimize} tamb@'em tem o mesmo
efeito de "colapsar" seus argumentos de forma que todas as subexpress@~oes comuns
s@~ao compartilhadas.
Fa@value{cedilha}a @code{example (optimize)} para exemplos.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} optimprefix
Valor por omiss@~ao: @code{%}

@code{optimprefix} @'e o prefixo usado para s@'{@dotless{i}}mbolos gerados pelo
comando @code{optimize}.

@end defvr

@c NEEDS WORK
@c WHAT DOES ">" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} ordergreat (@var{v_1}, ..., @var{v_n})
Escolhe aliases para as vari@'aveis @var{v_1}, ..., @var{v_n}
tais que @var{v_1} > @var{v_2} > ...  > @var{v_n},
e @var{v_n} > qualquer outra vari@'avel n@~ao mencionada como um
argumento.

Veja tamb@'em @code{orderless}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} ordergreatp (@var{expr_1}, @var{expr_2})
Retorna @code{true} se @var{expr_2} precede @var{expr_1} na
ordena@value{cedilha}@~ao escolhida com a fun@value{cedilha}@~ao @code{ordergreat}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "<" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} orderless (@var{v_1}, ..., @var{v_n})
Escolhe aliases para as vari@'aveis @var{v_1}, ..., @var{v_n}
tais que @var{v_1} < @var{v_2} < ...  < @var{v_n},
and @var{v_n} < qualquer outra vari@'avel n@~ao mencionada como um
argumento.

@c EXPRESS THIS ORDER IN A MORE COMPREHENSIBLE FASHION
Dessa forma a escala de ordena@value{cedilha}@~ao completa @'e: constantes num@'ericas <
constantes declaradas < escalares declarados < primeiro argumento para @code{orderless} <
...  < @'ultimo argumento para @code{orderless} < vari@'aveis que come@value{cedilha}am com A < ...
< vari@'aveis que come@value{cedilha}am com Z < @'ultimo argumento para @code{ordergreat} <
 ... < primeiro argumento para @code{ordergreat} < @code{mainvar}s - vari@'aveis principais declaradas.

Veja tamb@'em @code{ordergreat} e @code{mainvar}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} orderlessp (@var{expr_1}, @var{expr_2})
Retorna @code{true} se @var{expr_1} precede @var{expr_2} na
ordena@value{cedilha}@~ao escolhida pelo comando @code{orderless}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} part (@var{expr}, @var{n_1}, ..., @var{n_k})
Retorna partes da forma exibida de @code{expr}. Essa fun@value{cedilha}@~ao
obt@'em a parte de @code{expr} como especificado pelos @'{@dotless{i}}ndices @var{n_1}, ..., @var{n_k}.  A primeira
parte @var{n_1} de @code{expr} @'e obtida, ent@~ao a parte @var{n_2} daquela  @'e obtida, etc.  O resultado @'e
parte @var{n_k} de ... parte @var{n_2} da parte @var{n_1} da @code{expr}.

@code{part} pode ser usada para obter um elemento de uma lista, uma linha de uma matriz, etc.

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
Se o @'ultimo argumento para uma fun@value{cedilha}@~ao @code{part} for uma lista de @'{@dotless{i}}ndices ent@~ao
muitas subexpress@~oes ser@~ao pin@value{cedilha}adas, cada uma correspondendo a um
@'{@dotless{i}}ndice da lista.  Dessa forma @code{part (x + y + z, [1, 3])} @'e @code{z+x}.

@code{piece} mant@'em a @'ultima express@~ao seleccionada quando usando as fun@value{cedilha}@~oes
@code{part}.  Isso @'e escolhido durante a execu@value{cedilha}@~ao da fun@value{cedilha}@~ao e dessa forma
pode referir-se @`a fun@value{cedilha}@~ao em si mesma como mostrado abaixo.

Se @code{partswitch} for escolhido para @code{true} ent@~ao @code{end} @'e retornado quando uma
parte seleccionada de uma express@~ao n@~ao existir, de outra forma uma mensagem de
erro @'e forncecida.

@c NEED "SEE ALSO" POINTING TO ALL OTHER PART FUNCTIONS

Exemplo: @code{part (z+2*y, 2, 1)} retorna 2.

@c MERGE IN example (part) OUTPUT HERE
@code{example (part)} mostra exemplos adicionais.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} partition (@var{expr}, @var{x})
Retorna uma lista de duas express@~oes.  Elas s@~ao (1)
os factores de @var{expr} (se essa express@~ao for um produto), os termos de @var{expr} (se isso for uma
adi@value{cedilha}@~ao), ou a lista (se isso for uma lsita) que n@~ao contiver @code{var} e, (2)
os factores, termos, ou lista que faz.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@end deffn

@c NEEDS EXAMPLE
@defvr {Vari@'avel de op@value{cedilha}@~ao} partswitch
Valor por omiss@~ao: @code{false}

Quando @code{partswitch} for @code{true}, @code{end} @'e retornado
quando uma parte seleccionada de uma express@~ao n@~ao existir, de outra forma uma
mensagem de erro @'e fornecida.

@end defvr

@deffn {Fun@value{cedilha}@~ao} pickapart (@var{expr}, @var{n})
Atribui r@'otulos de express@~ao interm@'edia a subexpress@~oes de
@var{expr} de comprimento @var{n}, um inteiro.
A subexpress@~oes maiores ou menores n@~ao s@~ao atribuidos r@'otulos.
@code{pickapart} retorna uma express@~ao em termos de express@~oes interm@'edias
equivalentes @`a express@~ao original @var{expr}.

Veja tamb@'em @code{part}, @code{dpart}, @code{lpart}, @code{inpart}, e @code{reveal}.

Exemplos:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@end deffn

@c NEEDS WORK
@defvr {Vari@'avel de sistema} piece
Mant@'em a ultima express@~ao seleccionada quando usando fun@value{cedilha}@~oes
@code{part}.
@c WHAT DOES THIS MEAN EXACTLY ??
Isso @'e escolhido durante a execu@value{cedilha}@~ao da fun@value{cedilha}@~ao e dessa forma
pode referir-se @`a fun@value{cedilha}@~ao em si mesma.

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@end defvr

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} polarform (@var{expr})
Retorna uma express@~ao @code{r %e^(%i theta)} equivalente a @var{expr},
tal que @code{r} e @code{theta} sejam puramente reais.

@end deffn

@c ISN'T THERE AN EQUIVALENT FUNCTION SOMEWHERE ??
@c NEEDS WORK (IF KEPT)
@deffn {Fun@value{cedilha}@~ao} powers (@var{expr}, @var{x})
Fornece os expoentes de @var{x} que ocorrem em express@~ao @var{expr}.

@code{load (powers)} chama essa fun@value{cedilha}@~ao.
@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Representa um produto dos velores de @code{expr} com
o @'{@dotless{i}}ndice @var{i} variando de @var{i_0} a @var{i_1}.
A forma substantiva @code{'product} @'e mostrada como um pi mai@'{@dotless{i}}sculo.

@code{product} avalia @var{expr} e os limites inferior e superior @var{i_0} e @var{i_1},
@code{product} coloca um ap@'ostrofo (n@~ao avalia) o @'{@dotless{i}}ndice @var{i}.

Se os limites superiores e inferiores diferirem por um inteiro,
@var{expr} @'e avaliada para cada valor do @'{@dotless{i}}ndice @var{i},
e o resultado  um produto expl@'{@dotless{i}}cito.

de outra forma, o intervalo do @'{@dotless{i}}ndice @'e indefinido.
Algumas regras s@~ao aplicads para simplificar o produto.
Quando a vari@'avel global @code{simpproduct} for @code{true}, regras adicionais s@~ao aplicadas.
Em alguns casos, simplifica@value{cedilha}@~ao um resultado que n@~ao @'e um produto;
de outra forma, o resultado @'e uma forma substantiva @code{'product}.

Veja tamb@'em @code{nouns} e @code{evflag}.

Exemplos:

@c ===beg===
@c product (x + i*(i+1)/2, i, 1, 4);
@c product (i^2, i, 1, 7);
@c product (a[i], i, 1, 7);
@c product (a(i), i, 1, 7);
@c product (a(i), i, 1, n);
@c product (k, k, 1, n);
@c product (k, k, 1, n), simpproduct;
@c product (integrate (x^k, x, 0, 1), k, 1, n);
@c product (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example

@end deffn

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} realpart (@var{expr})
Retorna a parte real de @var{expr}. @code{realpart} e @code{imagpart} ir@~ao
trabalhar sobre express@~oes envolvendo fun@value{cedilha}@~oes trigonom@'etricas e hiperb@'olicas,
bem como ra@'{@dotless{i}}zes quadradas, logaritmos, e exponencia@value{cedilha}@~ao.

@end deffn

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} rectform (@var{expr})
Retorna uma express@~ao @code{a + b %i} equivalente a @var{expr},
tal que @var{a} e @var{b} sejam puramente reais.

@end deffn

@deffn {Fun@value{cedilha}@~ao} rembox (@var{expr}, unlabelled)
@deffnx {Fun@value{cedilha}@~ao} rembox (@var{expr}, @var{r@'otulo})
@deffnx {Fun@value{cedilha}@~ao} rembox (@var{expr})
Remove caixas de @var{expr}.

@code{rembox (@var{expr}, unlabelled)} remove todas as caixas sem r@'otulos de @var{expr}.

@code{rembox (@var{expr}, @var{r@'otulo})} remove somente caixas contendo @var{r@'otulo}.

@code{rembox (@var{expr})} remove todas as caixas, rotuladas e n@~a rotuladas.

Caixas s@~ao desenhadas pelas fun@value{cedilha}@~oes @code{box}, @code{dpart}, e @code{lpart}.

Exemplos:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Representa um somat@'orio dos valores de @var{expr} com
o @'{@dotless{i}}ndice @var{i} variando de @var{i_0} a @var{i_1}.
A forma substantiva @code{'sum} @'e mostrada com uma letra sigma mai@'uscula.
@code{sum} avalia seu somando @var{expr} e limites inferior e superior @var{i_0} e @var{i_1},
@code{sum} coloca ap@'ostrofo (n@~ao avalia) o @'{@dotless{i}}ndice @var{i}.

Se os limites superiores e inferiores diferirem de um n@'umero inteiro,
o somatoriando @var{expr} @'e avaliado para cada valor do @'{@dotless{i}}ndice do somat@'orio @var{i},
e o resultado @'e uma adi@value{cedilha}@~ao expl@'{@dotless{i}}cita.

De outra forma, o intervalo dos @'{@dotless{i}}ndices @'e indefinido.
Algumas regras s@~ao aplicadas para simplificar o somat@'orio.
Quando a vari@'avel global @code{simpsum} for @code{true}, regras adicionais s@~ao aplicadas.
Em alguns casos, simplifica@value{cedilha}@~oes retornam um resultado que n@~ao @'e um somat@'orio;
de outra forma, o resultado @'e uma forma substantiva @code{'sum}.

Quando o @code{evflag} (sinalizador de avalia@value{cedilha}@~ao) @code{cauchysum} for @code{true},
um produto de somat@'orios @'e mostrado como um produto de Cauchy,
no qual o @'{@dotless{i}}ndice do somat@'orio mais interno @'e uma fun@value{cedilha}@~ao de
@'{@dotless{i}}ndice de um n@'{@dotless{i}}vel acima, em lugar de variar independentemente.

A vari@'avel global @code{genindex} @'e o prefixo alfab@'etico usado para gerar o pr@'oximo @'{@dotless{i}}ndice do somat@'orio,
quando um @'{@dotless{i}}ndice automaticamente gerado for necess@'ario.

@code{gensumnum} @'e o sufixo num@'erico usando para gerar o pr@'oximo @'{@dotless{i}}ndice do somat@'orio,
quando um @'{@dotless{i}}ndice gerado automaticamente for necess@'ario.
Quando @code{gensumnum} for @code{false}, um @'{@dotless{i}}ndice gerado automaticamente @'e somente
@code{genindex} sem sufixo num@'erico.

Veja tamb@'em @code{sumcontract}, @code{intosum},
@code{bashindices}, @code{niceindices},
@code{nouns}, @code{evflag}, e @code{zeilberger}.

Exemplos:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c sum (2^i + i^2, i, 0, n);
@c sum (2^i + i^2, i, 0, n), simpsum;
@c sum (1/3^i, i, 1, inf);
@c sum (1/3^i, i, 1, inf), simpsum;
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
@c sum (integrate (x^k, x, 0, 1), k, 1, n);
@c sum (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
Incorrect syntax: Too many )'s
else b^k, k, 1, 10))
                  ^
(%i12) linenum:11;
(%o11)                         11
(%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o12)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} lsum (@var{expr}, @var{x}, @var{L})
Representas a adi@value{cedilha}@~ao de @var{expr} a cada elemento @var{x} em @var{L}.

Uma forma substantiva @code{'lsum} @'e retornada
se o argumento @var{L} n@~ao avaliar para uma lista.

Exemplos:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} verbify (@var{f})
Retorna a forma verbal da fun@value{cedilha}@~ao chamada @var{f}.

Veja tamb@'em @code{verb}, @code{noun}, e @code{nounify}.

Exemplos:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@end deffn
