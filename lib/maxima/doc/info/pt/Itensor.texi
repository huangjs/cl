@c /Itensor.texi/1.40/Sat Nov  4 16:15:55 2006//
@c RECOMMEND REVISE TEXT THROUGHOUT TO LOSE NOTION OF TIME RELATIVE TO PRESENT
@c LOOK FOR "NOW", "OLD", "NEW", "RECENT", "EARLIER", DATES

@c RERUN EXAMPLES WITH ADDT'L WHITESPACE IN INPUT TO AID LEGIBILITY

@menu
* Introdu@value{cedilha}@~ao a itensor::
* Defini@value{cedilha}@~oes para itensor::
@end menu

@node Introdu@value{cedilha}@~ao a itensor, Defini@value{cedilha}@~oes para itensor, itensor, itensor
@section Introdu@value{cedilha}@~ao a itensor

Maxima implementa a manipula@value{cedilha}@~ao de tensores simb@'olicos d dois tipos distintos:
manipula@value{cedilha}@~ao de componentes de tensores (pacote @code{ctensor}) e manipula@value{cedilha}@~ao de tensores indiciais (pacote @code{itensor}).

Note bem: Por favor veja a nota sobre 'nova nota@value{cedilha}@~ao de tensor' abaixo.

Manipula@value{cedilha}@~ao de componentes de tensores significa que objectos do tipo
tensor geom@'etrico s@~ao representados como arrays ou matrizes. Opera@value{cedilha}@~oes com tensores tais com
contra@value{cedilha}@~ao ou diferencia@value{cedilha}@~ao covariante s@~ao realizadas
sobre @'{@dotless{i}}ndices (que ocorrem exactamente duas vezes) repetidos com declara@value{cedilha}@~oes @code{do}.
Isto @'e, se executa explicitamente opera@value{cedilha}@~oes sobre as componentes apropriadas do
tensor armazenadas em um array ou uma matriz.

Manipula@value{cedilha}@~ao tensorial de @'{@dotless{i}}ndice @'e implementada atrav@'es da representa@value{cedilha}@~ao
de tensores como fun@value{cedilha}@~oes e suas covariantes, contravariantes e @'{@dotless{i}}ndices de
deriva@value{cedilha}@~ao. Opera@value{cedilha}@~oes com tensores como contra@value{cedilha}@~ao ou diferencia@value{cedilha}@~ao
covariante s@~ao executadas atrav@'es de manipula@value{cedilha}@~ao dos @'{@dotless{i}}ndices em si mesmos
em lugar das componentes para as quais eles correspondem.

Esses dois m@'etodos aproximam-se do tratamento de processos diferenciais, alg@'ebricos e
anal@'{@dotless{i}}ticos no contexto da geometria de Riemannian possuem v@'arias
vantagens e desvantagens as quais se revelam por si mesmas somente apesar da
natureza particular e dificuldade dos problemas de utilizador.  Todavia, se
pode ter em mente as seguintes caracter@'{@dotless{i}}sticas das duas
implementa@value{cedilha}@~oes:

As representa@value{cedilha}@~oes de tensores e de opera@value{cedilha}@~oes com tensores explicitamente em
termos de seus componntes tornam o pacote @code{ctensor} f@'acil de usar. Especifica@value{cedilha}@~ao da
m@'etrica e o c@'alculo de tensores induzidos e invariantes
@'e directo. Embora todas a capacidade de simplifica@value{cedilha}@~ao poderosa do
Maxima est@'a em manusear, uma m@'etrica complexa com intrincada depend@^encia funcional
e de coordenadas pode facilmente conduzir a express@~oes cujo tamanho @'e
excessivo e cuja estrutura est@'a escondida. Adicionalmente, muitos c@'alculos
envolvem express@~oes interm@'edias cujo crescimento fazem com que os programas
terminem antes de serem completados. Atrav@'es da experi@^encia, um utilizador pode evitar
muitas dessas dificuldade.

O motivo de caminhos especiais atrav@'es dos quais tensores e opera@value{cedilha}@~oes de tensores
s@~ao representados em termos de opera@value{cedilha}@~oes simb@'olicas sobre seus @'{@dotless{i}}ndices,
express@~oes cujas representa@value{cedilha}@~ao de componentes podem ser
n@~ao gerenciaveis da forma comum podem algumas vezes serem grandemente simplificadas atrav@'es do uso das rotinas
especiais para objectos sim@'etricos em @code{itensor}. Nesse caminho a estrutura
de uma express@~ao grande pode ser mais transparente. Por outro lado, o motivo
da representa@value{cedilha}@~ao indicial especial em @code{itensor}, faz com que em alguns casos o
utilizador possa encontrar dificuldade com a especifica@value{cedilha}@~ao da m@'etrica, defini@value{cedilha}@~ao
de fun@value{cedilha}@~ao, e a avalia@value{cedilha}@~ao de objectos "indexados" diferenciados.

@subsection Nova nota@value{cedilha}@~ao d tensores

At@'e agora, o pacote @code{itensor} no Maxima tinha usado uma nota@value{cedilha}@~ao que algumas vezes
conduzia a ordena@value{cedilha}@~ao incorrecta de @'{@dotless{i}}ndices. Considere o seguinte, por exemplo:

@example
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
@end example

O resultado est@'a incorrecto a menos que ocorra ser @code{a} um tensor sim@'etrico.
A raz@~ao para isso @'e que embora @code{itensor} mantenha correctamente
a ordem dentro do conjunto de @'{@dotless{i}}ndices covariantes e contravariantes, assim que um
@'{@dotless{i}}ndice @'e incrementado ou decrementado, sua posi@value{cedilha}@~ao relativa para o outro conjunto de
@'{@dotless{i}}ndices @'e perdida.

Para evitar esse problema, uma nova nota@value{cedilha}@~ao tem sido desenvolvida que mant@'em total
compatibilidade com a nota@value{cedilha}@~ao existente e pode ser usada intercambiavelmente. Nessa
nota@value{cedilha}@~ao, @'{@dotless{i}}ndices contravariantes s@~ao inseridos na posi@value{cedilha}@~ao
apropriada na lista de @'{@dotless{i}}ndices covariantes, mas com um sinal de menos colocado antes.
Fun@value{cedilha}@~oes como @code{contract} e @code{ishow} est@~ao agora consciente dessa
nova nota@value{cedilha}@~ao de @'{@dotless{i}}ndice e podem processar tensores apropriadamente.

Nessa nova nota@value{cedilha}@~ao, o exemplo anterior retorna um resultado correcto:

@example
(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
@end example

Presentemente, o @'unico c@'odigo que faz uso dessa nota@value{cedilha}@~ao @'e a fun@value{cedilha}@~ao
@code{lc2kdt}. Atrav@'es dessa nota@value{cedilha}@~ao, a fun@value{cedilha}@~ao @code{lc2kdt} encontra com @^exito resultados consistentes como
a aplica@value{cedilha}@~ao do tensor m@'etrico para resolver os s@'{@dotless{i}}mbolos de Levi-Civita sem reordenar
para @'{@dotless{i}}ndices num@'ericos.

Uma vez que esse c@'odigo @'e um tipo novo, provavelmente cont@'em erros. Enquanto esse tipo novo n@~ao tiver sido
testado para garantir que ele n@~ao interrompe nada usando a "antiga" nota@value{cedilha}@~ao de
tensor, existe uma consider@'avel chance que "novos" tensores ir@~ao falhar em
interoperar com certas fun@value{cedilha}@~oes ou recursos. Essas falhas ser@~ao corrigidas
@`a medida que forem encontradas... at@'e ent@~ao, seja cuidadoso!


@subsection Manipula@value{cedilha}@~ao de tensores indiciais

o pacote de manipula@value{cedilha}@~ao de tensores indiciais pode ser chamado atrav@'es de
@code{load(itensor)}. Demonsta@value{cedilha}@~oes est@~ao tamb@'em dispon@'{@dotless{i}}veis: tente @code{demo(tensor)}.
Em @code{itensor} um tensor @'e representado como um "objecto indexado" .  Um "objecto indexado" @'e uma
fun@value{cedilha}@~ao de 3 grupos de @'{@dotless{i}}ndices os quais representam o covariante,
o contravariante e o @'{@dotless{i}}ndice de deriva@value{cedilha}@~ao.  Os @'{@dotless{i}}ndices covariantes s@~ao
especificados atrav@'es de uma lista com o primeiro argumento para o objecto indexado, e
os @'{@dotless{i}}ndices contravariantes atrav@'es de uma lista como segundo argumento. Se o
objecto indexado carece de algum desses grupos de @'{@dotless{i}}ndices ent@~ao a lista
vazia @code{[]} @'e fornecida como o argumento correspondente.  Dessa forma, @code{g([a,b],[c])}
representa um objecto indexado chamado @code{g} o qual tem dois @'{@dotless{i}}ndices covariantes
@code{(a,b)}, um @'{@dotless{i}}ndice contravariante (@code{c}) e n@~ao possui @'{@dotless{i}}ndices de deriva@value{cedilha}@~ao.

Os @'{@dotless{i}}ndices de deriva@value{cedilha}@~ao, se estiverem presente, s@~ao anexados ao final como
argumentos adicionais para a fun@value{cedilha}@~ao num@'erica representando o tensor.
Eles podem ser explicitamente especificado pelo utilizador ou serem criados no
processo de diferencia@value{cedilha}@~ao com rela@value{cedilha}@~ao a alguma vari@'avel coordenada.
Uma vez que diferencia@value{cedilha}@~ao ordin@'aria @'e comutativa, os @'{@dotless{i}}ndices de deriva@value{cedilha}@~ao
s@~ao ordenados alfanumericamente, a menos que @code{iframe_flag} seja escolhida para @code{true},
indicando que um referencial m@'etrico est@'a a ser usado. Essa ordena@value{cedilha}@~ao can@'onica torna
poss@'{@dotless{i}}vel para Maxima reconhecer que, por exemplo, @code{t([a],[b],i,j)} @'e
o mesmo que @code{t([a],[b],j,i)}.  Diferencia@value{cedilha}@~ao de um objecto indexado com
rela@value{cedilha}@~ao a alguma coordenada cujos @'{@dotless{i}}ndices n@~ao aparecem como um argumento
para o objecto indexado podem normalmente retornar zero. Isso @'e porque
Maxima pode n@~ao saber que o tensor representado atrav@'es do objecto
indexado poss@'{@dotless{i}}velmente depende implicitamente da respectiva coordenada.  Pela
modifica@value{cedilha}@~ao da fun@value{cedilha}@~ao existente no Maxima, @code{diff},  em @code{itensor}, Maxima sabe
assumir que todos os objectos indexados dependem de qualquer vari@'avel de
diferencia@value{cedilha}@~ao a menos que seja declarado de outra forma.  Isso torna poss@'{@dotless{i}}vel para
a conven@value{cedilha}@`ao de somat@'orio ser extendida para @'{@dotless{i}}ndices derivativos. Pode
ser verificado que @code{itensor} n@~ao possui a compatibilidade de
incrementar @'{@dotless{i}}ndices derivativos, e ent@~ao eles s@~ao sempre tratados como
covariantes.

As seguintes fun@value{cedilha}@~oes est@~ao dispon@'{@dotless{i}}veis no pacote tensor para
manipula@value{cedilha}@~ao de objectos.  Actualmente, com rela@value{cedilha}@~ao @`as
rotinas de simplifica@value{cedilha}@~ao, @'e assumido que objectos indexados n@~ao
possuem por padr@~ao propriedades sim@'etricas. Isso pode ser modificado atrav@'es
da escolha da vari@'avel @code{allsym[false]} para @code{true}, o que ir@'a
resultar no tratamento de todos os objectos indexados completamente sim@'etricos em suas
listas de @'{@dotless{i}}ndices covariantes e sim@'etricos em suas listas de
@'{@dotless{i}}ndices contravariantes.

O pacote @code{itensor} geralmente trata tensores como objectos opacos. Equa@value{cedilha}@~oes
tensoriais s@~ao manipuladas baseadas em regras alg@'ebricas, especificamente simetria
e regras de contra@value{cedilha}@~ao. Adicionalmente, o pacote @code{itensor} n@~ao entende
diferencia@value{cedilha}@~ao covariante, curvatura, e tors@~ao. C@'alculos podem ser
executados relativamente a um m@'etrica de referenciais de movimento, dependendo da escolha para
a vari@'avel @code{iframe_flag}.

Uma sess@~ao demonstrativa abaixo mostra como chamar o pacote @code{itensor},
especificando o nome da m@'etrica, e executando alguns c@'alculos simples.

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
               %4 %5
(%t12) v    - g      v   (e p       + e   p     - e p       - e    p
        i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                + e p       + e   p    )/2
                                                     i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %8                    %6 %8
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %8 i             %6    i j %8      i,j

                                                    %6 %8
                                               - ifg      v   ifb      )/2
                                                           %6    %8 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
@end example



@c end concepts itensor

@node Defini@value{cedilha}@~oes para itensor,  , Introdu@value{cedilha}@~ao a itensor, itensor

@section Defini@value{cedilha}@~oes para itensor
@subsection Gerenciando objectos indexados

@deffn {Fun@value{cedilha}@~ao} entertensor (@var{nome})

@'E uma fun@value{cedilha}@~ao que, atrav@'es da linha de comando, permite criar um objecto
indexado chamado @var{nome} com qualquer n@'umero de @'{@dotless{i}}ndices de tensores e
derivativos. Ou um @'{@dotless{i}}ndice simples ou uma lista de @'{@dotless{i}}ndices (@`as quais podem ser
nulas) s@~ao entradas aceit@'aveis (veja o exemplo sob @code{covdiff}).

@end deffn

@deffn {Fun@value{cedilha}@~ao} changename (@var{antigo}, @var{novo}, @var{expr})

Ir@'a mudar o nome de todos os objectos indexados chamados @var{antigo} para @var{novo}
em @var{expr}. @var{antigo} pode ser ou um s@'{@dotless{i}}mbolo ou uma lista da forma
@code{[@var{nome}, @var{m}, @var{n}]} nesse caso somente esses objectos indexados chamados
@var{nome} com @'{@dotless{i}}ndice covariante @var{m} e @'{@dotless{i}}ndice contravariante @var{n} ser@~ao
renomeados para @var{novo}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} listoftens

Lista todos os tensores em uma express@~ao tensorial, incluindo seus @'{@dotless{i}}ndices. E.g.,

@example

(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} ishow (@var{expr})

Mostra @var{expr} com os objectos indexados tendo seus
@'{@dotless{i}}ndices covariantes como subscritos e @'{@dotless{i}}ndices contravariantes como
sobrescritos.  Os @'{@dotless{i}}ndices derivativos s@~ao mostrados como subscritos,
separados dos @'{@dotless{i}}ndices covariantes por uma v@'{@dotless{i}}rgula (veja os exemplos
atrav@'es desse documento).

@end deffn

@deffn {Fun@value{cedilha}@~ao} indices (@var{expr})

Retorna uma lista de dois elementos.  O primeiro @'e uma lista de @'{@dotless{i}}ndices
livres em @var{expr} (aqueles que ocorrem somente uma vez). O segundo @'e uma
lista de indices que ocorrem exactamente duas vezes em @var{expr} (dummy)
como demonstra o seguinte exemplo.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

@end example

Um produto de tensores contendo o mesmo @'{@dotless{i}}ndice mais que duas vezes @'e sintaticamente
ilegal. @code{indices} tenta lidar com essas express@~oes de uma
forma razo@'avel; todavia, quando @code{indices} @'e chamada para operar sobre tal uma
express@~ao ilegal, seu comportamento pode ser considerado indefinido.


@end deffn

@deffn {Fun@value{cedilha}@~ao} rename (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} rename (@var{expr}, @var{contador})

Retorna uma express@~ao equivalente para @var{expr} mas com @'{@dotless{i}}ndices que ocorrem exactamente duas vezes
em cada termo alterado do conjunto @code{[%1, %2,...]}, se o segundo argumento
opcional for omitido. De outra forma, os @'{@dotless{i}}ndices que ocorrem exactamente duas vezes s@~ao indexados
come@value{cedilha}ando no valor de @var{contador}.  Cada @'{@dotless{i}}ndice que ocorre exactamente duas vezes em um produto
ser@'a diferente. Para uma adi@value{cedilha}@~ao, @code{rename} ir@'a operar sobre cada termo na
a adi@value{cedilha}@~ao zerando o contador com cada termo. Nesse caminho @code{rename} pode
servir como um simplificador tensorial. Adicionalmente, os @'{@dotless{i}}ndices ser@~ao
ordenados alfanumericamente (se @code{allsym} for @code{true}) com rela@value{cedilha}@~ao a
@'{@dotless{i}}ndices covariantes ou contravariantes dependendo do valor de @code{flipflag}.
Se @code{flipflag} for @code{false} ent@~ao os @'{@dotless{i}}ndices ser@~ao renomeados conforme
a ordem dos @'{@dotless{i}}ndices contravariantes. Se @code{flipflag} for @code{true}
a renomea@value{cedilha}@~ao ocorrer@'a conforme a ordem dos @'{@dotless{i}}ndices
covariantes. Isso muitas vezes ajuda que o efeito combinado dos dois restantes sejam
reduzidos a uma express@~ao de valor um ou mais que um por si mesma.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

              %1 %2  %3 %4      %6         %5         %7        u
           - g      g      ichr2      ichr2      ichr2     ichr2
                                %1 %3      %2 %6      %4 r      %5 %7
@end example

@end deffn

@defvr {Vari@'avel de Op@value{cedilha}@~ao} flipflag

Valor por omiss@~ao: @code{false}. Se @code{false} ent@~ao os @'{@dotless{i}}ndices ir@~ao ser
renomeados conforme a ordem dos @'{@dotless{i}}ndices contravariantes,
de outra forma ser@~ao ordenados conforme a ordem dos @'{@dotless{i}}ndices covariantes.

Se @code{flipflag} for @code{false} ent@~ao @code{rename} forma uma lista
de @'{@dotless{i}}ndices contravariantes na ordem em que forem encontrados da esquerda para a direita
(se @code{true} ent@~ao de @'{@dotless{i}}ndices contravariantes). O primeiro @'{@dotless{i}}ndice
que ocorre exactamente duas vezes na lista @'e renomeado para @code{%1}, o seguinte para @code{%2}, etc.
Ent@~ao a ordena@value{cedilha}@~ao ocorre ap@'os a ocorr@^encia do @code{rename} (veja o exemplo
sob @code{rename}).

@end defvr

@deffn {Fun@value{cedilha}@~ao} defcon (@var{tensor_1})
@deffnx {Fun@value{cedilha}@~ao} defcon (@var{tensor_1}, @var{tensor_2}, @var{tensor_3})
Dado @var{tensor_1} a propriedade que a
contra@value{cedilha}@~ao de um produto do @var{tensor_1} e do @var{tensor_2} resulta em @var{tensor_3}
com os @'{@dotless{i}}ndices apropriados.  Se somente um argumento, @var{tensor_1}, for
dado, ent@~ao a contra@value{cedilha}@~ao do produto de @var{tensor_1} com qualquer objecto
indexado tendo os @'{@dotless{i}}ndices apropriados (digamos @code{my_tensor}) ir@'a retornar como resultado um
objecto indexado com aquele nome, i.e. @code{my_tensor}, e com uma nova escolha de
@'{@dotless{i}}ndices refletindo as contra@value{cedilha}@~oes executadas.
Por exemplo, se @code{imetric:g}, ent@~ao @code{defcon(g)} ir@'a implementar o
incremento e decremento de @'{@dotless{i}}ndices atrav@'es da contra@value{cedilha}@~ao com o tensor
m@'etrico.
Mais de uma @code{defcon} pode ser dada para o mesmo objecto indexado; o
@'ultimo  fornecido que for aplicado a uma contra@value{cedilha}@~ao particular ser@'a
usado.
@code{contractions} @'e uma lista de objectos indexados que tenham fornecido
propriedades de contra@value{cedilha}@~oes com @code{defcon}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} remcon (@var{tensor_1}, ..., @var{tensor_n})
@deffnx {Fun@value{cedilha}@~ao} remcon (all)
Remove todas as propriedades de contra@value{cedilha}@~ao
de @var{tensor_1}, ..., @var{tensor_n}). @code{remcon(all)} remove todas as propriedades de
contra@value{cedilha}@~ao de todos os objectos indexados.

@end deffn

@deffn {Fun@value{cedilha}@~ao} contract (@var{expr})

Realiza contra@value{cedilha}@~oes tensoriais em @var{expr} a qual pode ser qualquer
combina@value{cedilha}@~ao de adi@value{cedilha}@~oes e produtos. Essa fun@value{cedilha}@~ao usa a informa@value{cedilha}@~ao
dada para a fun@value{cedilha}@~ao @code{defcon}. Para melhores resultados, @code{expr}
pode ser completamente expandida. @code{ratexpand} @'e o meio mais r@'apido para expandir
produtos e expoentes de adi@value{cedilha}@~oes se n@~ao existirem vari@'aveis nos denominadores
dos termos. O comutador @code{gcd} pode ser @code{false} se cancelamentos de
m@'aximo divisor comum forem desnecess@'arios.

@end deffn

@deffn {Fun@value{cedilha}@~ao} indexed_tensor (@var{tensor})

Deve ser executada antes de atribuir componentes para um @var{tensor} para o qual
um valor interno j@'a existe como com @code{ichr1}, @code{ichr2},
@code{icurvature}. Veja o exemplo sob @code{icurvature}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} components (@var{tensor}, @var{expr})

Permite que se atribua um valor indicial a uma express@~ao
@var{expr} dando os valores das componentes do @var{tensor}. Esses
s@~ao automaticamente substitu@'{@dotless{i}}dos para o tensor mesmo que isso ocorra com
todos os seus @'{@dotless{i}}ndices. O tensor deve ser da forma @code{t([...],[...])}
onde qualquer lista pode ser vazia. @var{expr} pode ser qualquer express@~ao indexada
envolvendo outros objectos com os mesmos @'{@dotless{i}}ndices livres que @var{tensor}. Quando
usada para atribuir valores a um tensor m@'etrico no qual as componentes
possuem @'{@dotless{i}}ndices que ocorrem exactamente duas vezes se deve ser cuidadoso para definir esses @'{@dotless{i}}ndices de forma a
evitar a gera@value{cedilha}@~ao de @'{@dotless{i}}ndices que ocorrem exactamente duas vezes e que s@~ao m@'ultiplos. a remo@value{cedilha}@~ao dessas
atribui@value{cedilha}@~oes @'e dada para a fun@value{cedilha}@~ao @code{remcomps}.

@'E importante ter em mente que @code{components} cuida somente da
val@^encia de um tensor, e que ignora completamente qualquer ordena@value{cedilha}@~ao particular de @'{@dotless{i}}ndices. Dessa forma
atribuindo componentes a, digamos, @code{x([i,-j],[])}, @code{x([-j,i],[])}, ou
@code{x([i],[j])} todas essas atribui@value{cedilha}@~oes produzem o mesmo resultado, a saber componentes sendo
atribuidas a um tensor chamado @code{x} com val@^encia @code{(1,1)}.

Componentes podem ser atribuidas a uma express@~ao indexada por quatro caminhos, dois
dos quais envolvem o uso do comando @code{components}:

1) Como uma express@~ao indexada. Por exemplo:

@example

(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

@end example

2) Como uma matriz:

@example

(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([3,3],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

@end example

3) Como uma fun@value{cedilha}@~ao. Pode usar uma fun@value{cedilha}@~ao Maxima para especificar as
componentes de um tensor baseado nesses @'{@dotless{i}}ndices. Por exemplo, os seguintes
c@'odigos atribuem @code{kdelta} a @code{h} se @code{h} tiver o mesmo n@'umero de
@'{@dotless{i}}ndices covariantes e @'{@dotless{i}}ndices contravariantes e nenhum @'{@dotless{i}}ndice derivativo, e
atribui @code{kdelta} a @code{g} caso as condi@value{cedilha}@~oes anteriores n@~ao sejam atendidas:

@example

(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

@end example

4) Usando a compatibilidade dos modelos de coincid@^encia do Maxima, especificamente os
comandos @code{defrule} e @code{applyb1}:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} remcomps (@var{tensor})

Desassocia todos os valores de @var{tensor} que foram atribu@'{@dotless{i}}dos com a
fun@value{cedilha}@~ao @code{components}.

@end deffn

@c NEED LIST OF ARGUMENTS HERE
@deffn {Fun@value{cedilha}@~ao} showcomps (@var{tensor})

Mostra atribui@value{cedilha}@~oes de componentes de um tensor, feitas usando o comando
@code{components}. Essa fun@value{cedilha}@~ao pode ser particularmente @'util quando uma matriz @'e atribu@'{@dotless{i}}da
a um tensor indicial usando @code{components}, como demonstrado atrav@'es do
seguinte exemplo:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

@end example

O comando @code{showcomps} pode tamb@'em mostrar componentes de um tensor de
categoria maior que 2.

@end deffn

@deffn {Fun@value{cedilha}@~ao} idummy ()

Incrementos @code{icounter} e retorno como seu valor um @'{@dotless{i}}ndice da forma
@code{%n} onde n @'e um inteiro positivo.  Isso garante que @'{@dotless{i}}ndices que ocorrem exactamente duas vezes
e que s@~ao necess@'arios na forma@value{cedilha}@~ao de express@~oes n@~ao ir@~ao conflitar com @'{@dotless{i}}ndices
que j@'a estiverem sendo usados (veja o exemplo sob @code{indices}).

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} idummyx
Valor por omiss@~ao: @code{%}

@'E o prefixo para @'{@dotless{i}}ndices que ocorrem exactamente duas vezes (veja o exemplo sob @'{@dotless{i}}ndices @code{indices}).

@end defvr

@defvr {Vari@'avel de Op@value{cedilha}@~ao} icounter
Valor por omiss@~ao: @code{1}

Determina o sufixo num@'erico a ser usado na
gera@value{cedilha}@~ao do pr@'oximo @'{@dotless{i}}ndice que ocorre exactamente duas vezes no pacote tensor.  O prefixo @'e
determinado atrav@'es da op@value{cedilha}@~ao @code{idummy} (padr@~ao: @code{%}).
@end defvr

@deffn {Fun@value{cedilha}@~ao} kdelta (@var{L1}, @var{L2})
@'e a fun@value{cedilha}@~ao delta generalizada de Kronecker definida no
pacote @code{itensor} com @var{L1} a lista de @'{@dotless{i}}ndices covariantes e @var{L2}
a lista de @'{@dotless{i}}ndices contravariantes.  @code{kdelta([i],[j])} retorna o delta de
Kronecker comum.  O comando @code{ev(@var{expr},kdelta)} faz com que a avalia@value{cedilha}@~ao de
uma express@~ao contendo @code{kdelta([],[])} se d@^e para a dimens@~ao de
multiplica@value{cedilha}@~ao.

No que conduzir a um abuso dessa nota@value{cedilha}@~ao, @code{itensor} tamb@'em permite
@code{kdelta} ter 2 covariantes e nenhum contravariante, ou 2 contravariantes
e nenhum @'{@dotless{i}}ndice covariante, com efeito fornecendo uma compatibilidade para "matriz unit@'aria" covariante ou
contravariante. Isso @'e estritamente considerado um recurso de programa@value{cedilha}@~ao e n@~ao significa
implicar que @code{kdelta([i,j],[])} seja um objecto tensorial v@'alido.

@end deffn

@deffn {Fun@value{cedilha}@~ao} kdels (@var{L1}, @var{L2})

Delta de Kronecker simetrizado, usado em alguns c@'alculos. Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} levi_civita (@var{L})
@'e o tensor de permuta@value{cedilha}@~ao (ou de Levi-Civita) que retorna 1 se
a lista @var{L} consistir de uma permuta@value{cedilha}@~ao par de inteiros, -1 se isso
consistir de uma permuta@value{cedilha}@~ao @'{@dotless{i}}mpar, e 0 se alguns @'{@dotless{i}}ndices em @var{L} forem
repetidos.

@end deffn

@deffn {Fun@value{cedilha}@~ao} lc2kdt (@var{expr})
Simplifica express@~oes contendo os s@'{@dotless{i}}mbolos de Levi-Civita, convertendo esses
para express@~oes delta de Kronecker quando poss@'{@dotless{i}}vel. A principal diferen@value{cedilha}a entre
essa fun@value{cedilha}@~ao e simplesmente avaliar os simbolos de Levi-Civita @'e que a avalia@value{cedilha}@~ao
directa muitas vezes resulta em express@~oes Kronecker contendo @'{@dotless{i}}ndices
num@'ericos. Isso @'e muitas vezes indesej@'avel como na preven@value{cedilha}@~ao de simplifica@value{cedilha}@~ao adicional.
A fun@value{cedilha}@~ao @code{lc2kdt} evita esse problema, retornando express@~oes que
s@~ao mais facilmente simplificadas com @code{rename} ou @code{contract}.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

@end example

A fun@value{cedilha}@~ao @code{lc2kdt} algumas vezes faz uso de tensores m@'etricos.
Se o tensor m@'etrico n@~ao tiver sido definido previamente com @code{imetric},
isso resulta em um erro.

@example

(%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j       k
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                    %3             %4               %3             %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i      l i
(%t11)                           a    - a g

@end example


@end deffn

@c HMM, WHICH CATEGORY DOES THIS FALL INTO -- FUNCTION, VARIABLE, OTHER ??
@deffn {Fun@value{cedilha}@~ao} lc_l

Regra de simplifica@value{cedilha}@~ao usada para express@~oes contendo s@'{@dotless{i}}mbolos n@~ao avaliados de
Levi-Civita (@code{levi_civita}). Juntamente com @code{lc_u}, pode ser usada para simplificar
muitas express@~oes mais eficientemente que a avalia@value{cedilha}@~ao de @code{levi_civita}.
Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
(%t4)                                  0
(%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
(%t5)                                  0

@end example

@end deffn

@c HMM, WHICH CATEGORY DOES THIS FALL INTO -- FUNCTION, VARIABLE, OTHER ??
@deffn {Fun@value{cedilha}@~ao} lc_u

Regra de simplifica@value{cedilha}@~ao usada para express@~oes contendo s@'{@dotless{i}}mbolos n@~ao avaliados de
Levi-Civita (@code{levi_civita}). Juntamente com @code{lc_u}, pode ser usada para simplificar
muitas express@~oes mais eficientemente que a avalia@value{cedilha}@~ao de @code{levi_civita}.
Para detalhes, veja @code{lc_l}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} canten (@var{expr})
Simplifica @var{expr} por renomea@value{cedilha}@~ao (veja @code{rename})
e permutando @'{@dotless{i}}ndices que ocorrem exactamente duas vezes. @code{rename} @'e restrito a adi@value{cedilha}@~oes de produto
de tensores nos quais nenhum @'{@dotless{i}}ndice derivativo estiver presente. Como tal isso @'e limitado
e pode somente ser usado se @code{canform} n@~ao for capaz de realizar a
simplifica@value{cedilha}@~ao requerida.

A fun@value{cedilha}@~ao @code{canten} retorna um resultado matematicamente correcto somente
se seu argumento for uma express@~ao que @'e completamente sim@'etrica em seus @'{@dotless{i}}ndices.
Por essa raz@~ao, @code{canten} retorna um erro se @code{allsym} n@~ao for
posicionada em @code{true}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} concan (@var{expr})
Similar a @code{canten} mas tamb@'em executa contra@value{cedilha}@~ao de @'{@dotless{i}}ndices.

@end deffn

@subsection Simetrias de tensores

@defvr {Vari@'avel de Op@value{cedilha}@~ao} allsym

Valor por omiss@~ao: @code{false}. Se @code{true} ent@~ao todos os objectos indexados
s@~ao assumidos sim@'etricos em todos os seus @'{@dotless{i}}ndices covariantes e
contravariantes. Se @code{false} ent@~ao nenhum sim@'etrico de qualquer tipo @'e assumidos
nesses @'{@dotless{i}}ndices. @'Indices derivativos s@~ao sempre tomados para serem sim@'etricos
a menos que @code{iframe_flag} seja escolhida para @code{true}.

@end defvr

@deffn {Fun@value{cedilha}@~ao} decsym (@var{tensor}, @var{m}, @var{n}, [@var{cov_1}, @var{cov_2}, ...], [@var{contr_1}, @var{contr_2}, ...])

Declara propriedades de simetria para @var{tensor} de covariante @var{m} e
@var{n} @'{@dotless{i}}ndices contravariantes. As @var{cov_i} e @var{contr_i} s@~ao
pseudofun@value{cedilha}@~oes expressando rela@value{cedilha}@~oes de simetrias em meio a @'{@dotless{i}}ndices covariante e
@'{@dotless{i}}ndices contravariantes respectivamente.  Esses s@~ao da forma
@code{symoper(@var{index_1}, @var{index_2},...)} onde @code{symoper} @'e um entre
@code{sym}, @code{anti} ou @code{cyc} e os @var{index_i} s@~ao inteiros
indicando a posi@value{cedilha}@~ao do @'{@dotless{i}}ndice no @var{tensor}.  Isso ir@'a
declarar @var{tensor} para ser sim@'etrico, antisim@'etrico ou c@'{@dotless{i}}clico respectivamente
nos @var{index_i}. @code{symoper(all)} @'e tamb@'em forma permitida que
indica todos os @'{@dotless{i}}ndices obedecem @`a condi@value{cedilha}@~ao de simetria. Por exemplo, dado um
objecto @code{b} com 5 @'{@dotless{i}}ndices covariantes,
@code{decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])} declara @code{b}
sim@'etrico no seu primeiro e no seu segundo @'{@dotless{i}}ndices e antisim@'etrico no seu terceiro e
quarto @'{@dotless{i}}ndices covariantes, e c@'{@dotless{i}}clico em todos de seus @'{@dotless{i}}ndices contravariantes.
Qualquer lista de declara@value{cedilha}@~oes de simetria pode ser nula.  A fun@value{cedilha}@~ao que
executa as simplifica@value{cedilha}@~oes @'e @code{canform} como o exemplo abaixo
ilustra.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

@end example


@end deffn

@deffn {Fun@value{cedilha}@~ao} remsym (@var{tensor}, @var{m}, @var{n})
Remove todas as propriedades de simetria de @var{tensor} que tem @var{m}
@'{@dotless{i}}ndices covariantes e @var{n} @'{@dotless{i}}ndices contravariantes.
@end deffn

@deffn {Fun@value{cedilha}@~ao} canform (@var{expr})
Simplifica @var{expr} atrav@'es de mudan@value{cedilha}a de nome de @'{@dotless{i}}ndices
que ocorrem exactamente duas vezes e reordena@value{cedilha}@~ao de todos os @'{@dotless{i}}ndices como ditados pelas condi@value{cedilha}@~oes de simetria
impostas sobre eles. Se @code{allsym} for @code{true} ent@~ao todos os @'{@dotless{i}}ndices s@~ao assumidos
sim@'etricos, de outra forma a informa@value{cedilha}@~ao de simetria fornecida pelas declara@value{cedilha}@~oes
@code{decsym} ir@~ao ser usadas. Os @'{@dotless{i}}ndices que ocorrem exactamente duas vezes s@~ao renomeados da mesma
maneira que na fun@value{cedilha}@~ao @code{rename}. Quando @code{canform} @'e aplicada a uma express@~ao
larga o c@'alculo pode tomar um consider@'avel montante de tempo.
Esse tempo pode ser diminu@'{@dotless{i}}do atrav@'es do uso de @code{rename} sobre a express@~ao em primeiro lugar.
Tamb@'em veja o exemplo sob @code{decsym}. Nota: @code{canform} pode n@~ao estar apta a
reduzir um express@~ao completamente para sua forma mais simples embora
retorne sempre um resultado matem@'aticamente correcto.
@end deffn

@subsection C@'alculo de tensores indiciais

@deffn {Fun@value{cedilha}@~ao} diff (@var{expr}, @var{v_1}, [@var{n_1}, [@var{v_2}, @var{n_2}] ...])

@'E a fun@value{cedilha}@~ao usual de diferencia@value{cedilha}@~ao do Maxima que tem sido expandida
nessas habilidades para @code{itensor}. @code{diff} toma a derivada de @var{expr}
 @var{n_1} vezes com rela@value{cedilha}@~ao a @var{v_1}, @var{n_2} vezes com rela@value{cedilha}@~ao a @var{v_2}
, etc. Para o pacote @code{tensor}, a fun@value{cedilha}@~ao tem sido modificada de
forma que os @var{v_i} possam ser inteiros de 1 at@'e o valor da vari@'avel
@code{dim}.  Isso causar@'a a conclus@~ao da diferencia@value{cedilha}@~ao com
rela@value{cedilha}@~ao ao @var{v_i}@'esimo membro da lista @code{vect_coords}.  Se
@code{vect_coords} for associado a uma vari@'avel at@^omica, ent@~ao aquela vari@'avel
subscrita atrav@'es de @var{v_i} ser@'a usada para a vari@'avel de
diferencia@value{cedilha}@~ao.  Isso permite que um array de nomes de coordenadas ou
nomes subscritos como @code{x[1]}, @code{x[2]}, ...  sejam usados.
@end deffn

@deffn {Fun@value{cedilha}@~ao} idiff (@var{expr}, @var{v_1}, [@var{n_1}, [@var{v_2}, @var{n_2}] ...])
Diferencia@value{cedilha}@~ao indicial. A menos que @code{diff}, que diferencia
com rela@value{cedilha}@~ao a uma vari@'avel independente, @code{idiff} possa ser usada
para diferenciar com rela@value{cedilha}@~ao a uma coordenada. Para um objecto indexado,
isso equivale a anexar ao final os @var{v_i} como @'{@dotless{i}}ndices derivativos.
Subsequ@^entemente, @'{@dotless{i}}ndices derivativos ir@~ao ser ordenados, a menos que @code{iframe_flag}
seja escolhida para @code{true}.

@code{idiff} pode tamb@'em ser o determinante de um tensor
m@'etrico. Dessa forma, se @code{imetric} tiver sido associada a @code{G} ent@~ao
@code{idiff(determinant(g),k)} ir@'a retornar
@code{2*determinant(g)*ichr2([%i,k],[%i])} onde o @'{@dotless{i}}ndice que ocorre exactamente duas vezes @code{%i}
@'e escolhido apropriadamente.


@end deffn

@deffn {Fun@value{cedilha}@~ao} liediff (@var{v}, @var{ten})

Calcula a derivada de Lie da express@~ao tensorial @var{ten} com
rela@value{cedilha}@~ao ao campo vectorial @var{v}. @var{ten} pode ser qualquer express@~ao tensorial
indexada; @var{v} pode ser o nome (sem @'{@dotless{i}}ndices) de um campo
vectorial. Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                                %1  k        %1  k      %1  k
                            + (v   b      - b   v    + v   b   ) a
                                    ,%1 l    ,l  ,%1    ,l  ,%1   i j

@end example


@end deffn

@deffn {Fun@value{cedilha}@~ao} rediff (@var{ten})

Avalia todas as ocorr@^encias do comando @code{idiff} na express@~ao
tensorial @var{ten}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} undiff (@var{expr})

Retorna uma express@~ao equivalente a @var{expr} mas com todas as derivadas
de objectos indexados substitu@'{@dotless{i}}das pela forma substantiva da fun@value{cedilha}@~ao @code{idiff}. Seu
argumento pode retornar aquele objecto indexado se a diferencia@value{cedilha}@~ao for
conclu@'{@dotless{i}}da.  Isso @'e @'util quando for desejado substituir um
objecto indexado que sofreu diferencia@value{cedilha}@~ao com alguma defini@value{cedilha}@~ao de fun@value{cedilha}@~ao resultando
em @var{expr} e ent@~ao concluir a diferencia@value{cedilha}@~ao atrav@'es de digamos
@code{ev(@var{expr}, idiff)}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} evundiff (@var{expr})

Equivalente @`a execu@value{cedilha}@~ao de @code{undiff}, seguida por @code{ev} e
@code{rediff}.

O ponto dessa opera@value{cedilha}@~ao @'e facilmente avaliar express@~oes que n@~ao possam
ser directamente avaliadas na forma derivada. Por exemplo, o seguinte
causa um erro:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Todavia, se @code{icurvature} @'e informado em sua forma substantiva, pode ser avaliado
usando @code{evundiff}:

@example
(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

                l              l         %1           l           %1
         + ichr2        + ichr2     ichr2      + ichr2       ichr2
                i j,k m        %1 k      i j,m        %1 k,m      i j
@end example

Nota: Em vers@~oes anteriores do Maxima, formas derivadas dos
s@'{@dotless{i}}mbolos de Christoffel tamb@'em n@~ao podiam ser avaliadas. Isso foi corrigido actualmente,
de forma que @code{evundiff} n@~ao mais @'e necess@'aria para express@~oes como essa:

@example
(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
@end example


@end deffn

@deffn {Fun@value{cedilha}@~ao} flush (@var{expr}, @var{tensor_1}, @var{tensor_2}, ...)
Escolhe para zero, em
@var{expr}, todas as ocorr@^encias de @var{tensor_i} que n@~ao tiverem @'{@dotless{i}}ndices derivativos.

@end deffn

@deffn {Fun@value{cedilha}@~ao} flushd (@var{expr}, @var{tensor_1}, @var{tensor_2}, ...)
Escolhe para zero, em
@var{expr}, todas as ocorr@^encias de @var{tensor_i} que tiverem @'{@dotless{i}}ndices derivativos.

@end deffn

@deffn {Fun@value{cedilha}@~ao} flushnd (@var{expr}, @var{tensor}, @var{n})
Escolhe para zero, em @var{expr}, todas as
ocorr@^encias do objecto diferenciado @var{tensor} que tem @var{n} ou mais
@'{@dotless{i}}ndices derivativos como demonstra o seguinte exemplo.
@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
@end example
@end deffn

@deffn {Fun@value{cedilha}@~ao} coord (@var{tensor_1}, @var{tensor_2}, ...)

Dados os @var{tensor_i} a propriedade de diferencia@value{cedilha}@~ao da coordenada que a
derivada do vector contravariante cujo nome @'e um dos
@var{tensor_i} retorna um delta de Kronecker. Por exemplo, se @code{coord(x)} tiver
sido conclu@'{@dotless{i}}da ent@~ao @code{idiff(x([],[i]),j)} fornece @code{kdelta([i],[j])}.
@code{coord} que @'e uma lista de todos os objectos indexados tendo essa propriedade.

@end deffn

@deffn {Fun@value{cedilha}@~ao} remcoord (@var{tensor_1}, @var{tensor_2}, ...)
@deffnx {Fun@value{cedilha}@~ao} remcoord (all)

Remove a propriedade de coordenada de diferencia@value{cedilha}@~ao dos @code{tensor_i}
que foram estabelecidos atrav@'es da fun@value{cedilha}@~ao @code{coord}.  @code{remcoord(all)}
remove essa propriedade de todos os objectos indexados.

@end deffn

@deffn {Fun@value{cedilha}@~ao} makebox (@var{expr})
Mostra @var{expr} da mesma maneira que @code{show}; todavia,
qualquer tensor d'Alembertiano ocorrendo em @var{expr} ser@'a indicado usando o
s@'{@dotless{i}}mbolo @code{[]}.  Por exemplo, @code{[]p([m],[n])} representa
@code{g([],[i,j])*p([m],[n],i,j)}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} conmetderiv (@var{expr}, @var{tensor})

Simplifica express@~oes contendo derivadas comuns de
ambas as formas covariantes e contravariantes do tensor m@'etrico (a
restri@value{cedilha}@~ao corrente).  Por exemplo, @code{conmetderiv} pode relatar a
derivada do tensor contravariante m@'etrico com s@'{@dotless{i}}mbolos de
Christoffel como visto adiante:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
@end example
@end deffn

@deffn {Fun@value{cedilha}@~ao} simpmetderiv (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} simpmetderiv (@var{expr}[, @var{stop}])

Simplifica express@~oes contendo produtos de derivadas de
tensores m@'etricos. Especificamente, @code{simpmetderiv} reconhece duas identidades:

@example

   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

@end example

consequ@^entemente

@example

   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
@end example

e

@example

  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

@end example

que seguem de simetrias de s@'{@dotless{i}}mbolos de Christoffel.

A fun@value{cedilha}@~ao @code{simpmetderiv} toma um par@^ametro opcional que, quando
presente, faz com que a fun@value{cedilha}@~ao pare ap@'os a primeira substitui@value{cedilha}@~ao feita com
sucesso em uma express@~ao produto. A fun@value{cedilha}@~ao @code{simpmetderiv}
tamb@'em faz uso da vari@'avel global @var{flipflag} que determina
como aplicar uma ordena@value{cedilha}@~ao ``canonica'' para os @'{@dotless{i}}ndices de produto.

Colocados juntos, essas compatibilidades podem ser usadas poderosamente para encontrar
simplifica@value{cedilha}@~oes que s@~ao dif@'{@dotless{i}}ceis ou imposs@'{@dotless{i}}veis de realizar de outra forma.
Isso @'e demonstrado atrav@'es do seguinte exemplo que explicitamente usa o 
recurso de simplifica@value{cedilha}@~ao parcial de @code{simpmetderiv} para obter uma
express@~ao contract@'{@dotless{i}}vel:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

@end example

Veja tamb@'em @code{weyl.dem} para um exemplo que usa @code{simpmetderiv}
e @code{conmetderiv} juntos para simplificar contra@value{cedilha}@~oes do tensor de Weyl.

@end deffn

@deffn {Fun@value{cedilha}@~ao} flush1deriv (@var{expr}, @var{tensor})

Escolhe para zero, em @code{expr}, todas as ocorr@^encias de @code{tensor} que possuem
exactamente um @'{@dotless{i}}ndice derivativo.

@end deffn

@subsection Tensores em espa@value{cedilha}os curvos

@deffn {Fun@value{cedilha}@~ao} imetric (@var{g})
@deffnx {Vari@'avel de sistema} imetric

Especifica a m@'etrica atrav@'es de atribui@value{cedilha}@~ao @`a vari@'avel @code{imetric:@var{g}}
adicionalmente, as propriedades de contra@value{cedilha}@~ao da m@'etrica @var{g} s@~ao escolhidas atrav@'es da
execu@value{cedilha}@~ao dos comandos @code{defcon(@var{g}),defcon(@var{g},@var{g},kdelta)}.
A vari@'avel @code{imetric} (desassociada por padr@~ao), @'e associada @`a m@'etrica, atribuida pelo
comando @code{imetric(@var{g})}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} idim (@var{n})
Escolhe as dimens@~oes da m@'etrica. Tamb@'em inicializa as propriedades de
antisimetria dos s@'{@dotless{i}}mbolos de Levi-Civita para as dimens@~oes dadas.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ichr1 ([@var{i}, @var{j}, @var{k}])
Retorna o s@'{@dotless{i}}mbolo de Christoffel de primeiro tipo via
defini@value{cedilha}@~ao
@example
       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
@end example
@noindent
Para avaliar os s@'{@dotless{i}}mbolos de Christoffel para uma m@'etrica particular, @`a
vari@'avel @code{imetric} deve ser atribu@'{@dotless{i}}da um nome como no exemplo sob @code{chr2}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ichr2 ([@var{i}, @var{j}], [@var{k}])
Retorna o s@'{@dotless{i}}mbolo de Christoffel de segundo tipo
definido pela rela@value{cedilha}@~ao
@example
                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
@end example
@end deffn

@deffn {Fun@value{cedilha}@~ao} icurvature ([@var{i}, @var{j}, @var{k}], [@var{h}])
Retorna o tensor da curvatura de
Riemann em termos de s@'{@dotless{i}}mbolos de Christoffel de segundo
tipo (@code{ichr2}).  A seguinte nota@value{cedilha}@~ao @'e usada:
@example
               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
@end example
@end deffn

@deffn {Fun@value{cedilha}@~ao} covdiff (@var{expr}, @var{v_1}, @var{v_2}, ...)
Retorna a derivada da covariante de @var{expr} com
rela@value{cedilha}@~ao @`as vari@'aveis @var{v_i} em termos de s@'{@dotless{i}}mbolos de Christoffel de
segundo tipo (@code{ichr2}).  Com o objectivo de avaliar esses, se pode usar
@code{ev(@var{expr},ichr2)}.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the @'{@dotless{i}}ndices covariantes: [i,j];
Enter a list of the @'{@dotless{i}}ndices contravariantes: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k            k     %1
(%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
             i %1      j s    %1 j      i s    i j,s        %1 s  i j
(%i4) imetric:g;
(%o4)            g
(%i5) ishow(ev(%th(2),ichr2))$
  %1 %4  k
 g      a     (g       - g       + g  )
  i %1   s %4,j  j s,%4    j %4,s
(%t5) - ------------------------------------------
       2
    %1 %3  k
   g   a     (g       - g    + g     )
    %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
         2
    k %2  %1
   g     a    (g        - g    + g      )
   i j   s %2,%1    %1 s,%2    %1 %2,s   k
 + ------------------------------------------- + a
   2     i j,s
(%i6) 
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} lorentz_gauge (@var{expr})
Imp@~oe a condi@value{cedilha}@~ao de Lorentz atrav@'es da substitui@value{cedilha}@~ao de 0 para todos os
objectos indexados em @var{expr} que possui um @'{@dotless{i}}ndice de derivada id@^entico ao
@'{@dotless{i}}ndice contravariante.

@end deffn

@deffn {Fun@value{cedilha}@~ao} igeodesic_coords (@var{expr}, @var{nome})

Faz com que s@'{@dotless{i}}mbolos de Christoffel n@~ao diferenciados e
a primeira derivada do tensor m@'etrico tendam para zero em @var{expr}. O @var{nome}
na fun@value{cedilha}@~ao @code{igeodesic_coords} refere-se @`a m@'etrica @var{nome}
(se isso aparecer em @var{expr}) enquando os coeficientes de conec@value{cedilha}@~ao devem ser
chamados com os nomes @code{ichr1} e/ou @code{ichr2}. O seguinte exemplo
demonstra a verifica@value{cedilha}@~ao da identidade c@'{@dotless{i}}clica satisfeita atrav@'es do tensor da
curvatura de Riemann usando a fun@value{cedilha}@~ao @code{igeodesic_coords}.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u            u         %1
(%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
             r t,s        %1 s      r t        r s,t        %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t        r t,s

                                                                  u
                                                           + ichr2
                                                                  r s,t
(%i5) canform(%);
(%o5)                                  0

@end example

@end deffn

@subsection Referenciais m@'oveis

Maxima actualmente tem a habilidade de executar c@'alculos usando referenciais m@'oveis.
Essas podem ser referenciais ortonormais (tetrads, vielbeins) ou um referencial arbitr@'aria.

Para usar referenciais,  primeiro escolha @code{iframe_flag} para @code{true}. Isso
faz com que os s@'{@dotless{i}}mbolos de Christoffel, @code{ichr1} e @code{ichr2}, sejam substitu@'{@dotless{i}}dos
pelos referenciais mais gerais de coeficientes de conec@value{cedilha}@~ao @code{icc1} e @code{icc2}
em c@'alculos. Especialmente, o comportamento de @code{covdiff} e
@code{icurvature} s@~ao alterados.

O referencial @'e definido atrav@'es de dois tensores: o campo de referencial inversa (@code{ifri}),
a base tetrad dual),
e a m@'etrica do referencial @code{ifg}. A m@'etrica do referencial @'e a matriz identidade para
referenciais ortonormais, ou a m@'etrica de Lorentz para referenciais ortonormais no espa@value{cedilha}o-tempo de
Minkowski. O campo de referencial inverso define a base do referencial (vectores unit@'arios).
Propriedades de contra@value{cedilha}@~ao s@~ao definidas para o campo de referencial e para a m@'etrica do referencial.

Quando @code{iframe_flag} for @code{true}, muitas express@~oes @code{itensor} usam a m@'etrica do
referencial @code{ifg} em lugar da m@'etrica definida atrav@'es de @code{imetric} para
o decremento e para o incremento de @'{@dotless{i}}ndices.

IMPORTANTE: Escolhendo a vari@'avel @code{iframe_flag} para @code{true} N@~{A}O
remove a defini@value{cedilha}@~ao das propriedades de contra@value{cedilha}@~ao de uma m@'etrica definida atrav@'es de uma chamada a
@code{defcon} ou @code{imetric}. Se um campo de referencial for usado, ele @'e melhor para
definir a m@'etrica atrav@'es de atribui@value{cedilha}@~ao desse nome para a vari@'avel @code{imetric}
e N@~{A}O invoque a fun@value{cedilha}@~ao @code{imetric}.

Maxima usa esses dois tensores para definir os coeficientes de referencial (@code{ifc1}
e @code{ifc2}) cuja forma parte dos coeficientes de conec@value{cedilha}@~ao (@code{icc1}
e @code{icc2}), como demonstra o seguinte exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                        %1      i           i        i
(%t4)                  v   (ifc2     + ichr2    ) + v
                                %1 j        %1 j     ,j
(%i5) ishow(ev(%,ifc2))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t5)      -------------------------------------------------- + v
                                   2                             ,j
(%i6) ishow(ifb([a,b,c]))$
                       %5    %4
(%t6)               ifr   ifr   (ifri        - ifri       )
                       a     b       c %4,%5       c %5,%4

@end example

Um m@'etodo alternativo @'e usado para calcular o suporte do referencial (@code{ifb}) se
o sinalizador @code{iframe_bracket_form} @'e escolhido para @code{false}:

@example

(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                       %7    %6        %6      %7
(%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                       a     b,%7      a,%7    b       c %6

@end example


@deffn {Fun@value{cedilha}@~ao} iframes ()

Uma vez que nessa vers@~ao do Maxima, identidades de contra@value{cedilha}@~ao para @code{ifr} e
@code{ifri} s@~ao sempre definidas, como @'e o suporte do referencial (@code{ifb}), essa
fun@value{cedilha}@~ao n@~ao faz nada.

@end deffn

@defvr {Vari@'avel} ifb

O suporte do referencial. A contribui@value{cedilha}@~ao da m@'etrica do referencial para os coeficientes
de conec@value{cedilha}@~ao @'e expressa usando o suporte do referencial:

@example

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

@end example

O suporte do referencial por si mesmo @'e definido em termos de campo de
referencial e m@'etrica do referencial. Dois m@'etodos alternativos de
c@'alculo s@~ao usados dependendo do valor de
@code{frame_bracket_form}. Se @code{true} (o padr@~ao) ou se o
sinalizador @code{itorsion_flag} for @code{true}:

@example

          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


@end example

Otherwise:

@example

             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

@end example


@end defvr


@defvr {Vari@'avel} icc1

Coeficientes de conec@value{cedilha}@~ao de primeiro tipo. Em @code{itensor}, definido como

@example

icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

@end example

Nessa express@~ao, se @code{iframe_flag} for @code{true}, o s@'{@dotless{i}}mbolo de Christoffel
@code{ichr1} @'e substitu@'{@dotless{i}}do com o coeficiente de conec@value{cedilha}@~ao do referencial @code{ifc1}.
Se @code{itorsion_flag} for @code{false}, @code{ikt1}
ser@'a omitido. @code{ikt1} @'e tamb@'em omitido se uma base de referencial for usada, como a
tors@~ao est@'a j@'a calculada como parte do suporte do referencial.
Ultimamente, como @code{inonmet_flag} @'e @code{false},
@code{inmc1} n@~ao estar@'a presente.


@end defvr

@defvr {Vari@'avel} icc2

Coeficientes de conec@value{cedilha}@~ao de segundo tipo. Em @code{itensor}, definido como

@example

    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

@end example

Nessa express@~ao, se @code{iframe_flag} for @code{true}, o s@'{@dotless{i}}mbolo de Christoffel
@code{ichr2} @'e substitu@'{@dotless{i}}do com o coeficiente de conec@value{cedilha}@~ao @code{ifc2}.
Se @code{itorsion_flag} for @code{false}, @code{ikt2}
ser@'a omitido. @code{ikt2} tamb@'em ser@'a omitido se uma base de referencial for usada, uma vez que a
tors@~ao j@'a est@'a calculada como parte do suporte do referencial.
Ultimamente, como @code{inonmet_flag} @'e @code{false},
@code{inmc2} n@~ao estar@'a presente.

@end defvr

@defvr {Vari@'avel} ifc1

Coeficiente de referencial de primeiro tipo (tamb@'em conhecido como coeficientes de
rota@value{cedilha}@~ao de Ricci).  Esse tensor representa a contribui@value{cedilha}@~ao
da m@'etrica do referencial para o coeficiente de conec@value{cedilha}@~ao de primeiro tipo. Definido
como:

@example

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


@end example

@end defvr

@defvr {Vari@'avel} ifc2

Coeficiente de referencial de primeiro tipo. Esse tensor representa a contribui@value{cedilha}@~ao
da m@'etrica do referencial para o coeficiente de conec@value{cedilha}@~ao de primeiro tipo. Definido
como uma permuta@value{cedilha}@~ao de suporte de referencial (@code{ifb}) com os @'{@dotless{i}}ndices
apropriados incrementados e decrementados como necess@'ario:

@example

    c       cd
ifc2   = ifg   ifc1
    ab             abd

@end example

@end defvr

@defvr {Vari@'avel} ifr

O campo do referencial. Contrai (@code{ifri}) para e com a forma do
campo inverso do referencial para formar a m@'etrica do referencial
(@code{ifg}).

@end defvr

@defvr {Vari@'avel} ifri

O campo inverso do referencial. Especifica a base do referencial (vectores base duais). Juntamente
com a m@'etrica do referencial, forma a base de todos os c@'alculos baseados em
referenciais.

@end defvr

@defvr {Vari@'avel} ifg

A m@'etrica do referencial. O valor padr@~ao @'e @code{kdelta}, mas pode ser mudada usando
@code{components}.

@end defvr

@defvr {Vari@'avel} ifgi

O inverso da m@'etrica do referencial. Contrai com a m@'etrica do referencial (@code{ifg})
para @code{kdelta}.

@end defvr

@defvr {Vari@'avel de Op@value{cedilha}@~ao} iframe_bracket_form
Valor por omiss@~ao: @code{true}

Especifica como o suporte do referencial (@code{ifb}) @'e calculado.

@end defvr

@subsection Tors@~ao e n@~ao metricidade

Maxima pode trabalhar com tors@~ao e n@~ao metricidade. Quando o sinalizador
@code{itorsion_flag} for escolhido para @code{true}, a contribui@value{cedilha}@~ao de tors@~ao
@'e adicionada aos coeficientes de conec@value{cedilha}@~ao. Similarmente, quando o sinalizador
@code{inonmet_flag} for @code{true}, componentes de n@~ao metricidades s@~ao inclu@'{@dotless{i}}dos.

@defvr {Vari@'avel} inm

O vector de n@~ao metricidade. Conforme a n@~ao metricidade est@'a definida atrav@'es da
derivada covariante do tensor m@'etrico. Normalmente zero, o tensor da
m@'etrica derivada covariante ir@'a avaliar para o seguinte quando
@code{inonmet_flag} for escolhido para @code{true}:

@example

g     =- g  inm
 ij;k     ij  k

@end example

@end defvr


@defvr {Vari@'avel} inmc1

Permuta@value{cedilha}@~ao covariante de componentes do vector de n@~ao metricidade. Definida como

@example

           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

@end example

(Substitue @code{ifg} em lugar de @code{g} se um referencial m@'etrico for usada.)

@end defvr

@defvr {Vari@'avel} inmc2

Permuta@value{cedilha}@~ao covariante de componentes do vector de n@~ao metricidade. Usada
nos coeficicientes de conec@value{cedilha}@~ao se @code{inonmet_flag} for @code{true}. Definida
como:

@example

                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

@end example

(Substitue @code{ifg} em lugar de @code{g} se um referencial m@'etrico for usada.)

@end defvr

@defvr {Vari@'avel} ikt1

Permuta@value{cedilha}@~ao covariante do tensor de tors@~ao (tamb@'em conhecido como contors@~ao).
Definido como:

@example

                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

@end example

(Substitue @code{ifg} em lugar de @code{g} se um referencial m@'etrico for usada.)

@end defvr

@defvr {Vari@'avel} ikt2

Permuta@value{cedilha}@~ao contravariante do tensor de tors@~ao (tamb@'em conhecida como contors@~ao).
Definida como:

@example

    c     cd
ikt2   = g   ikt1
    ab           abd

@end example

(Substitue @code{ifg} em lugar de @code{g} se um referencial m@'etrico for usada.)

@end defvr

@defvr {Vari@'avel} itr

O tensor de tors@~ao. Para uma m@'etrica com tors@~ao, diferencia@value{cedilha}@~ao covariante
repetida sobre uma fun@value{cedilha}@`ao escalar n@~ao ir@'a comutar,como demonstrado
atrav@'es do seguinte exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

@end example

@end defvr

@subsection @'Algebra externa (como em produto externo)

O pacote @code{itensor} pode executar opera@value{cedilha}@~oes sobre campos tensores
covariantes totalmente antisim@'etricos. Um campo tensor totalmente antisim@'etrico de classe
(0,L) corresponde a uma forma diferencial L. Sobre esses objectos, uma
opera@value{cedilha}@~ao de multiplica@value{cedilha}@~ao funciona como um produto externo, ou produto cunha,
@'e definido.

Desafortunadamente, nem todos os autores concordam sobre a defini@value{cedilha}@~ao de produto
cunha. Alguns autores preferem uma defini@value{cedilha}@~ao que corresponde @`a
no@value{cedilha}@~ao de antisimetriza@value{cedilha}@~ao: nessas palavras, o produto cunha de
dois campos vectoriais, por exemplo, pode ser definido como

@example
            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
@end example

Mais geralmente, o produto de uma forma p e uma forma q pode ser definido como

@example
                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
@end example

onde @code{D} simboliza o delta de Kronecker.

Outros autores, todavia, preferem uma defini@value{cedilha}@~ao ``geom@'etrica'' que corresponde @`a
nota@value{cedilha}@~ao de elemento volume:

@example
a  /\ a  = a a  - a a
 i     j    i j    j i
@end example

e, no caso geral

@example
                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
@end example

Uma vez que @code{itensor} @'e um pacote de algebra de tensores, a primeira dessas duas
defini@value{cedilha}@~oes aparenta ser a mais natural por si mesma. Muitas aplica@value{cedilha}@~oes, todavia,
usam a segunda defini@value{cedilha}@~ao. Para resolver esse dilema, um sinalizador tem sido
implementado que controla o comportamento do produto cunha: se
@code{igeowedge_flag} for @code{false} (o padr@~ao), a primeira, defini@value{cedilha}@~ao
"tensorial" @'e usada, de outra forma a segunda, defini@value{cedilha}@~ao "geom@'etrica" ir@'a
ser aplicada.

@defvr {Operador} ~
@ifinfo
@fnindex Produto Externo
@end ifinfo
O operador do produto cunha @'e definido como sendo o acento til @code{~}. O til @'e
um operador bin@'ario. Seus argumentos podem ser express@~oes envolvendo escalares,
tensores covariantes de categoria 1, ou tensores covariantes de categoria @code{l} que
tiverem sido declarados antisim@'etricos em todos os @'{@dotless{i}}ndices covariantes.

O comportamento do operador do produto cunha @'e controlado atrav@'es do
sinalizador @code{igeowedge_flag}, como no seguinte exemplo:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
@end example

@end defvr

@defvr {Operador} |
@ifinfo
@fnindex Contra@value{cedilha}@~ao com um vector
@end ifinfo
A barra vertical @code{|} denota a opera@value{cedilha}@~ao bin@'aria
"contra@value{cedilha}@~ao com um vector". Quando um tensor covariante totalmente antisim@'etrico @'e contra@'{@dotless{i}}do
com um vector contravariante, o resultado @'e o mesmo independente de qual @'{@dotless{i}}ndice
foi usado para a contra@value{cedilha}@~ao. Dessa forma, @'e poss@'{@dotless{i}}vel definir a
opera@value{cedilha}@~ao de contra@value{cedilha}@~ao de uma forma livre de @'{@dotless{i}}ndices.

No pacote @code{itensor}, contra@value{cedilha}@~ao com um vector @'e sempre realizada
com rela@value{cedilha}@~ao ao primeiro @'{@dotless{i}}ndice na ordem literal de ordena@value{cedilha}@~ao. Isso garante
uma melhor simplifica@value{cedilha}@~ao de express@~oes envolvendo o operador @code{|}. Por exemplo:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
@end example

Note que isso @'e essencial que os tensores usado como o operador @code{|} seja
declarado totalmente antisim@'etrico em seus @'{@dotless{i}}ndices covariantes. De outra forma,
os resultados ser@~ao incorrectos.

@end defvr

@deffn {Fun@value{cedilha}@~ao} extdiff (@var{expr}, @var{i})

Calcula a derivada externa de @var{expr} com rela@value{cedilha}@~ao ao @'{@dotless{i}}ndice
@var{i}. A derivada externa @'e formalmente definida como o produto
cunha do operador de derivada parcial e uma forma diferencial. Como
tal, essa opera@value{cedilha}@~ao @'e tamb@'em controlada atrav@'es da escolha de @code{igeowedge_flag}.
Por exemplo:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                      a      - a      + a
                            j k,i    i k,j    i j,k
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} hodge (@var{expr})

Calcula o Hodge dual de @var{expr}. Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g        g
                                                     %1 %106  %2 %107
                                            g        g      A        /6
                                             %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

@end example

@end deffn

@defvr {Vari@'avel de Op@value{cedilha}@~ao} igeowedge_flag
Valor por omiss@~ao: @code{false}

Controla o comportamento de produto cunha e derivada externa. Quando
for esconhida para @code{false} (o padr@~ao), a no@value{cedilha}@~ao de formas diferenciais ir@'a
corresponder @`aquela de um campo tensor covariante totalmente antisim@'etrico.
Quando escolhida para @code{true}, formas diferenciais ir@~ao concordar com a no@value{cedilha}@~ao do
elemento volume.

@end defvr


@subsection Exportando express@~oes TeX

O pacote @code{itensor} fornece suporte limitado @`a exporta@value{cedilha}@~ao de express@~oes
de tensores para o TeX.  Uma vez que express@~oes @code{itensor} aparecem como chamada a fun@value{cedilha}@~oes,
o comando regular @code{tex} do Maxima n@~ao produzir@'a a sa@'{@dotless{i}}da
esperada. Pode tentar no seu lugar o comando @code{tentex}, o qual tenta
traduzir express@~oes de tensores dentro de objectos TeX indexados apropriadamente.

@deffn {Fun@value{cedilha}@~ao} tentex (@var{expr})

Para usar a fun@value{cedilha}@~ao @code{tentex}, deve primeiro chamar @code{tentex},
como no seguinte exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(tentex);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i            i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
            j k      m1 l        j l      m1 k        j l,k        j k,l
(%i5) tentex(%)$
$$\Gamma_@{j\,k@}^@{m_1@}\,\Gamma_@{l\,m_1@}^@{i@}-\Gamma_@{j\,l@}^@{m_1@}\,
 \Gamma_@{k\,m_1@}^@{i@}-\Gamma_@{j\,l,k@}^@{i@}+\Gamma_@{j\,k,l@}^@{i@}$$

@end example

Note o uso da declara@value{cedilha}@~ao @code{idummyx}, para evitar o aparecimento
do sinal de porcentagem na express@~ao TeX, o qual pode induzir a erros de compila@value{cedilha}@~ao.

Note Bem: Essa ves@~ao da fun@value{cedilha}@~ao @code{tentex} @'e um tanto quanto experimental.

@end deffn

@subsection Interagindo com o pacote @code{ctensor}

O pacote @code{itensor} possui a habilidade de gerar c@'odigo Maxima que pode
ent@~ao ser executado no contexto do pacote @code{ctensor}. A fun@value{cedilha}@~ao que executa
essa tarefa @'e @code{ic_convert}.

@deffn {Fun@value{cedilha}@~ao} ic_convert (@var{eqn})

Converte a equa@value{cedilha}@~ao @var{eqn} na sintaxe @code{itensor} para uma declara@value{cedilha}@~ao de atribui@value{cedilha}@~ao @code{ctensor}.
Adi@value{cedilha}@~oes impl@'{@dotless{i}}citas sobre @'{@dotless{i}}ndices que ocorrem exactamente duas vezes s@~ao tornadas expl@'{@dotless{i}}citas enquanto objectos
indexados s@~ao transformados em arrays (os arrays subscritos est@~ao na
ordem de covari@^ancia seguidos de @'{@dotless{i}}ndices contravariantes dos objectos
indexados). A derivada de um objecto indexado ser@'a substitu@'{@dotless{i}}da pela
forma substantiva de @code{diff} tomada com rela@value{cedilha}@~ao a @code{ct_coords} subscrita
pelo @'{@dotless{i}}ndice de deriva@value{cedilha}@~ao. Os s@'{@dotless{i}}mbolos de Christoffel @code{ichr1} e @code{ichr2}
ir@~ao ser traduzidos para @code{lcs} e @code{mcs}, respectivamente e se
@code{metricconvert} for @code{true} ent@~ao todas as ocorr@^encias da m@'etrica
com dois @'{@dotless{i}}ndices covariantes (ou contravariantes) ir@~ao ser renomeadas para @code{lg}
(ou @code{ug}). Adicionalmente, ciclos @code{do} ir@~ao ser introduzidos adicionando sobre
todos os @'{@dotless{i}}ndices livres de forma que a
declara@value{cedilha}@~ao de atribui@value{cedilha}@~ao transformada pode ser avaliada atrav@'es de apenas fazendo
@code{ev}. Os seguintes exemplos demonstam os recursos dessa
fun@value{cedilha}@~ao.

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
@end example

@end deffn

@subsection Palavras reservadas

As palavras seguintes do Maxima s@~ao usadas internamente pelo pacote @code{itensor} e
n@~ao podem ser redefinidas:

@c REFORMAT THIS TABLE USING TEXINFO MARKUP
@example
  Keyword    Comments
  ------------------------------------------
  indices2() vers@~ao interna de @code{indices()}
  conti      Lista de @'{@dotless{i}}ndices contravariantes
  covi       Lista de @'{@dotless{i}}ndices covariantes de um objecto indexado
  deri       Lista de @'{@dotless{i}}ndices de derivada de um objecto indexado
  name       Retorna o nome de um objecto indexado
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
@end example

