@c /Matrices.texi/1.28/Fri Mar  2 00:44:39 2007/-ko/
@menu
* Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear::  
* Defini@value{cedilha}@~oes para Matrizes e @'Algebra Linear::  
@end menu

@node Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear, Defini@value{cedilha}@~oes para Matrizes e @'Algebra Linear, Matrizes e @'Algebra Linear, Matrizes e @'Algebra Linear
@section Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear

@menu
* Ponto::                         
* Vetores::                     
* auto::
@end menu

@node Ponto, Vetores, Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear, Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear
@subsection Ponto
O operador @code{.} representa multiplica@value{cedilha}@~ao n@~ao comutativa e produto escalar.
Quando os operandos s@~ao matrizes 1-coluna ou 1-linha @code{a} e @code{b},
a expres@~ao @code{a.b} @'e equivalente a @code{sum (a[i]*b[i], i, 1, length(a))}.
Se @code{a} e @code{b} n@~ao s@~ao complexos, isso @'e o produto escalar,
tamb@'em chamado produto interno ou produto do ponto, de @code{a} e @code{b}.
O produto escalar @'e definido como @code{conjugate(a).b} quando @code{a} e @code{b} s@~ao complexos;
@code{innerproduct} no pacote @code{eigen} fornece o produto escalar complexo.

Quando os operandos s@~ao matrizes mais gerais,
o produto @'e a matriz produto @code{a} e @code{b}.
O n@'umero de linhas de @code{b} deve ser igual ao n@'umero de colunas de @code{a},
e o resultado tem n@'umero de linhas igual ao n@'umero de linhas de @code{a}
e n@'umero de colunas igual ao n@'umero de colunas de @code{b}.

Para distinguir @code{.} como um operador aritm@'etico do 
ponto decimal em um n@'umero em ponto flutuante,
pode ser necess@'ario deixar espa@value{cedilha}os em cada lado.
Por exemplo, @code{5.e3} @'e @code{5000.0} mas @code{5 . e3} @'e @code{5} vezes @code{e3}.

Existem muitos sinalizadores que governam a simplifica@value{cedilha}@~ao de
expres@~oes envolvendo @code{.}, a saber
@code{dot}, @code{dot0nscsimp}, @code{dot0simp}, @code{dot1simp}, @code{dotassoc}, 
@code{dotconstrules}, @code{dotdistrib}, @code{dotexptsimp}, @code{dotident},
e @code{dotscrules}.

@node Vetores, auto, Ponto, Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear
@subsection Vetores
@code{vect} @'e um pacote de fun@value{cedilha}@~oes para an@'alise vectorial.
@code{load ("vect")} chama esse pacote, e @code{demo ("vect")} permite visualizar uma demonstra@value{cedilha}@~ao.
@c find maxima -name \*orth\* YIELDS NOTHING; ARE THESE FUNCTIONS IN ANOTHER FILE NOW ??
@c and SHARE;VECT ORTH contains definitions of various orthogonal curvilinear coordinate systems.

O pacote de an@'alise vectorial pode combinar e simplificar expres@~oes
simb@'olicas incluindo produtos dos pontos e productos dos x, juntamente com
o gradiente, divergencia, tor@value{cedilha}@~ao, e operadores Laplacianos.  A 
distribui@value{cedilha}@~ao desses operadores sobre adi@value{cedilha}@~oes ou produtos @'e governada
por muitos sinalizadores, como s@~ao v@'arias outras expans@~oes, incluindo expans@~ao
dentro de componentes em qualquer sistema de coordenadas ortogonais.
Existem tamb@'em fun@value{cedilha}@~oes para derivar o escalar ou vector potencial
de um campo.

O pacote @code{vect} cont@'em essas fun@value{cedilha}@~oes:
@code{vectorsimp}, @code{scalefactors},
@code{express}, @code{potential}, e @code{vectorpotential}.
@c REVIEW vect.usg TO ENSURE THAT TEXINFO HAS WHATEVER IS THERE
@c PRINTFILE(VECT,USAGE,SHARE); for details.

Aten@value{cedilha}@~ao: o pacote @code{vect} declara o operador ponto @code{.}
como sendo um operador comutativo.

@node auto, , Vetores, Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear
@subsection auto

O pacote @code{eigen} cont@'em muitas fun@value{cedilha}@~oes devotadas para a
computa@value{cedilha}@~ao simb@'olica de autovalores e autovectores.
Maxima chama o pacote automaticamente se uma das fun@value{cedilha}@~oes
@code{eigenvalues} ou @code{eigenvectors} @'e invocada.
O pacote pode ser chamado explicitamente com @code{load ("eigen")}.

@code{demo ("eigen")} mostra uma demonstra@value{cedilha}@~ao das compatibilidades
desse pacote.
@code{batch ("eigen")} executa a mesma demonstra@value{cedilha}@~ao,
mas sem lembretes de utilizador entre sucessivas computa@value{cedilha}@~oes.

As fun@value{cedilha}@~oes no pacote @code{eigen} s@~ao
@code{innerproduct}, @code{unitvector}, @code{columnvector},
@code{gramschmidt}, @code{eigenvalues}, @code{eigenvectors}, @code{uniteigenvectors},
e @code{similaritytransform}.

@c end concepts Matrizes e @'Algebra Linear
@node Defini@value{cedilha}@~oes para Matrizes e @'Algebra Linear,  , Introdu@value{cedilha}@~ao a Matrizes e @'Algebra Linear, Matrizes e @'Algebra Linear
@section Defini@value{cedilha}@~oes para Matrizes e @'Algebra Linear

@deffn {Fun@value{cedilha}@~ao} addcol (@var{M}, @var{list_1}, ..., @var{list_n})
Anexa a(s) coluna(s) dadas por uma
ou mais listas (ou matrizes) sobre a matriz @var{M}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} addrow (@var{M}, @var{list_1}, ..., @var{list_n})
Anexa a(s) linha(s) dadas por uma ou
mais listas (ou matrizes) sobre a matriz @var{M}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} adjoint (@var{M})
Retorna a matriz adjunta da matriz @var{M}.
A matriz adjunta @'e a transposta da matriz dos cofactores de @var{M}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} augcoefmatrix ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Retorna a matriz dos coeficientes
aumentada para as vari@'aveis @var{x_1}, ..., @var{x_n} do sistema de equa@value{cedilha}@~oes lineares
@var{eqn_1}, ..., @var{eqn_m}.  Essa @'e a matriz dos coeficientes com uma coluna anexada para
os termos independentes em cada equa@value{cedilha}@~ao (i.e., esses termos n@~ao dependem de
@var{x_1}, ..., @var{x_n}).

@example
(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} charpoly (@var{M}, @var{x})
Retorna um polin@'omio caracter@'{@dotless{i}}stico para a matriz @var{M}
em rela@value{cedilha}@~ao @`a vari@'avel @var{x}.  Que @'e,
@code{determinant (@var{M} - diagmatrix (length (@var{M}), @var{x}))}.

@example
(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} coefmatrix ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Retorna a matriz dos coeficientes para as
vari@'aveis @var{x_1}, ..., @var{x_n} do sistema de equa@value{cedilha}@~oes lineares
@var{eqn_1}, ..., @var{eqn_m}.

@example
(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} col (@var{M}, @var{i})
Reorna a @var{i}'@'esima coluna da matriz @var{M}.
O valor de retorno @'e uma matriz.
@c EXAMPLE HERE

@end deffn

@deffn {Fun@value{cedilha}@~ao} columnvector (@var{L})
@deffnx {Fun@value{cedilha}@~ao} covect (@var{L})
Retorna uma matriz de uma coluna e @code{length (@var{L})} linhas,
contendo os elementos da lista @var{L}.

@code{covect} @'e um sin@^onimo para @code{columnvector}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~ao.

@c FOLLOWING COMMENT PRESERVED.  WHAT DOES THIS MEAN ??
Isso @'e @'util se quiser usar partes das sa@'{@dotless{i}}das das
fun@value{cedilha}@~oes nesse pacote em c@'alculos matriciais.

Exemplo:

@c HMM, SPURIOUS "redefining the Macsyma function".
@c LEAVE IT HERE SINCE THAT'S WHAT A USER ACTUALLY SEES.
@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovectores
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} conjugate (@var{x})
Retorna o conjugado complexo de @var{x}.

@c ===beg===
@c declare ([aa, bb], real, cc, complex, ii, imaginary);
@c conjugate (aa + bb*%i);
@c conjugate (cc);
@c conjugate (ii);
@c conjugate (xx + yy);
@c ===end===
@example
(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} copymatrix (@var{M})
Retorna uma c@'opia da matriz @var{M}.  Esse @'e o @'unico
para fazer uma copia separada copiando @var{M} elemento a elemento.

Note que uma atribui@value{cedilha}@~ao de uma matriz para outra, como em @code{m2: m1},
n@~ao copia @code{m1}.
Uma atribui@value{cedilha}@~ao @code{m2 [i,j]: x} ou @code{setelmx (x, i, j, m2} tamb@'em modifica @code{m1 [i,j]}.
criando uma c@'opia com @code{copymatrix} e ent@~ao usando atribu@value{cedilha}@~ao cria uma separada e modificada c@'opia.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} determinant (@var{M})
Calcula o determinante de @var{M} por um m@'etodo similar @`a
elimina@value{cedilha}@~ao de Gauss.

@c JUST HOW DOES ratmx AFFECT THE RESULT ??
A forma do resultado depende da escolha
do comutador @code{ratmx}.

@c IS A SPARSE DETERMINANT SOMETHING OTHER THAN THE DETERMINANT OF A SPARSE MATRIX ??
Existe uma rotina especial para calcular
determinantes esparsos que @'e chamada quando os comutadores
@code{ratmx} e @code{sparse} s@~ao ambos @code{true}.

@c EXAMPLES NEEDED HERE
@end deffn

@defvr {Vari@'avel} detout
Valor por omiss@~ao: @code{false}

Quando @code{detout} @'e @code{true}, o determinante de uma
matriz cuja inversa @'e calculada @'e factorado fora da inversa.

Para esse comutador ter efeito @code{doallmxops} e @code{doscmxops} deveram ambos serem
@code{false} (veja suas transcri@value{cedilha}@~oes).  Alternativamente esses comutadores podem ser
dados para @code{ev} o que faz com que os outros dois sejam escolhidos correctamente.

Exemplo:

@example
(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
@end example
@c THERE'S MORE TO THIS STORY: detout: false$ invert (m); RETURNS THE SAME THING.
@c IT APPEARS THAT doallmxops IS CRUCIAL HERE.

@end defvr

@deffn {Fun@value{cedilha}@~ao} diagmatrix (@var{n}, @var{x})
Retorna uma matriz diagonal de tamanho @var{n} por @var{n} com os
elementos da diagonal todos iguais a @var{x}.
@code{diagmatrix (@var{n}, 1)} retorna uma matriz identidade (o mesmo que @code{ident (@var{n})}).

@var{n} deve avaliar para um inteiro, de outra forma @code{diagmatrix} reclama com uma mensagem de erro.

@var{x} pode ser qualquer tipo de expres@~ao, incluindo outra matriz.
Se @var{x} @'e uma matriz, isso n@~ao @'e copiado; todos os elementos da diagonal referem-se @`a mesma inst@^ancia, @var{x}.

@c NEED EXAMPLE HERE
@end deffn

@defvr {Vari@'avel} doallmxops
Valor por omiss@~ao: @code{true}

Quando @code{doallmxops} @'e @code{true},
@c UMM, WHAT DOES THIS MEAN EXACTLY ??
todas as opera@value{cedilha}@~oes relacionadas a matrizes s@~ao realizadas.
Quando isso @'e @code{false} ent@~ao a escolha de
comutadores individuais @code{dot} governam quais opera@value{cedilha}@~oes s@~ao executadas.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'avel} domxexpt
Valor por omiss@~ao: @code{true}

Quando @code{domxexpt} @'e @code{true},
uma matriz exponencial, @code{exp (@var{M})} onde @var{M} @'e a matriz,
@'e interpretada como uma matriz com elementos @code{[i,j} iguais a @code{exp (m[i,j])}.
de outra forma @code{exp (@var{M})} avalia para @code{exp (@var{ev(M)}}.

@code{domxexpt}
afecta todas as expres@~oes da forma @code{@var{base}^@var{expoente}} onde @var{base} @'e uma
expres@~ao assumida escalar ou constante, e @var{expoente} @'e uma lista ou
matriz.

Exemplo:

@example
(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
@end example

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} domxmxops
Valor por omiss@~ao: @code{true}

Quando @code{domxmxops} @'e @code{true}, todas as opera@value{cedilha}@~oes matriz-matriz ou
matriz-lista s@~ao realizadas (mas n@~ao opera@value{cedilha}@~oes
escalar-matriz); se esse comutador @'e @code{false} tais opera@value{cedilha}@~oes n@~ao s@~ao.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} domxnctimes
Valor por omiss@~ao: @code{false}

Quando @code{domxnctimes} @'e @code{true}, produtos n@~ao comutativos de
matrizes s@~ao realizados.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dontfactor
Valor por omiss@~ao: @code{[]}

@code{dontfactor} pode ser escolhido para uma lista de vari@'aveis em rela@value{cedilha}@~ao
a qual factora@value{cedilha}@~ao n@~ao @'e para ocorrer.  (A lista @'e inicialmente vazia.)
Factora@value{cedilha}@~ao tamb@'em n@~ao pegar@'a lugares com rela@value{cedilha}@~ao a quaisquer vari@'aveis que
s@~ao menos importantes, conforme a hierarqu@'{@dotless{i}}a de vari@'avel assumida para a forma expres@~ao racional can@'onica (CRE),
que essas na lista @code{dontfactor}.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} doscmxops
Valor por omiss@~ao: @code{false}

Quando @code{doscmxops} @'e @code{true}, opera@value{cedilha}@~oes escalar-matriz s@~ao
realizadas.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} doscmxplus
Valor por omiss@~ao: @code{false}

Quando @code{doscmxplus} @'e @code{true}, opera@value{cedilha}@~oes escalar-matriz retornam
uma matriz resultado.  Esse comutador n@~ao @'e subsomado sob @code{doallmxops}.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dot0nscsimp
Valor por omiss@~ao: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{dot0nscsimp} @'e @code{true}, um produto n@~ao comutativo de zero
e um termo n@~ao escalar @'e simplificado para um produto comutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dot0simp
Valor por omiss@~ao: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{dot0simp} @'e @code{true},
um produto n@~ao comutativo de zero e
um termo escalar @'e simplificado para um produto n@~ao comutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dot1simp
Valor por omiss@~ao: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{dot1simp} @'e @code{true},
um produto n@~ao comutativo de um e
outro termo @'e simplificado para um produto comutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dotassoc
Valor por omiss@~ao: @code{true}

Quando @code{dotassoc} @'e @code{true}, uma expres@~ao @code{(A.B).C} simplifica para
@code{A.(B.C)}.
@c "." MEANS NONCOMMUTATIVE MULTIPLICATION RIGHT ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dotconstrules
Valor por omiss@~ao: @code{true}

Quando @code{dotconstrules} @'e @code{true}, um produto n@~ao comutativo de uma
constante e outro termo @'e simplificado para um produto comutativo.
@c TERMINOLOGY: (1) SWITCH/FLAG/SOME OTHER TERM ?? (2) ASSIGN/SET/TURN ON/SOME OTHER TERM ??
Ativando esse sinalizador efectivamente activamos @code{dot0simp}, @code{dot0nscsimp}, e
@code{dot1simp} tamb@'em.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dotdistrib
Valor por omiss@~ao: @code{false}

Quando @code{dotdistrib} @'e @code{true}, uma expres@~ao @code{A.(B + C)} simplifica para @code{A.B + A.C}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dotexptsimp
Valor por omiss@~ao: @code{true}

Quando @code{dotexptsimp} @'e @code{true}, uma expres@~ao @code{A.A} simplifica para @code{A^^2}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dotident
Valor por omiss@~ao: 1

@code{dotident} @'e o valor retornado por @code{X^^0}.
@c "RETURNED" ?? IS THIS A SIMPLIFICATION OR AN EVALUATION ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} dotscrules
Valor por omiss@~ao: @code{false}

Quando @code{dotscrules} @'e @code{true}, uma expres@~ao @code{A.SC} ou @code{SC.A} simplifica
para @code{SC*A} e @code{A.(SC*B)} simplifica para @code{SC*(A.B)}.
@c HMM, DOES "SC" MEAN "SCALAR" HERE ?? CLARIFY

@c NEED EXAMPLE HERE
@end defvr

@deffn {Fun@value{cedilha}@~ao} echelon (@var{M})
Retorna a forma escalonada da matriz @var{M},
como produzido atrav@'es da elimina@value{cedilha}@~ao de Gauss.
A forma escalonada @'e calculada de @var{M}
por opera@value{cedilha}@~oes elementares de linha tais que o primeiro
elemento n@~ao zero em cada linha na matriz resultante seja o n@'umero um e os
elementos da coluna abaixo do primeiro n@'umero um em cada linha sejam todos zero.

@code{triangularize} tamb@'em realiza elimina@value{cedilha}@~ao de Gaussian,
mas n@~ao normaliza o elemento l@'{@dotless{i}}der n@~ao nulo em cada linha.

@code{lu_factor} e @code{cholesky} s@~ao outras fun@value{cedilha}@~oes que retornam matrizes triangularizadas.

@c ===beg===
@c M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
@c echelon (M);
@c ===end===
@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} eigenvalues (@var{M})
@deffnx {Fun@value{cedilha}@~ao} eivals (@var{M})
@c eigen.mac IS AUTOLOADED IF eigenvalues OR eigenvectors IS REFERENCED; EXTEND THAT TO ALL FUNCTIONS ??
@c EACH FUNCTION INTENDED FOR EXTERNAL USE SHOULD HAVE ITS OWN DOCUMENTATION ITEM
Retorna uma lista de duas listas contendo os autovalores da matriz @var{M}.
A primeira sublista do valor de retorno @'e a lista de autovalores da
matriz, e a segunda sublista @'e a lista de
multiplicidade dos autovalores na ordem correspondente.

@code{eivals} @'e um sin@^onimo de @code{eigenvalues}.

@code{eigenvalues} chama a fun@value{cedilha}@~ao @code{solve} para achar as ra@'{@dotless{i}}zes do
polin@'omio caracter@'{@dotless{i}}stico da matriz.
Algumas vezes @code{solve} pode n@~ao estar habilitado a achar as ra@'{@dotless{i}}zes do polin@'omio;
nesse caso algumas outras fun@value{cedilha}@~oes nesse
pacote (except @code{innerproduct}, @code{unitvector}, @code{columnvector} e
@code{gramschmidt}) n@~ao ir@~ao trabalhar.
@c WHICH ONES ARE THE FUNCTIONS WHICH DON'T WORK ??
@c ACTUALLY IT'S MORE IMPORTANT TO LIST THE ONES WHICH DON'T WORK HERE
@c WHAT DOES "will not work" MEAN, ANYWAY ??

Em alguns casos os autovalores achados por @code{solve} podem ser expres@~oes complicadas.
(Isso pode acontecer quando @code{solve} retorna uma expres@~ao real n@~ao trivial
para um autovalor que @'e sabidamente real.)
Isso pode ser poss@'{@dotless{i}}vel para simplificar os autovalores usando algumas outras fun@value{cedilha}@~oes.
@c WHAT ARE THOSE OTHER FUNCTIONS ??

O pacote @code{eigen.mac} @'e chamado automaticamente quando
@code{eigenvalues} ou @code{eigenvectors} @'e referenciado.
Se @code{eigen.mac} n@~ao tiver sido ainda chamado,
@code{load ("eigen")} chama-o.
Ap@'os ser chamado, todas as fun@value{cedilha}@~oes e vari@'aveis no pacote estar@~ao dispon@'{@dotless{i}}veis.
@c REFER TO OVERVIEW OF PACKAGE (INCLUDING LIST OF FUNCTIONS) HERE

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} eigenvectors (@var{M})
@deffnx {Fun@value{cedilha}@~ao} eivects (@var{M})
pegam uma matriz @var{M} como seu argumento e retorna uma lista
de listas cuja primeira sublista @'e a sa@'{@dotless{i}}da de @code{eigenvalues}
e as outras sublistas s@~ao os autovectores da
matriz correspondente para esses autovalores respectivamente.

@code{eivects} @'e um sin@^onimo para @code{eigenvectors}.

O pacote @code{eigen.mac} @'e chamado automaticamente quando
@code{eigenvalues} ou @code{eigenvectors} @'e referenciado.
Se @code{eigen.mac} n@~ao tiver sido ainda chamado,
@code{load ("eigen")} chama-o.
Ap@'os ser chamado, todas as fun@value{cedilha}@~oes e vari@'aveis no pacote estar@~ao dispon@'{@dotless{i}}veis.

Os sinalizadores que afectam essa fun@value{cedilha}@~ao s@~ao:

@code{nondiagonalizable} @'e escolhido para @code{true} ou @code{false} dependendo de
se a matriz @'e n@~ao diagonaliz@'avel ou diagonaliz@'avel ap@'os o
retorno de @code{eigenvectors}.

@code{hermitianmatrix} quando @code{true}, faz com que os autovectores
degenerados da matriz Hermitiana sejam ortogonalizados usando o
algoritmo de Gram-Schmidt.

@code{knowneigvals} quando @code{true} faz com que o pacote @code{eigen} assumir que os
autovalores da matriz s@~ao conhecidos para o utilizador e armazenados sob o
nome global @code{listeigvals}.  @code{listeigvals} poder@'a ser escolhido para uma lista similar
@`a sa@'{@dotless{i}}da de @code{eigenvalues}.

A fun@value{cedilha}@~ao @code{algsys} @'e usada aqui para resolver em rela@value{cedilha}@~ao aos autovectores.  Algumas vezes se os
autovalores est@~ao aus@^entes, @code{algsys} pode n@~ao estar habilitado a achar uma solu@value{cedilha}@~ao.
Em alguns casos, isso pode ser poss@'{@dotless{i}}vel para simplificar os autovalores por
primeiro achando e ent@~ao usando o comando @code{eigenvalues} e ent@~ao usando outras fun@value{cedilha}@~oes
para reduzir os autovalores a alguma coisa mais simples.
Continuando a simplifica@value{cedilha}@~ao, @code{eigenvectors} pode ser chamada novamente
com o sinalizador @code{knowneigvals} escolhido para @code{true}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ematrix (@var{m}, @var{n}, @var{x}, @var{i}, @var{j})
Retorna uma matriz @var{m} por @var{n}, todos os elementos da qual
s@~ao zero excepto para o elemento @code{[@var{i}, @var{j}]} que @'e @var{x}.
@c WOW, THAT SEEMS PRETTY SPECIALIZED ...

@end deffn

@deffn {Fun@value{cedilha}@~ao} entermatrix (@var{m}, @var{n})
Retorna uma matriz @var{m} por @var{n}, lendo os elementos interativamente.

Se @var{n} @'e igual a @var{m},
Maxima pergunta pelo tipo de matriz (diagonal, sim@'etrica, antisim@'etrica, ou gen@'erica)
e por cada elemento.
Cada resposta @'e terminada por um ponto e v@'{@dotless{i}}rgula @code{;} ou sinal de d@'olar @code{$}.

Se @var{n} n@~ao @'e igual a @var{m},
Maxima pergunta por cada elemento.

Os elementos podem ser quaisquer express@~oes, que s@~ao avaliadas.
@code{entermatrix} avalia seus argumentos.

@example
(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matriz entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1}, @var{j_1})
@deffnx {Fun@value{cedilha}@~ao} genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1})
@deffnx {Fun@value{cedilha}@~ao} genmatrix (@var{a}, @var{i_2}, @var{j_2})
Retorna uma matriz gerada de @var{a},
pegando o elemento @code{@var{a}[@var{i_1},@var{j_1}]}
como o elemento do canto superior esquerdo e @code{@var{a}[@var{i_2},@var{j_2}]}
como o elemento do canto inferior directo da matriz.
Aqui @var{a} @'e um array declarado (criado atrav@'es de @code{array} mas n@~ao por meio de @code{make_array})
ou um array n@~ao declarado,
ou uma fun@value{cedilha}@~ao array,
ou uma express@~ao lambda de dois argumentos.
(Uma fun@value{cedilha}@~aO array @'e criado como outras fun@value{cedilha}@~oes com @code{:=} ou @code{define},
mas os argumentos s@~ao colocados entre colch@^etes em lugar de par@^entesis.)

Se @var{j_1} @'e omitido, isso @'e assumido ser igual a @var{i_1}.
Se ambos @var{j_1} e @var{i_1} s@~ao omitidos, ambos s@~ao assumidos iguais a 1.

Se um elemento seleccionado @code{i,j} de um array for indefinido,
a matriz conter@'a um elemento simb@'olico @code{@var{a}[i,j]}.

Exemplos:

@c ===beg===
@c h [i, j] := 1 / (i + j - 1);
@c genmatrix (h, 3, 3);
@c array (a, fixnum, 2, 2);
@c a [1, 1] : %e;
@c a [2, 2] : %pi;
@c genmatrix (a, 2, 2);
@c genmatrix (lambda ([i, j], j - i), 3, 3);
@c genmatrix (B, 2, 2);
@c ===end===
@example
(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} gramschmidt (@var{x})
@deffnx {Fun@value{cedilha}@~ao} gschmit (@var{x})
Realiza o algoritmo de ortonaliza@value{cedilha}@~ao de Gram-Schmidt sobre @var{x},
seja ela uma matriz ou uma lista de listas.
@var{x} n@~ao @'e modificado por @code{gramschmidt}.

Se @var{x} @'e uma matriz, o algoritmo @'e aplicado para as linhas de @var{x}.
Se @var{x} @'e uma lista de listas, o algoritmo @'e aplicado @`as sublistas,
que devem ter igual n@'umeros de elementos.
Nos dois casos,
o valor de retorno @'e uma lista de listas, as sublistas das listas s@~ao ortogonais
e gera o mesmo spa@value{cedilha}o que @var{x}.
Se a dimens@~ao do conjunto gerador de @var{x} @'e menor que o n@'umero de linhas ou sublistas,
algumas sublistas do valor de retorno s@~ao zero.

@code{factor} @'e chamada a cada est@'agio do algoritmo para simplificar resultados interm@'edios.
Como uma consequ@^encia, o valor de retorno pode conter inteiros factorados.

@code{gschmit} (nota ortogr@'afica) @'e um sin@^onimo para @code{gramschmidt}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~ao.

Exemplo:

@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovectores
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) i: innerproduct$
(%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
(%o5)                       [0, 0, 0]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} ident (@var{n})
Retorna uma matriz identidade @var{n} por @var{n}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} innerproduct (@var{x}, @var{y})
@deffnx {Fun@value{cedilha}@~ao} inprod (@var{x}, @var{y})
Retorna o produto interno (tamb@'em chamado produto escalar ou produto do ponto) de @var{x} e @var{y},
que s@~ao listas de igual comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual comprimento.
O valor de retorno @'e @code{conjugate (x) . y},
onde @code{.} @'e o operador de multiplica@value{cedilha}@~ao n@~ao comutativa.

@code{load ("eigen")} chama essa fun@value{cedilha}@~ao.

@code{inprod} @'e um sin@^onimo para @code{innerproduct}.

@c NEED EXAMPLE HERE
@end deffn

@c THIS DESCRIPTION NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} invert (@var{M})
Retorna a inversa da matriz @var{M}.
A inversa @'e calculada pelo m@'etodo adjunto.

Isso permite a um utilizador calcular a inversa de uma matriz com
entradas bfloat ou polin@'omios com coeficientes em ponto flutuante sem
converter para a forma CRE.

Cofactores s@~ao calculados pela fun@value{cedilha}@~ao  @code{determinant},
ent@~ao se @code{ratmx} @'e @code{false} a inversa @'e calculada
sem mudar a representa@value{cedilha}@~ao dos elementos.

A implementa@value{cedilha}@~ao
corrente @'e ineficiente para matrizes de alta ordem.

Quando @code{detout} @'e @code{true}, o determinante @'e factorado fora da
inversa.

Os elementos da inversa n@~ao s@~ao automaticamente expandidos.
Se @var{M} tem elementos polinomiais, melhor apar@^encia de sa@'{@dotless{i}}da pode ser
gerada por @code{expand (invert (m)), detout}.
Se isso @'e desej@'avel para ela
divis@~ao at@'e pelo determinante pode ser excelente por @code{xthru (%)}
ou alternativamente na unha por

@example
expe (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
@end example

Veja @code{^^} (expoente n@~ao comutativo) para outro m@'etodo de inverter uma matriz.

@c NEED EXAMPLE HERE
@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} lmxchar
Valor por omiss@~ao: @code{[}

@code{lmxchar} @'e o caractere mostrado como o delimitador
esquerdo de uma matriz.
Veja tamb@'em @code{rmxchar}.

Exemplo:

@example
(%i1) lmxchar: "|"$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
@end example

@end defvr

@deffn {Fun@value{cedilha}@~ao} matrix (@var{row_1}, ..., @var{row_n})
Retorna uma matriz retangular que tem as linhas @var{row_1}, ..., @var{row_n}.
Cada linha @'e uma lista de express@~oes.
Todas as linhas devem ter o mesmo comprimento.

As opera@value{cedilha}@~oes @code{+} (adi@value{cedilha}@~ao), @code{-} (subtra@value{cedilha}@~ao), @code{*} (multiplica@value{cedilha}@~ao),
e @code{/} (divis@~ao), s@~ao realizadas elemento por elemento
quando os operandos s@~ao duas matrizes, um escalar e uma matriz, ou uma matriz e um escalar.
A opera@value{cedilha}@~ao @code{^} (exponencia@value{cedilha}@~ao, equivalentemente @code{**})
@'e realizada elemento por elemento
se os operandos s@~ao um escalar e uma matriz ou uma matriz e um escalar,
mas n@~ao se os operandos forem duas matrizes.
@c WHAT DOES THIS NEXT PHRASE MEAN EXACTLY ??
Todos as opera@value{cedilha}@~oes s@~ao normalmente realizadas de forma completa,
incluindo @code{.} (multiplica@value{cedilha}@~ao n@~ao comutativa).

Multiplica@value{cedilha}@~ao de matrizes @'e representada pelo operador de multiplica@value{cedilha}@~ao n@~ao comutativa @code{.}.
O correspondente operador de exponencia@value{cedilha}@~ao n@~ao comutativa @'e @code{^^}.
Para uma matriz @code{@var{A}}, @code{@var{A}.@var{A} = @var{A}^^2} e
@code{@var{A}^^-1} @'e a inversa de @var{A}, se existir.

Existem comutadores para controlar a simplifica@value{cedilha}@~ao de expres@~oes
envolvendo opera@value{cedilha}@~oes escalar e matriz-lista.
S@~ao eles
@code{doallmxops}, @code{domxexpt}
@code{domxmxops}, @code{doscmxops}, e @code{doscmxplus}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Existem op@value{cedilha}@~oes adicionais que s@~ao relacionadas a matrizes.  S@~ao elas:
@code{lmxchar}, @code{rmxchar}, @code{ratmx}, @code{listarith}, @code{detout},
@code{scalarmatrix},
e @code{sparse}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Existe um n@'umero de
fun@value{cedilha}@~oes que pegam matrizes como argumentos ou devolvem matrizes como valor de retorno.
Veja @code{eigenvalues}, @code{eigenvectors},
@code{determinant},
@code{charpoly}, @code{genmatrix}, @code{addcol}, @code{addrow}, 
@code{copymatrix}, @code{transpose}, @code{echelon},
e @code{rank}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Exemplos:

@itemize @bullet
@item
Constru@value{cedilha}@~ao de matrizes de listas.
@end itemize
@example
(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
@end example
@itemize @bullet
@item
Adi@value{cedilha}@~ao, elemento por elemento.
@end itemize
@example
(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
@end example
@itemize @bullet
@item
Subtra@value{cedilha}@~ao, elemento por elemento.
@end itemize
@example
(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
@end example
@itemize @bullet
@item
Multiplica@value{cedilha}@~ao, elemento por elemento.
@end itemize
@example
(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
@end example
@itemize @bullet
@item
Divis@~ao, elemento por elemento.
@end itemize
@example
(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
@end example
@itemize @bullet
@item
Matriz para um expoente escalar, elemento por elemento.
@end itemize
@example
(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
@end example
@itemize @bullet
@item
Base escalar para um expoente matriz, elemento por elemento.
@end itemize
@example
(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
Base matriz para um expoente matriz.  Essa n@~ao @'e realizada elemento por elemento.
@c WHAT IS THIS ??
@end itemize
@example
(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
@end example
@itemize @bullet
@item
Multiplica@value{cedilha}@~ao n@~ao comutativa de matrizes.
@end itemize
@example
(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
@end example
@itemize @bullet
@item
Exponencia@value{cedilha}@~ao n@~ao comutativa de matrizes.
Uma base escalar @var{b} para uma pot@^encia matriz @var{M}
@'e realizada elemento por elemento e ent@~ao @code{b^^m} @'e o mesmo que @code{b^m}.
@end itemize
@example
(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
A matriz elevada a um expoente -1 com exponencia@value{cedilha}@~ao n@~ao comutativa @'e a matriz inversa,
se existir.
@end itemize
@example
(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} matrixmap (@var{f}, @var{M})
Retorna uma matriz com elemento @code{i,j} igual a @code{@var{f}(@var{M}[i,j])}.

Veja tamb@'em @code{map}, @code{fullmap}, @code{fullmapl}, e @code{apply}.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} matrixp (@var{expr})
Retorna @code{true} se @var{expr} @'e uma matriz, de outra forma retorna @code{false}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} matrix_element_add
Valor por omiss@~ao: @code{+}

@code{matrix_element_add} @'e a opera@value{cedilha}@~ao 
invocada em lugar da adi@value{cedilha}@~ao em uma multiplica@value{cedilha}@~ao de matrizes.
A @code{matrix_element_add} pode ser atribu@'{@dotless{i}}do qualquer operador n-@'ario
(que @'e, uma fun@value{cedilha}@~ao que manuseia qualquer n@'umero de argumentos).
Os valores atribu@'{@dotless{i}}dos podem ser o nome de um operador entre aspas duplas,
o nome da fun@value{cedilha}@~ao,
ou uma express@~ao lambda.

Veja tamb@'em @code{matrix_element_mult} e @code{matrix_element_transpose}.

Exemplo:

@example
(%i1) matrix_element_add: "*"$
(%i2) matrix_element_mult: "^"$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
@end example

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} matrix_element_mult
Valor por omiss@~ao: @code{*}

@code{matrix_element_mult} @'e a opera@value{cedilha}@~ao
invocada em lugar da multiplica@value{cedilha}@~ao em uma multiplica@value{cedilha}@~ao de matrizes.
A @code{matrix_element_mult} pode ser atribu@'{@dotless{i}}do qualquer operador bin@'ario.
O valor atribu@'{@dotless{i}}do pode ser o nome de um operador entre aspas duplas,
o nome de uma fun@value{cedilha}@~ao,
ou uma express@~ao lambda.

O operador do ponto @code{.} @'e uma escolha @'util em alguns contextos.

Veja tamb@'em @code{matrix_element_add} e @code{matrix_element_transpose}.

Exemplo:

@example
(%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
@end example

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} matrix_element_transpose
Valor por omiss@~ao: @code{false}

@code{matrix_element_transpose} @'e a opera@value{cedilha}@~ao
aplicada a cada elemento de uma matriz quando for uma transposta.
A @code{matrix_element_mult} pode ser atribu@'{@dotless{i}}do qualquer operador un@'ario.
O valor atribu@'{@dotless{i}}do pode ser  nome de um operador entre aspas duplas,
o nome de uma fun@value{cedilha}@~ao,
ou uma express@~ao lambda.

Quando @code{matrix_element_transpose} for igual a @code{transpose},
a fun@value{cedilha}@~ao  @code{transpose} @'e aplicada a todo elemento.
Quando @code{matrix_element_transpose} for igual a @code{nonscalars},
a fun@value{cedilha}@~ao @code{transpose} @'e aplicada a todo elemento n@~ao escalar.
Se algum elemento @'e um @'atomo, a op@value{cedilha}@~ao @code{nonscalars} aplica
@code{transpose} somente se o @'atomo for declarado n@~ao escalar,
enquanto a op@value{cedilha}@~ao @code{transpose} sempre aplica @code{transpose}.

O valor padr@~ao, @code{false}, significa nenhuma opera@value{cedilha}@~ao @'e aplicada.

Veja tamb@'em @code{matrix_element_add} e @code{matrix_element_mult}.

Exemplos:

@example
(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
@end example

@end defvr

@c IS THIS THE ONLY MATRIX TRACE FUNCTION ??
@deffn {Fun@value{cedilha}@~ao} mattrace (@var{M})
Retorna o tra@value{cedilha}o (que @'e, a soma dos elementos sobre a diagonal principal) da
matriz quadrada @var{M}.  

@code{mattrace} @'e chamada por @code{ncharpoly},
uma alternativa para @code{charpoly} do Maxima.
@c UMM, HOW IS THAT RELEVANT HERE ??

@code{load ("nchrpl")} chama essa fun@value{cedilha}@~ao.

@end deffn

@deffn {Fun@value{cedilha}@~ao} minor (@var{M}, @var{i}, @var{j})
Retorna o @var{i}, @var{j} menor do elemento localizado na linha @var{i} coluna @var{j} da matriz @var{M}.  Que @'e @var{M}
com linha @var{i} e coluna @var{j} ambas removidas.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ncexpt (@var{a}, @var{b})
Se uma express@~ao exponencial n@~ao comutativa @'e muito
alta para ser mostrada como @code{@var{a}^^@var{b}} aparecer@'a como @code{ncexpt (@var{a},@var{b})}.

@code{ncexpt} n@~ao @'e o nome de uma fun@value{cedilha}@~ao ou operador;
o nome somente aparece em sa@'{@dotless{i}}das, e n@~ao @'e reconhecido em entradas.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ncharpoly (@var{M}, @var{x})
Retorna o polin@'omio caracter@'{@dotless{i}}stico da matriz @var{M}
com rela@value{cedilha}@~ao a @var{x}.  Essa @'e uma alternativa para @code{charpoly} do Maxima.

@code{ncharpoly} trabalha pelo c@'alculo dos tra@value{cedilha}os das pot@^encias na dada matriz,
que s@~ao sabidos serem iguais a somas de pot@^encias das ra@'{@dotless{i}}zes do
polin@'omio caracter@'{@dotless{i}}stico.  Para essas quantidade a fun@value{cedilha}@~ao
sim@'etrica das ra@'{@dotless{i}}zes pode ser calculada, que nada mais s@~ao que
os coeficientes do polin@'omio caracter@'{@dotless{i}}stico.  @code{charpoly} trabalha
@c SHOULD THAT BE "m" INSTEAD OF "a" IN THE NEXT LINE ??
formatando o determinante de @code{@var{x} * ident [n] - a}.  Dessa forma @code{ncharpoly} @'e vencedor,
por exemplo, no caso de largas e densas matrizes preencidas com inteiros,
desde que isso evite inteiramente a aritm@'etica polinomial.

@code{load ("nchrpl")} loads this file.

@end deffn

@deffn {Fun@value{cedilha}@~ao} newdet (@var{M}, @var{n})
Calcula o determinante de uma matriz ou array @var{M} pelo
algoritmo da @'arvore menor de Johnson-Gentleman.
@c UGH -- ARRAYS ARE SUCH A MESS
O argumento @var{n} @'e a ordem; isso @'e opcional se @var{M} for uma matriz.

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@defvr {Declara@value{cedilha}@~ao} nonscalar
Faz @'atomos ser comportarem da mesma forma que uma lista ou matriz em rela@value{cedilha}@~ao ao
operador do ponto.

@end defvr

@deffn {Fun@value{cedilha}@~ao} nonscalarp (@var{expr})
Retorna @code{true} se @var{expr} @'e um n@~ao escalar, i.e., isso cont@'em
@'atomos declarados como n@~ao escalares, listas, ou matrizes.

@end deffn

@deffn {Fun@value{cedilha}@~ao} permanent (@var{M}, @var{n})
Calcula o permanente da matriz @var{M}.  Um permanente
@'e como um determinante mas sem mudan@value{cedilha}a de sinal.

@end deffn

@deffn {Fun@value{cedilha}@~ao} rank (@var{M})
Calcula o posto da matriz @var{M}.  Que @'e, a ordem do
mais largo determinante n@~ao singular de @var{M}.

@c STATEMENT NEEDS CLARIFICATION
@var{rank} pode retornar uma
resposta ruim se n@~ao puder determinar que um elemento da matriz que @'e
equivalente a zero @'e realmente isso.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratmx
Valor por omiss@~ao: @code{false}

Quando @code{ratmx} @'e @code{false}, adi@value{cedilha}@~ao, subtra@value{cedilha}@~ao,
e multiplica@value{cedilha}@~ao para determinantes e matrizes s@~ao executados na
representa@value{cedilha}@~ao dos elementos da matriz e fazem com que o resultado da
invers@~ao de matrizes seja esquerdo na representa@value{cedilha}@~ao geral.

Quando @code{ratmx} @'e @code{true},
as 4 opera@value{cedilha}@~oes mencionadas acima s@~ao executadas na forma CRE e o
resultado da matriz inversa @'e dado na forma CRE.  Note isso pode
fazer com que os elementos sejam expandidos (dependendo da escolha de @code{ratfac})
o que pode n@~ao ser desejado sempre.

@end defvr

@deffn {Fun@value{cedilha}@~ao} row (@var{M}, @var{i})
retorna a @var{i}'@'esima linha da matriz @var{M}.
O valor de retorno @'e uma matriz.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} scalarmatrixp
Valor por omiss@~ao: @code{true}

Quando @code{scalarmatrixp} @'e @code{true}, ent@~ao sempre que uma matriz 1 x 1
@'e produzida como um resultado de c@'alculos o produto do ponto de matrizes 
@'e simplificado para um escalar, a saber o elemento solit@'ario da matriz.

Quando @code{scalarmatrixp} @'e @code{all},
ent@~ao todas as matrizes 1 x 1 ser@~ao simplificadas para escalares.

Quando @code{scalarmatrixp} @'e @code{false}, matrizes 1 x 1 n@~ao s@~ao simplificadas para escalares.

@end defvr

@c I WONDER WHAT THIS IS ABOUT
@deffn {Fun@value{cedilha}@~ao} scalefactors (@var{coordinatetransform})
Aqui coordinatetransform
avalia para a forma [[expres@~ao1, expres@~ao2, ...],
indetermina@value{cedilha}@~ao1, indetermina@value{cedilha}@~ao2, ...], onde indetermina@value{cedilha}@~ao1,
indetermina@value{cedilha}@~ao2, etc.  s@~ao as vari@'aveis de coordenadas curvil@'{@dotless{i}}neas e
onde a escolha de componentes cartesianas retangulares @'e dada em termos das
coordenadas curvil@'{@dotless{i}}neas por [expres@~ao1, expres@~ao2, ...].
@code{coordinates} @'e escolhida para o vector [indetermina@value{cedilha}@~ao1, indetermina@value{cedilha}@~ao2,...],
e @code{dimension} @'e escolhida para o comprimento desse vector.  SF[1], SF[2],
..., SF[DIMENSION] s@~ao escohidos para factores de escala de coordenada, e @code{sfprod}
@'e escohido para o produto desse factores de escala.  Inicialmente, @code{coordinates}
@'e [X, Y, Z], @code{dimension} @'e 3, e SF[1]=SF[2]=SF[3]=SFPROD=1,
correspondendo a coordenadas Cartesianas retangulares 3-dimensional.
Para expandir uma expres@~ao dentro de componentes f@'{@dotless{i}}sicos no sistema de coordenadas
corrente , existe uma fun@value{cedilha}@~ao com uso da forma
@c SOME TEXT HAS GONE MISSING HERE

@end deffn

@deffn {Fun@value{cedilha}@~ao} setelmx (@var{x}, @var{i}, @var{j}, @var{M})
Atribue @var{x} para o (@var{i}, @var{j})'@'esimo elemento da matriz @var{M},
e retorna a matriz alterada.

@code{@var{M} [@var{i}, @var{j}]: @var{x}} tem o mesmo efeito,
mas retorna @var{x} em lugar de @var{M}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} similaritytransform (@var{M})
@deffnx {Fun@value{cedilha}@~ao} simtran (@var{M})
@code{similaritytransform} calcula uma transforma@value{cedilha}@~ao homot@'etica da matriz @code{M}.
Isso retorna uma lista que @'e a sa@'{@dotless{i}}da do
comando @code{uniteigenvectors}.  Em adi@value{cedilha}@~ao se o sinalizador @code{nondiagonalizable}
@'e @code{false} duas matrizes globais @code{leftmatrix} e @code{rightmatrix} s@~ao calculadas.
Essas matrizes possuem a propriedade de
@code{leftmatrix . @var{M} . rightmatrix} @'e uma matriz diagonal com os autovalores
de @var{M} sobre a diagonal.  Se @code{nondiagonalizable} @'e @code{true} as matrizes esquerda e
direita n@~ao s@~ao computadas.

Se o sinalizador @code{hermitianmatrix} @'e @code{true}
ent@~ao @code{leftmatrix} @'e o conjugado complexo da transposta de
@code{rightmatrix}.  De outra forma @code{leftmatrix} @'e a inversa de @code{rightmatrix}.

@code{rightmatrix} @'e a matriz cujas colunas s@~ao os autovectores
unit@'arios de @var{M}.  Os outros sinalizadores (veja @code{eigenvalues} e
@code{eigenvectors}) possuem o mesmo efeito desde que
@code{similaritytransform} chama as outras fun@value{cedilha}@~oes no pacote com o objectivo de
estar habilitado para a forma @code{rightmatrix}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~ao.

@code{simtran} @'e um sin@^onimo para @code{similaritytransform}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} sparse
Valor por omiss@~ao: @code{false}

Quando @code{sparse} @'e @code{true}, e se @code{ratmx} @'e @code{true}, ent@~ao @code{determinant}
usar@'a rotinas especiais para calcular determinantes esparsos.

@end defvr

@deffn {Fun@value{cedilha}@~ao} submatrix (@var{i_1}, ..., @var{i_m}, @var{M}, @var{j_1}, ..., @var{j_n})
@deffnx {Fun@value{cedilha}@~ao} submatrix (@var{i_1}, ..., @var{i_m}, @var{M})
@deffnx {Fun@value{cedilha}@~ao} submatrix (@var{M}, @var{j_1}, ..., @var{j_n})
Retorna uma nova matriz formada pela
matrix @var{M} com linhas @var{i_1}, ..., @var{i_m} exclu@'{@dotless{i}}das, e colunas @var{j_1}, ..., @var{j_n} exclu@'{@dotless{i}}das.

@end deffn

@deffn {Fun@value{cedilha}@~ao} transpose (@var{M})
Retorna a transposta de @var{M}.

Se @var{M} @'e uma matriz, o valor de retorno @'e outra matriz @var{N}
tal que @code{N[i,j] = M[j,i]}.

Se @var{M} for uma lista, o valor de retorno @'e uma matrix @var{N}
de @code{length (m)} linhas e 1 coluna, tal que @code{N[i,1] = M[i]}.

De outra forma @var{M} @'e um s@'{@dotless{i}}mbolo,
e o valor de retorno @'e uma express@~ao substantiva @code{'transpose (@var{M})}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} triangularize (@var{M})
Retorna a maior forma triangular da matriz @code{M}, como produzido atrav@'es da elimina@value{cedilha}@~ao de Gauss.
O valor de retorno @'e o mesmo que @code{echelon},
excepto que o o coeficiente lider n@~ao nulo em cada linha n@~ao @'e normalizado para 1.

@code{lu_factor} e @code{cholesky} s@~ao outras fun@value{cedilha}@~oes que retornam matrizes triangularizadas.

@c ===beg===
@c M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
@c triangularize (M);
@c ===end===
@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} uniteigenvectors (@var{M})
@deffnx {Fun@value{cedilha}@~ao} ueivects (@var{M})
Calcula autovectores unit@'arios da matriz @var{M}.
O valor de retorno @'e uma lista de listas, a primeiro sublista @'e a
sa@'{@dotless{i}}da do comando @code{eigenvalues}, e as outras sublistas s@~ao
os autovectores unit@'arios da matriz correspondente a esses autovalores
respectivamente.

@c COPY DESCRIPTIONS OF THOSE FLAGS HERE
Os sinalizadores mencionados na descri@value{cedilha}@~ao do
comando @code{eigenvectors} possuem o mesmo efeito aqui tamb@'em.

Quando @code{knowneigvects} @'e @code{true}, o pacote @code{eigen} assume
que os autovectores da matriz s@~ao conhecidos para o utilizador s@~ao
armazenados sob o nome global @code{listeigvects}.  @code{listeigvects} pode ser ecolhido
para uma lista similar @`a sa@'{@dotless{i}}da do comando @code{eigenvectors}.

@c FOLLOWING PARAGRAPH IS IN NEED OF SERIOUS CLARIFICATION
Se @code{knowneigvects} @'e escolhido para @code{true} e a lista de autovectores @'e dada a
escolha do sinalizador @code{nondiagonalizable} pode n@~ao estar correcta.  Se esse @'e
o caso por favor ecolha isso para o valor correcto.  O autor assume que
o utilizador sabe o que est@'a fazendo e que n@~ao tentar@'a diagonalizar uma
matriz cujos autovectores n@~ao geram o mesmo espa@value{cedilha}o vectorial de
dimens@~ao apropriada.

@code{load ("eigen")} chama essa fun@value{cedilha}@~ao.

@code{ueivects} @'e um sin@^onimo para @code{uniteigenvectors}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} unitvector (@var{x})
@deffnx {Fun@value{cedilha}@~ao} uvect (@var{x})
Retorna @math{@var{x}/norm(@var{x})};
isso @'e um vector unit@'ario na mesma dire@value{cedilha}@~ao que @var{x}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~ao.

@code{uvect} @'e um sin@^onimo para @code{unitvector}.

@end deffn

@c NEEDS A LOT OF WORK: MAKE SURE THAT ALL VECTOR SIMPLIFICATION FLAGS HAVE A DESCRIPTION HERE
@deffn {Fun@value{cedilha}@~ao} vectorsimp (@var{expr})
Aplica simplifica@value{cedilha}@~oes e expans@~oes conforme
os seguintes sinalizadores globais:

@code{expandall}, @code{expanddot}, @code{expanddotplus}, @code{expandcross}, @code{expandcrossplus},
@code{expandcrosscross}, @code{expandgrad}, @code{expandgradplus}, @code{expandgradprod},
@code{expanddiv}, @code{expanddivplus}, @code{expanddivprod}, @code{expandcurl}, @code{expandcurlplus},
@code{expandcurlcurl}, @code{expandlaplacian}, @code{expandlaplacianplus},
e @code{expandlaplacianprod}.

Todos esses sinalizadores possuem valor padr@~ao @code{false}.  O sufixo @code{plus} refere-se a
utiliza@value{cedilha}@~ao aditivamente ou distribuitivamente.  O sufixo @code{prod} refere-se a
expans@~ao para um operando que @'e qualquer tipo de produto.

@table @code
@item expandcrosscross
Simplifica @math{p ~ (q ~ r)} para @math{(p . r)*q - (p . q)*r}.
@item expandcurlcurl
Simplifica @math{curl curl p} para @math{grad div p + div grad p}.
@item expandlaplaciantodivgrad
Simplifica @math{laplacian p} para @math{div grad p}.
@item expandcross
Habilita @code{expandcrossplus} e @code{expandcrosscross}.
@item expandplus
Habilita @code{expanddotplus}, @code{expandcrossplus}, @code{expandgradplus},
@code{expanddivplus}, @code{expandcurlplus}, e @code{expandlaplacianplus}.
@item expandprod
Habilita @code{expandgradprod}, @code{expanddivprod}, e @code{expandlaplacianprod}.
@end table

@c EXPLAIN THE IMPORT OF THIS STATEMENT
Esses sinalizadores foram todos declarados @code{evflag}.

@c SEEMS SOME TEXT HAS GONE MISSING HERE; COMMENT OUT FRAGMENT PENDING
@c RECOVERY AND/OR RECONSTRUCTION OF THIS PARAGRAPH
@c For orthogonal curvilinear coordinates, the global variables
@c COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] s@~ao set
@c by the function invocation

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} vect_cross
Valor por omiss@~ao: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{vect_cross} @'e @code{true}, isso permite DIFF(X~Y,T) trabalhar onde
~ @'e definido em SHARE;VECT (onde VECT_CROSS @'e escolhido para @code{true}, de qualqeur modo.)

@end defvr

@deffn {Fun@value{cedilha}@~ao} zeromatrix (@var{m}, @var{n})
Retorna um matriz @var{m} por @var{n}, com todos os elementos sendo zero.

@end deffn

@defvr {S@'{@dotless{i}}mbolo especial} [
@defvrx {S@'{@dotless{i}}mbolo especial} ]
@ifinfo
@fnindex Delimitador de Lista
@fnindex Operador de Subscrito
@end ifinfo
@code{[} e @code{]} marcam o ome@value{cedilha}o e o fim, respectivamente, de uma lista.

@code{[} e @code{]} tamb@'em envolvem os subscritos de
uma lista, array, array desordenado, ou fun@value{cedilha}@~ao array.

Exemplos:

@example
(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
@end example

@end defvr
