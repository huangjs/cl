@c /Operators.texi/1.37/Fri Mar  2 00:44:42 2007/-ko/
@iftex
@hyphenation{con-se-cu-ti-vos}
@hyphenation{u-san-do}
@end iftex
@menu
* N-Argumentos::                        
* Operador n@~ao fixado::                       
* Operador P@'osfixado::                     
* Operador Pr@'efixado::                      
* Operadores Aritm@'eticos::   
* Operadores Relacionais::   
* Operadores Geral::   
@end menu


@node N-Argumentos, Operador n@~ao fixado, Operadores, Operadores
@section N-Argumentos
Um operador @code{nary} @'e usado para denotar uma fun@value{cedilha}@~ao com qualquer n@'umero de
argumentos, cada um dos quais @'e separado por uma ocorr@^encia do
operador, e.g. A+B ou A+B+C.  A fun@value{cedilha}@~ao @code{nary("x")}  @'e uma fun@value{cedilha}@~ao
de extens@~ao sint@'atica para declarar x como sendo um operador @code{nary}.
Fun@value{cedilha}@~oes podem ser declaradas para serem
@code{nary}.  Se @code{declare(j,nary);} @'e conclu@'{@dotless{i}}da, diz ao simplicador para
simplificar, e.g. @code{j(j(a,b),j(c,d))} para @code{j(a, b, c, d)}.

Veja tamb@'em @code{syntax}.

@node Operador n@~ao fixado, Operador P@'osfixado, N-Argumentos, Operadores
@section Operador n@~ao fixado
Operadores @code{nofix} s@~ao usados para denotar fun@value{cedilha}@~oes sem argumentos.
A mera presen@value{cedilha}a de tal operador em um comando far@'a com que a
fun@value{cedilha}@~ao correspondente seja avaliada.  Por exemplo, quando se digita
"exit;" para sair de uma parada do Maxima, "exit" tem comportamento similar a um
operador @code{nofix}.  A fun@value{cedilha}@~ao @code{nofix("x")} @'e uma fun@value{cedilha}@~ao de extens@~ao
sint@'atica que declara x como sendo um operador @code{nofix}. 

Veja tamb@'em @code{syntax}.

@node Operador P@'osfixado, Operador Pr@'efixado, Operador n@~ao fixado, Operadores
@section Operador P@'osfixado
Operadores @code{postfix} como a variedade @code{prefix} denotam fun@value{cedilha}@~oes
de um argumento simples, mas nesse caso  o argumento sucede
imediatamente uma ocorr@^encia do operador na sequ@^encia de caracteres de entrada, e.g. 3! .
Uma fun@value{cedilha}@~ao @code{postfix("x")} @'e uma fun@value{cedilha}@~ao de extens@~ao
sint@'atica que declara x como sendo um operador @code{postfix}.

Veja tamb@'em @code{syntax}.

@node Operador Pr@'efixado, Operadores Aritm@'eticos, Operador P@'osfixado, Operadores
@section Operador Pr@'efixado
Um operador @code{prefix} @'e um que significa uma fun@value{cedilha}@~ao de um
argumento, o qual imediatamente segue uma ocorr@^encia do
operador.  @code{prefix("x")} @'e uma fun@value{cedilha}@~ao de extens@~ao
sint@'atica que declara x como sendo um operador @code{prefix}.

Veja tamb@'em @code{syntax}.

@node Operadores Aritm@'eticos, Operadores Relacionais, Operador Pr@'efixado, Operadores
@section Operadores Aritm@'eticos

@deffn {Operador} +
@ifinfo
@fnindex Adi@value{cedilha}@~ao
@end ifinfo
@deffnx {Operador} -
@ifinfo
@fnindex Subtra@value{cedilha}@~ao
@end ifinfo
@deffnx {Operador} *
@ifinfo
@fnindex Multiplica@value{cedilha}@~ao
@end ifinfo
@deffnx {Operador} /
@ifinfo
@fnindex Divis@~ao
@end ifinfo
@deffnx {Operador} ^
@ifinfo
@fnindex Exponencia@value{cedilha}@~ao
@end ifinfo

Os s@'{@dotless{i}}mbolos @code{+} @code{*} @code{/} e @code{^} representam
adi@value{cedilha}@~ao, multiplica@value{cedilha}@~ao, divis@~ao, e exponencia@value{cedilha}@~ao, respectivamente.
O nome desses operadores s@~ao @code{"+"} @code{"*"} @code{"/"} e @code{"^"},
os quais podem aparecer em lugares onde o nome da fun@value{cedilha}@~ao ou operador @'e requerido.

Os s@'{@dotless{i}}mbolos @code{+} e @code{-} representam a adi@value{cedilha}@~ao un@'aria e a nega@value{cedilha}@~ao un@'aria, respectivamente,
e os nomes desses operadores s@~ao @code{"+"} e @code{"-"}, respectivamente.

A subtra@value{cedilha}@~ao @code{a - b} @'e representada dentro do Maxima como a adi@value{cedilha}@~ao, @code{a + (- b)}.
Express@~oes tais como @code{a + (- b)} s@~ao mostradas como subtra@value{cedilha}@~ao.
Maxima reconhece @code{"-"} somente como o nome do operador un@'ario de nega@value{cedilha}@~ao,
e n@~ao como o nome do operador bin@'ario de subra@value{cedilha}@~ao.

A divis@~ao @code{a / b} @'e representada dentro do Maxima como multiplica@value{cedilha}@~ao, @code{a * b^(- 1)}.
Express@~oes tais como @code{a * b^(- 1)} s@~ao mostradas como divis@~ao.
Maxima reconhece @code{"/"} como o nome do operador de divis@~ao.

A adi@value{cedilha}@~ao e a multiplica@value{cedilha}@~ao s@~ao operadores en@'arios e comutativos.
a divis@~ao e a exponencia@value{cedilha}@~ao s@~ao operadores bin@'arios e n@~ao comutativos.

Maxima ordena os operandos de operadores n@~ao comutativos para construir uma representa@value{cedilha}@~ao can@'onica.
Para armazenamento interno, a ordem @'e determinada por @code{orderlessp}.
Para mostrar na tela, a ordem para adi@value{cedilha}@~ao @'e determinada por @code{ordergreatp},
e para a multiplica@value{cedilha}@~ao, a ordem @'e a mesma da ordena@value{cedilha}@~ao para armazenamento interno.

Computa@value{cedilha}@~oes aritim@'eticas s@~ao realizadas sobre n@'umeros literais
(inteiro, racionais, n@'umeros comuns em ponto flutuante, e grandes n@'umeros em ponto flutuante de dupla precis@~ao).
Execto a exponencia@value{cedilha}@~ao, todas as opera@value{cedilha}@~oes aritm@'eticas sobre n@'umeros s@~ao simplificadas para n@'umeros.
A exponencia@value{cedilha}@~ao @'e simplificada para um n@'umero se ou o operando @'e um n@'umero comum em ponto flutuante ou um grande n@'umero em ponto flutuante de dupla precis@~ao
ou se o resultado for um inteiro exato ou um racional exato;
de outra forma uma exponencia@value{cedilha}@~ao pode ser simplificada para @code{sqrt} ou outra exponencia@value{cedilha}@~ao ou permanecer inalterada.

A propaga@value{cedilha}@~ao de n@'umeros em ponto flutuante aplica-se a computa@value{cedilha}@~oes aritim@'eticas:
Se qualquer operando for um grande n@'umero em ponto flutuante, o resultado @'e um grande n@'umero em ponto flutuante;
de outra forma, se qualquer operando for um n@'umero em ponto flutuante comum, o resultado @'e um n@'umero comum em ponto flutuante;
de outra forma, se os operandos forem racioanis ou inteiros e o resultado ser@'a um racional ou inteiro.

Computa@value{cedilha}@~aoes aritim@'eticas s@~ao uma simplifica@value{cedilha}@~ao, n@~ao uma avalia@value{cedilha}@~ao.
Dessa forma a aritm@'etica @'e realizada em  express@~oes com ap@'ostrofo (mas simplificadas).

Opera@value{cedilha}@~oes aritm@'eticas s@~ao aplicadas elemento-por-elemento
para listas quando a vari@'avel global @code{listarith} for @code{true},
e sempre aplicada elemento-por-elemento para matrizes.
Quando um operando for uma lista ou uma matriz e outro for um operando de algum outro tipo,
o outro operando @'e combinado com cada um dos elementos da lista ou matriz.

Exemplos:

Adi@value{cedilha}@~ao e multiplica@value{cedilha}@~ao s@~ao opeadores en@'arios comutativos.
Maxima ordena os operandos para construir uma representa@value{cedilha}@~ao can@'onica.
Os nomes desses operadores s@~ao @code{"+"} e @code{"*"}.
@c ===beg===
@c c + g + d + a + b + e + f;
@c [op (%), args (%)];
@c c * g * d * a * b * e * f;
@c [op (%), args (%)];
@c apply ("+", [a, 8, x, 2, 9, x, x, a]);
@c apply ("*", [a, 8, x, 2, 9, x, x, a]);
@c ===end===

@example
(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
@end example

Divis@~ao e exponencia@value{cedilha}@~ao s@~ao operadores bin@'arios e n@~ao comutativos.
Os nomes desses operadores s@~ao @code{"/"} e @code{"^"}.
@c ===beg===
@c [a / b, a ^ b];
@c [map (op, %), map (args, %)];
@c [apply ("/", [a, b]), apply ("^", [a, b])];
@c ===end===

@example
(%i1) [a / b, a ^ b];
                              a   b
(%o1)                        [-, a ]
                              b
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
@end example

Subtra@value{cedilha}@~ao e divis@~ao s@~ao representados internamente
em termos de adi@value{cedilha}@~ao e multiplica@value{cedilha}@~ao, respectivamente.
@c ===beg===
@c [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
@c [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
@c ===end===

@example
(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
@end example

C@'alculos s@~ao realizados sobre n@'umeros lterais.
A propaga@value{cedilha}@~ao de n@'umeros em poto flutuante aplica-se.
@c ===beg===
@c 17 + b - (1/2)*29 + 11^(2/4);
@c [17 + 29, 17 + 29.0, 17 + 29b0];
@c ===end===

@example
(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
@end example

Computa@value{cedilha}@~oes aritm@'eticas s@~ao uma simplifica@value{cedilha}@~ao, n@~ao uma avalia@value{cedilha}@~ao.
@c ===beg===
@c simp : false;
@c '(17 + 29*11/7 - 5^3);
@c simp : true;
@c '(17 + 29*11/7 - 5^3);
@c ===end===

@example
(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
@end example

A aritm@'etica @'e realizada elemento-por-elemento para listas lists (dependendo de @code{listarith}) e dependendo de matrizes.
@c ===beg===
@c matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
@c 5 * matrix ([a, x], [h, u]);
@c listarith : false;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c listarith : true;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c ===end===

@example
(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
(%i2) 5 * matrix ([a, x], [h, u]);
                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
@end example

@end deffn

@deffn {Operador} **

Operador de exponencia@value{cedilha}@~ao.
Maxima reconhece @code{**} como o mesmo operador que @code{^} em entrada,
e @code{**} @'e mostrado como @code{^} em sa@'{@dotless{i}}da unidimensional,
ou colocando o expoente  como sobrescrito em sa@'{@dotless{i}}da bidimensional.

A fun@value{cedilha}@~ao @code{fortran} mostra o operador de exponencia@value{cedilha}@~ao com como @code{**},
independente de a entrada ter sido na forma @code{**} ou a forma @code{^}.

Exemplos:

@c ===beg===
@c is (a**b = a^b);
@c x**y + x^z;
@c string (x**y + x^z);
@c fortran (x**y + x^z);
@c ===end===
@example
(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
@end example

@end deffn

@node Operadores Relacionais, Operadores Geral, Operadores Aritm@'eticos, Operadores
@section Operadores Relacionais

@deffn {Operador} <
@ifinfo
@fnindex Menor que
@end ifinfo
@deffnx {Operador} <=
@ifinfo
@fnindex Menor que ou igual a
@end ifinfo
@deffnx {Operador} >=
@ifinfo
@fnindex Maior que ou igual a
@end ifinfo
@deffnx {Operador} >
@ifinfo
@fnindex Maior que
@end ifinfo

@end deffn

@node Operadores Geral, , Operadores Relacionais, Operadores
@section Operadores Geral

@deffn {Operador} ^^
@ifinfo
@fnindex exponencia@value{cedilha}@~ao n@~ao comutativa
@end ifinfo

@end deffn

@deffn {Operador} !
@ifinfo
@fnindex Factorial
@end ifinfo
O operador factorial.
Para qualquer n@'umero complexo @code{x} (inclu@'{@dotless{i}}ndo n@'umeros inteiros, racionais, e reais) excepto para
inteiros negativos, @code{x!} @'e definido como @code{gamma(x+1)}.

Para um inteiro @code{x}, @code{x!} simplifica para o produto de inteiros de 1 a @code{x} inclusive.
@code{0!} simplifica para 1.
Para um n@'umero em ponto flutuante @code{x}, @code{x!} simplifica para o valor de @code{gamma (x+1)}.
Para @code{x} igual a @code{n/2} onde @code{n} @'e um inteiro @'{@dotless{i}}mpar,
@code{x!} simplifica para um factor racional vezes @code{sqrt (%pi)}
(uma vez que @code{gamma (1/2)} @'e igual a @code{sqrt (%pi)}).
Se @code{x} for qualquer outra coisa,
@code{x!} n@~ao @'e simplificado.

As vari@'aveis
@code{factlim}, @code{minfactorial}, e @code{factcomb} controlam a simplifica@value{cedilha}@~ao
de express@~oes contendo factoriais.

As fun@value{cedilha}@~oes @code{gamma}, @code{bffac}, e @code{cbffac}
s@~ao variedades da fun@value{cedilha}@~ao @code{gamma}. 
@code{makegamma} substitui @code{gamma} para fun@value{cedilha}@~oes relacionadas a factoriais.

Veja tamb@'em @code{binomial}.

O factorial de um inteiro, inteiro dividido por dois, ou argumento em ponto flutuante @'e simplificado
a menos que o operando seja maior que @code{factlim}.

@c ===beg===
@c factlim : 10;
@c [0!, (7/2)!, 4.77!, 8!, 20!];
@c ===end===
@example
(%i1) factlim : 10;
(%o1)                          10
(%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
+            105 sqrt(%pi)
+(%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
+                 16
@end example

O factorial de um n@'umero complexo, constante conhecida, ou express@~ao geral n@~ao @'e simplificado.
Ainda assim pode ser poss@'{@dotless{i}}vel simplificar o factorial ap@'os avaliar o operando.

@c ===beg===
@c [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
@c ev (%, numer, %enumer);
@c ===end===
@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357, 
                                               1.227580202486819]
@end example

O factorial de um s@'{@dotless{i}}mbolo n@~ao associado n@~ao @'e simplificado.

@c ===beg===
@c kill (foo);
@c foo!;
@c ===end===
@example
(%i1) kill (foo);
(%o1)                         done
(%i2) foo!;
(%o2)                         foo!
@end example

Factoriais s@~ao simplificados, n@~ao avaliados.
Dessa forma @code{x!} pode ser substitu@'{@dotless{i}}do mesmo em uma express@~ao com ap@'ostrofo.

@c ===beg===
@c '([0!, (7/2)!, 4.77!, 8!, 20!]);
@c ===end===
@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                                             2432902008176640000]
@end example

@end deffn

@deffn {Operador} !!
@ifinfo
@fnindex Duplo factorial
@end ifinfo
O operador de duplo factorial.

Para um n@'umero inteiro, n@'umero em ponto flutuante, ou n@'umero racional @code{n},
@code{n!!} avalia para o produto @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
onde @code{k} @'e igual a @code{entier (n/2)},
que @'e, o maior inteiro menor que ou igual a @code{n/2}.
Note que essa defini@value{cedilha}@~ao n@~ao coincide com outras defini@value{cedilha}@~oes publicadas
para argumentos que n@~ao s@~ao inteiros.
@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para um inteiro par (ou @'{@dotless{i}}mpar) @code{n}, @code{n!!} avalia para o produto de
todos os inteiros consecutivos pares (ou @'{@dotless{i}}mpares) de 2 (ou 1) at@'e @code{n} inclusive.

Para um argumento @code{n} que n@~ao @'e um n@'umero inteiro, um n@'umero em ponto flutuante, ou um n@'umero racional,
@code{n!!} retorna uma forma substantiva @code{genfact (n, n/2, 2)}.
@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn

@deffn {Operador} #
@ifinfo
@fnindex N@~ao igual (desigualdade sint@'atica)
@end ifinfo
Representa a nega@value{cedilha}@~ao da igualdade sint@'atica @code{=}.

Note que pelo facto de as regras de avalia@value{cedilha}@~ao de express@~oes predicadas
(em particular pelo facto de @code{not @var{expr}} fazer com que ocorra a avalia@value{cedilha}@~ao de @var{expr}),
a forma @code{not @var{a} = @var{b}} n@~ao @'e equivalente @`a forma @code{@var{a} # @var{b}} em alguns casos.

Note que devido @`as regras para avalia@value{cedilha}@~ao de express@~oes predicadas
(em particular devido a @code{not @var{expr}} fazer com que a avalia@value{cedilha}@~ao de @var{expr} ocorra),
@code{not @var{a} = @var{b}} @'e equivalente a @code{is(@var{a} # @var{b})},
em lugar de ser equivalente a @code{@var{a} # @var{b}}.

Exemplos:
@c ===beg===
@c a = b;
@c @'e (a = b);
@c a # b;
@c not a = b;
@c @'e (a # b);
@c @'e (not a = b);
@c ===end===
@example
(%i1) a = b;
(%o1)                         a = b
(%i2) @'e (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) @'e (a # b);
(%o5)                         true
(%i6) @'e (not a = b);
(%o6)                         true
@end example

@end deffn

@deffn {Operador} .
@ifinfo
@fnindex Multiplica@value{cedilha}@~ao n@~ao comutativa matricial
@end ifinfo
O operador ponto, para multiplica@value{cedilha}@~ao (n@~ao comutativa) de matrizes.
Quando "." @'e usado com essa finalidade, espa@value{cedilha}os devem ser colocados em ambos os lados desse
operador, e.g. A . B.  Isso distingue o operador ponto plenamente de um ponto decimal em
um n@'umero em ponto flutuante.

Veja tamb@'em
@code{dot},
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident},
e
@code{dotscrules}.

@end deffn

@deffn {Operador} :
@ifinfo
@fnindex Operador de atribui@value{cedilha}@~ao
@end ifinfo
O operador de atribui@value{cedilha}@~ao.  E.g. A:3 escolhe a vari@'avel A para 3.

@end deffn

@deffn {Operador} ::
@ifinfo
@fnindex Operador de atribui@value{cedilha}@~ao (avalia o lado esquerdo da igualdade)
@end ifinfo
Operador de atribui@value{cedilha}@~ao.  :: atribui o valor da express@~ao
em seu lado direito para o valor da quantidade na sua esquerda, que pode
avaliar para uma vari@'avel at@^omica ou vari@'avel subscrita.

@end deffn

@deffn {Operador} ::=
@ifinfo
@fnindex Operador de defini@value{cedilha}@~ao de fun@value{cedilha}@~ao de macro
@end ifinfo
Operador de defini@value{cedilha}@~ao de fun@value{cedilha}@~ao de macro.
@code{::=} define uma fun@value{cedilha}@~ao (chamada uma "macro" por raz@~oes hist@'oricas)
que coloca um ap@'ostrofo em seus argumentos (evitando avalia@value{cedilha}@~ao),
e a express@~ao que @'e retornada (chamada a "expans@~ao de macro")
@'e avaliada no contexto a partir do qual a macro foi chamada.
Uma fun@value{cedilha}@~ao de macro @'e de outra forma o mesmo que uma fun@value{cedilha}@~ao comum.

@code{macroexpand} retorna uma expans@~ao de macro (sem avaliar a expans@~ao).
@code{macroexpand (foo (x))} seguida por @code{''%} @'e equivalente a @code{foo (x)}
quando @code{foo} for uma fun@value{cedilha}@~ao de macro.

@code{::=} coloca o nome da nova fun@value{cedilha}@~ao de macro dentro da lista global @code{macros}.
@code{kill}, @code{remove}, e @code{remfunction} desassocia defini@value{cedilha}@~oes de fun@value{cedilha}@~ao de macro
e remove nomes de @code{macros}.

@code{fundef} e @code{dispfun} retornam respectivamente uma defini@value{cedilha}@~ao de fun@value{cedilha}@~ao de macro
e uma atribui@value{cedilha}@~ao dessa defini@value{cedilha}@~ao a um r@'otulo, respectivamente.

Fun@value{cedilha}@~oes de macro comumente possuem express@~oes @code{buildq} e
@code{splice} para construir uma express@~ao,
que @'e ent@~ao avaliada.

Exemplos

Uma fun@value{cedilha}@~ao de macro coloca um ap@'ostrofo em seus argumentos evitando ent@~ao a avalia@value{cedilha}@~ao,
ent@~ao mensagem (1) mostra @code{y - z}, n@~ao o valor de @code{y - z}.
A expans@~ao de macro (a express@~ao com ap@'ostrofo @code{'(print ("(2) x is equal to", x))}
@'e avaliada no contexto a partir do qual a macro for chamada,
mostrando a mensagem (2).

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c printq1 (x) ::= block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
@c printq1 (y - z);
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printq1 (x) ::= block (print ("(1) x @'e igual a", x), '(print ("(2) x @'e igual a", x)));
(%o4) printq1(x) ::= block(print("(1) x @'e igual a", x), 
                                '(print("(2) x @'e igual a", x)))
(%i5) printq1 (y - z);
(1) x @'e igual a y - z 
(2) x @'e igual a %pi 
(%o5)                          %pi
@end example

Uma fun@value{cedilha}@~ao comum avalia seus argumentos, ent@~ao message (1) mostra o valor de @code{y - z}.
O valor de retorno n@~ao @'e avaliado, ent@~ao mensagem (2) n@~ao @'e mostrada
at@'e a avalia@value{cedilha}@~ao expl@'{@dotless{i}}cita @code{''%}.

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c printe1 (x) := block (print ("(1) x @'e igual a", x), '(print ("(2) x @'e igual a", x)));
@c printe1 (y - z);
@c ''%;
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printe1 (x) := block (print ("(1) x @'e igual a", x), '(print ("(2) x @'e igual a", x)));
(%o4) printe1(x) := block(print("(1) x @'e igual a", x), 
                                '(print("(2) x @'e igual a", x)))
(%i5) printe1 (y - z);
(1) x @'e igual a 1234 - 1729 w 
(%o5)              print((2) x @'e igual a, x)
(%i6) ''%;
(2) x @'e igual a %pi 
(%o6)                          %pi
@end example

@code{macroexpand} retorna uma expans@~ao de macro.
@code{macroexpand (foo (x))} seguido por @code{''%} @'e equivalente a @code{foo (x)}
quando @code{foo} for uma fun@value{cedilha}@~ao de macro.

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c g (x) ::= buildq ([x], print ("x @'e igual a", x));
@c macroexpand (g (y - z));
@c ''%;
@c g (y - z);
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) g (x) ::= buildq ([x], print ("x @'e igual a", x));
(%o4)    g(x) ::= buildq([x], print("x @'e igual a", x))
(%i5) macroexpand (g (y - z));
(%o5)              print(x @'e igual a, y - z)
(%i6) ''%;
x @'e igual a 1234 - 1729 w 
(%o6)                     1234 - 1729 w
(%i7) g (y - z);
x @'e igual a 1234 - 1729 w 
(%o7)                     1234 - 1729 w
@end example

@end deffn

@deffn {Operador} :=
@ifinfo
@fnindex Operador de defini@value{cedilha}@~ao de fun@value{cedilha}@~ao
@end ifinfo
O operador de defini@value{cedilha}@~ao de fun@value{cedilha}@~ao.  E.g. @code{f(x):=sin(x)} define
uma fun@value{cedilha}@~ao @code{f}.

@end deffn

@deffn {Operador} =
@ifinfo
@fnindex Operador de equa@value{cedilha}@~ao
@fnindex Igual (igualdade sint@'atica)
@end ifinfo
O operador de equa@value{cedilha}@~ao.

Uma express@~ao @code{@var{a} = @var{b}}, por si mesma, representa
uma equa@value{cedilha}@~ao n@~ao avaliada, a qual pode ou n@~ao se manter.
Equa@value{cedilha}@~oes n@~ao avaliadas podem aparecer como argumentos para @code{solve} e @code{algsys}
ou algumas outras fun@value{cedilha}@~oes.

A fun@value{cedilha}@~ao @code{is} avalia @code{=} para um valor Booleano.
@code{is(@var{a} = @var{b})} avalia @code{@var{a} = @var{b}} para @code{true} quando @var{a} e @var{b}
forem id@^enticos. Isto @'e, @var{a} e @var{b} forem @'atomos que s@~ao id@^enticos,
ou se eles n@~ao forem @'atomos e seus operadores forem id@^enticos e seus argumentos forem id@^enticos.
De outra forma, @code{is(@var{a} = @var{b})} avalia para @code{false};
@code{is(@var{a} = @var{b})} nunca avalia para @code{unknown}.
Quando @code{is(@var{a} = @var{b})} for @code{true}, @var{a} e @var{b} s@~ao ditos para serem sintaticamente iguais,
em contraste para serem express@~oes equivalentes, para as quais @code{is(equal(@var{a}, @var{b}))} @'e @code{true}.
Express@~oes podem ser equivalentes e n@~ao sint@'aticamente iguais.

A nega@value{cedilha}@~ao de @code{=} @'e representada por @code{#}.
Da mesma forma que com @code{=}, uma express@~ao @code{@var{a} # @var{b}}, por si mesma, n@~ao @'e avaliada.
@code{is(@var{a} # @var{b})} avalia @code{@var{a} # @var{b}} para
@code{true} ou @code{false}.

Complementando a fun@value{cedilha}@~ao @code{is},
alguns outros operadores avaliam @code{=} e @code{#} para @code{true} ou @code{false},
a saber @code{if}, @code{and}, @code{or}, e @code{not}.

Note que pelo facto de as regras de avalia@value{cedilha}@~ao de express@~oes predicadas
(em particular pelo facto de @code{not @var{expr}} fazer com que ocorra a avalia@value{cedilha}@~ao de @var{expr}),
a forma @code{not @var{a} = @var{b}} @'e equivalente a @code{is(@var{a} # @var{b})},
em lugar de ser equivalente a @code{@var{a} # @var{b}}.

@code{rhs} e @code{lhs} retornam o primeiro membro e o segundo membro de uma equa@value{cedilha}@~ao,
respectivamente, de uma equa@value{cedilha}@~ao ou inequa@value{cedilha}@~ao.

Veja tamb@'em @code{equal} e @code{notequal}.

Exemplos:

Uma express@~ao @code{@var{a} = @var{b}}, por si mesma, representa
uma equa@value{cedilha}@~ao n@~ao avaliada, a qual pode ou n@~ao se manter.

@c ===beg===
@c eq_1 : a * x - 5 * y = 17;
@c eq_2 : b * x + 3 * y = 29;
@c solve ([eq_1, eq_2], [x, y]);
@c subst (%, [eq_1, eq_2]);
@c ratsimp (%);
@c ===end===
@example
(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
@end example

@code{is(@var{a} = @var{b})} avalia @code{@var{a} = @var{b}} para @code{true} quando @var{a} e @var{b}
s@~ao sintaticamente iguais (isto @'e, identicos).
Express@~oes podem ser equivalentes e n@~ao sintaticamente iguais.

@c ===beg===
@c a : (x + 1) * (x - 1);
@c b : x^2 - 1;
@c [is (a = b), is (a # b)];
@c [is (equal (a, b)), is (notequal (a, b))];
@c ===end===
@example
(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
@end example

Alguns operadores avaliam @code{=} e @code{#} para @code{true} ou @code{false}.

@c ===beg===
@c if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
@c eq_3 : 2 * x = 3 * x;
@c eq_4 : exp (2) = %e^2;
@c [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
@c ===end===
@example
(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
@end example

Devido a @code{not @var{expr}} fazer com que a avalia@value{cedilha}@~ao de @var{expr} ocorra,
@code{not @var{a} = @var{b}} @'e equivalente a @code{is(@var{a} # @var{b})}.

@c ===beg===
@c [2 * x # 3 * x, not (2 * x = 3 * x)];
@c is (2 * x # 3 * x);
@c ===end===
@example
(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
@end example

@end deffn

@c NEEDS EXAMPLES
@deffn {Operador} and
@ifinfo
@fnindex Conjun@value{cedilha}@~ao l@'ogica
@end ifinfo
O operador l@'ogico de conjun@value{cedilha}@~ao.
@code{and} @'e um operador n-@'ario infixo;
seus operandos s@~ao express@~oes Booleanas, e seu resultado @'e um valor Booleano.

@code{and} for@value{cedilha}a avalia@value{cedilha}@~ao (como @code{is}) de um ou mais operandos,
e pode for@value{cedilha}ar a avalia@value{cedilha}@~ao de todos os operandos.

Operandos s@~ao avaliados na ordem em que aparecerem.
@code{and} avalia somente quantos de seus operandos forem necess@'arios para determinar o resultado.
Se qualquer operando for @code{false},
o resultado @'e @code{false} e os operandos restantes n@~ao s@~ao avaliados.

O sinalizador global @code{prederror} governa o comportamento de @code{and}
quando um operando avaliado n@~ao pode ser determinado como sendo @code{true} ou @code{false}.
@code{and} imprime uma mensagem de erro quando @code{prederror} for @code{true}.  
De outra forma, @code{and} retorna @code{unknown} (desconhecido).

@code{and} n@~ao @'e comutativo:
@code{a and b} pode n@~ao ser igual a @code{b and a} devido ao tratamento de operandos indeterminados.

@end deffn

@c NEEDS EXAMPLES
@deffn {Operador} or
@ifinfo
@fnindex Disjun@value{cedilha}@~ao l@'ogica
@end ifinfo
O operador l@'ogico de disjun@value{cedilha}@~ao.
@code{or} @'e um operador n-@'ario infixo;
seus operandos s@~ao express@~oes Booleanas, e seu resultado @'e um valor Booleano.

@code{or} for@value{cedilha}a avalia@value{cedilha}@~ao (como @code{is}) de um ou mais operandos,
e pode for@value{cedilha}ar a avalia@value{cedilha}@~ao de todos os operandos.

Operandos s@~ao avaliados na ordem em que aparecem.
@code{or} avalia somente quantos de seus operandos forem necess@'arios para determinar o resultado.
Se qualquer operando for @code{true},
o resultado @'e @code{true} e os operandos restantes n@~ao s@~ao avaliados.

O sinalizador global @code{prederror} governa o comportamento de @code{or}
quando um operando avaliado n@~ao puder ser determinado como sendo @code{true} ou @code{false}.
@code{or} imprime uma mensagem de erro quando @code{prederror} for @code{true}.
De outra forma, @code{or} retorna @code{unknown}.

@code{or} n@~ao @'e comutativo:
@code{a or b} pode n@~ao ser igual a @code{b or a} devido ao tratamento de operando indeterminados.

@end deffn

@c NEEDS EXAMPLES
@deffn {Operador} not
@ifinfo
@fnindex Nega@value{cedilha}@~ao l@'ogica
@end ifinfo
O operador l@'ogico de nega@value{cedilha}@~ao.
@code{not} @'e operador prefixado;
Seu operando @'e uma express@~ao Booleana, e seu resultado @'e um valor Booleano.

@code{not} for@value{cedilha}a a avalia@value{cedilha}@~ao (como @code{is}) de seu operando.

O sinalizador global @code{prederror} governa o comportamento de @code{not}
quando seu operando n@~ao pode ser determinado em termos de @code{true} ou @code{false}.
@code{not} imprime uma mensagem de erro quando @code{prederror} for @code{true}.
De outra forma, @code{not} retorna @code{unknown}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} abs (@var{expr})
Retorna o valor absoluto de @var{expr}.  Se @var{expr} for um n@'umero complexo, retorna o m@'odulo
complexo de @var{expr}.

@end deffn

@defvr {Palavra chave} additive
Se @code{declare(f,additive)} tiver sido executado, ent@~ao:

(1) Se @code{f} for uma fun@value{cedilha}@~ao de uma @'unica vari@'avel, sempre que o simplificador encontrar @code{f} aplicada
a uma adi@value{cedilha}@~ao, @code{f} ser@'a distribu@'{@dotless{i}}do sobre aquela adi@value{cedilha}@~ao.  I.e. @code{f(y+x)} ir@'a
simplificar para @code{f(y)+f(x)}.

(2) Se @code{f} for uma fun@value{cedilha}@~ao de 2 ou mais argumentos, a adi@value{cedilha}@~ao @'e definida como 
adi@value{cedilha}@~ao no primeiro argumento para @code{f}, como no caso de @code{sum} ou  
@code{integrate}, i.e. @code{f(h(x)+g(x),x)} ir@'a simplificar para @code{f(h(x),x)+f(g(x),x)}.
Essa simplifica@value{cedilha}@~ao n@~ao ocorre quando @code{f} @'e aplicada para express@~oes da
forma @code{sum(x[i],i,lower-limit,upper-limit)}.

@end defvr

@c NEEDS TO BE REWORKED. NOT CONVINCED THIS SYMBOL NEEDS ITS OWN ITEM
@c (SHOULD BE DESCRIBED IN CONTEXT OF EACH FUNCTION WHICH RECOGNIZES IT)
@defvr {Palavra chave} allbut
trabalha com os comandos @code{part} (i.e. @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart}, e @code{lpart}).  Por exemplo,

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, [2, 5]);
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

enquanto

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, allbut (2, 5));
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
@end example

@code{allbut} @'e tamb@'em reconhecido por @code{kill}.
 
@c ===beg===
@c [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
@c kill (allbut (cc, dd));
@c [aa, bb, cc, dd];
@c ===end===
@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example

@code{kill(allbut(@var{a_1}, @var{a_2}, ...))} tem o mesmo efeito que @code{kill(all)}
excepto que n@~ao elimina os s@'{@dotless{i}}mbolos @var{a_1}, @var{a_2}, ... .

@end defvr

@defvr {Declara@value{cedilha}@~ao} antisymmetric
Se @code{declare(h,antisymmetric)} @'e conclu@'{@dotless{i}}da, diz ao
simplicador que @code{h} @'e uma fun@value{cedilha}@~ao antisim@'etrica.  E.g. @code{h(x,z,y)} simplificar@'a para
@code{- h(x, y, z)}.  Isto @'e, dar@'a (-1)^n vezes o resultado dado por
@code{symmetric} ou @code{commutative}, quando n for o n@'umero de interescolhas de dois
argumentos necess@'arios para converter isso naquela forma.

@end defvr

@deffn {Fun@value{cedilha}@~ao} cabs (@var{expr})
Retorna o valor absoluto complexo (o m@'odulo complexo) de
@var{expr}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ceiling (@var{x})

Quando @var{x} for um n@'umero real, retorna o @'ultimo inteiro que 
@'e maior que ou igual a @var{x}.  

Se @var{x} for uma express@~ao constante (@code{10 * %pi}, por exemplo), 
@code{ceiling} avalia @var{x} usando grandes n@'umeros em ponto flutuante, e 
aplica @code{ceiling} para o grande n@'umero em ponto flutuante resultante. Porque @code{ceiling} usa
avalia@value{cedilha}@~ao de ponto flutuante, @'e poss@'{@dotless{i}}vel, embora improv@'avel, 
que @code{ceiling} possa retornar uma valor err@^oneo para entradas
constantes. Para prevenir erros, a avalia@value{cedilha}@~ao de ponto flutuante
@'e conclu@'{@dotless{i}}da usando tr@^es valores para @code{fpprec}.

Para entradas n@~ao constantes, @code{ceiling} tenta retornar um valor
simplificado.  Aqui est@'a um exemplo de simplifica@value{cedilha}@~oes que @code{ceiling}
conhece:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                         false
@end example

A fun@value{cedilha}@~ao @code{ceiling} n@~ao mapeia automaticamente sobre listas ou matrizes.
Finalmente, para todas as entradas que forem manifestamente complexas, @code{ceiling} retorna 
uma forma substantiva.

Se o intervalo de uma fun@value{cedilha}@~ao @'e um subconjunto dos inteiros, o intervalo pode ser
declarado @code{integervalued}. Ambas as fun@value{cedilha}@~oes @code{ceiling} e @code{floor}
podem usar essa informa@value{cedilha}@~ao; por exemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} charfun (@var{p})

Retorna 0 quando o predicado @var{p} avaliar para @code{false}; retorna
1 quando o predicado avaliar para @code{true}.  Quando o predicado
avaliar para alguma coisa que n@~ao @code{true} ou @code{false} (@code{unknown}), 
retorna uma forma substantiva.

Exemplos:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun (x < 1);
(%o1)                    charfun(x < 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('"and" (-1 < x, x < 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
@end example

@end deffn

@defvr {Declara@value{cedilha}@~ao} commutative
Se @code{declare(h,commutative)} @'e conclu@'{@dotless{i}}da, diz ao
simplicador que @code{h} @'e uma fun@value{cedilha}@~ao comutativa.  E.g. @code{h(x,z,y)} ir@'a
simplificar para @code{h(x, y, z)}.  Isto @'e o mesmo que @code{symmetric}.

@end defvr

@deffn {Fun@value{cedilha}@~ao} compare (@var{x}, @var{y})

Retorna um operador de compara@value{cedilha}@~ao @var{op}
(@code{<}, @code{<=}, @code{>}, @code{>=}, @code{=}, ou @code{#}) tal que
@code{is (@var{x} @var{op} @var{y})} avalia para @code{true};
quando ou @var{x} ou @var{y} dependendo de @code{%i} e
@code{@var{x} # @var{y}}, retorna @code{notcomparable};
Quando n@~ao existir tal operador ou
Maxima n@~ao estiver apto a determinar o operador, retorna @code{unknown}.

Exemplos:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare (1, 2);
(%o1)                           <
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          <=
@end example

A fun@value{cedilha}@~ao @code{compare} n@~ao tenta de terminar se o dom@'{@dotless{i}}nio real de
seus argumentos @'e n@~ao vazio; dessa forma

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           <
@end example

O dom@'{@dotless{i}}nio real de @code{acos (x^2 + 1)} @'e vazio.

@end deffn

@deffn {Fun@value{cedilha}@~ao} entier (@var{x})
Retorna o @'ultimo inteiro menor que ou igual a @var{x} onde @var{x} @'e num@'erico.  @code{fix} (como em
@code{fixnum}) @'e um sin@^onimo disso, ent@~ao @code{fix(@var{x})} @'e precisamente o mesmo.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~ao} equal (@var{a}, @var{b})

Representa a equival@^encia, isto @'e, valor igual.
 
Por si mesma, @code{equal} n@~ao avalia ou simplifica.
A fun@value{cedilha}@~ao @code{is} tenta avaliar @code{equal} para um valor Booleano.
@code{is(equal(@var{a}, @var{b}))} 
retorna @code{true} (ou @code{false}) se
e somente se @var{a} e @var{b} forem iguais (ou n@~ao iguais) para todos os poss@'{@dotless{i}}veis
valores de suas vari@'aveis, como determinado atrav@'es da avalia@value{cedilha}@~ao de @code{ratsimp(@var{a} - @var{b})};
se @code{ratsimp} retornar 0, as duas express@~oes s@~ao consideradas equivalentes.
Duas express@~oes podem ser equivalentes mesmo se mesmo se elas n@~ao forem sintaticamente iguais (i.e., identicas).

Quando @code{is} falhar em reduzir @code{equal} a @code{true} ou @code{false},
o resultado @'e governado atrav@'es do sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
@code{is} reclama com uma mensagem de erro.
De outra forma, @code{is} retorna @code{unknown}.

Complementando @code{is},
alguns outros operadores avaliam @code{equal} e @code{notequal} para @code{true} ou @code{false},
a saber @code{if}, @code{and}, @code{or}, e @code{not}.

@c FOLLOWING STATEMENT IS MORE OR LESS TRUE BUT I DON'T THINK THE DETAILS ARE CORRECT
@c Declarations (integer, complex, etc)
@c for variables appearing in @var{a} and @var{b} are ignored by @code{equal}.
@c All variables are effectively assumed to be real-valued.

A nega@value{cedilha}@~ao de @code{equal} @'e @code{notequal}.
Note que devido @`as regras de avalia@value{cedilha}@~ao de express@~oes predicadas
(em particular pelo facto de @code{not @var{expr}} causar a avalia@value{cedilha}@~ao de @var{expr}),
@code{not equal(@var{a}, @var{b})}
@'e equivalente a @code{is(notequal(@var{a}, @var{b}))}
em lugar de ser equivalente a @code{notequal(@var{a}, @var{b})}.

Exemplos:

Por si mesmo, @code{equal} n@~ao avalia ou simplifica.

@c ===beg===
@c equal (x^2 - 1, (x + 1) * (x - 1));
@c equal (x, x + 1);
@c equal (x, y);
@c ===end===
@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

A fun@value{cedilha}@~ao @code{is} tenta avaliar @code{equal} para um valor Booleano.
@code{is(equal(@var{a}, @var{b}))} retorna @code{true} quando @code{ratsimp(@var{a} - @var{b})} retornar 0.
Duas express@~oes podem ser equivalentes mesmo se n@~ao forem sintaticamente iguais (i.e., identicas).

@c ===beg===
@c ratsimp (x^2 - 1 - (x + 1) * (x - 1));
@c is (equal (x^2 - 1, (x + 1) * (x - 1)));
@c is (x^2 - 1 = (x + 1) * (x - 1));
@c ratsimp (x - (x + 1));
@c is (equal (x, x + 1));
@c is (x = x + 1);
@c ratsimp (x - y);
@c is (equal (x, y));
@c is (x = y);
@c ===end===
@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
Maxima was unable to evaluate the predicate:
equal(x, y)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i9) is (x = y);
(%o9)                         false
@end example
 
Quando @code{is} falha em reduzir @code{equal} a @code{true} ou @code{false},
o resultado @'e governado atrav@'es do sinalizador global @code{prederror}.
 
@c ===beg===
@c [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
@c ratsimp (aa - bb);
@c prederror : true;
@c is (equal (aa, bb));
@c prederror : false;
@c is (equal (aa, bb));
@c ===end===
 @example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
 (%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

Alguns operadores avaliam @code{equal} e @code{notequal} para @code{true} ou @code{false}.

@c ===beg===
@c if equal (a, b) then FOO else BAR;
@c eq_1 : equal (x, x + 1);
@c eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
@c [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
@c ===end===
@example
(%i1) if equal (a, b) then FOO else BAR;
Maxima was unable to evaluate the predicate:
equal(a, b)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

Devido a @code{not @var{expr}} fazer com que ocorra a avalia@value{cedilha}@~ao de @var{expr},
@code{not equal(@var{a}, @var{b})} @'e equivalente a @code{is(notequal(@var{a}, @var{b}))}.

@c ===beg===
@c [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
@c is (notequal (2*z, 2*z - 1));
@c ===end===
@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} floor (@var{x})

Quando @var{x} for um n@'umero real, retorna o maior inteiro que 
@'e menor que ou igual a @var{x}.

Se @var{x} for uma express@~ao constante (@code{10 * %pi}, for exemplo), 
@code{floor} avalia @var{x} usando grandes n@'umeros em ponto flutuante, e 
aplica @code{floor} ao grande n@'umero em ponto flutuante resultante. Porque @code{floor} usa
avalia@value{cedilha}@~ao em ponto flutuante, @'e poss@'{@dotless{i}}vel, embora improv@'avel, 
que @code{floor} n@~ao possa retornar um valor err@^oneo para entradas
constantes.  Para prevenir erros, a avalia@value{cedilha}@~ao de ponto flutuante
@'e conclu@'{@dotless{i}}da usando tr@^es valores para @code{fpprec}.

Para entradas n@~ao constantes, @code{floor} tenta retornar um valor
simplificado.  Aqui est@'a exemplos de simplifica@value{cedilha}@~oes que @code{floor}
conhece:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a));
@c ===end===
@example
(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
@end example

A fun@value{cedilha}@~ao @code{floor} n@~ao mapeia automaticamente sobre listas ou matrizes.
Finalmente, para todas as entradas que forem manifestamente complexas, @code{floor} retorna
uma forma substantiva.

Se o intervalo de uma fun@value{cedilha}@~ao for um subconjunto dos inteiros, o intervalo pode ser
declarado @code{integervalued}. Ambas as fun@value{cedilha}@~oes @code{ceiling} e @code{floor}
podem usar essa informa@value{cedilha}@~ao; por exemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} notequal (@var{a}, @var{b})
Represents the negation of @code{equal(@var{a}, @var{b})}.

Note que pelo facto de as regras de avalia@value{cedilha}@~ao de express@~oes predicadas
(em particular pelo facto de @code{not @var{expr}} causar a avalia@value{cedilha}@~ao de @var{expr}),
@code{not equal(@var{a}, @var{b})}
@'e equivalente a @code{is(notequal(@var{a}, @var{b}))}
em lugar de ser equivalente a @code{notequal(@var{a}, @var{b})}.

Exemplos:

@c ===beg===
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c maybe (not equal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c maybe (not equal (a, b));
@c ===end===
@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
Maxima was unable to evaluate the predicate:
equal(a, b)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) maybe (not equal (a, b));
(%o6)                        unknown
(%i7) assume (a > b);
(%o7)                        [a > b]
(%i8) equal (a, b);
(%o8)                      equal(a, b)
(%i9) maybe (equal (a, b));
(%o9)                         false
(%i10) notequal (a, b);
(%o10)                   notequal(a, b)
(%i11) not equal (a, b);
(%o11)                        true
(%i12) maybe (notequal (a, b));
(%o12)                        true
(%i13) maybe (not equal (a, b));
(%o13)                        true
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c NOTE THAT eval IS RECOGNIZED ONLY AS AN ARGUMENT TO ev,
@c BUT FOR SOME REASON eval DOES NOT HAVE THE evflag PROPERTY
@deffn {Operador} eval
Como um argumento em uma chamada a @code{ev (@var{expr})},
@code{eval} causa uma avalia@value{cedilha}@~ao extra de @var{expr}.
Veja @code{ev}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} evenp (@var{expr})
Retorna @code{true} se @var{expr} for um inteiro sempre.
@c THIS IS STRANGE -- SHOULD RETURN NOUN FORM IF INDETERMINATE
@code{false} @'e retornado em todos os outros casos.

@end deffn

@deffn {Fun@value{cedilha}@~ao} fix (@var{x})
Um sin@^onimo para @code{entier (@var{x})}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} fullmap (@var{f}, @var{expr_1}, ...)
Similar a @code{map}, mas @code{fullmap} mant@'em mapeadas para
baixo todas as subexpress@~oes at@'e que os operadores principais n@~ao mais sejam os
mesmos.

@code{fullmap} @'e usada pelo simplificador do
Maxima para certas manipula@value{cedilha}@~oes de matrizes; dessa forma, Maxima algumas vezes gera
uma mensagem de erro concernente a @code{fullmap} mesmo apesar de @code{fullmap} n@~ao ter sido
explicitamente chamada pelo utilizador.

Exemplos:

@c ===beg===
@c a + b * c;
@c fullmap (g, %);
@c map (g, %th(2));
@c ===end===
@example
(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} fullmapl (@var{f}, @var{list_1}, ...)
Similar a @code{fullmap}, mas @code{fullmapl} somente mapeia sobre
listas e matrizes.

Exemplo:

@c ===beg===
@c fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
@c ===end===
@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} is (@var{expr})
Tenta determinar se a @var{expr} predicada (express@~oes que avaliam para @code{true}
ou @code{false}) @'e dedut@'{@dotless{i}}vel de factos localizados na base de dados de @code{assume}.

Se a dedutibilidade do predicado for @code{true} ou @code{false},
@code{is} retorna @code{true} ou @code{false}, respectivamente.
De outra forma, o valor de retorno @'e governado atrav@'es do sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
@code{is} reclama com uma mensagem de erro.
De outra forma, @code{is} retorna @code{unknown}.

@code{ev(@var{expr}, pred)}
(que pode ser escrita da forma  @code{@var{expr}, pred} na linha de comando interativa)
@'e equivalente a @code{is(@var{expr})}.

Veja tamb@'em @code{assume}, @code{facts}, e @code{maybe}.

Exemplos:

@code{is} causa avalia@value{cedilha}@~ao de predicados.
@c GENERATED FROM:
@c %pi > %e;
@c @'e (%pi > %e);

@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) @'e (%pi > %e);
(%o2)                         true
@end example

@code{is} tenta derivar predicados da base de dados do @code{assume}.

@c ===beg===
@c assume (a > b);
@c assume (b > c);
@c @'e (a < b);
@c @'e (a > c);
@c @'e (equal (a, c));
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) @'e (a < b);
(%o3)                         false
(%i4) @'e (a > c);
(%o4)                         true
(%i5) @'e (equal (a, c));
(%o5)                         false
@end example

Se @code{is} n@~ao puder nem comprovar nem refutar uma forma predicada a partir da base de dados de @code{assume},
o sinalizador global @code{prederror} governa o comportamento de @code{is}.

@c ===beg===
@c assume (a > b);
@c prederror: true$
@c @'e (a > 0);
@c prederror: false$
@c @'e (a > 0);
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) @'e (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) @'e (a > 0);
(%o5)                        unknown
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} maybe (@var{expr})
Tenta determinar se a @var{expr} predicada
@'e dedut@'{@dotless{i}}vel dos factos na base de dados de @code{assume}.

Se a dedutibilidade do predicado for @code{true} ou @code{false},
@code{maybe} retorna @code{true} ou @code{false}, respectivamente.
De outra forma, @code{maybe} retorna @code{unknown}.

@code{maybe} @'e funcinalmente equivalente a @code{is} com @code{prederror: false},
mas o resultado @'e computado sem actualmente atribuir um valor a @code{prederror}.

Veja tamb@'em @code{assume}, @code{facts}, e @code{is}.

Exemplos:

@c ===beg===
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);
@c ===end===
@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} isqrt (@var{x})
Retorna o "inteiro ra@'{@dotless{i}}z quadrada"
do valor absoluto de @var{x},
que @'e um inteiro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} lmax (@var{L})

Quando @var{L} for uma lista ou um conjunto, retorna @code{apply ('max, args (@var{L}))}.  Quando @var{L} n@~ao for uma
lista ou tamb@'em n@~ao for um conjunto, sinaliza um erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} lmin (@var{L})

Quando @var{L} for uma lista ou um conjunto, retorna @code{apply ('min, args (@var{L}))}. Quando @var{L} n@~ao for uma
lista ou ou tamb@'em n@~ao for um conjunto, sinaliza um erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} max (@var{x_1}, ..., @var{x_n})

Retorna um valor simplificado para o m@'aximo entre as express@~oes @var{x_1} a @var{x_n}.
Quando @code{get (trylevel, maxmin)}, for dois ou mais, @code{max} usa a simplifica@value{cedilha}@~ao 
@code{max (e, -e) --> |e|}.  Quando @code{get (trylevel, maxmin)} for 3 ou mais, @var{max} tenta
eliminar express@~oes que estiverem entre dois outros argumentos; por exemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}. Para escolher o valor de @code{trylevel} para 2, use
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} min (@var{x_1}, ..., @var{x_n})

Retorna um valor simplificado para o m@'{@dotless{i}}nimo entre as express@~oes @code{x_1} at@'e @code{x_n}.
Quando @code{get (trylevel, maxmin)}, for 2 ou mais, @code{min} usa a simplifica@value{cedilha}@~ao 
@code{min (e, -e) --> -|e|}.  Quando @code{get (trylevel, maxmin)} for 3 ou mais, @code{min} tenta
eliminar express@~oes que estiverem entre dois outros argumentos; por exemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}. Para escolher o valor de @code{trylevel} para 2, use
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} polymod (@var{p})
@deffnx {Fun@value{cedilha}@~ao} polymod (@var{p}, @var{m})
Converte o polin@'omio @var{p} para uma representa@value{cedilha}@~ao modular
com rela@value{cedilha}@~ao ao m@'odulo corrente que @'e o valor da vari@'avel
@code{modulus}.  

@code{polymod (@var{p}, @var{m})} especifica um m@'odulo @var{m} para ser usado 
em lugar do valor corrente de @code{modulus}.

Veja @code{modulus}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} mod (@var{x}, @var{y})

Se @var{x} e @var{y} forem n@'umeros reais e @var{y} for n@~ao nulo,
retorna @code{@var{x} - @var{y} * floor(@var{x} / @var{y})}.
Adicionalmente para todo real @var{x}, n@'os temos @code{mod (@var{x}, 0) = @var{x}}. Para uma discurs@~ao da
defini@value{cedilha}@~ao @code{mod (@var{x}, 0) = @var{x}}, veja a Se@value{cedilha}@~ao 3.4, de "Concrete Mathematics," 
por Graham, Knuth, e Patashnik. A fun@value{cedilha}@~ao @code{mod (@var{x}, 1)} 
@'e uma fun@value{cedilha}@~ao dente de serra com per@'{@dotless{i}}odo 1 e com @code{mod (1, 1) = 0} e 
@code{mod (0, 1) = 0}.

Para encontrar o argumento (um n@'umero no intervalo @code{(-%pi, %pi]}) de um 
n@'umero complexo, use a fun@value{cedilha}@~ao @code{@var{x} |-> %pi - mod (%pi - @var{x}, 2*%pi)}, onde 
@var{x} @'e um argumento.

Quando @var{x} e @var{y} forem express@~oes constantes (@code{10 * %pi}, por exemplo), @code{mod}
usa o mesmo esquema de avalia@value{cedilha}@~ao em ponto flutuante que @code{floor} e @code{ceiling} usam.
Novamente, @'e poss@'{@dotless{i}}vel, embora improv@'avel, que @code{mod} possa retornar um
valor err@^oneo nesses casos.

Para argumentos n@~ao num@'ericos @var{x} ou @var{y}, @code{mod }conhece muitas regras de
simplifica@value{cedilha}@~ao:

@c ===beg===
@c mod (x, 0);
@c mod (a*x, a*y);
@c mod (0, x);
@c ===end===
@example
(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} oddp (@var{expr})
@'e @code{true} se @var{expr} for um inteiro @'{@dotless{i}}mpar.
@c THIS IS STRANGE -- SHOULD RETURN NOUN FORM IF INDETERMINATE
@code{false} @'e retornado em todos os outros casos.

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c NOTE THAT pred IS RECOGNIZED ONLY AS AN ARGUMENT TO ev,
@c BUT FOR SOME REASON pred DOES NOT HAVE THE evflag PROPERTY
@deffn {Operador} pred
Como um argumento em uma chamada a @code{ev (@var{expr})},
@code{pred} faz com que predicados (express@~oes que avaliam para @code{true}
ou @code{false}) sejam avaliados.
Veja @code{ev}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} make_random_state (@var{n})
@deffnx {Fun@value{cedilha}@~ao} make_random_state (@var{s})
@deffnx {Fun@value{cedilha}@~ao} make_random_state (true)
@deffnx {Fun@value{cedilha}@~ao} make_random_state (false)
@c OMIT THIS FOR NOW. SEE COMMENT BELOW.
@c @defunx make_random_state (@var{a})
Um objecto de estado aleat@'orio representa o estado do gerador de n@'umeros aleat@'orios (aleat@'orios).
O estado compreende 627 palavras de 32 bits.

@code{make_random_state (@var{n})} retorna um novo objecto de estado aleat@'orio
criado de um valor inteiro semente igual a @var{n} modulo 2^32.  
@var{n} pode ser negativo.

@c OMIT THIS FOR NOW. NOT SURE HOW THIS IS SUPPOSED TO WORK.
@c @code{make_random_state (@var{a})} returns a new random state object
@c created from an array @var{a}, which must be a Lisp array of 32 unsigned bytes.

@code{make_random_state (@var{s})} retorna uma copia do estado aleat@'orio @var{s}.

@code{make_random_state (true)} retorna um novo objecto de estado aleat@'orio,
usando a hora corrente  do rel@'ogio do computador como semente.

@code{make_random_state (false)} retorna uma c@'opia do estado corrente
do gerador de n@'umeros aleat@'orios.

@end deffn

@deffn {Fun@value{cedilha}@~ao} set_random_state (@var{s})
Copia @var{s} para o estado do gerador de n@'umeros aleat@'orios.

@code{set_random_state} sempre retorna @code{done}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} random (@var{x})
Retorna um n@'umero pseudoaleat@'orio. Se @var{x} @'e um inteiro, @code{random (@var{x})} retorna um
inteiro de 0 a @code{@var{x} - 1} inclusive. Se @var{x} for um n@'umero em ponto flutuante,
@code{random (@var{x})} retorna um n@'umero n@~ao negativo em ponto flutuante menor que @var{x}.
@code{random} reclama com um erro se @var{x} n@~ao for nem um inteiro nem um n@'umero em ponto flutuante,
ou se @var{x} n@~ao for positivo.

As fun@value{cedilha}@~oes @code{make_random_state} e @code{set_random_state}
mant@'em o estado do gerador de n@'umeros aleat@'orios.

O gerador de n@'umeros aleat@'orios do Maxima @'e uma implementa@value{cedilha}@~ao do algoritmo de Mersenne twister MT 19937.

Exemplos:

@c ===beg===
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c ===end===
@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} rationalize (@var{expr})

Converte todos os n@'umeros em ponto flutuante de precis@~ao dupla e
grandes n@'umeros em ponto flutuante na express@~ao do Maxima @var{expr}
para seus exatos equivalentes racionais. Se vn@~ao estiver familiarizado
com a representa@value{cedilha}@~ao bin@'aria dos n@'umeros em ponto
flutuante, pode ficar surpreendido em saber que @code{rationalize (0.1)}
n@~ao @'e igual a 1/10.  Esse comportamento n@~ao @'e especial do Maxima
-- o n@'umero 1/10 tem uma representa@value{cedilha}@~ao bin@'aria
repetitiva e n@~ao terminada.

@c ===beg===
@c rationalize (0.5);
@c rationalize (0.1);
@c fpprec : 5$
@c rationalize (0.1b0);
@c fpprec : 20$
@c rationalize (0.1b0);
@c rationalize (sin (0.1*x + 5.6));
@c ===end===
@example
(%i1) rationalize (0.5);
                                1
(%o1)                           -
                                2
(%i2) rationalize (0.1);
                               1
(%o2)                          --
                               10
 (%i3) fpprec : 5$
(%i4) rationalize (0.1b0);
                             209715
(%o4)                        -------
                             2097152
(%i5) fpprec : 20$
(%i6) rationalize (0.1b0);
                     236118324143482260685
(%o6)                ----------------------
                     2361183241434822606848
(%i7) rationalize (sin (0.1*x + 5.6));
                              x    28
(%o7)                     sin(-- + --)
                              10   5
@end example

Exemplo de utiliza@value{cedilha}@~ao:

@c ===beg===
@c unitfrac(r) := block([uf : [], q],
@c     if not(ratnump(r)) then error("A entrada para 'unitfrac' deve ser um n@'umero racional"),
@c     while r # 0 do (
@c         uf : cons(q : 1/ceiling(1/r), uf),
@c         r : r - q),
@c     reverse(uf)); 
@c unitfrac (9/10);
@c apply ("+", %);
@c unitfrac (-9/10);
@c apply ("+", %);
@c unitfrac (36/37);
@c apply ("+", %);
@c ===end===
@example
(%i1) unitfrac(r) := block([uf : [], q],
    if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
    while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
    reverse(uf)); 
(%o1) unitfrac(r) := block([uf : [], q], 
if not ratnump(r) then error("The input to 'unitfrac' must be a rational number"
                                     1
), while r # 0 do (uf : cons(q : ----------, uf), r : r - q), 
                                         1
                                 ceiling(-)
                                         r
reverse(uf))
(%i2) unitfrac (9/10);
                            1  1  1
(%o2)                      [-, -, --]
                            2  3  15
(%i3) apply ("+", %);
                               9
(%o3)                          --
                               10
(%i4) unitfrac (-9/10);
                                  1
(%o4)                       [- 1, --]
                                  10
(%i5) apply ("+", %);
                                9
(%o5)                         - --
                                10
(%i6) unitfrac (36/37);
                        1  1  1  1    1
(%o6)                  [-, -, -, --, ----]
                        2  3  8  69  6808
(%i7) apply ("+", %);
                               36
(%o7)                          --
                               37
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} sign (@var{expr})
Tenta determinar o sinal de @var{expr}
a partir dos factos na base de dados corrente.  Retorna uma das
seguintes respostar: @code{pos} (positivo), @code{neg} (negativo), @code{zero}, @code{pz}
(positivo ou zero), @code{nz} (negativo ou zero), @code{pn} (positivo ou negativo),
ou @code{pnz} (positivo, negativo, ou zero, i.e. nada se sabe sobre o sinal da epress@~ao).

@end deffn

@deffn {Fun@value{cedilha}@~ao} signum (@var{x})
Para um @var{x} num@'erico retorna 0 se @var{x} for 0, de outra forma retorna -1 ou +1
@`a medida que @var{x} seja menor ou maior que 0, respectivamente.

Se @var{x} n@~ao for num@'erico ent@~ao uma forma simplificada mas equivalente @'e retornada.
Por exemplo, @code{signum(-x)} fornece @code{-signum(x)}.
@c UMM, THIS ISN'T THE WHOLE STORY, AS IT APPEARS signum CONSULTS THE assume DATABASE FOR SYMBOLIC ARGUMENT

@end deffn

@deffn {Fun@value{cedilha}@~ao} sort (@var{L}, @var{P})
@deffnx {Fun@value{cedilha}@~ao} sort (@var{L})
Organiza uma lista @var{L} coforme o predicado @code{P} de dois argumentos,
de forma que @code{@var{P} (@var{L}[k], @var{L}[k + 1])} seja @code{true}
para qualquer dois elementos sucessivos.
O predicado pode ser especificado como o nome de uma fun@value{cedilha}@~ao ou operador bin@'ario infixo,
ou como uma express@~ao @code{lambda}.
Se especificado como o nome de um operador,
o nome deve ser contido entre "aspas duplas".

A lista ordenada @'e retornada como novo objecto;
o argumento @var{L} n@~ao @'e modificado.
Para construir o valor de retorno,
@code{sort} faz uma c@'opia superficial dos elementos de @var{L}.
@c DUNNO IF WE NEED TO GO INTO THE IMPLICATIONS OF SHALLOW COPY HERE ...
@c MIGHT CONSIDER A REF FOR TOTAL ORDER HERE
Se o predicado @var{P} n@~ao for uma ordem total sobre os elementos de @var{L},
ent@~ao @code{sort} possivelvente pode executar para concluir sem error,
mas os resultados s@~ao indefinidos.
@code{sort} reclama se o predicado avaliar para alguma outra coisa
que n@~ao seja @code{true} ou @code{false}.

@code{sort (@var{L})} @'e equivalente a @code{sort (@var{L}, orderlessp)}.
Isto @'e, a ordem padr@~ao de organiza@value{cedilha}@~ao @'e ascendente,
como determinado por @code{orderlessp}.
Todos os @'atomos do Maxima e express@~oes s@~ao compar@'aveis sob @code{orderlessp},
embora exista exemplos isolados de express@~oes para as quais @code{orderlessp} n@~ao @'e transitiva;
isso @'e uma falha.
 
Exemplos:
 
@c ===beg===
@c sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
@c sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
@c sort ([%pi, 3, 4, %e, %gamma]);
@c sort ([%pi, 3, 4, %e, %gamma], "<");
@c my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
@c sort (my_list);
@c sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
@c ===end===
@example
(%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
               5
(%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
               2
(%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                   5
(%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                   2
(%i3) sort ([%pi, 3, 4, %e, %gamma]);
(%o3)                [3, 4, %e, %gamma, %pi]
(%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
(%o4)                [%gamma, %e, 3, %pi, 4]
(%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
(%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
(%i6) sort (my_list);
(%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
(%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
(%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]
@end example
 
@end deffn

@deffn {Fun@value{cedilha}@~ao} sqrt (@var{x})
A ra@'{@dotless{i}}z quadrada de @var{x}. @'E representada internamente por
@code{@var{x}^(1/2)}.  Veja tamb@'em @code{rootscontract}.

@code{radexpand} se @code{true} far@'a com que n-@'esimas ra@'{@dotless{i}}zes de factores de um produto
que forem pot@^encias de n sejam colocados fora do radical, e.g.
@code{sqrt(16*x^2)} retonar@'a @code{4*x} somente se @code{radexpand} for @code{true}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} sqrtdispflag
Valor por omiss@~ao: @code{true}

Quando @code{sqrtdispflag} for @code{false},
faz com que @code{sqrt} seja mostrado como expoente 1/2.
@c AND OTHERWISE ... ??

@end defvr

@c NEEDS EXPANSION, CLARIFICATION, MORE EXAMPLES
@c sublis CAN ONLY SUBSTITUTE FOR ATOMS, RIGHT ?? IF SO, SAY SO
@deffn {Fun@value{cedilha}@~ao} sublis (@var{lista}, @var{expr})
Faz m@'ultiplas substitui@value{cedilha}@~oes paralelas dentro de uma express@~ao.

A vari@'avel @code{sublis_apply_lambda} controla a simplifica@value{cedilha}@~ao ap@'os
@code{sublis}.

Exemplo:

@example
@c ===beg===
@c sublis ([a=b, b=a], sin(a) + cos(b));
@c ===end===
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} sublist (@var{lista}, @var{p})
Retorna a lista de elementos da @var{lista} da qual o
predicado @code{p} retornar @code{true}.

Exemplo:

@c ===beg===
@c L: [1, 2, 3, 4, 5, 6];
@c sublist (L, evenp);
@c ===end===
@example
(%i1) L: [1, 2, 3, 4, 5, 6];
(%o1)                  [1, 2, 3, 4, 5, 6]
(%i2) sublist (L, evenp);
(%o2)                       [2, 4, 6]
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} sublis_apply_lambda
Valor por omiss@~ao: @code{true} - controla se os substitutos de
@code{lambda} s@~ao aplicados na simplifica@value{cedilha}@~ao ap@'os as
@code{sublis} serem usadas ou se tiver que fazer um @code{ev} para obter
coisas para aplicar.  @code{true} significa fa@value{cedilha}a a
aplica@value{cedilha}@~ao.

@end defvr

@c NEEDS CLARIFICATION, MORE EXAMPLES
@deffn {Fun@value{cedilha}@~ao} subst (@var{a}, @var{b}, @var{c})
Substitue @var{a} por @var{b} em @var{c}.  @var{b} deve ser um @'atomo ou uma
subexpress@~ao completa de @var{c}.  Por exemplo, @code{x+y+z} @'e uma subexpress@~ao
completa de @code{2*(x+y+z)/w} enquanto @code{x+y} n@~ao @'e. Quando @var{b} n@~ao tem
essas caracter@'{@dotless{i}}sticas, pode-se algumas vezes usar @code{substpart} ou @code{ratsubst}
(veja abaixo).  Alternativamente, se @var{b} for da forma de @code{e/f} ent@~ao se poder@'a
usar @code{subst (a*f, e, c)} enquanto se @var{b} for da forma @code{e^(1/f)} ent@~ao se poder@'a
usar @code{subst (a^f, e, c)}.  O comando @code{subst} tamb@'em discerne o @code{x^y} de @code{x^-y}
de modo que @code{subst (a, sqrt(x), 1/sqrt(x))} retorna @code{1/a}.  @var{a} e @var{b} podem tamb@'em ser
operadores de uma express@~ao contida entre aspas duplas @code{"} ou eles podem ser nomes de
fun@value{cedilha}@~ao.  Se se desejar substituir por uma vari@'avel independente em
formas derivadas ent@~ao a fun@value{cedilha}@~ao @code{at} (veja abaixo) poder@'a ser usada.

@c UMM, REVERSE THIS AND MOVE IT TO substitute ??
@code{subst} @'e um @'alias para @code{substitute}.

@code{subst (@var{eq_1}, @var{expr})} ou @code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
s@~ao outras formas
permitidas.  As @var{eq_i} s@~ao equa@value{cedilha}@~oes indicando substitui@value{cedilha}@~oes a serem feitas.
Para cada equa@value{cedilha}@~ao, o lado direito ser@'a substitu@'{@dotless{i}}do pelo lado esquerdo na
express@~ao @var{expr}.

@code{exptsubst} se @code{true} permite que substitui@value{cedilha}@~oes
como @code{y} por @code{%e^x} em @code{%e^(a*x)} ocorram.

@c WHAT IS THIS ABOUT ??
Quando @code{opsubst} for @code{false},
@code{subst} tentar@'a substituir dentro do operador de uma express@~ao.
E.g. @code{(opsubst: false, subst (x^2, r, r+r[0]))} trabalhar@'a.

Exemplos:

@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
Para exemplos adicionais, fa@value{cedilha}a @code{example (subst)}.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~ao} substinpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Similar a @code{substpart}, mas @code{substinpart} trabalha sobre a
representa@value{cedilha}@~ao interna de @var{expr}.

Exemplos:

@c ===beg===
@c x . 'diff (f(x), x, 2);
@c substinpart (d^2, %, 2);
@c substinpart (f1, f[1](x + 1), 0);
@c ===end===
@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example

Se o @'ultimo argumento para a fun@value{cedilha}@~ao @code{part} for uma lista de @'{@dotless{i}}ndices ent@~ao
muitas subexpress@~oes s@~ao escolhidas, cada uma correspondendo a um
@'{@dotless{i}}ndice da lista.  Dessa forma

@c ===beg===
@c part (x + y + z, [1, 3]);
@c ===end===
@example
(%i1) part (x + y + z, [1, 3]);
(%o1)                         z + x
@end example

@code{piece} recebe o valor da @'ultima express@~ao seleccionada quando usando as
fun@value{cedilha}@~oes @code{part}.  @code{piece} @'e escolhida durante a execu@value{cedilha}@~ao da fun@value{cedilha}@~ao e
dessa forma pode ser referenciada para a pr@'opria fun@value{cedilha}@~ao como mostrado abaixo.
Se @code{partswitch} for escolhida para @code{true} ent@~ao @code{end} @'e retornado quando uma
parte seleccionada de uma express@~ao n@~ao existir, de outra forma uma mensagem
de erro @'e fornecida.

@c ===beg===
@c expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
@c part (expr, 2, [1, 3]);
@c sqrt (piece/54);
@c substpart (factor (piece), expr, [1, 2, 3, 5]);
@c expr: 1/x + y/x - 1/z;
@c substpart (xthru (piece), expr, [2, 3]);
@c ===end===
@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Tamb@'em, escolhendo a op@value{cedilha}@~ao @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} @'e
o mesmo que chamando @code{inpart} ou @code{substinpart}.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~ao} substpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Substitue @var{x} para a subexpress@~ao
seleccionada pelo resto dos argumentos como em @code{part}.  Isso retorna o
novo valor de @var{expr}.  @var{x} pode ser algum operador a ser substitu@'{@dotless{i}}do por um
operador de @var{expr}.  Em alguns casos @var{x} precisa ser contido em aspas duplas @code{"}
(e.g.  @code{substpart ("+", a*b, 0)} retorna @code{b + a}).

@c ===beg===
@c 1/(x^2 + 2);
@c substpart (3/2, %, 2, 1, 2);
@c a*x + f(b, y);
@c substpart ("+", %, 1, 0);
@c ===end===
@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Tamb@'em, escolhendo a op@value{cedilha}@~ao @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} @'e
o mesmo que chamando @code{inpart} ou @code{substinpart}.

@end deffn

@c NEEDS EXPANSION AND EXAMPLES
@deffn {Fun@value{cedilha}@~ao} subvarp (@var{expr})
Retorna @code{true} se @var{expr} for uma vari@'avel subscrita (i.e. que possui @'{@dotless{i}}ndice ou subscrito em sua grafia), por exemplo
@code{a[i]}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} symbolp (@var{expr})
Retorna @code{true} se @var{expr} for um s@'{@dotless{i}}mbolo, de outra forma retorna @code{false}.
com efeito, @code{symbolp(x)} @'e equivalente ao predicado @code{atom(x) and not numberp(x)}.

@c FOLLOWING REALLY WANTS TO BE @xref{Identiifers} BUT THAT
@c LEAVES THE UNPLEASANT RESIDUE *Note ...:: IN THE OUTPUT OF describe
Veja tamb@'em @emph{Identificadores}

@end deffn

@deffn {Fun@value{cedilha}@~ao} unorder ()
Disabilita a a@value{cedilha}@~ao de alias criada pelo @'ultimo uso dos comandos
de ordena@value{cedilha}@~ao @code{ordergreat} e @code{orderless}. @code{ordergreat} e @code{orderless} n@~ao podem
ser usados mais que uma vez cada sem chamar @code{unorder}. 
Veja tamb@'em @code{ordergreat} e @code{orderless}.

Exemplos:

@c HMM, IN THIS EXAMPLE, WHY ISN'T %o5 EQUAL TO ZERO ???
@c ===beg===
@c unorder();
@c b*x + a^2;
@c ordergreat (a);
@c b*x + a^2;
@c  %th(1) - %th(3);
@c unorder();
@c ===end===
@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
 %th(1) - %th(3);
                             2
(%o4)                       a  + b x
(%i5) unorder();
                              2    2
(%o5)                        a  - a
@end example

@end deffn

@c THIS ITEM SEEMS OUT OF PLACE -- IS IT FROM A SHARE PACKAGE ??
@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} vectorpotential (@var{givencurl})
Retorna o potencial do vector de um dado
vector de tor@value{cedilha}@~ao, no sistema de coordenadas corrente.
@code{potentialzeroloc} tem um papel similar ao de @code{potential}, mas a ordem dos
lados esquerdos das equa@value{cedilha}@~oes deve ser uma permuta@value{cedilha}@~ao c@'{@dotless{i}}clica das
vari@'aveis de coordenadas.

@end deffn

@deffn {Fun@value{cedilha}@~ao} xthru (@var{expr})
Combina todos os termos de @var{expr} (o qual pode ser uma adi@value{cedilha}@~ao) sobre um
denominador comum sem produtos e somas exponenciadas
como @code{ratsimp} faz.  @code{xthru} cancela factores comuns no numerador e
denominador de express@~oes racionais mas somente se os factores s@~ao
expl@'{@dotless{i}}citos.

@c REPHRASE IN NEUTRAL TONE (GET RID OF "IT IS BETTER")
Algumas vezes @'e melhor usar @code{xthru} antes de @code{ratsimp} em uma
express@~ao com o objectivo de fazer com que factores explicitos do m@'aximo divisor comum entre o
numerador e o denominador seja cancelado simplificando dessa forma a
express@~ao a ser aplicado o @code{ratsimp}.

@c ===beg===
@c ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
@c xthru (%);
@c ===end===
@example
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
@end example

@end deffn

@c THIS FUNCTION APPEARS TO BE A HACK; SEE 4'TH ITEM BELOW
@c DUNNO WHETHER WE CAN CLEAR THIS UP
@deffn {Fun@value{cedilha}@~ao} zeroequiv (@var{expr}, @var{v})
Testa se a express@~ao @var{expr} na vari@'avel
@var{v} @'e equivalente a zero, retornando @code{true}, @code{false}, ou
@code{dontknow} (n@~ao sei).

@code{zeroequiv} Tem essas restri@value{cedilha}@~oes:
@enumerate
@item
N@~ao use fun@value{cedilha}@~oes que o Maxima n@~ao sabe como
diferenciar e avaliar.
@item
Se a express@~ao tem postes sobre o eixo real, podem existir erros
no resultado (mas isso @'e improv@'avel ocorrer).
@item
Se a express@~ao contem fun@value{cedilha}@~oes que n@~ao s@~ao solu@value{cedilha}@~oes para
equa@value{cedilha}@~oes diferenciais de primeira ordem (e.g.  fun@value{cedilha}@~oes de Bessel) pode ocorrer
resultados incorrectos.
@item
O algoritmo usa avalia@value{cedilha}@~ao em pontos aleat@'oriamente escolhidos para
subexpress@~oes seleccionadas cuidadosamente.  Isso @'e sempre neg@'ocio um tanto
quanto perigoso, embora o algoritmo tente minimizar o
potencial de erro.
@end enumerate

Por exemplo
 @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} retorna
@code{true} e @code{zeroequiv (%e^x + x, x)} retorna @code{false}.
Por outro lado @code{zeroequiv (log(a*b) - log(a) - log(b), a)} retorna @code{dontknow} devido @`a
presen@value{cedilha}a de um par@^ametro extra @code{b}.

@end deffn
