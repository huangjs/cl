@c /Polynomials.texi/1.22/Sun May 21 07:18:29 2006/-ko/
@c FOR THE FUNCTIONS WHICH RETURN A CRE, BE SURE TO MENTION THAT
@menu
* Introdu@value{cedilha}@~ao a Polin@'omios::  
* Defini@value{cedilha}@~oes para Polin@'omios::  
@end menu

@node Introdu@value{cedilha}@~ao a Polin@'omios, Defini@value{cedilha}@~oes para Polin@'omios, Polin@'omios, Polin@'omios
@section Introdu@value{cedilha}@~ao a Polin@'omios

Polin@'omios s@~ao armazenados no Maxima ou na forma geral ou na
forma de Express@~oes Racionais Can@'onicas (CRE).  Essa @'ultima @'e uma forma
padr@~ao, e @'e usada internamente por opera@value{cedilha}@~oes tais como @code{factor}, @code{ratsimp}, e
assim por diante.

Express@~oes Racionais Can@'onicas constituem um tipo de representa@value{cedilha}@~ao
que @'e especialmente adequado para polin@'omios expandidos e fun@value{cedilha}@~oes
racionais (tamb@'em para polin@'omios parcialmente factorizados e fun@value{cedilha}@~oes
racionais quando RATFAC for escolhida para @code{true}).  Nessa forma CRE uma
ordena@value{cedilha}@~ao de vari@'aveis (da mais para a menos importante) @'e assumida para cada
express@~ao.  Polin@'omios s@~ao representados recursivamente por uma lista
consistindo da vari@'avel principal seguida por uma s@'erie de pares de
express@~oes, uma para cada termo do polin@'omio.  O primeiro membro de
cada par @'e o expoente da vari@'avel principal naquele termo e o
segundo membro @'e o coeficiente daquele termo que pode ser um n@'umero ou
um polin@'omio em outra vari@'avel novamente respresentado nessa forma.  Sendo assim
a parte principal da forma CRE de 3*X^2-1 @'e (X 2 3 0 -1) e que a parte principal da
forma CRE de 2*X*Y+X-3 @'e (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assumindo Y como sendo a
vari@'avel principal, e @'e (X 1 (Y 1 2 0 1) 0 -3) assumindo X como sendo a
vari@'avel principal. A vari@'avel principal @'e usualmente determineda pela ordem alfab@'etica
reversa.  As "vari@'aveis" de uma express@~ao CRE n@~ao necessariamente devem ser at@^omicas.  De facto
qualquer subexpress@~ao cujo principal operador n@~ao for + - * / or ^ com expoente
inteiro ser@'a considerado uma "vari@'avel" da express@~ao (na forma CRE) na
qual essa ocorrer.  Por exemplo as vari@'aveis CRE da express@~ao
X+SIN(X+1)+2*SQRT(X)+1 s@~ao X, SQRT(X), e SIN(X+1).  Se o utilizador
n@~ao especifica uma ordem de vari@'aveis pelo uso da fun@value{cedilha}@~ao RATVARS
Maxima escolher@'a a alfab@'etica por conta pr@'opria.  Em geral, CREs representam
express@~oes racionais, isto @'e, raz@~oes de polin@'omios, onde o
numerador e o denominador n@~ao possuem factores comuns, e o denominador for
positivo.  A forma interna @'e essencialmente um par de polin@'omios (o
numerador e o denominador) precedidos pela lista de ordena@value{cedilha}@~ao de vari@'avel.  Se
uma express@~ao a ser mostrada estiver na forma CRE ou se contiver quaisquer
subexpress@~oes na forma CRE, o s@'{@dotless{i}}mbolo /R/ seguir@'a o r@'otulo da linha.
Veja a fun@value{cedilha}@~ao RAT para saber como converter uma express@~ao para a forma CRE.  Uma
forma CRE extendida @'e usada para a representa@value{cedilha}@~ao de s@'eries de Taylor.  A
no@value{cedilha}@~ao de uma express@~ao racional @'e extendida de modo que os expoentes das
vari@'aveis podem ser n@'umeros racionais positivos ou negativos em lugar de apenas
inteiros positivos e os coeficientes podem eles mesmos serem express@~oes
racionais como descrito acima em lugar de apenas polin@'omios.  Estes s@~ao
representados internamente por uma forma polinomial recursiva que @'e similar
@`a forma CRE e @'e a generaliza@value{cedilha}@~ao dessa mesma forma CRE, mas carrega informa@value{cedilha}@~ao
adicional tal com o grau de trunca@value{cedilha}@~ao.  Do mesmo modo que na forma CRE, o
s@'{@dotless{i}}mbolo /T/ segue o r@'otulo de linha que cont@'em as tais express@~oes.

@node Defini@value{cedilha}@~oes para Polin@'omios,  , Introdu@value{cedilha}@~ao a Polin@'omios, Polin@'omios
@section Defini@value{cedilha}@~oes para Polin@'omios

@defvr {Vari@'avel de op@value{cedilha}@~ao} algebraic
Valor Padr@~ao: @code{false}

@code{algebraic} deve ser escolhida para @code{true} com o objectivo de que a
simplifica@value{cedilha}@~ao de inteiros alg@'ebricos tenha efeito.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} berlefact
Valor Padr@~ao: @code{true}

Quando @code{berlefact} for @code{false} ent@~ao o algoritmo de factoriza@value{cedilha}@~ao de
Kronecker ser@'a usado.  De outra forma o algoritmo de Berlekamp, que @'e o
padr@~ao, ser@'a usado.

@end defvr

@c WHAT IS THIS ABOUT EXACTLY ??
@deffn {Fun@value{cedilha}@~ao} bezout (@var{p1}, @var{p2}, @var{x})
uma alternativa para o comando @code{resultant}.  Isso
retorna uma matriz.  @code{determinant} dessa matriz @'e o resultante desejado.

@end deffn

@c REWORD THIS ITEM -- COULD BE MORE CONCISE
@deffn {Fun@value{cedilha}@~ao} bothcoef (@var{expr}, @var{x})
Retorna uma lista da qual o primeiro membro @'e o
coeficiente de @var{x} em @var{expr} (como achado por @code{ratcoef} se @var{expr} est@'a na forma CRE
de outro modo por @code{coeff}) e cujo segundo membro @'e a parte restante de
@var{expr}.  Isto @'e, @code{[A, B]} onde @code{@var{expr} = A*@var{x} + B}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         @'e (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);

@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        @'e (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} coeff (@var{expr}, @var{x}, @var{n})
Retorna o coeficiente de @code{@var{x}^@var{n}} em @var{expr}.  @var{n} pode ser
omitido se for 1.  @var{x} pode ser um @'atomo, ou subexpress@~ao completa de
@var{expr} e.g., @code{sin(x)}, @code{a[i+1]}, @code{x + y}, etc. (No @'ultimo caso a
express@~ao @code{(x + y)} pode ocorrer em @var{expr}).  Algumas vezes isso pode ser necess@'ario
para expandir ou factorizar @var{expr} com o objectivo de fazer @code{@var{x}^@var{n}} explicito.  Isso n@~ao @'e
realizado por @code{coeff}.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
@c coeff (y + x*%e^x + 1, x, 0);

@example
(%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
(%o1)                      2 a + 1 = 5
(%i2) coeff (y + x*%e^x + 1, x, 0);
(%o2)                         y + 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} combine (@var{expr})
Simplifica a adi@value{cedilha}@~ao @var{expr} por termos combinados com o mesmo
denominador dentro de um termo simples.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} content (@var{p_1}, @var{x_1}, ..., @var{x_n})
Retorna uma lista cujo primeiro elemento @'e
o m@'aximo divisor comum dos coeficientes dos termos do
polin@'omio @var{p_1} na vari@'avel @var{x_n} (isso @'e o conte@'udo) e cujo
segundo elemento @'e o polin@'omio @var{p_1} dividido pelo conte@'udo.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c content (2*x*y + 4*x^2*y^2, y);

@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} denom (@var{expr})
Retorna o denominador da express@~ao racional @var{expr}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} divide (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
calcula o quocietne e o resto
do polin@'omio @var{p_1} dividido pelo polin@'omio @var{p_2}, na vari@'avel
principal do polin@'omio, @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
As outras vari@'aveis s@~ao como na fun@value{cedilha}@~ao @code{ratvars}.
O resultado @'e uma lista cujo primeiro elemento @'e o quociente
e cujo segundo elemento @'e o resto.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@noindent
Note que @code{y} @'e a vari@'avel principal no segundo exemplo.

@end deffn

@deffn {Fun@value{cedilha}@~ao} eliminate ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_k}])
Elimina vari@'aveis de
equa@value{cedilha}@~oes (ou express@~oes assumidas iguais a zero) obtendo resultantes
sucessivos. Isso retorna uma lista de @code{@var{n} - @var{k}} express@~oes com @var{k}
vari@'aveis @var{x_1}, ..., @var{x_k} eliminadas.  Primeiro @var{x_1} @'e eliminado retornando @code{@var{n} - 1}
express@~oes, ent@~ao @code{x_2} @'e eliminado, etc.  Se @code{@var{k} = @var{n}} ent@~ao uma express@~ao simples em uma
lista @'e retornada livre das vari@'aveis @var{x_1}, ..., @var{x_k}.  Nesse caso @code{solve}
@'e chamado para resolver a @'ultima resultante para a @'ultima vari@'avel.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);

@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, ...)
Retorna uma lista cujo primeiro elemento @'e o m.d.c. dos
polin@'omios @var{p_1}, @var{p_2}, @var{p_3}, ...  e cujos restantes elementos s@~ao os
polin@'omios divididos pelo mdc.  Isso sempre usa o algoritmo
@code{ezgcd}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} facexpand
Valor Padr@~ao: @code{true}

@code{facexpand} controla se os factores irredut@'{@dotless{i}}veis
retornados por @code{factor} est@~ao na forma expandida (o padr@~ao) ou na forma recursiva
(CRE normal).

@end defvr

@deffn {Fun@value{cedilha}@~ao} factcomb (@var{expr})
Tenta combinar os coeficientes de factoriais em @var{expr}
com os pr@'oprios factoriais convertendo, por exemplo, @code{(n + 1)*n!}
em @code{(n + 1)!}.

@code{sumsplitfact} se escolhida para @code{false} far@'a com que @code{minfactorial} seja
aplicado ap@'os um @code{factcomb}.

@c Example:
@c UH, THESE ARE THE EXPRESSIONS WHICH WERE GIVEN IN 
@c THE PREVIOUS REVISION OF THIS FILE, BUT IN THIS CASE
@c factcomb HAS NO EFFECT -- I GUESS A DIFFERENT EXAMPLE IS CALLED FOR
@c (n + 1)^b*n!^b;
@c factcomb (%);
@end deffn

@deffn {Fun@value{cedilha}@~ao} factor (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} factor (@var{expr}, @var{p})

Factoriza a express@~ao @var{expr}, contendo qualquer n@'umero de
vari@'aveis ou fun@value{cedilha}@~oes, em factores irredut@'{@dotless{i}}veis sobre os inteiros.
@code{factor (@var{expr}, @var{p})} factoriza @var{expr} sobre o campo dos inteiros com um elemento
adjunto cujo menor polin@'omio @'e @var{p}.

@code{factor} usa a fun@value{cedilha}@~ao @code{ifactors} para factorizar inteiros.

@code{factorflag} se @code{false} suprime a factoriza@value{cedilha}@~ao de factores inteiros
de express@~oes racionais.

@code{dontfactor} pode ser escolhida para uma lista de vari@'aveis com rela@value{cedilha}@~ao @`a qual
factoriza@value{cedilha}@~ao n@~ao @'e para ocorrer.  (Essa @'e inicialmente vazia).  Factoriza@value{cedilha}@~ao tamb@'em
n@~ao acontece com rela@value{cedilha}@~ao a quaisquer vari@'aveis que s@~ao menos
importantes (usando a ordena@value{cedilha}@~ao de vari@'avel assumida pela forma CRE) como
essas na lista @code{dontfactor}.

@code{savefactors} se @code{true} faz com que os factores de uma express@~ao que
@'e um produto de factores seja guardada por certas fun@value{cedilha}@~oes com o objectivo de
aumentar a velocidade de futuras factoriza@value{cedilha}@~oes de express@~oes contendo alguns dos
mesmos factores.

@code{berlefact} se @code{false} ent@~ao o algoritmo de factoriza@value{cedilha}@~ao de Kronecker ser@'a
usado de outra forma o algoritmo de Berlekamp, que @'e o padr@~ao, ser@'a
usado.

@code{intfaclim} se @code{true} maxima ir@'a interromper a factoriza@value{cedilha}@~ao de
inteiros se nenhum factor for encontrado ap@'os tentar divis@~oes e o m@'etodo rho de
Pollard.  Se escolhida para @code{false} (esse @'e o caso quando o utilizador chama
@code{factor} explicitamente), a factoriza@value{cedilha}@~ao completa do inteiro ser@'a
tentada.  A escolha do utilizador para @code{intfaclim} @'e usada para chamadas
internas a @code{factor}. Dessa forma, @code{intfaclim} pode ser resetada para evitar que o
Maxima gaste um tempo muito longo factorizando inteiros grandes.

Exemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} factorflag
Valor Padr@~ao: @code{false}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{factorflag} for @code{false}, suprime a factoriza@value{cedilha}@~ao de
factores inteiros em express@~oes racionais.

@end defvr

@deffn {Fun@value{cedilha}@~ao} factorout (@var{expr}, @var{x_1}, @var{x_2}, ...)
Rearranja a adi@value{cedilha}@~ao @var{expr} em uma adi@value{cedilha}@~ao de
parcelas da forma @code{f (@var{x_1}, @var{x_2}, ...)*g} onde @code{g} @'e um produto de
express@~oes que n@~ao possuem qualquer @var{x_i} e @code{f} @'e factorizado.
@c NEED EXAMPLE HERE

@end deffn

@deffn {Fun@value{cedilha}@~ao} factorsum (@var{expr})
Tenta agrupar parcelas em factores de @var{expr} que s@~ao adi@value{cedilha}@~oes
em grupos de parcelas tais que sua adi@value{cedilha}@~ao @'e factor@'avel.  @code{factorsum} pode
recuperar o resultado de @code{expand ((x + y)^2 + (z + w)^2)} mas n@~ao pode recuperar
@code{expand ((x + 1)^2 + (x + y)^2)} porque os termos possuem vari@'aveis em comum.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} fasttimes (@var{p_1}, @var{p_2})
Retorna o produto dos polin@'omios @var{p_1} e @var{p_2} usando um
algoritmo especial para a multiplica@value{cedilha}@~ao de polin@'omios.  @code{p_1} e @code{p_2} podem ser
de v@'arias vari@'aveis, densos, e aproximadamente do mesmo tamanho.  A multiplica@value{cedilha}@~ao
cl@'assica @'e de ordem @code{n_1 n_2} onde
@code{n_1} @'e o grau de @code{p_1}
and @code{n_2} @'e o grau de @code{p_2}.
@code{fasttimes} @'e da ordem @code{max (n_1, n_2)^1.585}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} fullratsimp (@var{expr})
@code{fullratsimp} aplica
repetidamente @code{ratsimp} seguido por simplifica@value{cedilha}@~ao n@~ao racional a uma
express@~ao at@'e que nenhuma mudan@value{cedilha}a adicional ocorra,
e retorna o resultado.

Quando express@~oes n@~ao racionais est@~ao envolvidas, uma chamada
a @code{ratsimp} seguida como @'e usual por uma simplifica@value{cedilha}@~ao n@~ao racional
("geral") pode n@~ao ser suficiente para retornar um resultado simplificado.
Algumas vezes, mais que uma tal chamada pode ser necess@'aria. 
@code{fullratsimp} faz esse processo convenientemente.

@code{fullratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} aceita um ou
mais argumentos similar a @code{ratsimp} e @code{rat}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end deffn

@c SPELL OUT WHAT fullratsubst DOES INSTEAD OF ALLUDING TO ratsubst AND lratsubst
@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~ao} fullratsubst (@var{a}, @var{b}, @var{c})
@'e o mesmo que @code{ratsubst} excepto que essa chama
a si mesma recursivamente sobre esse resultado at@'e que o resultado para de mudar.
Essa fun@value{cedilha}@~ao @'e @'util quando a express@~ao de substitui@value{cedilha}@~ao e a
express@~ao substitu@'{@dotless{i}}da tenham uma ou mais vari@'aveis em comum.

@code{fullratsubst} ir@'a tamb@'em aceitar seus argumentos no formato de
@code{lratsubst}.  Isto @'e, o primeiro argumento pode ser uma substitui@value{cedilha}@~ao simples
de equa@value{cedilha}@~ao ou uma lista de tais equa@value{cedilha}@~oes, enquanto o segundo argumento @'e a
express@~ao sendo processada.

@code{load ("lrats")} chama @code{fullratsubst} e @code{lratsubst}.

Exemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c CAN PROBABLY CUT OUT THE lratsubst STUFF (lratsubst HAS ITS OWN DESCRIPTION)
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c errcatch (fullratsubst (b*a^2, a^2, a^3));

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} pode realizar multiplas substitui@value{cedilha}@~oes.
@code{lratsubst} @'e analogo a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Se somente uma substitui@value{cedilha}@~ao @'e desejada, ent@~ao uma equa@value{cedilha}@~ao
simples pode ser dada como primeiro argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@itemize @bullet
@item
@code{fullratsubst} @'e equivalente a @code{ratsubst}
excepto que essa executa recursivamente at@'e que seu resultado para de mudar.
@end itemize
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example
@itemize @bullet
@item
@code{fullratsubst} tamb@'em aceita uma lista de equa@value{cedilha}@~oes ou uma equa@value{cedilha}@~ao
simples como primeiro argumento.
@end itemize
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example
@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} pode causar uma recurs@~ao infinita.
@end itemize
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end deffn

@c GCD IS A VARIABLE AND A FUNCTION
@c THIS ITEM NEEDS A LOT OF WORK
@deffn {Fun@value{cedilha}@~ao} gcd (@var{p_1}, @var{p_2}, @var{x_1}, ...)
Retorna o m@'aximo divisor comum entre @var{p_1} e @var{p_2}.
O sinalizador @code{gcd} determina qual algoritmo @'e empregado.
Escolhendo @code{gcd} para @code{ez}, @code{subres}, @code{red}, ou @code{spmod} selecciona o algoritmo @code{ezgcd},
subresultante @code{prs}, reduzido, ou modular,
respectivamente.  Se @code{gcd} for @code{false} ent@~ao @code{gcd (@var{p_1}, @var{p_2}, @var{x})} sempre retorna 1
para todo @var{x}.  Muitas fun@value{cedilha}@~oes (e.g.  @code{ratsimp}, @code{factor}, etc.) fazem com que mdc's
sejam feitos implicitamente.  Para polin@'omios homog@^eneos @'e recomendado
que @code{gcd} igual a @code{subres} seja usado.  Para obter o mdc quando uma express@~ao alg@'ebrica est@'a
presente, e.g. @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))}, @code{algebraic} deve ser
@code{true} e @code{gcd} n@~ao deve ser @code{ez}.  @code{subres} @'e um novo algoritmo, e pessoas
que tenham estado usando a op@value{cedilha}@~ao @code{red} podem provavelmente alterar isso para
@code{subres}.

O sinalizador @code{gcd}, padr@~ao: @code{subres}, se @code{false} ir@'a tamb@'em evitar o m@'aximo
divisor comum de ser usado quando express@~oes s@~ao convertidas para a forma de express@~ao racional
can@'onica (CRE).  Isso ir@'a algumas vezes aumentar a velocidade dos c@'alculos se mdc's n@~ao s@~ao
requeridos.
@c NEEDS EXAMPLES HERE

@end deffn

@c IN NEED OF SERIOUS CLARIFICATION HERE
@deffn {Fun@value{cedilha}@~ao} gcdex (@var{f}, @var{g})
@deffnx {Fun@value{cedilha}@~ao} gcdex (@var{f}, @var{g}, @var{x})
Retornam uma lista @code{[@var{a}, @var{b}, @var{u}]}
onde @var{u} @'e o m@'aximo divisor comum (mdc) entre @var{f} e @var{g},
e @var{u} @'e igual a @code{@var{a} @var{f} + @var{b} @var{g}}.
Os argumentos @var{f} e @var{g} podem ser polin@'omios de uma vari@'avel,
ou de outra forma polin@'omios em @var{x} uma @b{main}(principal) vari@'avel suprida
desde que n@'os precisamos estar em um dom@'{@dotless{i}}nio de ideal principal para isso trabalhar.
O mdc significa o mdc considerando @var{f} e @var{g} como polin@'omios de uma @'unica vari@'avel com coeficientes
sendo fun@value{cedilha}@~oes racionais em outras vari@'aveis.

@code{gcdex} implementa o algoritmo Euclideano,
onde temos a sequ@^encia
of @code{L[i]: [a[i], b[i], r[i]]} que s@~ao todos perpendiculares
a @code{[f, g, -1]} e o pr@'oximo se @'e constru@'{@dotless{i}}do como
se @code{q = quotient(r[i]/r[i+1])} ent@~ao @code{L[i+2]: L[i] - q L[i+1]}, e isso
encerra em @code{L[i+1]} quando o resto @code{r[i+2]} for zero.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

@c SORRY FOR BEING DENSE BUT WHAT IS THIS ABOUT EXACTLY
Note que o mdc adiante @'e @code{1}
uma vez que trabalhamos em @code{k(y)[x]}, o @code{y+1} n@~ao pode ser esperado em @code{k[y, x]}.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x*(y + 1), y^2 - 1, x);

@example
(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
@end example

@end deffn


@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Fun@value{cedilha}@~ao} gcfactor (@var{n})
Factoriza o inteiro Gaussiano @var{n} sobre os inteiros Gaussianos, i.e.,
n@'umeros da forma @code{@var{a} + @var{b} @code{%i}} onde @var{a} e @var{b} s@~ao inteiros raconais
(i.e.,  inteiros comuns).  Factoriza@value{cedilha}@~oes s@~ao normalizadas fazendo @var{a} e @var{b}
n@~ao negativos.
@c NEED EXAMPLES HERE

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Fun@value{cedilha}@~ao} gfactor (@var{expr})
Factoriza o polin@'omio @var{expr} sobre os inteiros de Gauss
(isto @'e, os inteiros com a unidade imagin@'aria @code{%i} adjunta).
@c "This is like" -- IS IT THE SAME OR NOT ??
Isso @'e como @code{factor (@var{expr}, @var{a}^2+1)} trocando @var{a} por @code{%i}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@end deffn

@c DESCRIBE THIS INDEPENDENTLY OF factorsum
@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~ao} gfactorsum (@var{expr})
@'e similar a @code{factorsum} mas aplica @code{gfactor} em lugar
de @code{factor}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} hipow (@var{expr}, @var{x})
Retorna o maior expoente expl@'{@dotless{i}}cito de @var{x} em @var{expr}.
@var{x} pode ser uma vari@'avel ou uma express@~ao geral.
Se @var{x} n@~ao aparece em @var{expr},
@code{hipow} retorna @code{0}.

@code{hipow} n@~ao considera express@~oes equivalentes a @code{expr}.
Em particular, @code{hipow} n@~ao expande @code{expr},
ent@~ao @code{hipow (@var{expr}, @var{x})} e @code{hipow (expand (@var{expr}, @var{x}))}
podem retornar diferentes resultados.

Exemplos:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} intfaclim
Valor por omiss@~ao: true

Se @code{true}, maxima ir@'a interromper a factoriza@value{cedilha}@~ao de
inteiros se nenhum factor for encontrado ap@'os tentar divis@~oes e o m@'etodo rho de
Pollard e a factoriza@value{cedilha}@~ao n@~ao ser@'a completada.

Quando @code{intfaclim} for @code{false} (esse @'e o caso quando o utilizador
chama @code{factor} explicitamente), a factoriza@value{cedilha}@~ao completa ser@'a
tentada.  @code{intfaclim} @'e escolhida para @code{false} quando factores s@~ao
calculados em @code{divisors}, @code{divsum} e @code{totient}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Chamadas internas a @code{factor} respeitam o valor especificado pelo utilizador para
@code{intfaclim}. Setting @code{intfaclim} to @code{true} may reduce
@code{intfaclim}.  Escolhendo @code{intfaclim} para @code{true} podemos reduzir
o tempo gasto factorizando grandes inteiros.
@c NEED EXAMPLES HERE

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} keepfloat
Valor Padr@~ao: @code{false}

Quando @code{keepfloat} for @code{true}, evitamos que n@'umeros
em ponto flutuante sejam racionalizados quando express@~oes que os possuem
s@~ao ent@~ao convertidas para a forma de express@~ao racional can@'onica (CRE).
@c NEED EXAMPLES HERE

@end defvr

@c DESCRIBE lratsubst INDEPENDENTLY OF subst
@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~ao} lratsubst (@var{L}, @var{expr})
@'e an@'alogo a @code{subst (@var{L}, @var{expr})}
excepto que esse usa @code{ratsubst} em lugar de @code{subst}.

O primeiro argumento de
@code{lratsubst} @'e uma equa@value{cedilha}@~ao ou uma lista de equa@value{cedilha}@~oes id@^enticas em
formato para que sejam aceitas por @code{subst}.  As
substitui@value{cedilha}@~oes s@~ao feitas na ordem dada pela lista de equa@value{cedilha}@~oes,
isto @'e, da esquerda para a direita.

@code{load ("lrats")} chama @code{fullratsubst} e @code{lratsubst}.

Exemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} pode realizar multiplas substitui@value{cedilha}@~oes.
@code{lratsubst} @'e analoga a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Se somente uma substitui@value{cedilha}@~ao for desejada, ent@~ao uma equa@value{cedilha}@~ao
simples pode ser dada como primeiro argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} modulus
Valor Padr@~ao: @code{false}

Quando @code{modulus} for um n@'umero positivo @var{p},
opera@value{cedilha}@~oes sobre os n@'umeros racionais (como retornado por @code{rat} e fun@value{cedilha}@~oes relacionadas)
s@~ao realizadas m@'odulo @var{p},
usando o ent@~ao chamado sistema de m@'odulo "balanceado"
no qual @code{@var{n} m@'odulo @var{p}} @'e definido como 
um inteiro @var{k} em @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
quando @var{p} for @'{@dotless{i}}mpar, ou @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} quando @var{p} for par,
tal que @code{@var{a} @var{p} + @var{k}} seja igual a @var{n} para algum inteiro @var{a}.
@c NEED EXAMPLES OF "BALANCED MODULUS" HERE

@c WHAT CAN THIS MEAN ?? IS THE MODULUS STORED WITH THE EXPRESSION ??
@c "... in order to get correct results" -- WHAT DO YOU GET IF YOU DON'T RE-RAT ??
Se @var{expr} j@'a estiver na forma de express@~ao racional can@'onica
(CRE) quando @code{modulus} for colocado no seu valor original, ent@~ao
pode precisar repetir o rat @var{expr}, e.g., @code{expr: rat (ratdisrep
(expr))}, com o objectivo de obter resultados correctos.

Tipicamente @code{modulus} @'e escolhido para um n@'umero primo.
Se @code{modulus} for escolhido para um inteiro n@~ao primo positivo,
essa escolha @'e aceita, mas uma mensagem de alerta @'e mostrada.
Maxima permitir@'a que zero ou um inteiro negativo seja atribu@'{@dotless{i}}do a @code{modulus},
embora isso n@~ao seja limpo se aquele tiver quaisquer consequ@^encias @'uteis.

@c NEED EXAMPLES HERE
@end defvr

@c APPARENTLY OBSOLETE: ONLY EFFECT OF $newfac COULD BE TO CAUSE NONEXISTENT FUNCTION NMULTFACT
@c TO BE CALLED (IN FUNCTION FACTOR72 IN src/factor.lisp CIRCA LINE 1400)
@c $newfac NOT USED IN ANY OTHER CONTEXT (ASIDE FROM DECLARATIONS)
@c COMMENT IT OUT NOW, CUT IT ON THE NEXT PASS THROUGH THIS FILE
@c @defvar newfac
@c Default value: @code{false}
@c 
@c When @code{newfac} for @code{true}, @code{factor} will use the new factoring
@c routines.
@c 
@c @end defvar

@deffn {Fun@value{cedilha}@~ao} num (@var{expr})
Retorna o numerador de @var{expr} se isso for uma raz@~ao.
Se @var{expr} n@~ao for uma raz@~ao, @var{expr} @'e retornado.

@code{num} avalia seu argumento.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} polydecomp (@var{p}, @var{x})

Decomp@~oes o polin@'omio @var{p} na vari@'avel  @var{x}
em uma composi@value{cedilha}@~ao funcional de polin@'omios em @var{x}.
@code{polydecomp} retorna uma lista @code{[@var{p_1}, ..., @var{p_n}]} tal que

@example
lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))
@end example

seja igual a @var{p}.
O grau de @var{p_i} @'e maior que 1 para @var{i} menor que @var{n}.

Tal decomposi@value{cedilha}@~ao n@~ao @'e @'unica.

Exemplos:

@c ===beg===
@c polydecomp (x^210, x);
@c p : expand (subst (x^3 - x - 1, x, x^2 - a));
@c polydecomp (p, x);
@c ===end===
@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

As seguintes fun@value{cedilha}@~oes comp@~oem @code{L = [e_1, ..., e_n]} como fun@value{cedilha}@~oes em @code{x};
essa fun@value{cedilha}@`ao @'e a inversa de @code{polydecomp}:

@c ===beg===
@c compose (L, x) :=
@c   block ([r : x], for e in L do r : subst (e, x, r), r) $
@c ===end===
@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

Re-exprimindo o exemplo acima usando @code{compose}:

@c ===beg===
@c polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
@c ===end===
@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

Note que apesar de @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
sempre retornar @var{p} (n@~ao expandido),
@code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})} @i{n@~ao}
necess@'ariamente retorna @code{[@var{p_1}, ..., @var{p_n}]}:

@c ===beg===
@c polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
@c polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@c ===end===
@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} quotient (@var{p_1}, @var{p_2})
@deffnx {Fun@value{cedilha}@~ao} quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Retorna o polin@'omio @var{p_1} dividido pelo polin@'omio @var{p_2}.
Os argumentos @var{x_1}, ..., @var{x_n} s@~ao interpretados como em @code{ratvars}.

@code{quotient} retorna o primeiro elemento de uma lista de dois elementos retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@c THIS ITEM CAN PROBABLY BE IMPROVED
@deffn {Fun@value{cedilha}@~ao} rat (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} rat (@var{expr}, @var{x_1}, ..., @var{x_n})
Converte @var{expr} para a forma de express@~ao racional can@'onica (CRE) expandindo e
combinando todos os termos sobre um denominador comum e cancelando para fora o
m@'aximo divisor comum entre o numerador e o denominador, tamb@'em
convertendo n@'umeros em ponto flutuante para n@'umeros racionais dentro da
toler@^ancia de @code{ratepsilon}.
As vari@'aveis s@~ao ordenadas de acordo com
@var{x_1}, ..., @var{x_n}, se especificado, como em @code{ratvars}.

@code{rat} geralmente n@~ao simplifica fun@value{cedilha}@~oes outras que n@~ao sejam
adi@value{cedilha}@~ao @code{+}, subtra@value{cedilha}@~ao @code{-}, multiplica@value{cedilha}@~ao @code{*}, divis@~ao @code{/}, e
exponencia@value{cedilha}@~ao com expoente inteiro,
uma vez que @code{ratsimp} n@~ao manuseia esses casos.
Note que @'atomos (n@'umeros e vari@'aveis) na forma CRE n@~ao s@~ao os
mesmos que eles s@~ao na forma geral.
Por exemplo, @code{rat(x)- x} retorna 
@code{rat(0)} que tem uma representa@value{cedilha}@~ao interna diferente de 0.

@c WHAT'S THIS ABOUT EXACTLY ??
Quando @code{ratfac} for @code{true}, @code{rat} retorna uma forma parcialmente factorizada para CRE.
Durante opera@value{cedilha}@~oes racionais a express@~ao @'e
mantida como totalmente factorizada como poss@'{@dotless{i}}vel sem uma chamada ao
pacote de factoriza@value{cedilha}@~ao (@code{factor}).  Isso pode sempre economizar espa@value{cedilha}o de mem@'oria e algum tempo
em algumas computa@value{cedilha}@~oes.  O numerador e o denominador s@~ao ainda tidos como
relativamente primos
(e.g.  @code{rat ((x^2 - 1)^4/(x + 1)^2)} retorna @code{(x - 1)^4 (x + 1)^2)},
mas os factores dentro de cada parte podem n@~ao ser relativamente primos.

@code{ratprint} se @code{false} suprime a impress@~ao de mensagens
informando o utilizador de convers@~oes de n@'umeros em ponto flutuante para
n@'umeros racionais.

@code{keepfloat} se @code{true} evita que n@'umeros em ponto flutuante sejam
convertidos para n@'umeros racionais.

Veja tamb@'em @code{ratexpand} e  @code{ratsimp}.

Exemplos:
@c FOLLOW GENERATED FROM THESE EXPRESSIONS
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
@c rat (%, y, a, x);

@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratalgdenom
Valor Padr@~ao: @code{true}

Quando @code{ratalgdenom} for @code{true}, permite racionaliza@value{cedilha}@~ao de
denominadores com respeito a radicais tenham efeito.
@code{ratalgdenom} tem efeito somente quando express@~oes racionais can@'onicas (CRE) forem usadas no modo alg@'ebrico.

@end defvr

@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~ao} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Fun@value{cedilha}@~ao} ratcoef (@var{expr}, @var{x})
Retorna o coeficiente da express@~ao @code{@var{x}^@var{n}}
dentro da express@~ao @var{expr}.
Se omitido, @var{n} @'e assumido ser 1.

O valor de retorno est@'a livre
(excepto possivelmente em um senso n@~ao racional) das vari@'aveis em @var{x}.
Se nenhum coeficiente desse tipo existe, 0 @'e retornado.

@code{ratcoef}
expande e simplifica racionalmente seu primeiro argumento e dessa forma pode
produzir respostas diferentes das de @code{coeff} que @'e puramente
sint@'atica.
@c MOVE THIS TO EXAMPLES SECTION
Dessa forma @code{ratcoef ((x + 1)/y + x, x)} retorna @code{(y + 1)/y} ao passo que @code{coeff} retorna 1.

@code{ratcoef (@var{expr}, @var{x}, 0)}, visualiza @var{expr} como uma adi@value{cedilha}@~ao,
retornando uma soma desses termos que n@~ao possuem @var{x}.
@c "SHOULD NOT" -- WHAT DOES THIS MEAN ??
portanto se @var{x} ocorre para quaisquer expoentes negativos, @code{ratcoef} pode n@~ao ser usado.

@c WHAT IS THE INTENT HERE ??
Uma vez que @var{expr} @'e racionalmente
simplificada antes de ser examinada, coeficientes podem n@~ao aparecer inteiramente
no caminho que eles foram pensados.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@end deffn

@deffn {Fun@value{cedilha}@~ao} ratdenom (@var{expr})
Retorna o denominador de @var{expr},
ap@'os for@value{cedilha}ar a convers@~ao de @var{expr} para express@~ao racional can@'onica (CRE).
O valor de retorno @'e a CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} @'e for@value{cedilha}ada para uma CRE por @code{rat}
se n@~ao for j@'a uma CRE.
Essa convers@~ao pode mudar a forma de @var{expr} colocando todos os termos
sobre um denominador comum.

@code{denom} @'e similar, mas retorna uma express@~ao comum em lugar de uma CRE.
Tamb@'em, @code{denom} n@~ao tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas express@~oes que s@~ao consideradas raz@~oes por @code{ratdenom}
n@~ao s@~ao consideradas raz@~oes por @code{denom}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratdenomdivide
Valor Padr@~ao: @code{true}

Quando @code{ratdenomdivide} for @code{true},
@code{ratexpand} expande uma raz@~ao cujo o numerador for uma adi@value{cedilha}@~ao 
dentro de uma soma de raz@~oes,
tendo todos um denominador comum.
De outra forma, @code{ratexpand} colapsa uma adi@value{cedilha}@~ao de raz@~oes dentro de uma raz@~ao simples,
cujo numerador seja a adi@value{cedilha}@~ao dos numeradores de cada raz@~ao.

Exemplos:

@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example

@end defvr

@deffn {Fun@value{cedilha}@~ao} ratdiff (@var{expr}, @var{x})
Realiza a deriva@value{cedilha}@~ao da express@~ao racional @var{expr} com rela@value{cedilha}@~ao a @var{x}.
@var{expr} deve ser uma raz@~ao de polin@'omios ou um polin@'omio em @var{x}.
O argumento @var{x} pode ser uma vari@'avel ou uma subexpress@~ao de @var{expr}.
@c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
@c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
@c HOW TO DESCRIBE THAT ??

O resultado @'e equivalente a @code{diff}, embora talvez em uma forma diferente.
@code{ratdiff} pode ser mais r@'apida que @code{diff}, para express@~oes racionais.

@code{ratdiff} retorna uma express@~ao racional can@'onica (CRE) se @code{expr} for uma CRE.
De outra forma, @code{ratdiff} retorna uma express@~ao geral.

@code{ratdiff} considera somente as depend@^encias de @var{expr} sobre @var{x},
e ignora quaisquer depend@^encias estabelecidas por @code{depends}.

@c WHAT THIS IS ABOUT -- ratdiff (rat (factor (expr)), x) AND ratdiff (factor (rat (expr)), x) BOTH SUCCEED
@c COMMENTING THIS OUT UNTIL SOMEONE CAN ESTABLISH SOME CRE'S FOR WHICH ratdiff FAILS
@c However, @code{ratdiff} should not be used on factored CRE forms;
@c use @code{diff} instead for such express@~oes.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c ratdiff (expr, x);
@c expr: f(x)^3 - f(x)^2 + 7;
@c ratdiff (expr, f(x));
@c expr: (a + b)^3 + (a + b)^2;
@c ratdiff (expr, a + b);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} ratdisrep (@var{expr})
Retorna seu argumento como uma express@~ao geral.
Se @var{expr} for uma express@~ao geral, @'e retornada inalterada.

Tipicamente @code{ratdisrep} @'e chamada para converter uma express@~ao racional can@'onica (CRE)
em uma express@~ao geral.
@c NOT REALLY FOND OF YOU-CAN-DO-THIS-YOU-CAN-DO-THAT STATEMENTS
Isso @'e algumas vezes conveniente se deseja-se parar o "cont@'agio", ou
caso se esteja usando fun@value{cedilha}@~oes racionais em contextos n@~ao racionais.

Veja tamb@'em @code{totaldisrep}.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratepsilon
Valor Padr@~ao: 2.0e-8

@code{ratepsilon} @'e a toler@^ancia usada em convers@~oes
de n@'umeros em ponto flutuante para n@'umeros racionais.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~ao} ratexpand (@var{expr})
@deffnx {Vari@'avel de op@value{cedilha}@~ao} ratexpand
Expande @var{expr} multiplicando para fora produtos de somas e
somas exponenciadas, combinando fra@value{cedilha}@~oes sobre um denominador comum,
cancelando o m@'aximo divisor comum entre entre o numerador e o
denominador, ent@~ao quebrando o numerador (se for uma soma) dentro de suas
respectivas parcelas divididas pelo denominador.

O valor de retorno de @code{ratexpand} @'e uma express@~ao geral,
mesmo se @var{expr} for uma express@~ao racional can@'onica (CRE).

@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
O comutador @code{ratexpand} se @code{true} far@'a com que express@~oes
CRE sejam completamente expandidas quando forem convertidas de volta para
a forma geral ou mostradas, enquanto se for @code{false} ent@~ao elas ser@~ao colocadas
na forma recursiva.
Veja tamb@'em @code{ratsimp}.

Quando @code{ratdenomdivide} for @code{true},
@code{ratexpand} expande uma raz@~ao na qual o numerador @'e uma adi@value{cedilha}@~ao
dentro de uma adi@value{cedilha}@~ao de raz@~oes,
todas tendo um denominador comum.
De outra forma, @code{ratexpand} contrai uma soma de raz@~oes em uma raz@~ao simples,
cujo numerador @'e a soma dos numeradores de cada raz@~ao.

Quando @code{keepfloat} for @code{true}, evita que n@'umeros
em ponto flutuante sejam racionalizados quando express@~oes que contenham
n@'umeros em ponto flutuante forem convertidas para a forma de express@~ao racional can@'onica (CRE).

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratfac
Valor Padr@~ao: @code{false}

Quando @code{ratfac} for @code{true},
express@~oes racionais can@'onicas (CRE) s@~ao manipuladas na forma parcialmente factorizada.

Durante opera@value{cedilha}@~oes racionais a
express@~ao @'e mantida como completamente factorizada como foi poss@'{@dotless{i}}vel sem chamadas a @code{factor}.
Isso pode sempre economizar espa@value{cedilha}o e pode economizar tempo em algumas computa@value{cedilha}@~oes.
O numerador e o denominador s@~ao feitos relativamente primos, por exemplo
@code{rat ((x^2 - 1)^4/(x + 1)^2)} retorna @code{(x - 1)^4 (x + 1)^2)},
mas o factor dentro de cada parte pode n@~ao ser relativamente primo.

No pacote @code{ctensor} (Manipula@value{cedilha}@~ao de componentes de tensores),
tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura escalar 
s@~ao factorizados automaticamente quando @code{ratfac} for @code{true}.
@i{@code{ratfac} pode somente ser
escolhido para casos onde as componentes tensoriais sejam sabidametne consistidas de
poucos termos.}

Os esquemas de @code{ratfac} e de @code{ratweight} s@~ao incompat@'{@dotless{i}}veis e n@~ao podem
ambos serem usados ao mesmo tempo.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~ao} ratnumer (@var{expr})
Retorna o numerador de @var{expr},
ap@'os for@value{cedilha}ar @var{expr} para uma express@~ao racional can@'onica (CRE).
O valor de retorno @'e uma CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} @'e for@value{cedilha}ada para uma CRE por @code{rat}
se isso n@~ao for j@'a uma CRE.
Essa convers@~ao pode alterar a forma de @var{expr} pela coloca@value{cedilha}@~ao de todos os termos
sobre um denominador comum.

@code{num} @'e similar, mas retorna uma express@~ao comum em lugar de uma CRE.
Tamb@'em, @code{num} n@~ao tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas express@~oes que s@~ao consideradas raz@~oes por @code{ratnumer}
n@~ao s@~ao consideradas raz@~oes por @code{num}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} ratnump (@var{expr})
Retorna @code{true} se @var{expr} for um inteiro literal ou raz@~ao de inteiros literais,
de outra forma retorna @code{false}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ratp (@var{expr})
Retorna @code{true} se @var{expr} for uma express@~ao racional can@'onica (CRE) ou CRE extendida,
de outra forma retorna @code{false}.

CRE s@~ao criadas por @code{rat} e fun@value{cedilha}@~oes relacionadas.
CRE extendidas s@~ao criadas por @code{taylor} e fun@value{cedilha}@~oes relacionadas.

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratprint
Valor Padr@~ao: @code{true}

Quando @code{ratprint} for @code{true},
uma mensagem informando ao utilizador da convers@~ao de n@'umeros em ponto flutuante
para n@'umeros racionais @'e mostrada.

@end defvr

@deffn {Fun@value{cedilha}@~ao} ratsimp (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})
Simplifica a express@~ao @var{expr} e todas as suas subexpress@~oes,
incluindo os argumentos para fun@value{cedilha}@~oes n@~ao racionais.
O resultado @'e retornado como o quociente de dois polin@'omios na forma recursiva,
isto @'e, os coeficientes de vari@'avel principal s@~ao polin@'omios em outras vari@'aveis.
Vari@'aveis podem incluir fun@value{cedilha}@~oes n@~ao racionais (e.g., @code{sin (x^2 + 1)})
e os argumentos para quaisquer tais fun@value{cedilha}@~oes s@~ao tamb@'em simplificados racionalmente.

@code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})}
habilita simplifica@value{cedilha}@~ao racional com a
especiica@value{cedilha}@~ao de vari@'avel ordenando como em @code{ratvars}.

Quando @code{ratsimpexpons} for @code{true},
@code{ratsimp} @'e aplicado para os expoentes de express@~oes durante a simplifica@value{cedilha}@~ao.

Veja tamb@'em @code{ratexpand}.
Note que @code{ratsimp} @'e afectado por algum dos
sinalizadores que afectam @code{ratexpand}.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratsimpexpons
Valor Padr@~ao: @code{false}

Quando @code{ratsimpexpons} for @code{true},
@code{ratsimp} @'e aplicado para os expoentes de express@~oes durante uma simplifica@value{cedilha}@~ao.

@c NEED AN EXAMPLE HERE -- RECYCLE THE ratsimpexpons EXAMPLE FROM ratsimp ABOVE
@end defvr

@deffn {Fun@value{cedilha}@~ao} ratsubst (@var{a}, @var{b}, @var{c})
Substitue @var{a} por @var{b} em @var{c} e retorna a express@~ao resultante. 
@c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE -- NOT LIKELY THE CASE
@var{b} pode tamb@'em ser uma adi@value{cedilha}@~ao, produto, expoente, etc.

@c WHAT, EXACTLY, DOES ratsubst KNOW ??
@code{ratsubst} sabe alguma coisa do significado de express@~oes
uma vez que @code{subst} n@~ao @'e uma substitui@value{cedilha}@~ao puramente sint@'atica.
Dessa forma @code{subst (a, x + y, x + y + z)} retorna @code{x + y + z}
ao passo que @code{ratsubst} retorna @code{z + a}.

Quando @code{radsubstflag} for @code{true},
@code{ratsubst} faz substitui@value{cedilha}@~ao de radicais em express@~oes
que explicitamente n@~ao possuem esses radicais.

Exemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c WITH SOME ADDITIONAL STUFF
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@c radsubstflag: false$
@c ratsubst (u, sqrt(x), x);
@c radsubstflag: true$
@c ratsubst (u, sqrt(x), x);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} ratvars (@var{x_1}, ..., @var{x_n})
@deffnx {Fun@value{cedilha}@~ao} ratvars ()
@deffnx {Vari@'avel de sistema} ratvars
Declara vari@'aveis principais @var{x_1}, ..., @var{x_n} para express@~oes racionais.
@var{x_n}, se presente em uma express@~ao racional, @'e considerada a vari@'avel principal.
De outra forma, @var{x_[n-1]} @'e considerada a vari@'avel principal se presente,
e assim por diante at@'e as vari@'aveis precedentes para @var{x_1},
que @'e considerada a vari@'avel principal somente se nenhuma das vari@'aveis que a sucedem estiver presente.

Se uma vari@'avel em uma express@~ao racional n@~ao est@'a presente na lista @code{ratvars},
a ela @'e dada uma prioridade menor que @var{x_1}.

Os argumentos para @code{ratvars} podem ser ou vari@'aveis ou fun@value{cedilha}@~oes n@~ao racionais
tais como @code{sin(x)}.

A vari@'avel @code{ratvars} @'e uma lista de argumentos da
fun@value{cedilha}@~ao @code{ratvars} quando ela foi chamada mais recentemente.
Cada chamada para a fun@value{cedilha}@~ao @code{ratvars} sobre-grava a lista apagando seu conte@'udo anterior.
@code{ratvars ()} limpa a lista.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} ratweight (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})
@deffnx {Fun@value{cedilha}@~ao} ratweight ()
Atribui um peso @var{w_i} para a vari@'avel @var{x_i}.
Isso faz com que um termo seja substitu@'{@dotless{i}}do por 0 se seu peso exceder o
valor da vari@'avel @code{ratwtlvl} (o padr@~ao retorna sem trunca@value{cedilha}@~ao).
O peso de um termo @'e a soma dos produtos dos
pesos de uma vari@'avel no termo vezes seu expoente.
Por exemplo, o peso de @code{3 x_1^2 x_2} @'e @code{2 w_1 + w_2}.
A trunca@value{cedilha}@~ao de acordo com @code{ratwtlvl} @'e realizada somente quando multiplicando
ou exponencializando express@~oes racionais can@'onicas (CRE).

@code{ratweight ()} retorna a lista cumulativa de atribui@value{cedilha}@~oes de pesos.

Nota: Os esquemas de @code{ratfac} e @code{ratweight} s@~ao incompat@'{@dotless{i}}veis e n@~ao podem
ambo serem usados ao mesmo tempo.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

@end deffn

@defvr {Vari@'avel de sistema} ratweights
Valor Padr@~ao: @code{[]}

@code{ratweights} @'e a lista de pesos atribu@'{@dotless{i}}dos por @code{ratweight}.
A lista @'e cumulativa:
cada chamada a @code{ratweight} coloca @'{@dotless{i}}tens adicionais na lista.

@c DO WE REALLY NEED TO MENTION THIS ??
@code{kill (ratweights)} e @code{save (ratweights)} ambos trabalham como esperado.

@end defvr

@defvr {Vari@'avel de op@value{cedilha}@~ao} ratwtlvl
Valor Padr@~ao: @code{false}

@code{ratwtlvl} @'e usada em combina@value{cedilha}@~ao com a fun@value{cedilha}@~ao 
@code{ratweight} para controlar a trunca@value{cedilha}@~ao de express@~ao racionais can@'onicas (CRE).
Para o valor padr@~ao @code{false}, nenhuma trunca@value{cedilha}@~ao ocorre.

@end defvr

@deffn {Fun@value{cedilha}@~ao} remainder (@var{p_1}, @var{p_2})
@deffnx {Fun@value{cedilha}@~ao} remainder (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Retorna o resto do polin@'omio @var{p_1} dividido pelo polin@'omio @var{p_2}.
Os argumentos @var{x_1}, ..., @var{x_n} s@~ao interpretados como em @code{ratvars}.

@code{remainder} retorna o segundo elemento
de uma lista de dois elementos retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@c CAN PROBABLY BE CLARIFIED
@deffn {Fun@value{cedilha}@~ao} resultant (@var{p_1}, @var{p_2}, @var{x})
@deffnx {Vari@'avel} resultant
Calcula o resultante de dois polin@'omios @var{p_1} e @var{p_2},
eliminando a vari@'avel @var{x}.
O resultante @'e um determinante dos coeficientes de @var{x}
em @var{p_1} e @var{p_2},
que @'e igual a zero
se e somente se @var{p_1} e @var{p_2} tiverem um factor em comum n@~ao constante.

Se @var{p_1} ou @var{p_2} puderem ser factorizados,
pode ser desej@'avel chamar @code{factor} antes de chamar @code{resultant}.

A vari@'avel @code{resultant} controla que algoritmo ser@'a usado para calcular
o resultante.
@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@code{subres} para o prs subresultante,
@code{mod} para o algoritmo resultante modular,
e @code{red} para prs reduzido.
Para muitos problemas @code{subres} pode ser melhor.
Para alguns problemas com valores grandes de grau de uma @'unica vari@'avel ou de duas vari@'aveis @code{mod} pode ser melhor.

A fun@value{cedilha}@~ao @code{bezout} aceita os mesmos argumentos que @code{resultant} e retorna
uma matriz.  O determinante do valor de retorno @'e o resultante desejado.

@c NEED AN EXAMPLE HERE
@end deffn

@defvr {Vari@'avel de op@value{cedilha}@~ao} savefactors
Valor Padr@~ao: @code{false}

@c "certain functions" -- WHICH ONES ??
Quando @code{savefactors} for @code{true}, faz com que os factores de uma
express@~ao que @'e um produto de factores sejam gravados por certas
fun@value{cedilha}@~oes com o objectivo de aumentar a velocidade em posteriores factoriza@value{cedilha}@~oes de express@~oes
contendo algum desses mesmos factores.

@end defvr

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO BE ABOUT
@deffn {Fun@value{cedilha}@~ao} sqfr (@var{expr})
@'e similar a @code{factor} excepto que os factores do polin@'omio s@~ao "livres de ra@'{@dotless{i}}zes".
Isto @'e, eles possuem factores somente de grau um.
Esse algoritmo, que @'e tamb@'em usado no primeiro est@'agio de @code{factor}, utiliza
o facto que um polin@'omio tem em comum com sua n'@'esima derivada todos
os seus factores de grau maior que n.  Dessa forma obtendo o maior divisor comum
com o polin@'omio das
derivadas com rela@value{cedilha}@~ao a cada vari@'avel no polin@'omio, todos
os factores de grau maior que 1 podem ser achados.

Exemplo:
@c FOLLOWING GENERATED FROM THIS EXPRESSION
@c sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);

@example
(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
@end example

@end deffn

@c THIS ITEM STILL NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} tellrat (@var{p_1}, ..., @var{p_n})
@deffnx {Fun@value{cedilha}@~ao} tellrat ()
Adiciona ao anel dos inteiros alg@'ebricos conhecidos do Maxima
os elementos que s@~ao as solu@value{cedilha}@~oes dos polin@'omios @var{p_1}, ..., @var{p_n}.
Cada argumento @var{p_i} @'e um polin@'omio concoeficientes inteiros.

@code{tellrat (@var{x})} efectivamente significa substituir 0 por @var{x} em fun@value{cedilha}@~oes
racionais.

@code{tellrat ()} retorna uma lista das substitui@value{cedilha}@~oes correntes.

@code{algebraic} deve ser escolhida para @code{true} com o objectivo de que a simplifica@value{cedilha}@~ao de
inteiros alg@'ebricos tenha efeito.

Maxima inicialmente sabe sobre a unidade imagin@'aria @code{%i}
e todas as ra@'{@dotless{i}}zes de inteiros.

Existe um comando @code{untellrat} que recebe n@'ucleos e
remove propriedades @code{tellrat}.

Quando fazemos @code{tellrat} em um polin@'omio
de v@'arias vari@'aveis, e.g., @code{tellrat (x^2 - y^2)}, pode existir uma ambiguidade como para
ou substituir @code{@var{y}^2} por @code{@var{x}^2}
ou vice-versa.  
Maxima selecciona uma ordena@value{cedilha}@~ao particular, mas se o utilizador desejar especificar qual e.g.
@code{tellrat (y^2 = x^2)} forne@value{cedilha}e uma sintaxe que diga para substituir
@code{@var{y}^2} por @code{@var{x}^2}.

@c CAN'T TELL WHAT THIS IS ABOUT -- tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w));
@c DOES NOT YIELD AN ERROR, SO WHAT IS THE POINT ABOUT ratalgdenom ??
@c When you @code{tellrat} reducible polinomials, you want to be careful not to
@c attempt to rationalize a denominador with a zero divisor.  E.g.
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w)); will give "quotient by
@c zero".  This error can be avoided by setting @code{ratalgdenom} to @code{false}.

Exemplos:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} totaldisrep (@var{expr})
Converte toda subexpress@~ao de @var{expr} da forma de express@~ao racionais can@'onicas (CRE) para
a forma geral e retorna o resultado.
Se @var{expr} @'e em s@'{@dotless{i}} mesma na forma CRE ent@~ao @code{totaldisrep} @'e identica a
@code{ratdisrep}.

@code{totaldisrep} pode ser usada para
fazer um @code{ratdisrep} em express@~oes tais como equa@value{cedilha}@~oes, listas, matrizes, etc., que
tiverem algumas subexpress@~oes na forma CRE.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} untellrat (@var{x_1}, ..., @var{x_n})
Remove propriedades @code{tellrat} de @var{x_1}, ..., @var{x_n}.

@c NEED EXAMPLES HERE
@end deffn
