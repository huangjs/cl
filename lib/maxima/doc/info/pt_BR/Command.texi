@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Command.texi/1.44/Sat Jun  2 00:12:33 2007/-ko/
@iftex
@hyphenation{si-na-li-za-do-res}
@hyphenation{de-mo-ra-da-men-te}
@hyphenation{va-lo-res}
@end iftex
@menu
* Introdu@value{cedilha}@~{a}o a Linha de Comando::  
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Linha de Comando::  
@end menu

@node Introdu@value{cedilha}@~{a}o a Linha de Comando, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Linha de Comando, Linha de Comando, Linha de Comando
@section Introdu@value{cedilha}@~{a}o a Linha de Comando

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn {Operador} '
@ifinfo
@fnindex Operador Ap@'{o}strofo
@end ifinfo
O operador ap@'{o}strofo @code{'} evita avalia@value{cedilha}@~{a}o.

Aplicado a um s@'{i}mbolo,
o ap@'{o}strofo evita avalia@value{cedilha}@~{a}o do s@'{i}mbolo.

Aplicado a uma chamada de fun@value{cedilha}@~{a}o,
o ap@'{o}strofo evita avalia@value{cedilha}@~{a}o da chamada de fun@value{cedilha}@~{a}o,
embora os argumentos da fun@value{cedilha}@~{a}o sejam ainda avaliados (se a avalia@value{cedilha}@~{a}o n@~{a}o for de outra forma evitada).
O resultado @'{e} a forma substantiva da chamada de fun@value{cedilha}@~{a}o.

Aplicada a uma espress@~{a}o com par@^{e}ntesis,
o ap@'{o}strofo evita avalia@value{cedilha}@~{a}o de todos os s@'{i}mbolos e chamadas de fun@value{cedilha}@~{a}o na express@~{a}o.
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
E.g., @code{'(f(x))} significa n@~{a}o avalie a express@~{a}o @code{f(x)}.
@code{'f(x)} (com ap@'{o}strofo aplicado a @code{f} em lugar de @code{f(x)})
retorna a forma substantiva de @code{f} aplicada a @code{[x]}.

O ap@'{o}strofo nao evita simplifica@value{cedilha}@~{a}o.

Quando o sinalizador global @code{noundisp} for @code{true},
substantivos s@~{a}o mostrados com um ap@'{o}strofo.
Esse comutador @'{e} sempre @code{true} quando mostrando defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{o}es.

Veja tamb@'{e}m operador ap@'{o}strofo-ap@'{o}strofo @code{''} e @code{nouns}.

Exemplos:

Aplicado a um s@'{i}mbolo,
o ap@'{o}strofo evita avalia@value{cedilha}@~{a}o do s@'{i}mbolo.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Aplicado a uma chamada de fun@value{cedilha}@~{a}o,
o ap@'{o}strofo evita avalia@value{cedilha}@~{a}o da chamada de fun@value{cedilha}@~{a}o.
O resultado @'{e} a forma substantiva da chamada de fun@value{cedilha}@~{a}o.

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Aplicado a uma express@~{a}o com par@^{e}ntesis,
o ap@'{o}strofo evita avalia@value{cedilha}@~{a}o de todos os s@'{i}mbolos e chamadas de fun@value{cedilha}@~{a}o na express@~{a}o.

@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

O ap@'{o}strofo n@~{a}o evita simplifica@value{cedilha}@~{a}o.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

@end deffn

@deffn {Operador} ''
@ifinfo
@fnindex Operador ap@'{o}strofo-ap@'{o}strofo
@end ifinfo
O operador ap@'{o}strofo-ap@'{o}strofo @code{'@w{}'} (dois ap@'{o}strofost) modifica avalia@value{cedilha}@~{a}o em express@~{o}es de entrada.

Aplicado a uma express@~{a}o geral @var{expr}, ap@'{o}strofo-ap@'{o}strofo faz com que o valor de @var{expr}
seja substitu@'{i}do por @var{expr} na express@~{a}o de entrada.

Aplicado ao operadro de uma express@~{a}o,
ap@'{o}strofo-ap@'{o}strofo modifica o operadro de um susbstantivo para um verbo (se esse operador n@~{a}o for j@'{a} um verbo).

O operador ap@'{o}strofo-ap@'{o}strofo @'{e} aplicado atrav@'{e}s do passador de entrada;
o ap@'{o}strofo-ap@'{o}strofo n@~{a}o @'{e} armazenado como parte de uma express@~{a}o de entrada passada.
O operador ap@'{o}strofo-ap@'{o}strofo @'{e} sempre aplicado t@~{a}o rapidamente quanto for passado,
e n@~{a}o pode receber um terceiro ap@'{o}strofo.
Dessa forma faz com que ocorra avalia@value{cedilha}@~{a}o quando essa avalia@value{cedilha}@~{a}o for de outra forma suprimida,
da mesma forma que em defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o, defini@value{cedilha}@~{o}es de express@~{a}oes lambda, e express@~{o}es que recebem um ap@'{o}strofo simples @code{'}.

Ap@'{o}strofo-ap@'{o}strofo @'{e} reconhecido por @code{batch} e @code{load}.

Veja tamb@'{e}m o operador ap@'{o}strofo @code{'} e @code{nouns}.

Exemplos:

Aplicado a uma express@~{a}o geral @var{expr}, ap@'{o}strofo-ap@'{o}strofo fazem com que o valor de @var{expr}
seja substituido por @var{expr} na express@~{a}o de entrada.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Aplicado ao operador de uma express@~{a}o,
ap@'{o}strofo-ap@'{o}strofo muda o operadro de um substantivo para um verbo (se esse operadro n@~{a}o for j@'{a} um verbo).

@c ===beg==
@c sin (1);
@c ''sin (1);
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end==
@example
(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
@end example

O operador ap@'{o}strofo-ap@'{o}strofo @'{e} aplicado por meio de um passador de entrada;
operador-ap@'{o}strofo n@~{a}o @'{e} armazenado como parte da express@~{a}o de entrada.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

Ap@'{o}strofo ap@'{o}strofo faz com que ocorra avalia@value{cedilha}@~{a}o quando a avalia@value{cedilha}@~{a}o tiver sido de outra forma suprimida,
da mesma forma que em defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o, da mesma forma que em defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o lambda expressions, E express@~{o}es que recebem o ap@'{o}strofo simples @code{'}.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@end deffn

@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Linha de Comando,  , Introdu@value{cedilha}@~{a}o a Linha de Comando, Linha de Comando
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Linha de Comando

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
prov@^{e} um
nome alternativo para uma fun@value{cedilha}@~{a}o (de usu@'{a}rio ou de sistema), vari@'{a}vel, array, etc.
Qualquer n@'{u}mero de argumentos pode ser usado.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} debugmode
Valor padr@~{a}o: @code{false}

Quando um erro do Maxima ocorre, Maxima iniciar@'{a} o depurador se @code{debugmode} for @code{true}.
O usu@'{a}rio pode informar comandos para examinar o hist@'{o}rico de chamadas, marcar pontos de parada, percorrer uma linha por vez
o c@'{o}digo do Maxima, e assim por diante.  Veja @code{debugging} para uma lista de op@value{cedilha}@~{o}es do depurador.

Habilitando @code{debugmode} por meio da altera@value{cedilha}@~{a}o de seu valor para @code{true}, n@~{a}o ser@~{a}o capturados erros do Lisp.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Fun@value{cedilha}@~{a}o} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Avalia a express@~{a}o @var{expr} no ambiente
especificado pelos argumentos @var{arg_1}, ..., @var{arg_n}.
Os argumentos s@~{a}o comutadores (sinalizadores Booleanos), atribui@value{cedilha}@~{o}es, equa@value{cedilha}@~{o}es, e fun@value{cedilha}@~{o}es.
@code{ev} retorna o resultado (outra express@~{a}o) da avalia@value{cedilha}@~{a}o.

A avalia@value{cedilha}@~{a}o @'{e} realizada em passos, como segue.

@enumerate
@item
Primeiro o ambiente @'{e} preparado examinando os argumentos que podem
ser quaisquer ou todos os seguintes.

@itemize @bullet
@item
@code{simp} faz com que @var{expr} seja simplificado independentemente da posi@value{cedilha}@~{a}o do
comutador @code{simp} que inibe simplifica@value{cedilha}@~{a}o se @code{false}.
@item
@code{noeval} suprime a fase de avalia@value{cedilha}@~{a}o de @code{ev} (veja passo (4) adiante).
Isso @'{e} @'{u}til juntamente com outros comutadores e faz com que
@var{expr} seja simplificado novamente sem ser reavaliado.
@item
@code{nouns} causa a avalia@value{cedilha}@~{a}o de formas substantivas
(tipicamente fun@value{cedilha}@~{o}es n@~{a}o avaliadas tais como @code{'integrate} ou @code{'diff})
em @var{expr}.
@item
@code{expand} causa expans@~{a}o.
@item
@code{expand (@var{m}, @var{n})} causa expans@~{a}o, alterando os valores de @code{maxposex} e
@code{maxnegex} para @var{m} e @var{n} respectivamente.
@item
@code{detout} faz com que qualquer matriz inversa calculada em @var{expr} tenha seu
determinante mantido fora da inversa ao inv@'{e}s de dividindo a
cada elemento.
@item
@code{diff} faz com que todas as diferencia@value{cedilha}@~{o}es indicadas em @var{expr} sejam executadas.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} causa somente diferencia@value{cedilha}@~{o}es referentes @`as
vari@'{a}veis indicadas.
@item
@code{float} faz com que n@'{u}meros racionais n@~{a}o inteiros sejam convertidos para ponto 
flutuante.
@item
@code{numer} faz com que algumas fun@value{cedilha}@~{o}es matem@'{a}ticas (incluindo a exponencia@value{cedilha}@~{a}o)
com argumentos sejam valiadas em ponto flutuante.  Isso faz com que
vari@'{a}vels em @var{expr} que tenham sido dados numervals (valores num@'{e}ricos) sejam substitu@'{i}das por
seus valores.  Isso tamb@'{e}m modifica o comutador @code{float} para ativado.
@item
@code{pred} faz com que predicados (express@~{o}es que podem ser avaliados em @code{true} ou @code{false})
sejam avaliadas.
@item
@code{eval} faz com que uma avalia@value{cedilha}@~{a}o posterior de @var{expr} ocorra.  (Veja passo (5)
adiante.)
@code{eval} pode ocorrer multiplas vezes.
Para cada inst@^{a}ncia de @code{eval}, a express@~{a}o @'{e} avaliada novamente.
@item
@code{A} onde @code{A} @'{e} um @'{a}tomo declarado seja um sinalizador de avalia@value{cedilha}@~{a}o (veja @code{evflag})
faz com que @code{A} seja associado a
@code{true} durante a avalia@value{cedilha}@~{a}o de @var{expr}.
@item
@code{V: expres@~{a}o} (ou alternativamente @code{V=express@~{a}o}) faz com que @code{V} seja associado ao
valor de @code{express@~{a}o} durante a avalia@value{cedilha}@~{a}o de @var{expr}.  Note que se @code{V} @'{e} uma
op@value{cedilha}@~{a}o do Maxima, ent@~{a}o @code{expression} @'{e} usada para seu valor durante a
avalia@value{cedilha}@~{a}o de @var{expr}.  Se mais que um argumento para @code{ev} @'{e} desse tipo
ent@~{a}o a associa@value{cedilha}@~{a}o termina em paralelo.  Se @code{V} @'{e} uma express@~{a}o n@~{a}o at@^{o}mica
ent@~{a}o a substitui@value{cedilha}@~{a}o, ao inv@'{e}s de uma associa@value{cedilha}@~{a}o, @'{e} executada.
@item
@code{F} onde @code{F}, um nome de fun@value{cedilha}@~{a}o, tenha sido declarado para ser uma fun@value{cedilha}@~{a}o de avalia@value{cedilha}@~{a}o (veja @code{evfun})
faz com que @code{F}
seja aplicado a @var{expr}.
@item
Qualquer outro nome de fun@value{cedilha}@~{a}o (e.g., @code{sum}) causa a avalia@value{cedilha}@~{a}o de ocorr@^{e}ncias
desses nomes em @var{expr} mesmo que eles tenham sido verbos.
@item
De forma adicional uma fun@value{cedilha}@~{a}o ocorrendo em @var{expr} (digamos @code{F(x)}) pode ser definida
localmente para o prop@'{o}sito dessa avalia@value{cedilha}@~{a}o de @var{expr} dando
@code{F(x) := express@~{a}o} como um argumento para @code{ev}.
@item
Se um @'{a}tomo n@~{a}o mensionado acima ou uma vari@'{a}vel subscrita ou
express@~{a}o subscrita for dada como um argumento, isso @'{e} avaliado e
se o resultado for uma equa@value{cedilha}@~{a}o ou uma atribui@value{cedilha}@~{a}o ent@~{a}o a associa@value{cedilha}@~{a}o indicada
ou substitui@value{cedilha}@~{a}o @'{e} executada.  Se o resultado for uma lista ent@~{a}o os
membros da lista ser@~{a}o tratados  como se eles fossem argumentos adicionais
dados para @code{ev}.  Isso permite que uma lista de equa@value{cedilha}@~{o}es seja dada (e.g. @code{[X=1, Y=A**2]})
ou que seja dado uma lista de nomes de equa@value{cedilha}@~{o}es (e.g., @code{[%t1, %t2]} onde @code{%t1} e
@code{%t2} s@~{a}o equa@value{cedilha}@~{o}es) tais como aquelas listas retornadas por @code{solve}.
@end itemize

Os argumentos de @code{ev} podem ser dados em qualquer ordem com exce@value{cedilha}@~{a}o de
substitui@value{cedilha}@~{o}es de equa@value{cedilha}@~{o}es que s@~{a}o manuseadas em seq@"{u}@^{e}ncia, da esquerda para a direita,
e fun@value{cedilha}@~{o}es de avalia@value{cedilha}@~{a}o que s@~{a}o compostas, e.g., @code{ev (@var{expr}, ratsimp, realpart)} s@~{a}o
manuseadas como @code{realpart (ratsimp (@var{expr}))}.

Os comutadores @code{simp}, @code{numer}, @code{float}, e @code{pred} podem tamb@'{e}m ser alterados localmente em um
bloco, ou globalmente no Maxima dessa forma eles ir@~{a}
permanecer em efeito at@'{e} serem resetados ao t@'{e}rmino da execu@value{cedilha}@~{a}o do bloco.

Se @var{expr} for uma express@~{a}o racional can@^{o}nica (CRE),
ent@~{a}o a express@~{a}o retornada por @code{ev} @'{e} tamb@'{e}m uma CRE,
contanto que os comutadores @code{numer} e @code{float} n@~{a}o sejam ambos @code{true}.

@item
Durante o passo (1), @'{e} feito uma lista  de vari@'{a}veis n@~{a}o subscritas
aparecendo do lado esquerdo das equa@value{cedilha}@~{o}es nos argumentos ou nos
valores de alguns argumentos se o valor for uma equa@value{cedilha}@~{a}o.  As vari@'{a}veis
(vari@'{a}veis subscritas que n@~{a}o possuem fun@value{cedilha}@~{o}es array
associadas bem como vari@'{a}veis n@~{a}o subscritas) na express@~{a}o @var{expr} s@~{a}o
substitu@'{i}das por seus valores globais, exceto para esse aparecendo nessa 
lista.  Usualmente, @var{expr} @'{e} apenas um r@'{o}tulo ou @code{%}
(como em @code{%i2} no exemplo adiante), ent@~{a}o esse 
passo simplesmente repete a express@~{a}o nomeada pelo r@'{o}tulo, de modo que @code{ev}
possa trabalhar sobre isso.

@item
Se quaisquer substitui@value{cedilha}@~{o}es tiveem sido indicadas pelos argumentos, elas ser@~{a}o
realizadas agora.

@item
A express@~{a}o resultante @'{e} ent@~{a}o reavaliada (a menos que um dos
argumentos seja @code{noeval}) e simplificada conforme os argumentos.  Note que
qualquer chamada de fun@value{cedilha}@~{a}o em @var{expr} ser@'{a} completada depois das vari@'{a}veis
nela serem avalidas e que @code{ev(F(x))} dessa forma possa comportar-se como @code{F(ev(x))}.

@item
Para cada inst@^{a}ncia de @code{eval} nos argumentos, os passos (3) e (4) s@~{a}o repetidos.
@end enumerate

                     Exemplos

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Uma sintaxe alternativa de alto n@'{i}vel tem sido provida por @code{ev}, por meio da qual
se pode apenas digitar seus argumentos, sem o @code{ev()}.  Isto @'{e}, se pode
escrever simplesmente

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Isso n@~{a}o @'{e} permitido como parte de
outra express@~{a}o, e.g., em fun@value{cedilha}@~{o}es, blocos, etc.

Observe o processo de associa@value{cedilha}@~{a}o paralela no seguinte exemplo.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end deffn

@defvr {Propriedade} evflag
Quando um s@'{i}mbolo @var{x} tem a propriedade @code{evflag},
as express@~{o}es @code{ev(@var{expr}, @var{x})} e @code{@var{expr}, @var{x}}
(na linha de comando interativa) s@~{a}o equivalentes a @code{ev(@var{expr}, @var{x} = true)}.
Isto @'{e}, @var{x} est@'{a} associada a @code{true} enquanto @var{expr} for avaliada.

A express@~{a}o @code{declare(@var{x}, evflag)}
fornece a propriedade @code{evflag} para a vari@'{a}vel @var{x}.

Os sinalizadores que possuem a propriedade @code{evflag} por padr@~{a}o s@~{a}o os seguintes:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand}, e
@code{trigexpand}.

Exemplos:

@c ===beg===
@c sin (1/2);
@c sin (1/2), float;
@c sin (1/2), float=true;
@c simp : false;
@c 1 + 1;
@c 1 + 1, simp;
@c simp : true;
@c sum (1/k^2, k, 1, inf);
@c sum (1/k^2, k, 1, inf), simpsum;
@c declare (aa, evflag);
@c if aa = true then YES else NO;
@c if aa = true then YES else NO, aa;
@c ===end===
@example
(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        >    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then SIM else N@~{A}O;
(%o11)                         N@~{A}O
(%i12) if aa = true then SIM else N@~{A}O, aa;
(%o12)                         SIM
@end example

@end defvr

@defvr {Propriedade}  evfun
Quando uma fun@value{cedilha}@~{a}o @var{F} tem a propriedade @code{evfun},
as express@~{o}es @code{ev(@var{expr}, @var{F})} e @code{@var{expr}, @var{F}}
(na linha de comando interativa)
s@~{a}o equivalentes a @code{@var{F}(ev(@var{expr}))}.

Se duas ou mais fun@value{cedilha}@~{o}es @var{F}, @var{G}, etc., que possuem a propriedade @code{evfun} forem especificadas,
as fun@value{cedilha}@~{o}es ser@~{a}o aplicadas na ordem em que forem especificadas.

A express@~{a}o @code{declare(@var{F}, evfun)}
fornece a propriedade @code{evfun} para a fun@value{cedilha}@~{a}o @var{F}.

As fun@value{cedilha}@~{o}es que possuem a propriedade @code{evfun} por padr@~{a}o s@~{a}o as seguintes:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, e
@code{trigreduce}.

Exemplos:
 
@c ===beg===
@c x^3 - 1;
@c x^3 - 1, factor;
@c factor (x^3 - 1);
@c cos(4 * x) / sin(x)^4;
@c cos(4 * x) / sin(x)^4, trigexpand;
@c cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
@c ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
@c declare ([F, G], evfun);
@c (aa : bb, bb : cc, cc : dd);
@c aa;
@c aa, F;
@c F (aa);
@c F (ev (aa));
@c aa, F, G;
@c G (F (ev (aa)));
@c ===end===
@example
(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
@end example

@end defvr

@c NEEDS WORK
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} infeval
Habilita o modo "avalia@value{cedilha}@~{a}o infinita".  @code{ev} repetidamente avalia
uma express@~{a}o at@'{e} que ela permane@value{cedilha}a invariante.  Para prevenir uma
vari@'{a}vel, digamos @code{X}, seja demoradamente avaliada nesso modo, simplesmente
inclua @code{X='X} como um argumento para @code{ev}.  Certamente express@~{o}es tais como
@code{ev (X, X=X+1, infeval)} ir@~{a}o gerar um ciclo infinito.

@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Fun@value{cedilha}@~{a}o} kill (labels)
@deffnx {Fun@value{cedilha}@~{a}o} kill (inlabels, outlabels, linelabels)
@deffnx {Fun@value{cedilha}@~{a}o} kill (@var{n})
@deffnx {Fun@value{cedilha}@~{a}o} kill ([@var{m}, @var{n}])
@deffnx {Fun@value{cedilha}@~{a}o} kill (values, functions, arrays, ...)
@deffnx {Fun@value{cedilha}@~{a}o} kill (all)
@deffnx {Fun@value{cedilha}@~{a}o} kill (allbut (@var{a_1}, ..., @var{a_n}))

Remove todas as associa@value{cedilha}@~{o}es (valor, fun@value{cedilha}@~{o}es, array, ou regra) dos argumentos
@var{a_1}, ..., @var{a_n}.
Um argumento @var{a_k} pode ser um s@'{i}mbolo ou um elemento de array simples.
Quando @var{a_k} for um elemento de array simples, @code{kill} remove a associa@value{cedilha}@~{a}o daquele elemento
sem afetar qualquer outro elemento do array.

Muitos argumentos especiais s@~{a}o reconhecidos.  
Diferentes fam@'{i}lias de argumentos 
podem ser combinadas, e.g., @code{kill (inlabels, functions, allbut (foo, bar))}

todos os r@'{o}tulos de entrada, de sa@'{i}da, e de express@~{o}es intermedi@'{a}rias criados at@'{e} ent@~{a}o.
@code{kill (inlabels)} libera somente r@'{o}tudos de entrada 
que come@value{cedilha}am com o valor corrente de @code{inchar}.
De forma semelhante,
@code{kill (outlabels)} libera somente r@'{o}tulos de sa@'{i}da
que come@value{cedilha}am com o valor corrente de @code{outchar},
e @code{kill (linelabels)} libera somente r@'{o}tulos de express@~{o}es intermedi@'{a}rias
que come@value{cedilha}am com o valor corrente de @code{linechar}.

@code{kill (@var{n})}, onde @var{n} @'{e} um inteiro,
libera os @var{n} mais recentes r@'{o}tulos de entrada e sa@'{i}da.

@code{kill ([@var{m}, @var{n}])} libera r@'{o}tulos de entrada e sa@'{i}da de @var{m} at@'{e} @var{n}.

@code{kill (@var{infolist})}, onde @var{infolist} @'{e} um item em @code{infolists}
(tais como @code{values}, @code{functions}, ou @code{arrays})
libera todos os @'{i}tens em @var{infolist}.
Veja tamb@'{e}m @code{infolists}.

@code{kill (all)} liberar todos os @'{i}tens em todas as infolists.
@code{kill (all)} n@~{a}o retorna vari@'{a}veis globais para seus valores padr@~{o}es;
Veja @code{reset} sobre esse ponto.

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
remove a associa@value{cedilha}@~{a}o de todos os itens sobre todas as infolistas exceto para @var{a_1}, ..., @var{a_n}.
@code{kill (allbut (@var{infolist}))} libera todos os @'{i}tens exceto para si pr@'{o}prio em @var{infolist},
onde @var{infolist} @'{e} @code{values}, @code{functions}, @code{arrays}, etc.

A mem@'{o}ria usada por uma propriedade de associa@value{cedilha}@~{a}o n@~{a}o ser@'{a} liberada at@'{e} que todos os s@'{i}mbolos
sejam liberados disso.
Em particular, para liberar a mem@'{o}ria usada pelo valor de um s@'{i}mbolo,
deve-se liberar o r@'{o}tulo de sa@'{i}da que mosta o valor associado, bem como liberando o pr@'{o}prio s@'{i}mbolo.

@code{kill} coloca um ap@'{o}stro em seus argumentos (n@~{a}o os avalia).
O operador ap@'{o}strofo-ap@'{o}strofo, @code{'@w{}'}, faz com que ocorra avalia@value{cedilha}@~{a}o.

@code{kill (@var{s@'{i}mbolo})} libera todas as propriedades de @var{s@'{i}mbolo}.
Em oposi@value{cedilha}@~{a}o, @code{remvalue}, @code{remfunction}, @code{remarray}, e @code{remrule}
liberam uma propriedade espec@'{i}fica.

@code{kill} sempre retorna @code{done}, igualmente se um argumento n@~{a}o tem associa@value{cedilha}@~{o}es.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} labels (@var{s@'{i}mbolo})
@deffnx {Vari@'{a}vel de sistema} labels
Retorna a lista de r@'{o}tulos de entradas, de sa@'{i}da, de express@~{o}es intermedi@'{a}rias que come@value{cedilha}am com @var{s@'{i}mbolo}.
Tipicamente @var{s@'{i}mbolo} @'{e} o valor de @code{inchar}, @code{outchar}, ou @code{linechar}.
O caracter r@'{o}tulo pode ser dado com ou sem o sinal de porcentagem,
ent@~{a}o, por exemplo, @code{i} e @code{%i} retornam o mesmo resultado.

Se nenhum r@'{o}tulo come@value{cedilha}a com @var{s@'{i}mbolo}, @code{labels} retorna uma lista vazia.

A fun@value{cedilha}@~{a}o @code{labels} n@~{a}o avalia seu argumento.
O operador ap@'{o}strofo-ap@'{o}strofo @code{'@w{}'} faz com que ocorra avalia@value{cedilha}@~{a}o.
Por exemplo,
@code{labels (''inchar)} retorna os r@'{o}tulos de entrada que come@value{cedilha}am com o caractere corrente do r@'{o}tulo de entrada.

A vari@'{a}vel @code{labels} @'{e} uma lista de r@'{o}tulos de entrada, sa@'{i}da, e de express@~{o}es intermedi@'{a}rias,
incluindo todos os r@'{o}tulos anteriores se @code{inchar}, @code{outchar}, ou @code{linechar} que tiverem sido redefinidos.

Por padr@~{a}o, Maxima mostra o resultado de cada express@~{a}o de entrada do usu@'{a}rio,
dando ao resultado um r@'{o}tulo de sa@'{i}da.
A exibi@value{cedilha}@~{a}o da sa@'{i}da @'{e} suprimida pelo encerramento da entrada com @code{$} (sinal de dolar)
em lugar de @code{;} (ponto e v@'{i}rgula).
Um r@'{o}tulo de sa@'{i}da @'{e} construido e associado ao resultado, mas n@~{a}o @'{e} mostrado, 
e o r@'{o}tulo pode ser referenciado da mesma forma que r@'{o}tulos de sa@'{i}da mostrados.
Veja tamb@'{e}m @code{%}, @code{%%}, e @code{%th}.

R@'{o}tulos de express@~{o}es intermedi@'{a}rias podem ser gerados por algumas fun@value{cedilha}@~{o}es.
O sinalizador @code{programmode} controla se @code{solve} e algumas outras fun@value{cedilha}@~{o}es
geram r@'{o}tulos de express@~{o}es intermedi@'{a}rias em lugar de retornar uma lista de express@~{o}es.
Algumas outras fun@value{cedilha}@~{o}es, tais como @code{ldisplay}, sempre geram r@'{o}tulos de express@~{o}es intermedi@'{a}rias.

Veja tamb@'{e}m @code{inchar}, @code{outchar}, @code{linechar}, e @code{infolists}.

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Vari@'{a}vel de sistema} linenum
Retorna o n@'{u}mero da linha do par corrente de express@~{o}es de entrada e sa@'{i}da.

@end defvr

@c NEEDS WORK
@defvr {Vari@'{a}vel de sistema} myoptions
Valor padr@~{a}o: @code{[]}

@code{myoptions} @'{e} a lista de todas as op@value{cedilha}@~{o}es alguma vez alteradas pelo usu@'{a}rio,
tenha ou n@~{a}o ele retornado a altera@value{cedilha}@~{a}o para o seu valor padr@~{a}o.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} nolabels
Valor padr@~{a}o: @code{false}

@c PREVIOUS DESCRIPTION OF nolabels: THIS IS OUT OF DATE
@c When @code{nolabels} is @code{true}, then no labels will be bound
@c except for intermediate express@~{a}o lines generated by the solve functions.  This is most
@c useful in the batch mode where it eliminates the need to do
@c @code{kill (labels)} in order to free up storage.

Quando @code{nolabels} for @code{true},
r@'{o}tulos de entrada e sa@'{i}da
(@code{%i} e @code{%o}, respectivamente)
s@~{a}o mostrados,
mas os r@'{o}tulos n@~{a}o s@~{a}o associados aos resultados,
e os r@'{o}tulos n@~{a}o s@~{a}o anexados ao final da lista @code{labels}.
Uma vez que r@'{o}tulos n@~{a}o s@~{a}o associados aos resultados,
a reciclagem pode recuperar a mem@'{o}ria tomada pelos resultados.

De outra forma r@'{o}tulos de entrada e sa@'{i}da s@~{a}o associados aos resultados,
e os r@'{o}tulos s@~{a}o anexados ao final da lista @code{labels}.

Veja tamb@'{e}m @code{batch}, @code{batchload}, e @code{labels}.

@end defvr

@c NEEDS WORK
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} optionset
Valor padr@~{a}o: @code{false}

Quando @code{optionset} for @code{true}, Maxima mostrar@'{a} uma
mensagem sempre que uma op@value{cedilha}@~{a}o do Maxima for alterada.  Isso @'{e} @'{u}til se o
usu@'{a}rio est@'{a} incerto sobre a ortografia de alguma op@value{cedilha}@~{a}o e quer ter certeza
que a vari@'{a}vel por ele atribu@'{i}do um valor foi realmente uma vari@'{a}vel de op@value{cedilha}@~{a}o.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} playback ()
@deffnx {Fun@value{cedilha}@~{a}o} playback (@var{n})
@deffnx {Fun@value{cedilha}@~{a}o} playback ([@var{m}, @var{n}])
@deffnx {Fun@value{cedilha}@~{a}o} playback ([@var{m}])
@deffnx {Fun@value{cedilha}@~{a}o} playback (input)
@deffnx {Fun@value{cedilha}@~{a}o} playback (slow)
@deffnx {Fun@value{cedilha}@~{a}o} playback (time)
@deffnx {Fun@value{cedilha}@~{a}o} playback (grind)
Mostra express@~{o}es de entrada, de sa@'{i}da, e express@~{o}es intermedi@'{a}rias,
sem refazer os c@'{a}lculos.
@code{playback} somente mostra as express@~{o}es associadas a r@'{o}tulos;
qualquer outra sa@'{i}da (tais como textos impressos por @code{print} ou @code{describe}, ou messagens de erro)
n@~{a}o @'{e} mostrada.
Veja tamb@'{e}m @code{labels}.

@code{playback} n@~{a}o avalia seus argumentos.
O operador ap@'{o}strofo-ap@'{o}strofo, @code{'@w{}'}, sobrep@~{o}e-se @`as aspas.
@code{playback} sempre retorna @code{done}.

@code{playback ()} (sem argumentos) mostra todas as entradas, sa@'{i}das e express@~{o}es intermedi@'{a}rias
geradas at@'{e} ent@~{a}o.
Uma express@~{a}o de sa@'{i}da @'{e} mostrada mesmo se for suprimida pelo terminador @code{$}
quando ela tiver sido originalmente calculada.

@code{playback (@var{n})} mostra as mais recentes @var{n} express@~{o}es.
Cada entrada, sa@'{i}da e express@~{a}o intermedi@'{a}ria
conta como um.

@code{playback ([@var{m}, @var{n}])} mostra entradas, sa@'{i}das e express@~{o}es intermedi@'{a}rias
com os n@'{u}meros de @var{m} at@'{e} @var{n}, inclusive.

@code{playback ([@var{m}])} @'{e} equivalente a @code{playback ([@var{m}, @var{m}])};
isso usualmente imprime um par de express@~{o}es de entrada e sa@'{i}da.

@code{playback (input)} mostra todas as express@~{o}es de entrada geradas at@'{e} ent@~{a}o.

@code{playback (slow)} insere pausas entre express@~{o}es
e espera que o usu@'{a}rio pressione @code{enter}.
Esse comportamento @'{e} similar a @code{demo}.
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} @'{e} @'{u}til juntamente com @code{save} ou @code{stringout}
quando criamos um arquivo secund@'{a}rio de armazenagem com a finalidade de capturar express@~{o}es @'{u}teis.

@code{playback (time)} mostra o tempo de computa@value{cedilha}@~{a}o de cada express@~{a}o.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} e @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} mostra express@~{o}es de entrada
no mesmo formato da fun@value{cedilha}@~{a}o @code{grind}.
Express@~{o}es de sa@'{i}da n@~{a}o s@~{a}o afetadas pela op@value{cedilha}@~{a}o @code{grind}.
Veja @code{grind}.

Argumentos podem ser combinados, e.g., 
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS).  CORRECT ???

@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Fun@value{cedilha}@~{a}o} printprops (@var{a}, @var{i})
@deffnx {Fun@value{cedilha}@~{a}o} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Fun@value{cedilha}@~{a}o} printprops (all, @var{i})
Mostra a propriedade como o indicador @var{i}
associada com o @'{a}tomo @var{a}.  @var{a} pode tamb@'{e}m ser uma lista de @'{a}tomos ou o @'{a}tomo
@code{all} nesse caso todos os @'{a}tomos com a propriedade dada ser@~{a}o
usados.  Por exemplo, @code{printprops ([f, g], atvalue)}.  @code{printprops} @'{e} para
propriedades que n@~{a}o podem  ser mostradas de outra forma, i.e. para
@code{atvalue}, @code{atomgrad}, @code{gradef}, e @code{matchdeclare}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} prompt
Valor padr@~{a}o: @code{_}

@code{prompt} @'{e} o s@'{i}mbolo de linha de comando da fun@value{cedilha}@~{a}o @code{demo},
modo @code{playback (slow)}, e da interrup@value{cedilha}@~{a}o de ciclos do Maxima (como invocado por @code{break}).

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} quit ()
Encerra a sess@~{a}o do Maxima.
Note que a fun@value{cedilha}@~{a}o pode ser invocada como @code{quit();} ou @code{quit()$},
n@~{a}o por s@'{i} mesma @code{quit}.

Para parar um c@'{a}lculo muito longo,
digite @code{control-C}.
A a@value{cedilha}@~{a}o padr@~{a}o @'{e} retornar @`a linha de comando do Maxima.
Se @code{*debugger-hook*} @'{e} @code{nil},
@code{control-C} abre o depurador Lisp.
Veja tamb@'{e}m @code{debugging}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@value{cedilha}@~{a}o} remfunction (all)
Desassocia as defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o dos s@'{i}bolos @var{f_1}, ..., @var{f_n}.
Os argumentos podem ser os nomes de fun@value{cedilha}@~{o}es comuns (criadas por meio de @code{:=} ou @code{define})
ou fun@value{cedilha}@~{o}es macro (criadas por meio de @code{::=}).

@code{remfunction (all)} desassocia todas as defini@value{cedilha}@~{o}es de func@value{cedilha}@~{a}o.

@code{remfunction} coloca um ap'ostrofo em seus argumentos (n@~{a}o os avalia).

@code{remfunction} retorna uma lista de s@'{i}mbolos para a qual a defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o foi desassociada.
@code{false} @'{e} retornado em lugar de qualquer s@'{i}mbolo para o qual n@~{a}o exista defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} reset ()
Retorna muitas vari@'{a}veis globais e op@value{cedilha}@~{o}es, e algumas outras vari@'{a}veis, para seus valores padr@~{o}es.

@code{reset} processa as vari@'{a}veis na lista Lisp @code{*variable-initial-values*}.
A macro Lisp @code{defmvar} coloca vari@'{a}veis nessa lista (entre outras a@value{cedilha}@~{o}es).
Muitas, mas n@~{a}o todas, vari@'{a}veis globais e op@value{cedilha}@~{o}es s@~{a}o definidas por @code{defmvar},
 e algumas vari@'{a}veis definidas por @code{defmvar} n@~{a}o s@~{a}o vari@'{a}veis globais ou vari@'{a}veis de op@value{cedilha}@~{a}o.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} showtime
Valor padr@~{a}o: @code{false}

Quando @code{showtime} for @code{true}, o tempo de computa@value{cedilha}@~{a}o e o tempo decorrido s@~{a}o
impressos na tela com cada express@~{a}o de sa@'{i}da.

O tempo de c@'{a}lculo @'{e} sempre gravado,
ent@~{a}o @code{time} e @code{playback} podem mostrar o tempo de c@'{a}lculo
mesmo quando @code{showtime} for @code{false}.

Veja tamb@'{e}m @code{timer}.

@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Fun@value{cedilha}@~{a}o} sstatus (@var{recurso}, @var{pacote})
Altera o status de @var{recurso} em @var{pacote}.
Ap@'{o}s @code{sstatus (@var{recurso}, @var{pacote})} ser executado,
@code{status (@var{recurso}, @var{pacote})} retorna @code{true}.
Isso pode ser @'{u}til para quem escreve pacotes, para
manter um registro de quais recursos os pacotes usam.

@end deffn

@c NEEDS EXPANSION, EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} to_lisp ()
Insere o sistema Lisp dentro do Maxima.  @code{(to-maxima)} retorna para o Maxima.

@end deffn

@defvr {Vari@'{a}vel de sistema} values
Valor inicial: @code{[]}

@code{values} @'{e} uma lista de todas as var@'{a}veis de usu@'{a}rio associadas (n@~{a}o op@value{cedilha}@~{o}es Maxima ou comutadores).
A lista compreende s@'{i}mbolos associados por @code{:} , @code{::}, ou @code{:=}.

@end defvr
