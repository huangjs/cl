@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Ctensor.texi/1.33/Sat Jun  2 00:12:36 2007/-ko/
@menu
* Introdu@value{cedilha}@~{a}o a ctensor::     
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para ctensor::     
@end menu

@node Introdu@value{cedilha}@~{a}o a ctensor, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para ctensor, ctensor, ctensor
@section Introdu@value{cedilha}@~{a}o a ctensor

@code{ctensor} @'{e} um pacote de manipula@value{cedilha}@~{a}o de componentes.  Para usar o pacote
@code{ctensor}, digite @code{load(ctensor)}.
Para come@value{cedilha}ar uma sess@~{a}o iterativa com @code{ctensor}, digite @code{csetup()}.  Voc@^{e} @'{e}
primeiramente solicitado a especificar a dimens@~{a}o a ser manipulada. Se a dimens@~{a}o
for 2, 3 ou 4 ent@~{a}o a lista de coordenadas padr@~{a}o @'{e} @code{[x,y]}, @code{[x,y,z]}
ou @code{[x,y,z,t]} respectivamente.
Esses nomes podem ser mudados atrav@'{e}s da atribui@value{cedilha}@~{a}o de uma nova lista de coordenadas para
a vari@'{a}vel @code{ct_coords} (descrita abaixo) e o usu@'{a}rio @'{e} perguntado sobre
isso.Cuidado deve ser tomado para evitar o conflito de nomes de coordenadas
com outras defini@value{cedilha}@~{o}es de objetos.

No pr@'{o}ximo passo, o usu@'{a}rio informa a m@'{e}trica ou diretamente ou de um arquivo
especificando sua posi@value{cedilha}@~{a}o ordinal. Como um exemplo de um arquivo de m@'{e}trica
comum, veja @code{share/tensor/metrics.mac}. A m@'{e}trica est@'{a} armazenada na matriz
LG. Finalmente, o inverso da m@'{e}trica @'{e} calculado e armazenado na matriz
UG. Se tem a op@value{cedilha}@~{a}o de realizar todos os c@'{a}lculos em s@'{e}ries de
pot@^{e}ncia.

Um protocolo amostra @'{e} iniciado abaixo para a m@'{e}trica est@'{a}tica, esfericamente sim@'{e}trica
(coordenadas padr@~{a}o) que ser@'{a} aplicadas ao problema de
deriva@value{cedilha}@~{a}o das equa@value{cedilha}@~{o}es de v@'{a}cuo de Einstein (que levam @`a solu@value{cedilha}@~{a}o de
Schwarzschild) como um exemplo. Muitas das fun@value{cedilha}@~{o}es em @code{ctensor} ir@~{a}o ser
mostradas para a m@'{e}trica padr@~{a}o como exemplos.

@example
(%i1) load(ctensor);
(%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system: 
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none 
depends([a,d],x);
Do you wish to see the metric? 
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done

@end example

@c end concepts ctensor
@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para ctensor,  , Introdu@value{cedilha}@~{a}o a ctensor, ctensor

@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para ctensor

@subsection Inicializa@value{cedilha}@~{a}o e configura@value{cedilha}@~{a}o

@deffn {Fun@value{cedilha}@~{a}o} csetup ()
@'{E} uma fun@value{cedilha}@~{a}o no pacote @code{ctensor} (component tensor)
que inicializa o pacote e permite ao usu@'{a}rio inserir uma m@'{e}trica
interativamente. Veja @code{ctensor} para mais detalhes.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} cmetric (@var{dis})
@deffnx {Fun@value{cedilha}@~{a}o} cmetric ()
@'{E} uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}
que calcula o inverso da m@'{e}trica e prepara o pacote para
c@'{a}lculos adiante.

Se @code{cframe_flag} for @code{false}, a fun@value{cedilha}@~{a}o calcula a m@'{e}trica inversa
@code{ug} a partir da matriz @code{lg} (definida pelo usu@'{a}rio). O determinante da m@'{e}trica @'{e}
tamb@'{e}m calculado e armazenado na vari@'{a}vel @code{gdet}. Mais adiante, o
pacote determina se a m@'{e}trica @'{e} diagonal e escolhe o valor
de @code{diagmetric} conforme a determina@value{cedilha}@~{a}o. Se o argumento opcional @var{dis}
estiver presente e n@~{a}o for @code{false}, a sa@'{i}da @'{e} mostrada ao usu@'{a}rio pela linha de comando para que ele possa ver
o inverso da m@'{e}trica.

Se @code{cframe_flag} for @code{true}, a fun@value{cedilha}@~{a}o espera que o valor de
@code{fri} (a matriz moldura inversa) e @code{lfg} (a m@'{e}trica da moldura) sejam
definidas. A partir dessas, a matriz da moldura @code{fr} e a m@'{e}trica da moldura
inversa @code{ufg} s@~{a}o calculadas.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ct_coordsys (@var{sistema_de_coordenadas}, @var{extra_arg})
@deffnx {Fun@value{cedilha}@~{a}o} ct_coordsys (@var{sistema_de_coordenadas})
Escolhe um sistema de coordenadas predefinido e uma m@'{e}trica. O argumento
@var{sistema_de_coordenadas} pode ser um dos seguintes s@'{i}mbolos:

@example

  SYMBOL               Dim Coordenadas       Descri@value{cedilha}@~{a}o/coment@'{a}rios
  --------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
  polar                 2  [r,phi]           Sist. de coord. Polare
  elliptic              2  [u,v]
  confocalelliptic      2  [u,v]
  bipolar               2  [u,v]
  parabolic             2  [u,v]
  cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
  polarcylindrical      3  [r,theta,z]
  ellipticcylindrical   3  [u,v,z]           El@'{i}ptica 2D com Z cil@'{i}ndrico
  confocalellipsoidal   3  [u,v,w]
  bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cil@'{i}ndrico
  paraboliccylindrical  3  [u,v,z]           Parab@'{o}lico 2D com Z cil@'{i}ndrico
  paraboloidal          3  [u,v,phi]
  conical               3  [u,v,w]
  toroidal              3  [u,v,phi]
  spherical             3  [r,theta,phi]     Sist. de coord. Esf@'{e}ricas
  oblatespheroidal      3  [u,v,phi]
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]
  cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
  spherical4d           4  [r,theta,eta,phi]
  exteriorschwarzschild 4  [t,r,theta,phi]   M@'{e}trica de Schwarzschild
  interiorschwarzschild 4  [t,z,u,v]        M@'{e}trica de Schwarzschild Interior
  kerr_newman           4  [t,r,theta,phi]   M@'{e}trica sim@'{e}trica axialmente alterada

@end example

@code{sistema_de_coordenadas} pode tamb@'{e}m ser uma lista de fun@value{cedilha}@~{o}es de transforma@value{cedilha}@~{a}o,
seguida por uma lista contendo as var@'{a}veis coordenadas. Por exemplo,
voc@^{e} pode especificar uma m@'{e}trica esf@'{e}rica como segue:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

@end example

Fun@value{cedilha}@~{o}es de transforma@value{cedilha}@~{a}o podem tamb@'{e}m serem usadas quando @code{cframe_flag} for @code{true}:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

@end example

O argumento opcional @var{extra_arg} pode ser qualquer um dos seguintes:
@c LOOKING AT share/tensor/ctensor.mac CIRCA LINE 837, misner IS RECOGNIZED ALSO; WHAT EFFECT DOES IT HAVE ??

@code{cylindrical} diz a @code{ct_coordsys} para anexar uma coordenada adicional cil@'{i}ndrica.

@code{minkowski} diz a @code{ct_coordsys} para anexar uma coordenada com assinatura m@'{e}trica negativa.

@code{all} diz a @code{ct_coordsys} para chamar @code{cmetric} e @code{christof(false)} ap@'{o}s escolher a m@'{e}trica.

@c GLOBAL VARIABLE verbose IS USED IN ctensor.mac IN JUST THIS ONE CONTEXT
Se a vari@'{a}vel global @code{verbose} for escolhida para @code{true}, @code{ct_coordsys} mostra os valores de @code{dim}, @code{ct_coords}, e ou @code{lg} ou @code{lfg} e @code{fri}, dependendo do valor de @code{cframe_flag}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} init_ctensor ()
Inicializa o pacote @code{ctensor}.

A fun@value{cedilha}@~{a}o @code{init_ctensor} reinicializa o pacote @code{ctensor}. Essa fun@value{cedilha}@~{a}o remove todos os arrays e matrizes usados por @code{ctensor}, coloca todos os sinalizadores de volta a seus valores padr@~{a}o, retorna @code{dim} para 4, e retorna a m@'{e}trica da moldura para a m@'{e}trica da moldura de Lorentz.

@end deffn


@subsection Os tensores do espa@value{cedilha}o curvo

O principal prop@'{o}sito do pacote @code{ctensor} @'{e} calcular os tensores
do espa@value{cedilha}(tempo) curvo, mais notavelmente os tensores usados na relatividade
geral.

Quando uma base m@'{e}trica @'{e} usada, @code{ctensor} pode calcular os seguintes tensores:

@example

 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric 
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


@end example

@code{ctensor} pode tamb@'{e}m usar molduras m@'{o}veis. Quando @code{cframe_flag} for
escolhida para @code{true}, os seguintes tensores podem ser calculados:

@example

 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

@end example

@deffn {Fun@value{cedilha}@~{a}o} christof (@var{dis})
Uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}.
Essa fun@value{cedilha}@~{a}o calcula os s@'{i}mbolos de Christoffel de ambos
os tipos.  O argumento @var{dis} determina quais resultados s@~{a}o para serem imediatamente
mostrados.  Os s@'{i}mbolos de Christoffel de primeiro e de segundo tipo s@~{a}o
armazenados nos arrays @code{lcs[i,j,k]} e @code{mcs[i,j,k]} respectivamente e
definidos para serem sim@'{e}tricos nos primeiros dois @'{i}ndices. Se o argumento para
@code{christof} for @code{lcs} ou for @code{mcs} ent@~{a}o o @'{u}nico valor n@~{a}o nulo de @code{lcs[i,j,k]}
ou de @code{mcs[i,j,k]}, respectivamente, ser@'{a} mostrado. Se o argumento for @code{all}
ent@~{a}o o @'{u}nico valor n@~{a}o nulo de @code{lcs[i,j,k]} e o @'{u}nico valor n@~{a}o nulo de  @code{mcs[i,j,k]} ser@~{a}o
mostrados.  Se o argumento for @code{false} ent@~{a}o a exibi@value{cedilha}@~{a}o dos elementos
n@~{a}o acontecer@'{a}. Os elementos do array @code{mcs[i,j,k]} s@~{a}o definidos de uma tal
maneira que o @'{i}ndice final @'{e} contravariante.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ricci (@var{dis})
Uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}.
@code{ricci} calcula as componentes contravariantes
(sim@'{e}tricas) @code{ric[i,j]} do tensor de Ricci.  Se o argumento @var{dis} for @code{true},
ent@~{a}o as componentes n@~{a}o nulas s@~{a}o mostradas.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} uricci (@var{dis})
Essa fun@value{cedilha}@~{a}o primeiro calcula as
componentes contravariantes @code{ric[i,j]} do tensor de Ricci.
Ent@~{a}o o tensor misto de Ricci @'{e} calculado usando o
tensor m@'{e}trico contravariante.  Se o valor do argumento @var{dis}
for @code{true}, ent@~{a}o essas componentes mistas, @code{uric[i,j]} (o @'{i}ndice "i" @'{e}
covariante e o @'{i}ndice "j" @'{e} contravariante), ser@~{a}o mostradas
diretamente.  De outra forma, @code{ricci(false)} ir@'{a} simplesmente calcular as entradas
do array @code{uric[i,j]} sem mostrar os resultados.

@end deffn
@deffn {Fun@value{cedilha}@~{a}o} scurvature ()

Retorna a curvatura escalar (obtida atrav@'{e}s da contra@value{cedilha}@~{a}o
do tensor de Ricci) do Riemaniano multiplicado com a m@'{e}trica dada.

@end deffn
@deffn {Fun@value{cedilha}@~{a}o} einstein (@var{dis})
Uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}.
@code{einstein} calcula o tensor misto de Einstein
ap@'{o}s os s@'{i}mbolos de Christoffel e o tensor de Ricci terem sido obtidos
(com as fun@value{cedilha}@~{o}es @code{christof} e @code{ricci}).  Se o argumento @var{dis} for
@code{true}, ent@~{a}o os valores n@~{a}o nulos do tensor misto de Einstein @code{ein[i,j]}
ser@~{a}o mostrados quando @code{j} for o @'{i}ndice contravariante.
A vari@'{a}vel @code{rateinstein} far@'{a} com que a simplifica@value{cedilha}@~{a}o racional ocorra sobre
esses componentes. Se @code{ratfac} for @code{true} ent@~{a}o as componentes ir@~{a}o
tamb@'{e}m ser fatoradas.

@end deffn
@deffn {Fun@value{cedilha}@~{a}o} leinstein (@var{dis})
Tensor covariante de Einstein. @code{leinstein} armazena o valor do tensor covariante de Einstein no array @code{lein}. O tensor covariante de Einstein @'{e} calculado a partir tensor misto de Einstein @code{ein} atrav@'{e}s da multiplica@value{cedilha}@~{a}o desse pelo tensor m@'{e}trico. Se o argumento @var{dis} for @code{true}, ent@~{a}o os valores n@~{a}o nulos do tensor covariante de Einstein s@~{a}o mostrados.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} riemann (@var{dis})
Uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}.
@code{riemann} calcula o tensor de curvatura de Riemann
a partir da m@'{e}trica dada e correspondendo aos s@'{i}mbolos de Christoffel. As seguintes
conven@value{cedilha}@~{o}es de @'{i}ndice s@~{a}o usadas:

@example
                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
@end example

Essa nota@value{cedilha}@~{a}o @'{e} consistente com a nota@value{cedilha}@~{a}o usada por no pacote
@code{itensor} e sua fun@value{cedilha}@~{a}o @code{icurvature}.
Se o argumento opcional @var{dis} for @code{true},
as componentes n@~{a}o nulas @code{riem[i,j,k,l]} ser@~{a}o mostradas.
Como com o tensor de Einstein, v@'{a}rios comutadores escolhidos pelo usu@'{a}rio
controlam a simplifica@value{cedilha}@~{a}o de componentes do tensor de Riemann.
Se @code{ratriemann} for @code{true}, ent@~{a}o
simplifica@value{cedilha}@~{a}o racional ser@'{a} feita. Se @code{ratfac}
for @code{true} ent@~{a}o
cada uma das componentes ir@'{a} tamb@'{e}m ser fatorada.

Se a vari@'{a}vel @code{cframe_flag} for @code{false}, o tensor de Riemann @'{e}
calculado diretamente dos s@'{i}mbolos de Christoffel. Se @code{cframe_flag} for
@code{true}, o tensor covariante de Riemann @'{e} calculado primeiro dos
coeficientes de campo da moldura.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lriemann (@var{dis})
Tensor covariante de Riemann (@code{lriem[]}).

Calcula o tensor covariante de Riemann como o array @code{lriem}. Se o
argumento @var{dis} for @code{true}, @'{u}nicos valores n@~{a}o nulos s@~{a}o mostrados.

Se a vari@'{a}vel @code{cframe_flag} for @code{true}, o tensor covariante
de Riemann @'{e} calculado diretamente dos coeficientes de campo da moldura. De outra forma,
o tensor (3,1) de Riemann @'{e} calculado primeiro.

Para informa@value{cedilha}@~{a}o sobre a ordena@value{cedilha}@~{a}o de @'{i}ndice, veja @code{riemann}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} uriemann (@var{dis})
Calcula as componentes contravariantes do tensor de curvatura
 de Riemann como elementos do array @code{uriem[i,j,k,l]}.  Esses s@~{a}o mostrados
se @var{dis} for @code{true}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rinvariant ()
Comp@~{o}e o invariante de Kretchmann (@code{kinvariant}) obtido atrav@'{e}s da
contra@value{cedilha}@~{a}o dos tensores

@example
lriem[i,j,k,l]*uriem[i,j,k,l].
@end example

Esse objeto n@~{a}o @'{e} automaticamente simplificado devido ao fato de poder ser muito largo.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} weyl (@var{dis})
Calcula o tensor conformal de Weyl.  Se o argumento @var{dis} for
@code{true}, as componentes n@~{a}o nulas @code{weyl[i,j,k,l]} ir@~{a}o ser mostradas para o
usu@'{a}rio.  De outra forma, essas componentes ir@~{a}o simplesmente serem calculadas e armazenadas.
Se o comutador @code{ratweyl} @'{e} escolhido para @code{true}, ent@~{a}o as componentes ir@~{a}o ser
racionalmente simplificadas; se @code{ratfac} for @code{true} ent@~{a}o os resultados ir@~{a}o ser
fatorados tamb@'{e}m.

@end deffn

@subsection Expans@~{a}o das s@'{e}ries de Taylor

O pacote @code{ctensor} possui a habilidade para truncar resultados assumindo
que eles s@~{a}o aproxima@value{cedilha}@~{o}es das s@'{e}ries de Taylor. Esse comportamenteo @'{e} controlado atrav@'{e}s
da vari@'{a}vel @code{ctayswitch}; quando escolhida para @code{true}, @code{ctensor} faz uso
internamente da fun@value{cedilha}@~{a}o @code{ctaylor} quando simplifica resultados.

A fun@value{cedilha}@~{a}o @code{ctaylor} @'{e} invocada pelas seguintes fun@value{cedilha}@~{o}es de @code{ctensor}:

@example

    Function     Comments
    ---------------------------------
    christof()   s@'{o} para mcs
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
@end example

@deffn {Fun@value{cedilha}@~{a}o} ctaylor ()

A fun@value{cedilha}@~{a}o @code{ctaylor} trunca seus argumentos atrav@'{e}s da convers@~{a}o
destes para uma s@'{e}rie de Taylor usando @code{taylor}, e ent@~{a}o chamando
@code{ratdisrep}. Isso tem efeito combinado de abandonar termos
de ordem mais alta na vari@'{a}vel de expans@~{a}o @code{ctayvar}. A ordem
dos termos que podem ser abandonados @'{e} definida atrav@'{e}s de @code{ctaypov}; o
ponto em torno do qual a expans@~{a}o da s@'{e}rie @'{e} realizada est@'{a} especificado
em @code{ctaypt}.

Como um exemplo, considere uma m@'{e}trica simples que @'{e} uma perturba@value{cedilha}@~{a}o da
m@'{e}trica de Minkowski. Sem restri@value{cedilha}@~{o}es adicionais, mesmo uma m@'{e}trica
diagonal produz express@~{o}es para o tensor de Einstein que s@~{a}o de longe muito
complexas:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
         [ h11 l - 1      0          0                 0            ]
         [                                                          ]
         [     0      h22 l + 1      0                 0            ]
         [                                                          ]
(%o8)    [                        2                                 ]
         [     0          0      r  + h33 l            0            ]
         [                                                          ]
         [                                    2    2                ]
         [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 24] 
[[2, 3], 0] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 0] 
[[3, 3], 46] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 46] 
(%o12)                               done

@end example

Todavia, se n@'{o}s recalcularmos esse exemplo como uma aproxima@value{cedilha}@~{a}o que @'{e}
linear na vari@'{a}vel @code{l}, pegamos express@~{o}es muito simples:

@example

(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 13] 
[[2, 3], 2] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 2] 
[[3, 3], 9] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 9] 
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                                2               2      4    2
                  - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                           r r                r



@end example

Essa compatibilidade pode ser @'{u}til, por exemplo, quando trabalhamos no limite
do campo fraco longe de uma fonte gravitacional.

@end deffn
    

@subsection Campos de moldura

Quando a vari@'{a}vel @code{cframe_flag} for escolhida para @code{true}, o pacote @code{ctensor}
executa seus c@'{a}lculos usando uma moldura m@'{o}vel.

@deffn {Fun@value{cedilha}@~{a}o} frame_bracket (@var{fr}, @var{fri}, @var{diagframe})
O delimitador da moldura (@code{fb[]}).

Calcula o delimitador da moldura conforme a seguinte defini@value{cedilha}@~{a}o:

@example
   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
@end example

@end deffn

@subsection Classifica@value{cedilha}@~{a}o Alg@'{e}brica

Um novo recurso (a partir de November de 2004) de @code{ctensor} @'{e} sua habilidade para
calcular a classifica@value{cedilha}@~{a}o de Petrov de uma m@'{e}trica espa@value{cedilha}o tempo tetradimensional.
Para uma demonstra@value{cedilha}@~{a}o dessa compatibilidade, veja o arquivo
@code{share/tensor/petrov.dem}.

@deffn {Fun@value{cedilha}@~{a}o} nptetrad ()
Calcula um tetrad nulo de Newman-Penrose (@code{np}) e seus @'{i}ndices ascendentes
em contrapartida (@code{npi}). Veja @code{petrov} para um exemplo.

O tetrad nulo @'{e} constru@'{i}do assumindo que uma moldura m@'{e}trica ortonormal
tetradimensional com assinatura m@'{e}trica (-,+,+,+) est@'{a} sendo usada.
As componentes do tetrad nulo s@~{a}o relacionadas para a matriz moldura inversa
como segue:

@example

np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} psi (@var{dis})
Calcula os cinco coeficientes de Newman-Penrose @code{psi[0]}...@code{psi[4]}.
Se @code{psi} for escolhida para @code{true}, os coeficientes s@~{a}o mostrados.
Veja @code{petrov} para um exemplo.

Esses coeficientes s@~{a}o calculados a partir do tensor de Weyl em uma base de coordenada.
Se uma base de moldura for usada,o tensor de Weyl @'{e} primeiro convertido para a base de
coordenada, que pode ser um procedimento computacional expans@'{i}vel. Por essa raz@~{a}o,
em alguns casos pode ser mais vantajoso usar uma base de coordenada em
primeiro lugar antes que o tensor de Weyl seja calculado. Note todavia, que
para a constru@value{cedilha}@~{a}o de um tetrad nulo de Newman-Penrose @'{e} necess@'{a}rio uma base de moldura. Portanto,
uma seq@"{u}@^{e}ncia de c@'{a}lculo expressiva pode come@value{cedilha}ar com uma base de moldura, que
@'{e} ent@~{a}o usada para calcular @code{lg} (calculada automaticamente atrav@'{e}s de @code{cmetric})
e em seguida calcula @code{ug}. Nesse ponto, voc@^{e} pode comutar de volta para uma base de coordenada
escolhendo @code{cframe_flag} para @code{false} antes de come@value{cedilha}ar a calcular os
s@'{i}mbolos de Christoffel. Mudando para uma base de moldura em um est@'{a}gio posterior pode retornar
resultados inconsistentes, j@'{a} que voc@^{e} pode terminar com um grande mistura de tensores, alguns
calculados em uma base de moldura, alguns em uma base de coordenada, sem nenhum modo para
disting@"{u}ir entre os dois tipos.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} petrov ()
Calcula a classifica@value{cedilha}@~{a}o de petrov da m@'{e}trica caracterizada atrav@'{e}s de @code{psi[0]}...@code{psi[4]}.

Por exemplo, o seguinte demonstra como obter a classifica@value{cedilha}@~{a}o de Petrov
da m@'{e}trica de Kerr:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np = 

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0], 
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0], 
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------], 
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

@end example

A fun@value{cedilha}@~{a}o de classifica@value{cedilha}@~{a}o Petrov @'{e} baseada no algor@'{i}tmo publicado em
"Classifying geometries in general relativity: III Classification in practice"
por Pollney, Skea, e d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Exceto para alguns casos de teste simples, a implementa@value{cedilha}@~{a}o n@~{a}o est@'{a} testada at@'{e}
19 de Dezembro de 2004, e @'{e} prov@'{a}vel que contenha erros.

@end deffn


@subsection Tors@~{a}o e n@~{a}o metricidade

@code{ctensor} possui a habilidade de calcular e incluir coeficientes de tors@~{a}o e n@~{a}o
metricidade nos coeficientes de conec@value{cedilha}@~{a}o.

Os coeficientes de tors@~{a}o s@~{a}o calculados a partir de um tensor fornecido pelo usu@'{a}rio
@code{tr}, que pode ser um tensor de categoria (2,1).  A partir disso, os coeficientes de
tors@~{a}o @code{kt} s@~{a}o calculados de acordo com a seguinte f@'{o}rmula:

@example

              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

@end example

Note que somente o tensor de @'{i}ndice misto @'{e} calculao e armazenado no
array @code{kt}.

Os coeficientes de n@~{a}o metricidade s@~{a}o calculados a partir  do vetor de n@~{a}o metricidade
fornecido pelo usu@'{a}rio @code{nm}. A partir disso, os coeficientes de n@~{a}o metricidade
@code{nmc} s@~{a}o calculados como segue:

@example

             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

@end example

onde D simboliza o delta de Kronecker.

Quando @code{ctorsion_flag} for escolhida para @code{true}, os valores de @code{kt}
s@~{a}o subtra@'{i}dos dos coeficientes de conec@value{cedilha}@~{a}o indexados mistos calculados atrav@'{e}s de
@code{christof} e armazenados em @code{mcs}. Similarmente, se @code{cnonmet_flag}
for escolhida para @code{true}, os valores de @code{nmc} s@~{a}o subtra@'{i}dos dos
coeficientes de conec@value{cedilha}@~{a}o indexados mistos.

Se necess@'{a}rio, @code{christof} chama as fun@value{cedilha}@~{o}es @code{contortion} e
@code{nonmetricity} com o objetivo de calcular @code{kt} e @code{nm}.

@deffn {Fun@value{cedilha}@~{a}o} contortion (@var{tr})

Calcula os coeficientes de contors@~{a}o de categoria (2,1) a partir do tensor de tors@~{a}o @var{tr}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} nonmetricity (@var{nm})

Calcula o coeficiente de n@~{a}o metricidade de categoria (2,1) a partir do vetor de
n@~{a}o metricidade @var{nm}.

@end deffn



@subsection Recursos diversos

@deffn {Fun@value{cedilha}@~{a}o} ctransform (@var{M})
Uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}
que ir@'{a} executar uma transforma@value{cedilha}@~{a}o de coordenadas
sobre uma matriz sim@'{e}trica quadrada arbitr@'{a}ria @var{M}. O usu@'{a}rio deve informar as
fun@value{cedilha}@~{a}oes que definem a transforma@value{cedilha}@~{a}o.  (Formalmente chamada @code{transform}.)

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} findde (@var{A}, @var{n})

Retorna uma lista de equa@value{cedilha}@~{o}es diferenciais @'{u}nicas (express@~{o}es)
correspondendo aos elementos do array quadrado @var{n} dimensional
@var{A}. Atualmente, @var{n} pode ser 2 ou 3. @code{deindex} @'{e} uma lista global
contendo os @'{i}ndices de @var{A} correspondendo a essas @'{u}nicas
equa@value{cedilha}@~{o}es diferenciais. Para o tensor de Einstein (@code{ein}), que
@'{e} um array dimensional, se calculado para a m@'{e}trica no exemplo
abaixo, @code{findde} fornece as seguintes equa@value{cedilha}@~{o}es diferenciais independentes:


@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]

@end example


@end deffn
@deffn {Fun@value{cedilha}@~{a}o} cograd ()
Calcula o gradiente covariante de uma fun@value{cedilha}@~{a}o escalar permitindo ao
usu@'{a}rio escolher o nome do vetor correspondente como o exemplo sob
@code{contragrad} ilustra.
@end deffn
@deffn {Fun@value{cedilha}@~{a}o} contragrad ()

Calcula o gradiente contravariante de uma fun@value{cedilha}@~{a}o escalar permitindo
@c "vector^F2name^F*" LOOKS LIKE IT NEEDS TO BE FIXED UP, NOT SURE HOW THOUGH
ao usu@'{a}rio escolher o nome do vetor correspondente como o exemplo
abaixo como ilustra a m@'{e}trica de Schwarzschild:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

@end example

@end deffn
@deffn {Fun@value{cedilha}@~{a}o} dscalar ()
Calcula o tensor d'Alembertiano da fun@value{cedilha}@~{a}o escalar assim que
as depend@^{e}ncias tiverem sido declaradas sobre a fun@value{cedilha}@~{a}o. Po exemplo:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
@end example

@end deffn
@deffn {Fun@value{cedilha}@~{a}o} checkdiv ()

Calcula a diverg@^{e}ncia covariante do tensor de segunda categoria misto
(cujo primeiro @'{i}ndice deve ser covariante) imprimindo as
correspondentes n componentes do campo do vetor (a diverg@^{e}ncia) onde
n = @code{dim}. Se o argumento para a fun@value{cedilha}@~{a}o for @code{g} ent@~{a}o a
diverg@^{e}ncia do tensor de Einstein ser@'{a} formada e pode ser zero.
Adicionalmente, a diverg@^{e}ncia (vetor) @'{e} dada no array chamado @code{div}.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} cgeodesic (@var{dis})
Uma fun@value{cedilha}@~{a}o no pacote @code{ctensor}.
@code{cgeodesic} calcula as equa@value{cedilha}@~{o}es geod@'{e}sicas de
movimento para uma dada m@'{e}trica.  Elas s@~{a}o armazenadas no array @code{geod[i]}.  Se
o argumento @var{dis} for @code{true} ent@~{a}o essas equa@value{cedilha}@~{o}es s@~{a}o mostradas.

@end deffn


@deffn {Fun@value{cedilha}@~{a}o} bdvac (@var{f})

Gera as componentes covariantes das equa@value{cedilha}@~{o}es de campo de v@'{a}cuo da
teoria de gravita@value{cedilha}@~{a}o de Brans-Dicke. O campo escalar @'{e} especificado
atrav@'{e}s do argumento @var{f}, que pode ser um nome de fun@value{cedilha}@~{a}o (com ap@'{o}strofo)
com depend@^{e}ncias funcionais, e.g., @code{'p(x)}.

As componentes de segunda categoria do tensor campo covariante s@~{a}o as componentes de segunda categoria
representadas pelo array @code{bd}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} invariant1 ()

Gera o tensor misto de Euler-Lagrange (equa@value{cedilha}@~{o}es de campo) para a
densidade invariante de R^2. As equa@value{cedilha}@~{o}es de campo s@~{a}o componentes de um
array chamado @code{inv1}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} invariant2 ()

*** NOT YET IMPLEMENTED ***

Gera o tensor misto de Euler-Lagrange (equa@value{cedilha}@~{o}es de campo) para a
densidade invariante de @code{ric[i,j]*uriem[i,j]}. As equa@value{cedilha}@~{o}es de campo s@~{a}o as
componentes de um array chamado @code{inv2}.


@end deffn
@deffn {Fun@value{cedilha}@~{a}o} bimetric ()

*** NOT YET IMPLEMENTED ***

Gera as euaua@value{cedilha}@~{o}es de campo da teoria bim@'{e}trica de Rosen. As equa@value{cedilha}@~{o}es
de campo s@~{a}o as componentes de um array chamado @code{rosen}.

@end deffn

@subsection Fun@value{cedilha}@~{o}es utilit@'{a}rias

@deffn {Fun@value{cedilha}@~{a}o} diagmatrixp (@var{M})

Retorna @code{true} se @var{M} for uma matriz diagonal ou um array (2D).

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} symmetricp (@var{M})

Retorna @code{true} se @var{M} for uma matriz sim@'{e}trica ou um array (2D).

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ntermst (@var{f})
Fornece ao usu@'{a}rio um r@'{a}pido quadro do "tamanho" do tensor duplamente
subscrito (array) @var{f}.  Imprime uma lista de dois elementos onde o segundo
elemento corresponde a N-TERMOS de componentes especificadas atrav@'{e}s dos primeiros
elementos.  Nesse caminho, @'{e} poss@'{i}vel rapidamente encontrar as express@~{o}es
n@~{a}o nulas e tentar simplifica@value{cedilha}@~{a}o.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} cdisplay (@var{ten})
Mostra todos os elementos do tensor @var{ten}, como representados por
um array multidimensional. Tensores de categoria 0 e 1, assim como outros tipos de
vari@'{a}veis, s@~{a}o mostrados com @code{ldisplay}. Tensores de categoria 2 s@~{a}o
mostrados como matrizes bidimensionais, enquanto tensores de alta categoria s@~{a}o mostrados
como uma lista de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
m@'{e}trica de Schwarzschild pode ser visto como:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

@end example
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} deleten (@var{L}, @var{n})
Retorna uma nova lista consistindo de @var{L} com o @var{n}'@'{e}simo elemento
apagado.
@end deffn

@subsection Vari@'{a}veis usadas por @code{ctensor}


@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dim
Valor padr@~{a}o: 4

Uma op@value{cedilha}@~{a}o no pacote @code{ctensor}.
@code{dim} @'{e} a dimens@~{a}o de multiplica@value{cedilha}@~{a}o com o
padr@~{a}o 4. O comando @code{dim: n} ir@'{a} escolher a dimens@~{a}o para qualquer outro
valor @code{n}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} diagmetric
Valor padr@~{a}o: @code{false}

Uma op@value{cedilha}@~{a}o no pacote @code{ctensor}.
Se @code{diagmetric} for @code{true} rotinas especiais calculam
todos os objetos geom@'{e}tricos (que possuem o tensor m@'{e}trico explicitamente)
levando em considera@value{cedilha}@~{a}o a diagonalidade da m@'{e}trica. Tempo de
execu@value{cedilha}@`ao reduzido ir@'{a}, com certeza, resultar dessa escolha. Nota: essa op@value{cedilha}@~{a}o @'{e} escolhida
automaticamente por @code{csetup} se uma m@'{e}trica diagonal for especificada.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ctrgsimp

Faz com que simplifica@value{cedilha}@~{o}es trigonom@'{e}tricas sejam usadas quando tensores forem calculados. Atualmente,
@code{ctrgsimp} afeta somente c@'{a}lculos envolvendo uma moldura m@'{o}vel.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} cframe_flag

Faz com que c@'{a}lculos sejam executados relativamente a uma moldura m@'{o}vel em oposi@value{cedilha}@~{a}o a
uma m@'{e}trica holon@^{o}mica. A moldura @'{e} definida atrav@'{e}s do array da moldura inversa @code{fri}
e da m@'{e}trica da moldura @code{lfg}. Para c@'{a}lculos usando uma moldura Cartesiana,
@code{lfg} pode ser a matriz unit@'{a}ria de dimens@~{a}o apropriada; para
c@'{a}lculos em uma moldura de Lorentz, @code{lfg} pode ter a assinatura
apropriada.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ctorsion_flag

Faz com que o tensor de contors@~{a}o seja inclu@'{i}do no c@'{a}lculo dos
coeficientes de conec@value{cedilha}@~{a}o. O tensor de contors@~{a}o por si mesmo @'{e} calculado atrav@'{e}s de
@code{contortion} a partir do tensor @code{tr} fornecido pelo usu@'{a}rio.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} cnonmet_flag

Faz com que os coeficientes de n@~{a}o metricidade sejam inclu@'{i}dos no c@'{a}lculo dos
coeficientes de conec@value{cedilha}@~{a}o. Os coeficientes de n@~{a}o metricidade s@~{a}o calculados
a partir do vetor de n@~{a}o metricidade @code{nm} fornecido pelo usu@'{a}rio atrav@'{e}s da fun@value{cedilha}@~{a}o
@code{nonmetricity}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ctayswitch

Se escolhida para @code{true}, faz com que alguns c@'{a}lculos de @code{ctensor} sejam realizados usando
expans@~{o}es das s@'{e}ries de Taylor. atualmente, @code{christof}, @code{ricci},
@code{uricci}, @code{einstein}, e @code{weyl} levam em conta essa
escolha.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ctayvar

Vari@'{a}vel usada pela expans@~{a}o de s@'{e}ries de Taylor se @code{ctayswitch} @'{e} escolhida para
@code{true}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ctaypov

Maximo expoente usado em expans@~{o}es de s@'{e}ries de Taylor quando @code{ctayswitch} for
escolhida para @code{true}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ctaypt

Ponto em torno do qual expans@~{o}es de s@'{e}ries de Taylor sao realizadas quando
@code{ctayswitch} for escolhida para @code{true}.

@end defvr

@defvr {Vari@'{a}vel de sistema} gdet

O determinante do tensor m@'{e}trico @code{lg}. Calculado atrav@'{e}s de @code{cmetric} quando
@code{cframe_flag} for escolhido para @code{false}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratchristof

Faz com que simplifica@value{cedilha}@~{o}es racionais sejam aplicadas atrav@'{e}s de @code{christof}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} rateinstein
Valor padr@~{a}o: @code{true}

Se @code{true} simplifica@value{cedilha}@~{a}o racional ser@'{a}
executada sobre as componentes n@~{a}o nulas de tensores de Einstein; se
@code{ratfac} for @code{true} ent@~{a}o as componentes ir@~{a}o tamb@'{e}m ser fatoradas.

@end defvr
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratriemann
Valor padr@~{a}o: @code{true}

Um dos comutadores que controlam
simplifica@value{cedilha}@~{o}es dos tensores de Riemann; se @code{true}, ent@~{a}o simplifica@value{cedilha}@~{o}es
racionais ir@~{a}o ser conclu@'{i}das; se @code{ratfac} for @code{true} ent@~{a}o cada uma das
componentes ir@'{a} tamb@'{e}m ser fatorada.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratweyl
Valor padr@~{a}o: @code{true}

Se @code{true}, esse comutador faz com que a fun@value{cedilha}@~{a}o de @code{weyl}
aplique simplifica@value{cedilha}@~{o}es racionais aos valores do tensor de Weyl. Se
@code{ratfac} for @code{true}, ent@~{a}o as componentes ir@~{a}o tamb@'{e}m ser fatoradas.
@end defvr

@defvr {Vari@'{a}vel} lfg
A moldura m@'{e}trica covariante. Por padr@~{a}o, @'{e} inicializada para a moldura tetradimensional de Lorentz com assinatura (+,+,+,-). Usada quando @code{cframe_flag} for @code{true}.
@end defvr

@defvr {Vari@'{a}vel} ufg
A m@'{e}trica da moldura inversa. Calculada de @code{lfg} quando @code{cmetric} for chamada enquanto @code{cframe_flag} for escolhida para @code{true}.
@end defvr

@defvr {Vari@'{a}vel} riem
O tensor de categoria (3,1) de Riemann. Calculado quando a fun@value{cedilha}@~{a}o @code{riemann} @'{e} invocada. Para informa@value{cedilha}@~{a}o sobre ordena@value{cedilha}@~{a}o de @'{i}ndices, veja a descri@value{cedilha}@~{a}o de @code{riemann}.

Se @code{cframe_flag} for @code{true}, @code{riem} @'{e} calculado a partir do tensor covariante de Riemann @code{lriem}.

@end defvr

@defvr {Vari@'{a}vel} lriem

O tensor covariante de Riemann. Calculado atrav@'{e}s de @code{lriemann}.

@end defvr

@defvr {Vari@'{a}vel} uriem

O tensor contravariante de Riemann. Calculado atrav@'{e}s de @code{uriemann}.

@end defvr

@defvr {Vari@'{a}vel} ric

O tensor misto de Ricci. Calculado atrav@'{e}s de @code{ricci}.

@end defvr

@defvr {Vari@'{a}vel} uric

O tensor contravariante de Ricci. Calculado atrav@'{e}s de @code{uricci}.

@end defvr

@defvr {Vari@'{a}vel} lg

O tensor m@'{e}trico. Esse tensor deve ser especificado (como uma @code{dim} atrav@'{e}s da matriz @code{dim})
antes que outro c@'{a}lculo possa ser executado.

@end defvr

@defvr {Vari@'{a}vel} ug

O inverso do tensor m@'{e}trico. Calculado atrav@'{e}s de @code{cmetric}.

@end defvr

@defvr {Vari@'{a}vel} weyl

O tensor de Weyl. Calculado atrav@'{e}s de @code{weyl}.

@end defvr

@defvr {Vari@'{a}vel} fb

Coeficientes delimitadores da moldura, como calculado atrav@'{e}s de @code{frame_bracket}.

@end defvr

@defvr {Vari@'{a}vel} kinvariant

O invariante de Kretchmann. Calculado atrav@'{e}s de @code{rinvariant}.

@end defvr

@defvr {Vari@'{a}vel} np

Um tetrad nulo de Newman-Penrose. Calculado atrav@'{e}s de @code{nptetrad}.

@end defvr

@defvr {Vari@'{a}vel} npi

O @'{i}ndice ascendente do tetrad nulo de Newman-Penrose. Calculado atrav@'{e}s de @code{nptetrad}.
Definido como @code{ug.np}. O produto @code{np.transpose(npi)} @'{e} constante:

@example
(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
@end example

@end defvr

@defvr {Vari@'{a}vel} tr

Tensor de categoria 3 fornecido pelo usu@'{a}rio representando tors@~{a}o. Usado por @code{contortion}.
@end defvr

@defvr {Vari@'{a}vel} kt

O tensor de contors@~{a}o, calculado a partir de @code{tr} atrav@'{e}s de @code{contortion}.
@end defvr

@defvr {Vari@'{a}vel} nm

Vetor de n@~{a}o metrcidade fornecido pelo usu@'{a}rio. Usado por @code{nonmetricity}.
@end defvr

@defvr {Vari@'{a}vel} nmc

Os coeficientes de n@~{a}o metricidade, calculados a partir de @code{nm} por @code{nonmetricity}.

@end defvr

@defvr {Vari@'{a}vel de sistema} tensorkill

Vari@'{a}vel indicando se o pacote tensor foi inicializado. Escolhida e usada por
@code{csetup}, retornada ao seu valor original atrav@'{e}s de @code{init_ctensor}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ct_coords
Valor padr@~{a}o: @code{[]}

Uma op@value{cedilha}@~{a}o no pacote @code{ctensor}.
@code{ct_coords} cont@'{e}m uma lista de coordenadas.
Enquanto normalmente definida quando a fun@value{cedilha}@~{a}o @code{csetup} for chamada,
se pode redefinir as coordenadas com a atribui@value{cedilha}@~{a}o
@code{ct_coords: [j1, j2, ..., jn]} onde os j's s@~{a}o os novos nomes de coordenadas.
Veja tamb@'{e}m @code{csetup}.

@end defvr

@subsection Nomes reservados

Os seguintes nomes s@~{a}o usados internamente pelo pacote @code{ctensor} e
n@~{a}o devem ser redefinidos:

@example
  Name         Description
  ---------------------------------------
  _lg()        Avalia para @code{lfg} se a moldura m@'{e}trica for usada,
                    para @code{lg} de outra forma
  _ug()        Avalia para @code{ufg} se a moldura m@'{e}trica for usada,
                    para @code{ug} de outra forma
  cleanup()    Remove @'{i}tens da lista @code{deindex}
  contract4()  Usado por psi()
  filemet()    Usado por csetup() quando lendo a m@'{e}trica de um arquivo
  findde1()    Usado por findde()
  findde2()    Usado por findde()
  findde3()    Usado por findde()
  kdelt()      Delta de Kronecker (n@~{a}o generalizado)
  newmet()     Usado por csetup() para escolher uma m@'{e}trica
                    interativamente
  setflags()   Usado por init_ctensor()
  readvalue()
  resimp()
  sermet()     Usado por csetup() para informar uma m@'{e}tricacom s@'{e}rie
                    de Taylor
  txyzsum()
  tmetric()    Moldura m@'{e}trica, usado por cmetric() quando
                    cframe_flag:true
  triemann()   Tensor de Riemann em base de moldura, usado quando
                    cframe_flag:true
  tricci()     Tensor de Ricci em base de moldura, usada quando
                    cframe_flag:true
  trrc()       Coeficientes de rota@value{cedilha}@~{a}o de Ricci, usado por
                    christof()
  yesp()
@end example


@subsection Modifica@value{cedilha}@~{o}es

Em Novembro de 2004, o pacote @code{ctensor} foi extensivamente reescrito.
Muitas fun@value{cedilha}@~{o}es e vari@'{a}veis foram renomeadas com o objetivo de tornar o
pacote com a vers@~{a}o comercial do Macsyma.


@example
  Novo Nome    Nome Antigo     Descri@value{cedilha}@~{a}o
  --------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Expans@~{a}o da s@'{e}rie de Taylor de uma
  -----------------------------express@~{a}o
  lgeod[]      EM              Equa@value{cedilha}@~{o}es geod@'{e}sicas
  ein[]        G[]             Tensor misto de Einstein
  ric[]        LR[]            Tensor misto de Ricci
  ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
  ctaypov      MINP            Maximo expoente em expans@~{o}es de s@'{e}ries de
  -----------------------------Taylor
  cgeodesic()  MOTION          Calcula as equa@value{cedilha}@~{o}es geod@'{e}sicas
  ct_coords    OMEGA           Coordenadas m@'{e}tricas
  ctayvar      PARAM           Vari@'{a}vel de expans@~{a}o de s@'{e}ries de
  -----------------------------Taylor
  lriem[]      R[]             Tensor covariante de Riemann
  uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
  -----------------------------Riemann
  ratriemann   RATRIEMAN       Simplifica@value{cedilha}@~{a}o racional do tensor de
  -----------------------------Riemann
  uric[]       RICCI[]         Tensor de Ricci contravariante
  uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
  cmetric()    SETMETRIC()     Escolhe a m@'{e}trica
  ctaypt       TAYPT           Ponto para expans@~{o}es de s@'{e}ries de Taylor
  ctayswitch   TAYSWITCH       Escolhe o comutador de s@'{e}ries de Taylor
  csetup()     TSETUP()        Inicia sess@~{a}o interativa de configura@value{cedilha}@~{a}o
  ctransform() TTRANSFORM()    Transforma@value{cedilha}@~{a}o de coordenadas interativa
  uriem[]      UR[]            Tensor contravariante de Riemann 
  weyl[]       W[]             Tensor (3,1) de Weyl

@end example

