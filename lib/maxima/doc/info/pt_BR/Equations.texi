@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Equations.texi/1.25/Sat Jun  2 00:12:41 2007/-ko/
@c end concepts Equations
@menu
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Equa@value{cedilha}@~{o}es::   
@end menu

@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Equa@value{cedilha}@~{o}es,  , Equa@value{cedilha}@~{o}es, Equa@value{cedilha}@~{o}es
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Equa@value{cedilha}@~{o}es

@c NEED A DESCRIPTION OF %rnum AS WELL
@defvr {Vari@'{a}vel} %rnum_list
Valor padr@~{a}o: @code{[]}

@code{%rnum_list} @'{e} a lista de vari@'{a}veis introduzidas em solu@value{cedilha}@~{o}es
por @code{algsys}.
@code{%r} vari@'{a}veis S@~{a}o adicionadas a @code{%rnum_list} na ordem em que
forem criadas.
Isso @'{e} conveniente para fazer substitui@value{cedilha}@~{o}es dentro da
solu@value{cedilha}@~{a}o mais tarde.
@c WHAT DOES THIS STATEMENT MEAN ??
@'{E} recomendado usar essa lista em lugar de
fazer @code{concat ('%r, j)}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel} algexact
Valor padr@~{a}o: @code{false}

@code{algexact} afeta o comportamento de @code{algsys} como segue:

Se @code{algexact} @'{e} @code{true},
@code{algsys} sempre chama @code{solve} e ent@~{a}o usa @code{realroots}
sobre falhas de @code{solve}.

Se @code{algexact} @'{e} @code{false}, @code{solve} @'{e} chamada somente se
o eliminante n@~{a}o for de uma vari@'{a}vel, ou se for uma quadr@'{a}tica ou uma
biquadrada.

Dessa forma @code{algexact: true} n@~{a}o garante somente solu@value{cedilha}@~{o}es
exatas, apenas que @code{algsys} tentar@'{a} primeiro pegar
solu@value{cedilha}@~{o}es exatas, e somente retorna aproxima@value{cedilha}@~{o}es quando tudo mais falha.

@c ABOVE DESCRIPTION NOT TOO CLEAR -- MAYBE EXAMPLES WILL HELP
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} algsys ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
@deffnx {Fun@value{cedilha}@~{a}o} algsys ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Resolve polin@^{o}mios simult@^{a}neos @var{expr_1}, ..., @var{expr_m}
ou equa@value{cedilha}@~{o}es polin@^{o}miais @var{eqn_1}, ..., @var{eqn_m}
para as vari@'{a}veis @var{x_1}, ..., @var{x_n}.
Uma express@~{a}o @var{expr} @'{e} equivalente a uma equa@value{cedilha}@~{a}o @code{@var{expr} = 0}.
Pode existir mais equa@value{cedilha}@~{o}es que vari@'{a}veis ou vice-versa.

@code{algsys} retorna uma lista de solu@value{cedilha}@~{o}es,
com cada solu@value{cedilha}@~{a}o dada com uma lista de valores de estado das equa@value{cedilha}@~{o}es
das vari@'{a}veis @var{x_1}, ..., @var{x_n} que satisfazem o sistema de equa@value{cedilha}@~{o}es.
Se @code{algsys} n@~{a}o pode achar uma solu@value{cedilha}@~{a}o, uma lista vazia @code{[]} @'{e} retornada.

Os s@'{i}mbolos @code{%r1}, @code{%r2}, ...,
s@~{a}o introduzidos tantos quantos forem necess@'{a}rios para representar par@^{a}metros arbitr@'{a}rios na solu@value{cedilha}@~{a}o;
essas vari@'{a}veis s@~{a}o tamb@'{e}m anexadas @`a lista @code{%rnum_list}.

O m@'{e}todo usado @'{e} o seguinte:

(1) Primeiro as equa@value{cedilha}@~{o}es s@~{a}o fatoradas e quebradas em subsistemas.

(2) Para cada subsistema @var{S_i}, uma equa@value{cedilha}@~{a}o @var{E} e uma vari@'{a}vel @var{x} s@~{a}o
selecionados.
A vari@'{a}vel @'{e} escolhida para ter o menor grau n@~{a}o zero.
Ent@~{a}o a resultante de @var{E} e @var{E_j} em rela@value{cedilha}@~{a}o a @var{x} @'{e} calculada para cada um das
equa@value{cedilha}@~{o}es restantes @var{E_j} nos subsistemas @var{S_i}.
Isso retorna um novo subsistema @var{S_i'} em umas poucas vari@'{a}veis, como @var{x} tenha sido eliminada.
O processo agora retorna ao passo (1).

(3) Eventualmente, um subsistema consistindo de uma equa@value{cedilha}@~{a}o simples @'{e}
obtido.  Se a equa@value{cedilha}@~{a}o @'{e} de v@'{a}rias vari@'{a}veis e aproxima@value{cedilha}@~{o}es na
forma de n@'{u}meros em ponto flutuante n@~{a} tenham sido introduzidas, ent@~{a}o @code{solve} @'{e}
chamada para achar uma solu@value{cedilha}@~{a}o exata.

Em alguns casos, @code{solve} n@~{a}o est@'{a} habilitada a achar uma solu@value{cedilha}@~{a}o,
ou se isso @'{e} feito a solu@value{cedilha}@~{a}o pode ser uma express@~{a}o express@~{a}o muito larga.

@c REMAINDER OF (3) IS PRETTY COMPLEX.  HOW CAN IT BE CLARIFIED ??
Se a equa@value{cedilha}@~{a}o @'{e} de uma @'{u}nica vari@'{a}vel e @'{e} ou linear, ou quadr@'{a}tica, ou
biquadrada, ent@~{a}o novamente @code{solve} @'{e} chamada se aproxima@value{cedilha}@~{o}es n@~{a}o tiverem
sido introduzidas.  Se aproxima@value{cedilha}@~{o}es tiverem sido introduzidas ou a
equa@value{cedilha}@~{a}o n@~{a}o @'{e} de uma @'{u}nica vari@'{a}vel e nem t@~{a}o pouco linear, quadratica, ou
biquadrada, ent@~{a}o o comutador @code{realonly} @'{e} @code{true}, A fun@value{cedilha}@~{a}o
@code{realroots} @'{e} chamada para achar o valor real das solu@value{cedilha}@~{o}es.  Se
@code{realonly} @'{e} @code{false}, ent@~{a}o @code{allroots} @'{e} chamada a qual procura por
solu@value{cedilha}@~{o}es reais e complexas.

Se @code{algsys} produz uma solu@value{cedilha}@~{a}o que tem
poucos digitos significativos que o requerido, o usu@'{a}rio pode escolher o valor
de @code{algepsilon} para um valor maior.

Se @code{algexact} @'{e} escolhido para
@code{true}, @code{solve} ser@'{a} sempre chamada.
@c algepsilon IS IN Floating.texi -- MAY WANT TO BRING IT INTO THIS FILE

(4) Finalmente, as solu@value{cedilha}@~{o}es obtidas no passo (3) s@~{a}o substitu@'{i}das dentro
dos n@'{i}veis pr@'{e}vios e o processo de solu@value{cedilha}@~{a}o retorna para (1).
@c "PREVIOUS LEVELS" -- WHAT ARE THOSE ??

Quando @code{algsys} encontrar uma equa@value{cedilha}@~{a}o de v@'{a}rias vari@'{a}veis que cont@'{e}m
aproxima@value{cedilha}@~{o}es em ponto flutuante (usualmente devido a suas falhas em achar
solu@value{cedilha}@~{o}es exatas por um est@'{a}gio mais f@'{a}cil), ent@~{a}o n@~{a}o tentar@'{a}
aplicar m@'{e}todos exatos para tais equa@value{cedilha}@~{o}es e em lugar disso imprime a mensagem:
"@code{algsys} cannot solve - system too complicated."

Intera@value{cedilha}@~{o}es com @code{radcan} podem produzir express@~{o}es largas ou
complicadas.
Naquele caso, pode ser poss@'{i}vel isolar partes do resultado
com @code{pickapart} ou @code{reveal}.

Ocasionalmente, @code{radcan} pode introduzir uma unidade imagin@'{a}ria
@code{%i} dentro de uma solu@value{cedilha}@~{a}o que @'{e} atualmente avaliada como real.

Exemplos:

@c ===beg===
@c e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
+@c e2: a2 - a1;
+@c e3: a1*(-y - x^2 + 1);
@c e4: a2*(y - (x - 1)^2);
@c algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
@c e1: x^2 - y^2;
@c e2: -1 - y + 2*y^2 - x + x^2;
@c algsys ([e1, e2], [x, y]);
@c ===end===
@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} allroots (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} allroots (@var{eqn})
Calcula aproxima@value{cedilha}@~{o}es num@'{e}ricas de ra@'{i}zes reais e complexas do
polin@^{o}mio @var{expr} ou equa@value{cedilha}@~{a}o polin@^{o}mial @var{eqn} de uma vari@'{a}vel.

@c polyfactor IS NOT OTHERWISE DOCUMENTED
O sinalizador @code{polyfactor} quando @code{true} faz com que
@code{allroots} fatore o polin@^{o}mio sobre os n@'{u}meros reais se o
polin@^{o}mio for real, ou sobre os n@'{u}meros complexos, se o polin@^{o}mio for
complexo.

@code{allroots} pode retornar resultados imprecisos no caso de multiplas ra@'{i}zes.
Se o polin@^{o}mio for real, @code{allroots (%i*@var{p})}) pode retornar
aproxima@value{cedilha}@~{o}es mais precisas que @code{allroots (@var{p})},
como @code{allroots} invoca um algor@'{i}tmo diferente naquele caso.

@code{allroots} rejeita n@~{a}o-polin@^{o}mios.  Isso requer que o numerador
ap@'{o}s a classifica@value{cedilha}@~{a}o (@code{rat}'ing) poder@'{a} ser um polin@^{o}mio, e isso requer que o
denominador seja quando muito um n@'{u}mero complexo.  Com um resultado disso @code{allroots}
ir@'{a} sempre retornar uma express@~{a}o equivalente (mas fatorada), se
@code{polyfactor} for @code{true}.

Para polin@^{o}mios complexos um algor@'{i}tmo por Jenkins e Traub @'{e}
usado (Algorithm 419, @i{Comm.  ACM}, vol.  15, (1972), p.  97).
Para polin@^{o}mios reais o algor@'{i}tmo usado @'{e} devido a Jenkins (Algorithm 493, @i{ACM TOMS},
vol.  1, (1975), p.178).

Exemplos:
@c EXAMPLES GENERATED BY THESE INPUTS:
@c eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@c soln: allroots (eqn);
@c for e in soln
@c         do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
@c polyfactor: true$
@c allroots (eqn);

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example

@end deffn

@defvr {Vari@'{a}vel} backsubst
Valor padr@~{a}o: @code{true}

@c WHAT IS THE CONTEXT HERE ?? (TO WHICH OTHER FUNCTION DOES THIS APPLY ??)
Quando @code{backsubst} @'{e} @code{false}, evita substitui@value{cedilha}@~{o}es
em express@~{o}es anteriores ap@'{o}s as equa@value{cedilha}@~{o}es terem sido triangularizadas.  Isso pode
ser de grande ajuda em problemas muito grandes onde substitui@value{cedilha}@~{a}o em express@~{o}es anteriores pode vir a causar
a gera@value{cedilha}@~{a}o de express@~{o}es extremamente largas.

@end defvr

@defvr {Vari@'{a}vel} breakup
Valor padr@~{a}o: @code{true}

Quando @code{breakup} @'{e} @code{true}, @code{solve} expressa solu@value{cedilha}@~{o}es
de equa@value{cedilha}@~{o}es c@'{u}bicas e qu@'{a}rticas em termos de subexpress@~{o}es comuns,
que s@~{a}o atribu@'{i}das a r@'{o}tulos de express@~{o}es intermedi@'{a}rias (@code{%t1}, @code{%t2}, etc.).
De outra forma, subexpress@~{o}es comuns n@~{a}o s@~{a}o identificadas.

@code{breakup: true} tem efeito somente quando @code{programmode} @'{e} @code{false}.

Exemplos:

@example
(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
@end example

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} dimension (@var{eqn})
@deffnx {Fun@value{cedilha}@~{a}o} dimension (@var{eqn_1}, ..., @var{eqn_n})
@code{dimen} @'{e} um pacote de an@'{a}lise dimensional.
@code{load ("dimen")} chama esse pacote.
@code{demo ("dimen")} mostra uma cura demostra@value{cedilha}@~{a}o.
@c I GUESS THIS SHOULD BE EXPANDED TO COVER EACH FUNCTION IN THE PACKAGE

@end deffn

@defvr {Vari@'{a}vel} dispflag
Valor padr@~{a}o: @code{true}

@c WHAT DOES THIS MEAN ??
Se escolhida para @code{false} dentro de um @code{block} inibir@'{a}
a visualiza@value{cedilha}@~{a}o da sa@'{i}da gerada pelas fun@value{cedilha}@~{o}es solve chamadas de
dentro de @code{block}.  Terminando @code{block} com um sinal de dolar, $, escolhe
@code{dispflag} para @code{false}.

@end defvr

@c THIS COULD BENEFIT FROM REPHRASING
@deffn {Fun@value{cedilha}@~{a}o} funcsolve (@var{eqn}, @var{g}(@var{t}))
Retorna @code{[@var{g}(@var{t}) = ...]}  ou @code{[]}, dependendo de existir
ou n@~{a}o uma fun@value{cedilha}@~{a}o racional @code{@var{g}(@var{t})} satisfazendo @var{eqn},
que deve ser de primeira ordem, polin@^{o}mio linear em (para esse caso) 
@code{@var{g}(@var{t})} e @code{@var{g}(@var{t}+1)}

@example
(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Equa@value{cedilha}@~{o}es dependentes eliminadas:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
@end example

Aten@value{cedilha}@~{a}o: essa @'{e} uma implementa@value{cedilha}@~{a}o muito rudimentar -- muitas verifica@value{cedilha}@~{o}es de seguran@value{cedilha}a
e obviamente generaliza@value{cedilha}@~{o}es est@~{a}o aus@^{e}ntes.

@end deffn

@defvr {Vari@'{a}vel} globalsolve
Valor padr@~{a}o: @code{false}

When @code{globalsolve} for @code{true},
vari@'{a}veis para as quais as equa@value{cedilha}@~{o}es s@~{a}o resolvidas s@~{a}o atribuidas aos valores da solu@value{cedilha}@~{a}o encontrados por @code{linsolve},
e por @code{solve} quando resolvendo duas ou mais equa@value{cedilha}@~{o}es lineares.

Quando @code{globalsolve} for @code{false},
solu@value{cedilha}@~{o}es encontradas por @code{linsolve} e por @code{solve} quando resolvendo duas ou mais equa@value{cedilha}@~{o}es lineares
s@~{a}o espressas como equa@value{cedilha}@~{o}es,
e as vari@'{a}veis para as quais a equa@value{cedilha}@~{a}o foi resolvida n@~{a}o s@~{a}o atribuidas.

Quando resolvendo qualquer coisa outra que n@~{a}o duas equa@value{cedilha}@~{o}es lineares ou mais,
@code{solve} ignora @code{globalsolve}.
Outras fun@value{cedilha}@~{o}es que resolvem equa@value{cedilha}@~{o}es (e.g., @code{algsys}) sempre ignoram @code{globalsolve}.
    
Exemplos:

@example
(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
@end example

@end defvr

@c THIS DESCRIPTION NEEDS WORK AND EXAMPLES
@c MERGE IN TEXT FROM share/integequations/inteqn.usg
@c AND EXAMPLES FROM .../intexs.mac
@deffn {Fun@value{cedilha}@~{a}o} ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})
@code{inteqn} @'{e} um pacote para resolver equa@value{cedilha}@~{o}es com integrais.
@code{load ("inteqn")} carrega esse pacote.

@var{ie} @'{e} a equa@value{cedilha}@~{a}o integral; @var{unk} @'{e} a fun@value{cedilha}@~{a}o desconhecida; @var{tech} @'{e} a
t@'{e}cnica a ser tentada nesses dados acima (@var{tech} = @code{first} significa: tente
a primeira t@'{e}cnica que achar uma solu@value{cedilha}@~{a}o; @var{tech} = @code{all} significa: tente todas a
t@'{e}cnicas aplic@'{a}veis); @var{n} @'{e} o n@'{u}mero m@'{a}ximo de termos a serem usados de
@code{taylor}, @code{neumann}, @code{firstkindseries}, ou @code{fredseries} (isso @'{e} tamb@'{e}m o
n@'{u}mero m@'{a}ximo de ciclos de recurss@~{a}o para o m@'{e}todo de diferencia@value{cedilha}@~{a}o); @var{guess} @'{e}
o inicial suposto para @code{neumann} ou @code{firstkindseries}.

Valores padr@~{a}o do segundo at@'{e} o quinto par@^{a}metro s@~{a}o:

@var{unk}: @code{@var{p}(@var{x})}, onde @var{p} @'{e} a primeira fun@value{cedilha}@~{a}o encontrada em um integrando
que @'{e} desconhecida para Maxima e @var{x} @'{e} a vari@'{a}vel que ocorre como um
argumento para a primeira ocorr@^{e}ncia de @var{p} achada fora de uma integral no
caso de equa@value{cedilha}@~{o}es @code{secondkind} , ou @'{e} somente outra vari@'{a}vel
ao lado da vari@'{a}vel de integra@value{cedilha}@~{a}o em equa@value{cedilha}@~{o}es @code{firstkind}.  Se uma
tentativa de procurar por @var{x} falha, o usu@'{a}rio ser@'{a} perguntado para suprir a
vari@'{a}vel independente.

tech: @code{first}

n: 1

guess: @code{none} o que far@'{a} com que @code{neumann} e @code{firstkindseries} use
@code{@var{f}(@var{x})} como uma suposi@value{cedilha}@~{a}o inicial.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ieqnprint
Valor padr@~{a}o: @code{true}

@code{ieqnprint} governa o comportamento do resultado
retornado pelo comando @code{ieqn}.  Quando @code{ieqnprint} @'{e}
@code{false}, as listas retornadas pela fun@value{cedilha}@~{a}o @code{ieqn} s@~{a}o da forma

   [@var{solu@value{cedilha}@~{a}o}, @var{tecnica usada}, @var{nterms}, @var{sinalizador}]

onde @var{sinalizador} @'{e} retirado se a solu@value{cedilha}@~{a}o for exata.

De outra forma, isso @'{e} a
palavra @code{approximate} ou @code{incomplete} correspondendo @`a forma inexata ou
forma aberta de solu@value{cedilha}@~{a}o, respectivamente.  Se um m@'{e}todo de s@'{e}rie foi usado,
@var{nterms} fornece o n@'{u}mero de termos usados (que poder@'{a} ser menor que os n
dados para @code{ieqn} se ocorrer um erro evita a gera@value{cedilha}@~{a}o de termos adicionais).

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} lhs (@var{expr})
Retorna o lado esquerdo (isto @'{e}, o primeiro argumento)
da express@~{a}o @var{expr},
quando o operador de @var{expr}
for um dos operadores relacionais @code{< <= = # equal notequal >= >},
@c MENTION -> (MARROW) IN THIS LIST IF/WHEN THE PARSER RECOGNIZES IT
um dos operadores de atribui@value{cedilha}@~{a}o @code{:= ::= : ::},
ou um operadro infixo definido pelo usu@'{a}rio, como declarado por meio de @code{infix}.

Quando @var{expr} for um @'{a}tomo ou
seu operador for alguma coisa que n@~{a}o esses listados acima,
@code{lhs} retorna @var{expr}.

Veja tamb@'{e}m @code{rhs}.

Exemplos:

@c ===beg===
@c e: aa + bb = cc;
@c lhs (e);
@c rhs (e);
@c [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
@c [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
@c e1: '(foo(x) := 2*x);
@c e2: '(bar(y) ::= 3*y);
@c e3: '(x : y);
@c e4: '(x :: y);
@c [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
@c infix ("][");
@c lhs (aa ][ bb);
@c ===end===
@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix ("][");
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
@end example

@end deffn

@c REVISIT -- THERE'S PROBABLY MORE TO SAY HERE
@deffn {Fun@value{cedilha}@~{a}o} linsolve ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
Resolve a lista de
equa@value{cedilha}@~{o}es lineares simult@^{a}neas para a lista de vari@'{a}veis.  As express@~{o}es
devem ser cada uma polin@^{o}mios nas vari@'{a}veis e podem ser equa@value{cedilha}@~{o}es.

Quando @code{globalsolve} @'{e} @code{true} ent@~{a}o vari@'{a}veis que foram resolvidas
ser@~{a}o escolhidas para a solu@value{cedilha}@~{a}o do conjunto de equa@value{cedilha}@~{o}es simult@^{a}neas.

Quando @code{backsubst} @'{e} @code{false}, @code{linsolve}
n@~{a}o realiza substitui@value{cedilha}@~{a}o em equa@value{cedilha}@~{o}es anteriores ap@'{o}s
as equa@value{cedilha}@~{o}es terem sido triangularizadas.  Isso pode ser necess@'{a}rio em problemas
muito grandes onde substitui@value{cedilha}@~{a}o em equa@value{cedilha}@~{o}es anteriores poder@'{a} causar a gera@value{cedilha}@~{a}o de
express@~{o}es extremamente largas.

Quando @code{linsolve_params} for @code{true},
@code{linsolve} tamb@'{e}m gera s@'{i}mbolos @code{%r}
usados para representar par@^{a}metros arbitr@'{a}rios descritos no manual sob
@code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equa@value{cedilha}@~{o}es com algumas vari@'{a}veis expressas em termos de outras.

Quando @code{programmode} for @code{false},
@code{linsolve} mostra a solu@value{cedilha}@~{a}o com express@~{o}es intermedi@'{a}rias com r@'{o}tulos (@code{%t}),
e retorna a lista de r@'{o}tulos.

@c ===beg===
@c e1: x + z = y;
@c e2: 2*a*x - y = 2*a^2;
@c e3: y - 2*z = 2;
@c [globalsolve: false, programmode: true];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c [globalsolve: false, programmode: false];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c ''%;
@c [globalsolve: true, programmode: false];
@c linsolve ([e1, e2, e3], [x, y, z]);
@c ''%;
@c [x, y, z];
@c [globalsolve: true, programmode: true];
@c linsolve ([e1, e2, e3], '[x, y, z]);
@c [x, y, z];
@c ===end===
@example
(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
@end example

@end deffn

@c DO ANY FUNCTIONS OTHER THAN linsolve RESPECT linsolvewarn ??
@defvr {Vari@'{a}vel} linsolvewarn
Valor padr@~{a}o: @code{true}

Quando @code{linsolvewarn} @'{e} @code{true},
@code{linsolve} imprime uma mensagem "Dependent equa@value{cedilha}@~{o}es eliminated".

@end defvr

@defvr {Vari@'{a}vel} linsolve_params
Valor padr@~{a}o: @code{true}

Quando @code{linsolve_params} @'{e} @code{true}, @code{linsolve} tamb@'{e}m gera
os s@'{i}mbolos @code{%r} usados para representar par@^{a}metros arbitr@'{a}rios descritos no
manual sob @code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equa@value{cedilha}@~{o}es com algumas vari@'{a}veis expressas em termos e outras.

@end defvr

@defvr {Vari@'{a}vel} multiplicities
Valor padr@~{a}o: @code{not_set_yet}

@code{multiplicities} @'{e} escolhida para uma lista de
multiplicidades das solu@value{cedilha}@~{o}es individuais retornadas por @code{solve} ou
@code{realroots}.
@c NEED AN EXAMPLE HERE

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} nroots (@var{p}, @var{low}, @var{high})
Retorna o n@'{u}mero de ra@'{i}zes reais do polin@^{o}mio 
real de uma @'{u}nica vari@'{a}vel @var{p} no intervalo semi-aberto
@code{(@var{low}, @var{high}]}.
Uma extremidade do intervalo podem ser @code{minf} ou @code{inf}.
infinito e mais infinito.

@code{nroots} usa o m@'{e}todo das sequ@"{u}@^{e}ncias de Sturm.

@example
(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} nthroot (@var{p}, @var{n})
Onde p @'{e} um polin@^{o}mio com coeficientes inteiros e
n @'{e} um inteiro positivo retorna q, um polin@^{o}mio sobre os inteiros, tal
que q^n=p ou imprime uma mensagem de erro indicando que p n@~{a}o @'{e} uma pot@^{e}ncia n-@'{e}sima
perfeita.  Essa rotina @'{e} mais r@'{a}pida que @code{factor} ou mesmo @code{sqfr}.

@end deffn

@defvr {Vari@'{a}vel} programmode
Valor padr@~{a}o: @code{true}

Quando @code{programmode} @'{e} @code{true},
@code{solve}, @code{realroots}, @code{allroots}, e @code{linsolve}
retornam solu@value{cedilha}@~{o}es como elementos em uma lista.
@c WHAT DOES BACKSUBSTITUTION HAVE TO DO WITH RETURN VALUES ??
(Exceto quando @code{backsubst} @'{e} escolhido para @code{false}, nesse caso
@code{programmode: false} @'{e} assumido.)

Quando @code{programmode} @'{e} @code{false}, @code{solve}, etc.
cria r@'{o}tulos de express@~{o}es intermedi@'{a}rias
@code{%t1}, @code{t2}, etc., e atribui as solu@value{cedilha}@~{o}es para eles.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'{a}vel} realonly
Valor padr@~{a}o: @code{false}

Quando @code{realonly} @'{e} @code{true}, @code{algsys} retorna somente
aquelas solu@value{cedilha}@~{o}es que est@~{a}o livres de @code{%i}.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} realroots (@var{expr}, @var{bound})
@deffnx {Fun@value{cedilha}@~{a}o} realroots (@var{eqn}, @var{bound})
@deffnx {Fun@value{cedilha}@~{a}o} realroots (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} realroots (@var{eqn})
Calcula aproxima@value{cedilha}@~{o}es racionais das ra@'{i}zes reais da express@~{a}o polinomial @var{expr}
ou da equa@value{cedilha}@~{a}o polinomial @var{eqn} de uma vari@'{a}vel,
dentro de uma toler@^{a}ncia de @var{bound}.
coeficientes de @var{expr} ou de @var{eqn} devem ser n@'{u}meros literais;
constantes s@'{i}mbolo tais como @code{%pi} s@~{a}o rejeitadas.

@code{realroots} atribui as multiplicidades das ra@'{i}zes que encontrar
para a vari@'{a}vel global @code{multiplicities}.

@code{realroots} constr@'{o}i uma seq@"{u}@^{e}ncia de Sturm para delimitar cada ra@'{i}z,
e ent@~{a}o palica a bisec@value{cedilha}@~{a}o para redefinir as aproxima@value{cedilha}@~{o}es.
Todos os coeficientes s@~{a}o convertidos para os equivalentes racionais antes da busca por ra@'{i}zes,
e c@'{a}lculos s@~{a}o realizados por meio de aritm@'{e}tica racional exata.
Mesmo se alguns coeficientes forem n@'{u}meros em ponto flutuante,
os resultados s@~{a}o racionais (a menos que for@value{cedilha}ados a n@'{u}meros em ponto flutuante por @code{float} ou por @code{numer} flags).

Quando @var{bound} for menor que 1, todas as ra@'{i}zes inteiras s@~{a}o encontradas exatamente.
Quando @var{bound} n@~{a}o for especificado, ser@'{a} assumido como sendo igual @`a vari@'{a}vel globa @code{rootsepsilon}.

Quando a var@'{a}vel global @code{programmode} for @code{true},
@code{realroots} retorna uma lista da forma @code{[x = @var{x_1}, x = @var{x_2}, ...]}.
Quando @code{programmode} for @code{false},
@code{realroots} cria r@'{o}tulos de express@~{o}es intermedi@'{a}rias @code{%t1}, @code{%t2}, ...,
atribui os resultados a eles, e retorna a lista de r@'{o}tulos.

Exemplos:
@c ===beg===
@c realroots (-1 - x + x^5, 5e-6);
@c ev (%[1], float);
@c ev (-1 - x + x^5, %);
@c ===end===

@example
(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
@end example

@c ===beg===
@c realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
@c multiplicities;
@c ===end===

@example
(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rhs (@var{expr})
Retorna o lado direito (isto @'{e}, o segundo argumento)
da express@~{a}o @var{expr},
quando o operador de @var{expr}
for um dos operadores relacionais @code{< <= = # equal notequal >= >},
@c MENTION -> (MARROW) IN THIS LIST IF/WHEN THE PARSER RECOGNIZES IT
um dos operadores de atribui@value{cedilha}@~{a}o @code{:= ::= : ::},
ou um operador bin@'{a}rio infixo definido pelo usu@'{a}rio, como declarado por meio de @code{infix}.

Quando @var{expr} for um @'{e}tomo ou
seu operadro for alguma coisa que n@~{a}o esses listados acima,
@code{rhs} retorna 0.

Veja tamb@'{e}m @code{lhs}.

Exemplos:

@c ===beg===
@c e: aa + bb = cc;
@c lhs (e);
@c rhs (e);
@c [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
@c [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
@c e1: '(foo(x) := 2*x);
@c e2: '(bar(y) ::= 3*y);
@c e3: '(x : y);
@c e4: '(x :: y);
@c [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
@c infix ("][");
@c rhs (aa ][ bb);
@c ===end===
@example
(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix ("][");
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} rootsconmode
Valor padr@~{a}o: @code{true}

@code{rootsconmode} governa o comportamento do comando
@code{rootscontract}.  Veja @code{rootscontract} para detalhes.

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} rootscontract (@var{expr})
Converte produtos de ra@'{i}zes em ra@'{i}zes de produtos.
Por exemplo,
@code{rootscontract (sqrt(x)*y^(3/2))} retorna @code{sqrt(x*y^3)}.

Quando @code{radexpand} @'{e} @code{true} e @code{domain} @'{e} @code{real},
@code{rootscontract} converte @code{abs} em @code{sqrt}, e.g.,
@code{rootscontract (abs(x)*sqrt(y))} retorna @code{sqrt(x^2*y)}.

Existe uma op@value{cedilha}@~{a}o @code{rootsconmode}
afetando @code{rootscontract} como segue:

@example
Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
@end example

Quando @code{rootsconmode} @'{e} @code{false}, @code{rootscontract} contrai somente como rela@value{cedilha}@~{a}o a expoentes
de n@'{u}mero racional cujos denominadores s@~{a}o os mesmos.  A chave para os exemplos
@code{rootsconmode: true} @'{e} simplesmente que 2 divides 4 mas n@~{a}o 
divide 3.  @code{rootsconmode: all} envolve pegar o menor multiplo comum
dos denominadores dos expoentes.

@code{rootscontract} usa @code{ratsimp} em uma maneira similar a @code{logcontract}.

Exemplos:
@c FOLLOWING ADAPTED FROM example (rootscontract)
@c rootsconmode: false$
@c rootscontract (x^(1/2)*y^(3/2));
@c rootscontract (x^(1/2)*y^(1/4));
@c rootsconmode: true$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: all$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: false$
@c rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
@c                     *sqrt(sqrt(1 + x) - sqrt(x)));
@c rootsconmode: true$
@c rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));

@example
(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} rootsepsilon
Valor padr@~{a}o: 1.0e-7

@code{rootsepsilon} @'{e} a toler@^{a}ncia que estabelece o
intervalo de confic@^{e}ncia para as ra@'{i}zes achadas pela fun@value{cedilha}@~{a}o @code{realroots}.
@c IS IT GUARANTEED THAT |ACTUAL - ESTIMATE| < rootepsilon OR IS IT SOME OTHER NOTION ??
@c NEED EXAMPLE HERE

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} solve (@var{expr}, @var{x})
@deffnx {Fun@value{cedilha}@~{a}o} solve (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])
Resolve a equa@value{cedilha}@~{a}o alg@'{e}brica @var{expr} para a vari@'{a}vel
@var{x} e retorna uma lista de equa@value{cedilha}@~{o}es solu@value{cedilha}@~{a}o em @var{x}.  Se @var{expr} n@~{a}o @'{e} uma
equa@value{cedilha}@~{a}o, a equa@value{cedilha}@~{a}o @code{@var{expr} = 0} @'{e} assumida em seu lugar.
@var{x} pode ser uma fun@value{cedilha}@~{a}o (e.g. @code{f(x)}), ou outra express@~{a}o n@~{a}o at@^{o}mica
exceto uma adi@value{cedilha}@~{a}o ou um produto.  @var{x} pode ser omitido se @var{expr} cont@'{e}m somente uma
vari@'{a}vel.  @var{expr} pode ser uma express@~{a}o racional, e pode conter
fun@value{cedilha}@~{o}es trigonom@'{e}tricas, exponenciais, etc.

O seguinte m@'{e}todo @'{e} usado:

Tome @var{E} sendo a express@~{a}o e @var{X} sendo a vari@'{a}vel.  Se @var{E} @'{e} linear em @var{X}
ent@~{a}o isso @'{e} trivialmente resolvido para @var{X}.  De outra forma se @var{E} @'{e} da forma
@code{A*X^N + B} ent@~{a}o o resultado @'{e} @code{(-B/A)^1/N)} vezes as @code{N}'@'{e}simas ra@'{i}zes da
unidade.

Se @var{E} n@~{a}o @'{e} linear em @var{X} ent@~{a}o o m@'{a}ximo divisor comum (mdc) dos expoentes de @var{X} em @var{E} (digamos
@var{N}) @'{e} dividido dentro dos expoentes e a multiplicidade das ra@'{i}zes @'{e}
multiplicada por @var{N}.  Ent@~{a}o @code{solve} @'{e} chamada novamente sobre o resultado.
Se @var{E} for dada em fatores ent@~{a}o @code{solve} @'{e} chamada sobre cada um dos fatores.  Finalmente
@code{solve} usar@'{a} as f@'{o}rmulas quadr@'{a}ticas, c@'{u}bicas, ou qu@'{a}rticas onde
necess@'{a}rio.

No caso onde @var{E} for um polin@^{o}mio em alguma fun@value{cedilha}@~{a}o de vari@'{a}vel a ser
resolvida, digamos @code{F(X)}, ent@~{a}o isso @'{e} primeiro resolvida para @code{F(X)} (chama o
resultado @var{C}), ent@~{a}o a equa@value{cedilha}@~{a}o @code{F(X)=C} pode ser resolvida para @var{X} fornecendo o
inverso da fun@value{cedilha}@~{a}o @var{F} que @'{e} conhecida.

@code{breakup} se @code{false} far@'{a} com que @code{solve} expresse as solu@value{cedilha}@~{o}es de
equa@value{cedilha}@~{o}es c@'{u}bicas ou qu@'{a}rticas como express@~{o}es simples ao inv@'{e}s de como feito
em cima de v@'{a}rias subexpress@~{o}es comuns que @'{e} o padr@~{a}o.

@code{multiplicities} - ser@'{a} escolhido para uma lista de multiplicidades de
solu@value{cedilha}@~{o}es individuais retornadas por @code{solve}, @code{realroots}, ou @code{allroots}.
Tente @code{apropos (solve)} para os comutadores que afetam @code{solve}.  @code{describe} pode
ent@~{a}o ser usada sobre o nome do comutador individual se seu propr@'{o}sito n@~{a}o @'{e}
claro.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
resolve um sistema de equa@value{cedilha}@~{o}es polinomiais
(lineares ou n@~{a}o-lineares) simult@^{a}neas por chamada a @code{linsolve} ou
@code{algsys} e retorna uma lista de listas solu@value{cedilha}@~{a}o nas vari@'{a}veis.  No
caso de @code{linsolve} essa lista conter@'{a} uma lista simples de
solu@value{cedilha}@~{o}es.  Isso pega duas listas como argumentos.  A primeira lista
representa as equa@value{cedilha}@~{o}es a serem resolvidas; a segunda lista @'{e} a
lista de desconhecidos a ser determinada.  Se o n@'{u}mero total de
vari@'{a}veis nas equa@value{cedilha}@~{o}es @'{e} igual ao n@'{u}mero de equa@value{cedilha}@~{o}es, a
segunda lista-argumento pode ser omitida.  Para sistemas lineares se as dadas
equa@value{cedilha}@~{o}es n@~{a}o s@~{a}o compat@'{i}veis, a mensagem @code{inconsistent} ser@'{a}
mostrada (veja o comutador @code{solve_inconsistent_error} ); se n@~{a}o existe
solu@value{cedilha}@~{a}o @'{u}nica, ent@~{a}o @code{singular} ser@'{a} mostrado.

Quando @code{programmode} for @code{false},
@code{solve} mostra solu@value{cedilha}@~{o}es com r@'{o}tulos de express@~{o}es intermedi@'{a}rias (@code{%t}),
e retorna a lista de r@'{o}tulos.

Quando @code{globalsolve} for @code{true} e o problema for resolver duas ou mais equa@value{cedilha}@~{o}es lineares,
cada vari@'{a}vel para a qual a equa@value{cedilha}@~{a}o for resolvida @'{e} associada a seu valor na solu@value{cedilha}@~{a}o das equa@value{cedilha}@~{o}es.

Exemplos:
@c FOLLOWING ADAPTED FROM example (solve)
@c ===beg===
@c solve (asin (cos (3*x))*(f(x) - 1), x);
@c ev (solve (5^f(x) = 125, f(x)), solveradcan);
@c [4*x^2 - y^2 = 12, x*y - x = 2];
@c solve (%, [x, y]);
@c solve (1 + a*x + x^3, x);
@c solve (x^3 - 1);
@c solve (x^6 - 1);
@c ev (x^6 - 1, %[1]);
@c expand (%);
@c x^2 - 1;
@c solve (%, x);
@c ev (%th(2), %[1]);
@c ===end===
@example
(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solvedecomposes
Valor padr@~{a}o: @code{true}

Quando @code{solvedecomposes} @'{e} @code{true}, @code{solve} chama
@code{polydecomp} se perguntado para resolver polin@^{o}mios.
@c OTHERWISE WHAT HAPPENS -- CAN'T SOLVE POLYNOMIALS, OR SOME OTHER METHOD IS USED ??

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solveexplicit
Valor padr@~{a}o: @code{false}

Quando @code{solveexplicit} @'{e} @code{true}, inibe @code{solve} de
retornar solu@value{cedilha}@~{o}es impl@'{i}citas, isto @'{e}, solu@value{cedilha}@~{o}es da forma @code{F(x) = 0}
onde @code{F} @'{e} alguma fun@value{cedilha}@~{a}o.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solvefactors
Valor padr@~{a}o: @code{true}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{solvefactors} @'{e} @code{false}, @code{solve} n@~{a}o tenta
fatorar a express@~{a}o.  O @code{false} escolhido pode ser desejado em alguns casos
onde a fatora@value{cedilha}@~{a}o n@~{a}o @'{e} necess@'{a}ria.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solvenullwarn
Valor padr@~{a}o: @code{true}

Quando @code{solvenullwarn} @'{e} @code{true}, 
@code{solve} imprime uma mensagem de alerta se chamada com ou uma lista equa@value{cedilha}@~{a}o ou uma vari@'{a}vel lista nula.
Por exemplo, @code{solve ([], [])} imprimir@'{a} duas mensagens de alerta e retorna @code{[]}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solveradcan
Valor padr@~{a}o: @code{false}

Quando @code{solveradcan} @'{e} @code{true}, @code{solve} chama @code{radcan}
que faz @code{solve} lento mas permitir@'{a} certamente que problemas
contendo exponeniais e logar@'{i}tmos sejam resolvidos.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solvetrigwarn
Valor padr@~{a}o: @code{true}

@c MAYBE THIS CAN BE CLARIFIED
Quando @code{solvetrigwarn} @'{e} @code{true},
@code{solve} pode imprimir uma mensagem dizendo que est@'{a} usando fun@value{cedilha}@~{o}es
trigonom@'{e}tricas inversas para resolver a equa@value{cedilha}@~{a}o, e desse modo perdendo
solu@value{cedilha}@~{o}es.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} solve_inconsistent_error
Valor padr@~{a}o: @code{true}

Quando @code{solve_inconsistent_error} for @code{true}, @code{solve} e
@code{linsolve} resultam em erro se as equa@value{cedilha}@~{o}es a serem resolvidas forem inconsistentes.

Se @code{false}, @code{solve} e @code{linsolve} retornam uma lista vazia @code{[]} 
se as equa@value{cedilha}@~{o}es forem inconsistentes.

Exemplo:

@example
(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equa@value{cedilha}@~{o}es:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
@end example

@end defvr
