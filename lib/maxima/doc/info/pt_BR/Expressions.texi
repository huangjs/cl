@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Expressions.texi/1.53/Sat Jun  2 00:12:43 2007/-ko/
@menu
* Introdu@value{cedilha}@~{a}o a Express@~{o}es::  
* Complexo::                     
* Substantivos e Verbos::
* Identificadores::
* Seq@"{u}@^{e}ncias de caracteres::
* Desigualdade::                  
* Sintaxe::                      
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Express@~{o}es::  
@end menu

@node Introdu@value{cedilha}@~{a}o a Express@~{o}es, Complexo, Express@~{o}es, Express@~{o}es
@section Introdu@value{cedilha}@~{a}o a Express@~{o}es

Existe um conjunto de palavras reservadas que n@~{a}o pode ser usado como
nome de vari@'{a}vel.   Seu uso pode causar um poss@'{i}vel erro cr@'{i}tico de sintaxe.

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

Muitas coisas em Maxima s@~{a}o express@~{o}es.   Uma seq@"{u}@^{e}ncia de express@~{o}es
pode ser feita dentro de uma express@~{a}o maior atrav@'{e}s da separa@value{cedilha}@~{a}o dessas atrav@'{e}s de v@'{i}rgulas e
colocando par@^{e}ntesis em torno dela.   Isso @'{e} similar ao @b{C}
@i{express@~{a}o com v@'{i}rgula}.

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Mesmo ciclos em Maxima s@~{a}o express@~{o}es, embora o valor de retorno desses
ciclos n@~{a}o seja muito @'{u}til (eles retornam sempre @code{done}).

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

contanto que o que voc@^{e} realmente queira seja provavelmente incluir um terceiro
termo na @i{express@~{a}o com v@'{i}rgula} que fornece de volta o valor atualizado.

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example



@c THIS REALLY NEEDS EXPANSION
@node Complexo, Substantivos e Verbos, Introdu@value{cedilha}@~{a}o a Express@~{o}es, Express@~{o}es
@section Complexo
Uma express@~{a}o complexa @'{e} especificada no Maxima atrav@'{e}s da adi@value{cedilha}@~{a}o da
parte real da express@~{a}o a @code{%i} vezes a parte imagin@'{a}ria.  Dessa forma as
ra@'{i}zes da equa@value{cedilha}@~{a}o @code{x^2 - 4*x + 13 = 0} s@~{a}o @code{2 + 3*%i} e @code{2 - 3*%i}.  Note que
produtos de simplifica@value{cedilha}@~{a}o de express@~{o}es complexas podem ser efetuadas atrav@'{e}s da
expans@~{a}o do produto.  Simplifica@value{cedilha}@~{a}o de quocientes, ra@'{i}zes, e outras
fun@value{cedilha}@~{o}es de express@~{o}es complexas podem usualmente serem realizadas atrav@'{e}s do uso
das fun@value{cedilha}@~{o}es @code{realpart}, @code{imagpart}, @code{rectform}, @code{polarform}, @code{abs}, @code{carg}.

@node Substantivos e Verbos, Identificadores, Complexo, Express@~{o}es
@section Substantivos e Verbos
Maxima distingue entre operadores que s@~{a}o "substantivos" e operadores que s@~{a}o "verbos".
Um verbo @'{e} um operador que pode ser executado.
Um substantivo @'{e} um operador que aparece como um s@'{i}mbolo em uma express@~{a}o, sem ser executado.
Por padr@~{a}o, nomes de fun@value{cedilha}@~{a}o s@~{a}o verbos.
Um verbo pode ser mudado em um substantivo atrav@'{e}s da adi@value{cedilha}@~{a}o de um ap@'{o}strofo no in@'{i}cio do nome da fun@value{cedilha}@~{a}o
ou aplicando a fun@value{cedilha}@~{a}o @code{nounify}.
Um substantivo pode ser mudado em um verbo atrav@'{e}s da aplica@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o @code{verbify}.
O sinalizador de avalia@value{cedilha}@~{a}o @code{nouns} faz com que @code{ev} avalie substantivos em uma express@~{a}o.

A forma verbal @'{e} distinguida atrav@'{e}s de
um sinal de d@'{o}lar @code{$} no in@'{i}cio do s@'{i}mbolo Lisp correspondente.
De forma oposta,
a forma substantiva @'{e} distinguida atrav@'{e}s de 
um sinal de @code{%} no in@'{i}cio do s@'{i}mbolo Lisp correspondente.
Alguns substantivos possuem propriedades especiais de exibi@value{cedilha}@~{a}o, tais como @code{'integrate} e @code{'derivative}
(retornado por @code{diff}), mas muitos n@~{a}o.
Por padr@~{a}o, as formas substantiva e verbal de uma fun@value{cedilha}@~{a}o s@~{a}o id@^{e}nticas quando mostradas.
O sinalizador global @code{noundisp} faz com que Maxima mostre substantivos com um ap@'{o}strofo no in@'{i}cio @code{'}.

Veja tamb@'{e}m @code{noun}, @code{nouns}, @code{nounify}, e @code{verbify}.

Exemplos:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example

@node Identificadores, Seq@"{u}@^{e}ncias de caracteres, Substantivos e Verbos, Express@~{o}es
@section Identificadores
Identificadores do Maxima podem compreender caracteres alfab@'{e}ticos,
mais os numerais de 0 a 9,
mais qualquer caractere especial precedido por um caractere contra-barra @code{\}.

Um numeral pode ser o primeiro caractere de um identificador
se esse numeral for precedido por uma contra-barra.
Numerais que forem o segundo ou o @'{u}ltimo caractere n@~{a}o precisam ser precedidos por uma contra barra.

Caracteres podem ser declarados para serem alfab@'{e}ticos por meio da fun@value{cedilha}@~{a}o @code{declare}.
Se ent@~{a}o declarados alfab@'{e}ticos, eles n@~{a}o precisam serem precedidos de uma contrabarra em um identificador.
Os caracteres alfab@'{e}ticos v@~{a}o inicialmente 
de @code{A} a @code{Z}, de @code{a} a @code{z}, @code{%}, e @code{_}.

Maxima @'{e} sens@'{i}vel @`a caixa . Os identificadores @code{algumacoisa}, @code{ALGUMACOISA}, e @code{Algumacoisa} s@~{a}o distintos.
Veja @ref{Lisp e Maxima} para mais sobre esse ponto.

Um identificador Maxima @'{e} um s@'{i}mbolo Lisp que come@value{cedilha}a com um sinal de d@'{o}lar @code{$}.
Qualquer outro s@'{i}mbolo Lisp @'{e} precedido por um ponto de interroga@value{cedilha}@~{a}o @code{?} quando aparecer no Maxima.
Veja @ref{Lisp e Maxima} para maiores detalhes sobre esse ponto.

Exemplos:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example

@node Seq@"{u}@^{e}ncias de caracteres, Desigualdade, Identificadores, Express@~{o}es
@section Seq@"{u}@^{e}ncias de caracteres

Strings (seq@"{u}@^{e}ncias de caracteres) s@~{a}o contidas entre aspas duplas @code{"} em entradas de dados usados pelo Maxima,
e mostradas com ou sem as aspas duplas, 
dependendo do valor escolhido para a vari@'{a}vel global @code{stringdisp}.

Seq@"{u}@^{e}ncias de caracteres podem conter quaisquer caracteres,
incluindo tabula@value{cedilha}@~{o}es (tab), nova linha (ou fim de linha), e caracteres de retorno da cabe@value{cedilha}a de impress@~{a}o (carriage return).
A seq@"{u}@^{e}ncia @code{\"} @'{e} reconhecida com uma aspa dupla literal,
e @code{\\} como uma contrabarra literal.
Quando a contrabarra aparecer no final de uma linha,
a contrabarra e a termina@value{cedilha}@~{a}o de linha
(ou nova linha ou retorno de carro e nova linha)
s@~{a}o ignorados,
de forma que a seq@"{u}@^{e}ncia de caracteres continue na pr@'{o}xima linha.
Nenhuma outra combina@value{cedilha}@~{a}o especial de contrabarra com outro caractere @'{e} reconhecida;
quando a contrabarra aparecer antes de qualquer outro caractere que n@~{a}o seja @code{"}, @code{\},
ou um fim de linha, a contrabarra @'{e} ignorada.
N@~{a}o exite caminho para representar um caractere especial
(tal como uma tabula@value{cedilha}@~{a}o, nova linha, ou retorno da cabe@value{cedilha}a de impress@~{a}o)
exceto atrav@'{e}s de encaixar o caractere literal na seq@"{u}@^{e}ncia de caracteres.

N@~{a}o existe tipo de caractere no Maxima;
um caractere simples @'{e} representado como uma seq@"{u}@^{e}ncia de caracteres de um @'{u}nico caractere.

Seq@"{u}@^{e}ncias de caracteres no Maxima s@~{a}o implementadas como s@'{i}mbolos do Lisp, n@~{a}o como seq@"{u}encias de caracteres do not Lisp;
o que pode mudar em futuras vers@~{o}es do Maxima.
Maxima pode mostrar seq@"{u}@^{e}ncias de caracteres do Lisp e caracteres do Lisp,
embora algumas outras opera@value{cedilha}@~{o}es (por exemplo, testes de igualdade) possam falhar.
@c DISCOMFORT WITH LISP STRINGS AND CHARACTERS IS A BUG.

O pacote adicional @code{stringproc} cont@'{e}m muitas fun@value{cedilha}@~{o}es que trabalham com seq@"{u}@^{e}ncias de caracteres.

Exemplos:

@c ===beg===
@c s_1 : "Isso @'{e} uma seq@"{u}@^{e}ncia de caracteres  do Maxima.";
@c s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma seq@"{u}@^{e}ncia de caracteres.";
@c s_3 : "Caractere de fim de linha encaixado
@c nessa seq@"{u}@^{e}ncia de caracteres.";
@c s_4 : "Ignore o \
@c caractere de \
@c fim de linha nessa \
@c seq@"{u}@^{e}ncia de caracteres.";
@c stringdisp : false;
@c s_1;
@c stringdisp : true;
@c s_1;
@c ===end===
@example
(%i1) s_1 : "Isso @'{e} uma seq@"{u}@^{e}ncia de caracteres  do Maxima.";
(%o1)               Isso @'{e} uma seq@"{u}@^{e}ncia de caracteres  do Maxima.
(%i2) s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma seq@"{u}@^{e}ncia de caracteres.";
(%o2) Caracteres "aspas duplas" e contrabarra \ encaixados em uma seq@"{u}@^{e}ncia de caracteres.
(%i3) s_3 : "Caractere de fim de linha encaixado
nessa seq@"{u}@^{e}ncia de caracteres.";
(%o3) Caractere de fim de linha encaixado
nessa seq@"{u}@^{e}ncia de caracteres.
(%i4) s_4 : "Ignore o \
caractere de \
fim de linha nessa \
seq@"{u}@^{e}ncia de caracteres.";
(%o4) Ignore o caractere de fim de linha nessa seq@"{u}@^{e}ncia de caracteres.
(%i5) stringdisp : false;
(%o5)                         false
(%i6) s_1;
(%o6)               Isso @'{e} uma seq@"{u}@^{e}ncia de caracteres  do Maxima.
(%i7) stringdisp : true;
(%o7)                         true
(%i8) s_1;
(%o8)              "Isso @'{e} uma seq@"{u}@^{e}ncia de caracteres  do Maxima."
@end example

@node Desigualdade, Sintaxe, Seq@"{u}@^{e}ncias de caracteres, Express@~{o}es
@section Desigualdade
Maxima tem os operadores de desigualdade @code{<}, @code{<=}, @code{>=}, @code{>}, @code{#}, e @code{notequal}.
Veja @code{if} para uma descri@value{cedilha}@~{a}o de express@~{o}es condicionais.

@node Sintaxe, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Express@~{o}es, Desigualdade, Express@~{o}es
@section Sintaxe
@'{E} poss@'{i}vel definir novos operadores com preced@^{e}ncia especificada,
remover a defini@value{cedilha}@~{a}o de operadores existentes,
ou redefinir a preced@^{e}ncia de operadores existentes.  
Um operador pode ser un@'{a}rio prefixado ou un@'{a}rio p@'{o}sfixado, binario infixado, n-@'{a}rio infixado, matchfix, ou nofix.
"Matchfix" significa um par de s@'{i}mbolos que abra@value{cedilha}am seu argumento ou seus argumentos,
e "nofix" significa um operador que n@~{a}o precisa de argumentos.
Como exemplos dos diferentes tipos de operadores, existe o seguinte.

@table @asis
@item un@'{a}rio prefixado
nega@value{cedilha}@~{a}o @code{- a}
@item un@'{a}rio posfixado
fatorial @code{a!}
@item bin@'{a}rio infixado
exponencia@value{cedilha}@~{a}o @code{a^b}
@item n-@'{a}rio infixado
adi@value{cedilha}@~{a}o @code{a + b}
@item matchfix
constru@value{cedilha}@~{a}o de lista @code{[a, b]}
@end table

(N@~{a}o existe operadores internos nofix;
para um exemplo de tal operador, veja @code{nofix}.)

O mecanismo para definir um novo operador @'{e} direto.
Somente @'{e} necess@'{a}rio declarar uma fun@value{cedilha}@~{a}o como um operador;
a fun@value{cedilha}@~{a}o operador pode ou n@~{a}o estar definida previamente.

Um exemplo de operadores definidos pelo usu@'{a}rio @'{e} o seguinte.
Note que a chamada expl@'{i}cita de fun@value{cedilha}@~{a}o @code{"dd" (a)} @'{e} equivalente a @code{dd a},
da mesma forma @code{"<-" (a, b)} @'{e} equivalente a @code{a <- b}.
Note tamb@'{e}m que as fun@value{cedilha}@~{o}es @code{"dd"} e @code{"<-"} s@~{a}o indefinidas nesse exemplo.

@c ===beg===
@c prefix ("dd");
@c dd a;
@c "dd" (a);
@c infix ("<-");
@c a <- dd b;
@c "<-" (a, "dd" (b));
@c ===end===
@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

As fun@value{cedilha}@~{o}es m@'{a}xima que definem novos operadores est@~{a}o sumarizadas nessa tabela,
equilibrando expoente associado esquerdo (padr@~{a}o) e o expoente associado direito ("eae" e "ead", respectivamente).
@c REWORK FOLLOWING COMMENT. IT'S NOT CLEAR ENOUGH, GIVEN THAT IT'S FAIRLY IMPORTANT
(Associa@value{cedilha}@~{a}o de expoentes determina a preced@^{e}ncia do operador. todavia, uma vez que os expoentes
esquerdo e direito podem ser diferentes, associa@value{cedilha}@~{a}o de expoentes @'{e} at@'{e} certo ponto mais complicado que preced@^{e}ncia.)
Alguma das fun@value{cedilha}@~{o}es de defini@value{cedilha}@~{a}o de opera@value{cedilha}@~{o}es tomam argumentos adicionais;
veja as descri@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o para maiores detalhes.

@c MAKE ANCHORS FOR ALL 6 FUNCTIONS AND CHANGE @code TO @ref ACCORDINGLY
@table @code
@item prefixado
ead=180
@item posfixado
eae=180
@item infixado
eae=180, ead=180
@item n@'{a}rio
eae=180, ead=180
@item matchfix
(associa@value{cedilha}@~{a}o de expoentes n@~{a}o @'{e} aplic@'{a}vel)
@item nofix
(associa@value{cedilha}@~{a}o de expoentes n@~{a}o @'{e} aplic@'{a}vel)
@end table

Para compara@value{cedilha}@~{a}o,
aqui est@'{a} alguns operadores internos e seus expoentes associados esquerdo e direito.

@example
Operador   eae     ead

  :        180     20 
  ::       180     20 
  :=       180     20 
  ::=      180     20 
  !        160
  !!       160
  ^        140     139 
  .        130     129 
  *        120
  /        120     120 
  +        100     100 
  -        100     134 
  =        80      80 
  #        80      80 
  >        80      80 
  >=       80      80 
  <        80      80 
  <=       80      80 
  not              70 
  and      65
  or       60
  ,        10
  $        -1
  ;        -1
@end example

@code{remove} e @code{kill} removem propriedades de operador de um @'{a}tomo.
@code{remove ("@var{a}", op)} remove somente as propriedades de operador de @var{a}.
@code{kill ("@var{a}")} remove todas as propriedades de @var{a}, incluindo as propriedades de operador.
Note que o nome do operador dever estar abra@value{cedilha}ado por aspas duplas.

@c MAYBE COPY THIS EXAMPLE TO remove AND/OR kill
@c ===beg===
@c infix ("##");
@c "##" (a, b) := a^b;
@c 5 ## 3;
@c remove ("##", op);
@c 5 ## 3;
@c "##" (5, 3);
@c infix ("##");
@c 5 ## 3;
@c kill ("##");
@c 5 ## 3;
@c "##" (5, 3);
@c ===end===
@example
(%i1) infix ("##");
(%o1)                          ##
(%i2) "##" (a, b) := a^b;
                                     b
(%o2)                     a ## b := a
(%i3) 5 ## 3;
(%o3)                          125
(%i4) remove ("##", op);
(%o4)                         done
(%i5) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i5) "##" (5, 3);
(%o5)                          125
(%i6) infix ("##");
(%o6)                          ##
(%i7) 5 ## 3;
(%o7)                          125
(%i8) kill ("##");
(%o8)                         done
(%i9) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i9) "##" (5, 3);
(%o9)                       ##(5, 3)
@end example

@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Express@~{o}es,  , Sintaxe, Express@~{o}es
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Express@~{o}es

@deffn {Fun@value{cedilha}@~{a}o} at (@var{expr}, [@var{eqn_1}, ..., @var{eqn_n}])
@deffnx {Fun@value{cedilha}@~{a}o} at (@var{expr}, @var{eqn})
Avalia a express@~{a}o @var{expr} com
as vari@'{a}veis assumindo os valores como especificado para elas na lista de
equa@value{cedilha}@~{o}es @code{[@var{eqn_1}, ..., @var{eqn_n}]} ou a equa@value{cedilha}@~{a}o simples @var{eqn}.

Se uma subexpress@~{a}o depender de qualquer das vari@'{a}veis para a qual um valor foi especificado
mas n@~{a}o existe @code{atvalue} especificado e essa subexpress@~{a}o n@~{a}o pode ser avaliada de outra forma,
ent@~{a}o uma forma substantiva de @code{at} @'{e} retornada que mostra em uma forma bidimensional.

@code{at} realiza m@'{u}ltiplas substitui@value{cedilha}@~{o}es em s@'{e}rie, n@~{a}o em paralelo.

Veja tamb@'{e}m @code{atvalue}.
Para outras fun@value{cedilha}@~{o}es que realizam substitui@value{cedilha}@~{o}es,
veja tamb@'{e}m @code{subst} e @code{ev}.

Exemplos:
@c COPIED FROM example(at)

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x, y)^2 - u(x, y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} box (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} box (@var{expr}, @var{a})
Retorna @var{expr} dentro de uma caixa.
O valor de retorno @'{e} uma express@~{a}o com @code{box} como o operador e @var{expr} como o argumento.
Uma caixa @'{e} desenhada sobre a tela quando @code{display2d} for @code{true}.

@code{box (@var{expr}, @var{a})}
Empacota @var{expr} em uma caixa rotulada pelo s@'{i}mbolo @var{a}.
O r@'{o}tulo @'{e} truncado se for maior que a largura da caixa.

@code{box} avalia seu argumento.
Todavia, uma express@~{a}o dentro de uma caixa n@~{a}o avalia para seu conte@'{u}do,
ent@~{a}o express@~{o}es dentro de caixas s@~{a}o efetivamente exclu@'{i}das de c@'{a}lculos.

@code{boxchar} @'{e} o caractere usado para desenhar a caixa em @code{box}
e nas fun@value{cedilha}@~{o}es @code{dpart} e @code{lpart}.

Exemplos:

@c ===beg===
@c box (a^2 + b^2);
@c a : 1234;
@c b : c - d;
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
(%i1) box (a^2 + b^2);
                            """""""""
                            " 2    2"
(%o1)                       "b  + a "
                            """""""""
(%i2) a : 1234;
(%o2)                         1234
(%i3) b : c - d;
(%o3)                         c - d
(%i4) box (a^2 + b^2);
                      """"""""""""""""""""
                      "       2          "
(%o4)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i5) box (a^2 + b^2, term_1);
                      term_1""""""""""""""
                      "       2          "
(%o5)                 "(c - d)  + 1522756"
                      """"""""""""""""""""
(%i6) 1729 - box (1729);
                                 """"""
(%o6)                     1729 - "1729"
                                 """"""
(%i7) boxchar: "-";
(%o7)                           -
(%i8) box (sin(x) + cos(y));
                        -----------------
(%o8)                   -cos(y) + sin(x)-
                        -----------------
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} boxchar
Valor padr@~{a}o: @code{"}

@code{boxchar} @'{e} o caractere usado para desenhar a caixa por @code{box}
e nas fun@value{cedilha}@~{o}es @code{dpart} e @code{lpart}.

Todas as caixas em uma express@~{a}o s@~{a}o desenhadas com o valor atual de @code{boxchar};
o caractere de desenho n@~{a}o @'{e} armazenado com a express@~{a}o de caixa. Isso quer dizer que se voc@^{e}
desenhar uma caixa e em seguida mudar o caractere de desenho a caixa anteriormente
desenhada ser@'{a} redesenhada com o caractere mudado caso isso seja solicitado.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} carg (@var{z})
Retorna o argumento complexo de @var{z}.
O argumento complexo @'{e} um @^{a}ngulo @code{theta} no intervalo de @code{(-%pi, %pi]}
tal que @code{r exp (theta %i) = @var{z}} onde @code{r} @'{e} o m@'{o}dulo de @var{z}.
@c ACTUALLY carg DOESN'T ALWAYS RETURN A VALUE IN (-%pi, %pi]; SEE SF BUG REPORT # 816166

@code{carg} @'{e} uma fun@value{cedilha}@~{a}o computacional,
n@~{a}o uma fun@value{cedilha}@~{a}o de simplifica@value{cedilha}@~{a}o.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

@code{carg} ignora a declara@value{cedilha}@~{a}o @code{declare (@var{x}, complex)},
e trata @var{x} como uma vari@'{a}vel real.
Isso @'{e} um erro. @c SEE SF BUG REPORT # 620246

Veja tamb@'{e}m @code{abs} (m@'{o}dulo de n@'{u}mero complexo), @code{polarform}, @code{rectform},
@code{realpart}, e @code{imagpart}.

Exemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c CROSS REF declare, properties, ETC
@deffn {Opereador especial} constant
@code{declare (@var{a}, constant)} declara @var{a} para ser uma constante.
Veja @code{declare}.
@c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} constantp (@var{expr})
Retorna @code{true} se @var{expr} for uma express@~{a}o constante,
de outra forma retorna @code{false}.
@c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

Uma express@~{a}o @'{e} considerada uma express@~{a}o constante se seus argumentos forem
n@'{u}meros (incluindo n@'{u}meros racionais, como mostrado com @code{/R/}),
constantes simb@'{o}licas como @code{%pi}, @code{%e}, e @code{%i},
vari@'{a}veis associadas a uma constante ou constante declarada atrav@'{e}s de @code{declare},
ou fun@value{cedilha}@~{o}es cujos argumentos forem constantes.

@code{constantp} avalia seus argumentos.

Exemplos:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===

@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c THIS ITEM IS EXTREMELY IMPORTANT
@c ENSURE THAT ALL KEYWORDS RECOGNIZED BY declare HAVE THEIR OWN DOCUMENTATION ITEMS !!
@c ALSO: HOW TO FIND THE LIST OF ALL SYMBOLS WHICH HAVE A GIVEN PROPERTY ??
@deffn {Fun@value{cedilha}@~{a}o} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, ...)
Atribui aos @'{a}tomos ou lista de @'{a}tomos @var{a_i} a propriedade ou lista de propriedades @var{p_i}.
Quando @var{a_i} e/ou @var{p_i} forem listas,
cada um dos @'{a}tomos recebe todas as propriedades.

@code{declare} n@~{a}o avalia seus argumentos.
@code{declare} sempre retorna @code{done}.

Como colocado na descri@value{cedilha}@~{a}o para cada sinalizador de declara@value{cedilha}@~{a}o,
para alguns sinalizadores
@code{featurep(@var{objeto}, @var{recurso})}
retorna @code{true} se @var{objeto} tiver sido declarado para ter @var{recurso}.
Todavia, @code{featurep} n@~{a}o reconhece alguns sinalizadores; isso @'{e} um erro.

Veja tamb@'{e}m @code{features}.

@code{declare} reconhece as seguintes propriedades:

@table @asis
@item @code{evfun}
Torna @var{a_i} conhecido para @code{ev} de forma que a fun@value{cedilha}@~{a}o nomeada por @var{a_i}
@'{e} aplicada quando @var{a_i} aparece como um sinalizador argumento de @code{ev}.
Veja @code{evfun}.

@item @code{evflag}
Torna @var{a_i} conhecido para a fun@value{cedilha}@~{a}o @code{ev} de forma que @var{a_i} @'{e} associado a @code{true}
durante a execu@value{cedilha}@~{a}o de @code{ev} quando @var{a_i} aparece como um sinalizador argumento de @code{ev}.
Veja @code{evflag}.

@c OBSOLETE @code{special} (RECONHECIDA POR DECLARE MAS NUNCA USADA EM LUGAR ALGUM)
 
@c OBSOLETE @code{nonarray} (RECONHECIDA POR DECLARE MAS NUNCA USADA EM LUGAR ALGUM)

@item @code{bindtest}
Diz ao Maxima para disparar um erro quando @var{a_i} for avaliado como sendo livre de associa@value{cedilha}@~{a}o.

@item @code{noun}
Diz ao Maxima para passar @var{a_i} como um substantivo. 
O efeito disso @'{e} substituir int@^{a}ncias de @var{a_i} com @code{'@var{a_i}}
ou @code{nounify(@var{a_i})}, ependendo do contexto.

@item @code{constant}
Diz ao Maxima para considerar @var{a_i} uma constante simb@'{o}lica.
@c WHAT MAXIMA KNOWS ABOUT SYMBOLIC CONSTANTS IS PRETTY LIMITED
@c DUNNO IF WE WANT TO GET INTO DETAILS HERE. 
@c MAYBE IN THE DOCUMENTATION FOR CONSTANT (IF THERE IS SUCH)

@item @code{scalar}
Diz ao Maxima para considerar @var{a_i} uma vari@'{a}vel escalar.

@item @code{nonscalar}
Diz ao Maxima para considerar @var{a_i} uma vari@'{a}vel n@~{a}o escalar.
The usual application is to declare a variable as a symbolic vector or matrix.

@item @code{mainvar}
Diz ao Maxima para considerar @var{a_i} uma "vari@'{a}vel principal" (@code{mainvar}).
@code{ordergreatp} determina a ordena@value{cedilha}@~{a}o de @'{a}tomos como segue:

(vari@'{a}veis principais) > (outras vari@'{a}veis) > (vari@'{a}veis escalares) > (constantes) > (n@'{u}meros)

@item @code{alphabetic}
Diz ao Maxima para reconhecer todos os caracteres em @var{a_i} (que deve ser uma seq@"{u}@^{e}ncia de caracteres) como caractere alfab@'{e}tico.

@item @code{feature}
Diz ao Maxima para reconhecer @var{a_i} como nome de um recurso.
Other atoms may then be declared to have the @var{a_i} property.

@item @code{rassociative}, @code{lassociative}
Diz ao Maxima para reconhecer @var{a_i} como uma func@~{a}o associativa a direita ou associativa a esquerda.

@item @code{nary}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~{a}o n-@'{a}ria (com muitos argumentos).

A declara@value{cedilha}@~{a}o @code{nary} n@~{a}o tem o mesmo objetivo que uma chamada @`a fun@value{cedilha}@~{a}o @code{nary}.
O @'{u}nico efeito de @code{declare(foo, nary)} @'{e} para instruir o simplificador do Maxima
a melhorar as pr@'{o}ximas express@~{o}es,
por exemplo, para simplificar @code{foo(x, foo(y, z))} para @code{foo(x, y, z)}.

@item @code{symmetric}, @code{antisymmetric}, @code{commutative}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~{a}o sim@'{e}trica ou antisim@'{e}trica.
@code{commutative} @'{e} o mesmo que @code{symmetric}.

@item
@code{oddfun}, @code{evenfun}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~{a}o par ou uma fun@value{cedilha}@~{a}o @'{i}mpar.
 
@item @code{outative}
Diz ao Maxima para simplificar express@~{o}es @var{a_i}
colocando fatores constantes em evid@^{e}ncia no primeiro argumento.

Quando @var{a_i} tiver um argumento,
um fator @'{e} onsiderado constante se for um literal ou se for declarado como sendo constante.

Quando @var{a_i} tiver dois ou mais argumentos,
um fator @'{e} considerado constante
se o segundo argumento for um s@'{i}mbolo
e o fator estiver livre do segundo argumento.

@item @code{multiplicative}
Diz ao Maxima para simplificar express@~{o}es do tipo @var{a_i}
atrav@'{e}s da substitui@value{cedilha}@~{a}o @code{@var{a_i}(x * y * z * ...)} @code{-->}
@code{@var{a_i}(x) * @var{a_i}(y) * @var{a_i}(z) * ...}.
A substitui@value{cedilha}@~{a}o @'{e} realizada no primeiro argumento somente.

@item @code{additive}
Diz ao Maxima para simplificar express@~{o}es do tipo @var{a_i}
atrav@'{e}s da substitui@value{cedilha}@~{a}o @code{@var{a_i}(x + y + z + ...)} @code{-->}
@code{@var{a_i}(x) + @var{a_i}(y) + @var{a_i}(z) + ...}.
A substitui@value{cedilha}@~{a}o @'{e} realizada no primeiro argumento somente.

@item @code{linear}
Equivalente a declarar @var{a_i} ao mesmo tempo @code{outative} e @code{additive}.

@c OBSOLETE @code{analytic} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)
 
@item @code{integer}, @code{noninteger}
Diz ao Maxima para reconhecer @var{a_i} como como uma vari@'{a}vel inteira ou como uma vari@'{a}vel n@~{a}o inteira.
 
Maxima reconhece os seguintes recursos de objetos:

@item @code{even}, @code{odd}
Diz ao Maxima para reconhecer @var{a_i} como uma vari@'{a}vel inteira par ou como uma vari@'{a}vel inteira @'{i}mpar.

@item @code{rational}, @code{irrational}
Diz ao Maxima para reconhecer @var{a_i} como uma vari@'{a}vel real e racional ou como uma vari@'{a}vel real e irracional.

@item @code{real}, @code{imaginary}, @code{complex}
Dia ao Maxima para reconhecer @var{a_i} como uma vari@'{a}vel real, imagin@'{a}ria pura ou complexa.
 
@item @code{increasing}, @code{decreasing}
Dia ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~{a}o de incremento ou decremento.
@c MAXIMA FAILS TO DEDUCE F(2) > F(1) FOR INCREASING FUNCTION F
@c AND FAILS TO DEDUCE ANYTHING AT ALL ABOUT DECREASING FUNCTIONS
@c REPORTED AS SF BUG # 1483194

@item @code{posfun}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~{a}o positiva.

@item @code{integervalued}
Diz ao Maxima para reconhecer @var{a_i} como uma fun@value{cedilha}@~{a}o de valores inteiros.

@end table

Exemplos:

Declara@value{cedilha}@~{o}es @code{evfun} e @code{evflag}.
@c ===beg===
@c declare (expand, evfun);
@c (a + b)^3;
@c (a + b)^3, expand;
@c declare (demoivre, evflag);
@c exp (a + b*%i);
@c exp (a + b*%i), demoivre;
@c ===end===
@example
(%i1) declare (expand, evfun);
(%o1)                         done
(%i2) (a + b)^3;
                                   3
(%o2)                       (b + a)
(%i3) (a + b)^3, expand;
                     3        2      2      3
(%o3)               b  + 3 a b  + 3 a  b + a
(%i4) declare (demoivre, evflag);
(%o4)                         done
(%i5) exp (a + b*%i);
                             %i b + a
(%o5)                      %e
(%i6) exp (a + b*%i), demoivre;
                      a
(%o6)               %e  (%i sin(b) + cos(b))
@end example

Declara@value{cedilha}@~{a}o @code{bindtest}.
@c ===beg===
@c aa + bb;
@c declare (aa, bindtest);
@c aa + bb;
@c aa : 1234;
@c aa + bb;
@c ===end===
@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example

Declara@value{cedilha}@~{a}o @code{noun}.
@c ===beg===
@c factor (12345678);
@c declare (factor, noun);
@c factor (12345678);
@c ''%, nouns;
@c ===end===
@example
(%i1) factor (12345678);
                             2
(%o1)                     2 3  47 14593
(%i2) declare (factor, noun);
(%o2)                         done
(%i3) factor (12345678);
(%o3)                   factor(12345678)
(%i4) ''%, nouns;
                             2
(%o4)                     2 3  47 14593
@end example

Declara@value{cedilha}@~{o}es @code{constant}, @code{scalar}, @code{nonscalar}, e @code{mainvar}.
@c ===beg===
@c declare (bb, constant);
@c declare (cc, scalar);
@c declare (dd, nonscalar);
@c declare (ee, mainvar);
@c ===end===
@example
@end example

Declara@value{cedilha}@~{a}o @code{alphabetic}.
@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example

Declara@value{cedilha}@~{a}o @code{feature}.
@c ===beg===
@c declare (FOO, feature);
@c declare (x, FOO);
@c featurep (x, FOO);
@c ===end===
@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example

Declara@value{cedilha}@~{o}es @code{rassociative} e @code{lassociative}.
@c ===beg===
@c declare (F, rassociative);
@c declare (G, lassociative);
@c ===end===
@example
@end example

Declara@value{cedilha}@~{a}o @code{nary}.
@c ===beg===
@c H (H (a, b), H (c, H (d, e)));
@c declare (H, nary);
@c H (H (a, b), H (c, H (d, e)));
@c ===end===
@example
(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
@end example

Declara@value{cedilha}@~{o}es @code{symmetric} e @code{antisymmetric}.
@c ===beg===
@c S (b, a);
@c declare (S, symmetric);
@c S (b, a);
@c S (a, c, e, d, b);
@c T (b, a);
@c declare (T, antisymmetric);
@c T (b, a);
@c T (a, c, e, d, b);
@c ===end===
@example
(%i1) S (b, a);
(%o1)                        S(b, a)
(%i2) declare (S, symmetric);
(%o2)                         done
(%i3) S (b, a);
(%o3)                        S(a, b)
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
(%i5) T (b, a);
(%o5)                        T(b, a)
(%i6) declare (T, antisymmetric);
(%o6)                         done
(%i7) T (b, a);
(%o7)                       - T(a, b)
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
@end example

Declara@value{cedilha}@~{o}es @code{oddfun} e @code{evenfun}.
@c ===beg===
@c o (- u) + o (u);
@c declare (o, oddfun);
@c o (- u) + o (u);
@c e (- u) - e (u);
@c declare (e, evenfun);
@c e (- u) - e (u);
@c ===end===
@example
(%i1) o (- u) + o (u);
(%o1)                     o(u) + o(- u)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- u) + o (u);
(%o3)                           0
(%i4) e (- u) - e (u);
(%o4)                     e(- u) - e(u)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- u) - e (u);
(%o6)                           0
@end example

Declara@value{cedilha}@~{a}o @code{outative}.
@c ===beg===
@c F1 (100 * x);
@c declare (F1, outative);
@c F1 (100 * x);
@c declare (zz, constant);
@c F1 (zz * y);
@c ===end===
@example
(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
(%i2) declare (F1, outative);
(%o2)                         done
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
(%i4) declare (zz, constant);
(%o4)                         done
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
@end example

Declara@value{cedilha}@~{a}o @code{multiplicative}.
@c ===beg===
@c F2 (a * b * c);
@c declare (F2, multiplicative);
@c F2 (a * b * c);
@c ===end===
@example
(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
(%i2) declare (F2, multiplicative);
(%o2)                         done
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
@end example

Declara@value{cedilha}@~{a}o @code{additive}.
@c ===beg===
@c F3 (a + b + c);
@c declare (F3, additive);
@c F3 (a + b + c);
@c ===end===
@example
(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
(%i2) declare (F3, additive);
(%o2)                         done
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
@end example

Declara@value{cedilha}@~{a}o @code{linear}.
@c ===beg===
@c 'sum (F(k) + G(k), k, 1, inf);
@c declare (nounify (sum), linear);
@c 'sum (F(k) + G(k), k, 1, inf);
@c ===end===
@example
(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   >    (G(k) + F(k))
                       /
                       ====
                       k = 1
(%i2) declare (nounify (sum), linear);
(%o2)                         done
(%i3) 'sum (F(k) + G(k), k, 1, inf);
                     inf          inf
                     ====         ====
                     \            \
(%o3)                 >    G(k) +  >    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} disolate (@var{expr}, @var{x_1}, ..., @var{x_n})
@'{e} similar a @code{isolate (@var{expr}, @var{x})}
exceto que essa fun@value{cedilha}@~{a}o habilita ao usu@'{a}rio isolar
mais que uma vari@'{a}vel simult@^{a}neamente.  Isso pode ser @'{u}til, por
exemplo, se se tiver tentado mudar vari@'{a}veis em uma integra@value{cedilha}@~{a}o
m@'{u}ltipla, e em mudan@value{cedilha}a de vari@'{a}vel envolvendo duas ou mais das
vari@'{a}veis de integra@value{cedilha}@~{a}o.  Essa fun@value{cedilha}@~{a}o @'{e} chamada automaticamente de
@file{simplification/disol.mac}.  Uma demostra@value{cedilha}@~{a}o est@'{a} dispon@'{i}vel atrav@'{e}s de
@code{demo("disol")$}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} dispform (@var{expr})
Retorna a representa@value{cedilha}@~{a}o externa de @var{expr} com rela@value{cedilha}@~{a}o a seu
principal operador.  Isso pode ser @'{u}til em conjun@value{cedilha}@~{a}o com @code{part} que
tamb@'{e}m lida com a representa@value{cedilha}@~{a}o externa.  Suponha que @var{expr} seja -A .
Ent@~{a}o a representa@value{cedilha}@~{a}o interna de @var{expr} @'{e}  "*"(-1,A), enquanto que
a representa@value{cedilha}@~{a}o externa @'{e} "-"(A). @code{dispform (@var{expr}, all)} converte a
express@~{a}o inteira (n@~{a}o apenas o n@'{i}vel mais alto) para o formato externo.  Por
exemplo, se @code{expr: sin (sqrt (x))}, ent@~{a}o @code{freeof (sqrt, expr)} e
@code{freeof (sqrt, dispform (expr))} fornece @code{true}, enquanto
@code{freeof (sqrt, dispform (expr, all))} fornece @code{false}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} distrib (@var{expr})
Distribue adi@value{cedilha}@~{o}es sobre produtos.  @code{distrib} difere de @code{expand}
no fato de que @code{distrib} trabalha em somente no n@'{i}vel mais alto de uma express@~{a}o, i.e., @code{distrib} n@~{a}o
@'{e} recursiva e @code{distrib} @'{e} mais r@'{a}pida que @code{expand}.  @code{distrib} difere de @code{multthru} no
que @code{distrib} expande todas as adi@value{cedilha}@~{o}es naquele n@'{i}vel.

Exemplos:

@example
(%i1) distrib ((a+b) * (c+d));
(%o1)                 b d + a d + b c + a c
(%i2) multthru ((a+b) * (c+d));
(%o2)                 (b + a) d + (b + a) c
(%i3) distrib (1/((a+b) * (c+d)));
                                1
(%o3)                    ---------------
                         (b + a) (d + c)
(%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                1
(%o4)                 ---------------------
                      b d + a d + b c + a c
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} dpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Seleciona a mesma subexpress@~{a}o que @code{part}, mas
em lugar de apenas retornar aquela subexpress@~{a}o como seu valor, isso retorna
a express@~{a}o completa com a subexpress@~{a}o selecionada mostrada dentro
de uma caixa.  A caixa @'{e} atualmente parte da express@~{a}o.

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example

@end deffn

@c PROBABLY MORE TO BE SAID HERE
@deffn {Fun@value{cedilha}@~{a}o} exp (@var{x})
Representa fun@value{cedilha}@~{a}o exponencial.  
Inst@^{a}ncias de @code{exp (@var{x})} em uma entrada s@~{a}o simplificadas para @code{%e^@var{x}};
@code{exp} n@~{a}o aparece em express@~{o}es simplificadas.

@code{demoivre} se @code{true} faz com que @code{%e^(a + b %i)} simplificar para
@code{%e^(a (cos(b) + %i sin(b)))} se @code{b} for livre de @code{%i}. veja @code{demoivre}.

@code{%emode}, quando @code{true}, 
faz com que @code{%e^(%pi %i x)} seja simplificado. Veja @code{%emode}.

@code{%enumer}, quando @code{true} faz com que @code{%e} seja substitu@'{i}do por
2.718...  quando @code{numer} for @code{true}. Veja @code{%enumer}.

@c NEED EXAMPLES HERE
@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} %emode
Valor padr@~{a}o: @code{true}

Quando @code{%emode} for @code{true},
@code{%e^(%pi %i x)} @'{e} simplificado como
segue.

@code{%e^(%pi %i x)} simplifica para @code{cos (%pi x) + %i sin (%pi x)} se @code{x} for um inteiro ou
um multiplo de 1/2, 1/3, 1/4, ou 1/6, e ent@~{a}o @'{e} adicionalmente simplificado.

Para outro @code{x} num@'{e}rico,
@code{%e^(%pi %i x)} simplifica para @code{%e^(%pi %i y)} onde @code{y} @'{e} @code{x - 2 k}
para algum inteiro @code{k} tal que @code{abs(y) < 1}.  

Quando @code{%emode} for @code{false}, nenhuma
simplifica@value{cedilha}@~{a}o adicional de @code{%e^(%pi %i x)} @'{e} realizada.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} %enumer
Valor padr@~{a}o: @code{false}

Quando @code{%enumer} for @code{true},
@code{%e} @'{e} substituido por seu valor num@'{e}rico
2.718...  mesmo que @code{numer} seja @code{true}. 

Quando @code{%enumer} for @code{false}, essa substitui@value{cedilha}@~{a}o @'{e} realizada
somente se o expoente em @code{%e^x} avaliar para um n@'{u}mero.

Veja tamb@'{e}m @code{ev} e @code{numer}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} exptisolate
Valor padr@~{a}o: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
@code{exptisolate}, quando @code{true}, faz com que @code{isolate (expr, var)}
examine expoentes de @'{a}tomos (tais como @code{%e}) que contenham @code{var}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} exptsubst
Valor padr@~{a}o: @code{false}

@code{exptsubst}, quando @code{true}, permite substitui@value{cedilha}@~{o}es tais como @code{y}
para @code{%e^x} em @code{%e^(a x)}.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} freeof (@var{x_1}, ..., @var{x_n}, @var{expr})
@code{freeof (@var{x_1}, @var{expr})}
Retorna @code{true}
se nenhuma subexpress@~{a}o de @var{expr} for igual a @var{x_1}
ou se @var{x_1} ocorrer somente uma vari@'{a}vel que n@~{a}o tenha associa@value{cedilha}@~{a}o fora da express@~{a}o @var{expr},
e retorna @code{false} de outra forma.

@code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}
@'{e} equivalente a @code{freeof (@var{x_1}, @var{expr}) and ... and freeof (@var{x_n}, @var{expr})}.

Os argumentos @var{x_1}, ..., @var{x_n} 
podem ser nomes de fun@value{cedilha}@~{o}es e vari@'{a}veis, nomes subscritos,
operadores (empacotados em aspas duplas), ou express@~{o}es gerais.
@code{freeof} avalia seus argumentos.

@code{freeof} opera somente sobre @var{expr} como isso representa (ap@'{o}s simplifica@value{cedilha}@~{a}o e avalia@value{cedilha}@~{a}o) e
n@~{a}o tenta determinar se alguma express@~{a}o equivalente pode fornecer um resultado diferente.
Em particular, simplifica@value{cedilha}@~{a}o pode retornar uma express@~{a}o equivalente mas diferente que compreende
alguns diferentes elementos da forma original de @var{expr}.

Uma vari@'{a}vel @'{e} uma vari@'{a}vel dummy em uma express@~{a}o se n@~{a}o tiver associa@value{cedilha}@~{a}o fora da express@~{a}o.
Vari@'{a}veis dummy recoreconhecidas atrav@'{e}s de @code{freeof} s@~{a}o
o @'{i}ndice de um somat@'{o}rio ou produt@'{o}rio, o limite da vari@'{a}vel em @code{limit},
a vari@'{a}vel de integra@value{cedilha}@~{a}o na forma de integral definida de @code{integrate},
a vari@'{a}vel original em @code{laplace},
vari@'{a}veis formais em expressoes @code{at},
e argumentos em express@~{o}es @code{lambda}.
Vari@'{a}veis locais em @code{block} n@~{a}o s@~{a}o reconhecidas por @code{freeof} como vari@'{a}veis dummy;
isso @'{e} um bug.

A forma indefinida de @code{integrate} @i{not} @'{e} livre de suas vari@'{a}veis de integra@value{cedilha}@~{a}o.

@itemize @bullet
@item
Argumentos s@~{a}o nomes de fun@value{cedilha}@~{o}es, vari@'{a}veis, nomes subscritos, operadores, e express@~{o}es.
@code{freeof (a, b, expr)} @'{e} equivalente a
@code{freeof (a, expr) and freeof (b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@item
@code{freeof} avalia seus argumentos.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@item
@code{freeof} n@~{a}o considera express@~{o}es equivalentes.
Simplifica@value{cedilha}@~{a}o pode retornar uma express@~{a}o equivalente mas diferente.

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

@item Um somat@'{o}rio ou uma integral definida est@'{a} livre de uma vari@'{a}vel dummy.
Uma integral indefinida n@~{a}o @'{e} livre de suas vari@'{a}veis de integra@value{cedilha}@~{a}o.

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end itemize

@end deffn

@c IS THIS DEFINITION CORRECT ??
@deffn {Fun@value{cedilha}@~{a}o} genfact (@var{x}, @var{y}, @var{z})
Retorna o fatorial generalizado, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Dessa forma, para integral @var{x},
@code{genfact (x, x, 1) = x!} e @code{genfact (x, x/2, 2) = x!!}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} imagpart (@var{expr})
Retorna a parte imagin@'{a}ria da express@~{a}o @var{expr}.

@code{imagpart} @'{e} uma fun@value{cedilha}@~{a}o computacional,
n@~{a}o uma fun@value{cedilha}@~{a}o de simplifica@value{cedilha}@~{a}o.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

Veja tamb@'{e}m @code{abs}, @code{carg}, @code{polarform}, @code{rectform},
e @code{realpart}.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} infix (@var{op})
@deffnx {Fun@value{cedilha}@~{a}o} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {Fun@value{cedilha}@~{a}o} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})
Declara @var{op} para ser um operador infixo.
Um operador infixo @'{e} uma fun@value{cedilha}@~{a}o de dois argumentos,
com o nome da fun@value{cedilha}@~{a}o escrito entre os argumentos.
Por exemplo, o operador de subtra@value{cedilha}@~{a}o @code{-} @'{e} um operador infixo.

@code{infix (@var{op})} declara @var{op} para ser um operador infixo
com expoentes associados padr@~{a}o (esquerdo e direito ambos iguais a 180)
e podendo ser qualquer entre prefixado, infixado, posfixado, n@'{a}rio, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).
@c HOW IS pos DIFFERENT FROM lpos AND rpos ??

@code{infix (@var{op}, @var{lbp}, @var{rbp})} declara @var{op} para ser um operador infixo
com expoentes associados esquerdo e diretio equilibrados
e podendo ser qualquer entre prefixado, infixado, posfixado, n@'{a}rio, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).

@code{infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}
declara @var{op} para ser um operdor infixo
com expoentes associados padr@~{a}o e podendo ser um entre 
prefixado, infixado, posfixado, n@'{a}rio, matchfix e nofix.

A preced@^{e}ncia de @var{op} com rela@value{cedilha}@~{a}o a outros operadores
derivam dos expoentes associados diretiro e esquerdo dos operadores em quest@~{a}o.
Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que o expoente associado esquerdo e o direito de algum outro operador,
ent@~{a}o @var{op} tem preded@^{e}ncia sobre o outro operador.
Se os expoentes associados n@~{a}o forem ambos maior ou menor,
alguma rela@value{cedilha}@~{a}o mais complicada ocorre.

A associatividade de @var{op} depende de seus expoentes associados.
Maior expoente associado esquerdo (@var{eae}) implica uma inst@^{a}ncia de
@var{op} @'{e} avaliadas antes de outros operadores para sua esquerda em uma express@~{a}o,
enquanto maior expoente associado direito (@var{ead}) implica uma inst@^{a}ncia de
@var{op} @'{e} avaliada antes de outros operadores para sua direita em uma express@~{a}o.
Dessa forma maior @var{eae} torna @var{op} associativo @`a direita,
enquanto maior @var{ead} torna @var{op} associativa @`a esquerda.
Se @var{eae} for igual a @var{ead}, @var{op} @'{e} associativa @`a esquerda.

Veja tamb@'{e}m @code{Syntax}.

Exemplos:

Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que os expoentes associados @`a direita e @`a esquerda de algum outro operador,
ent@~{a}o @var{op} tem preced@^{e}ncia sobre o outro operador.

@c ===beg===
@c :lisp (get '$+ 'lbp)
@c :lisp (get '$+ 'rbp)
@c infix ("##", 101, 101);
@c "##"(a, b) := sconcat("(", a, ",", b, ")");
@c 1 + a ## b + 2;
@c infix ("##", 99, 99);
@c 1 + a ## b + 2;
@c ===end===
@example
(%i1) :lisp (get '$+ 'lbp)
100
(%i1) :lisp (get '$+ 'rbp)
100
(%i1) infix ("##", 101, 101);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
(%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
(%i3) 1 + a ## b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("##", 99, 99);
(%o4)                          ##
(%i5) 1 + a ## b + 2;
(%o5)                       (a+1,b+2)
@end example

grande @var{eae} torna @var{op} associativa @`a direita,
enquanto grande @var{ead} torna @var{op} associativa @`a esquerda.

@c ===beg===
@c infix ("##", 100, 99);
@c "##"(a, b) := sconcat("(", a, ",", b, ")")$
@c foo ## bar ## baz;
@c infix ("##", 100, 101);
@c foo ## bar ## baz;
@c ===end===
@example
(%i1) infix ("##", 100, 99);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
(%i3) foo ## bar ## baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("##", 100, 101);
(%o4)                          ##
(%i5) foo ## bar ## baz;
(%o5)                    ((foo,bar),baz)
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} inflag
Velor padr@~{a}o: @code{false}

Quando @code{inflag} for @code{true}, fun@value{cedilha}@~{o}es para extra@value{cedilha}@~{a}o de
partes inspecionam a forma interna de @code{expr}.

Note que o simplificador re-organiza express@~{o}es.
Dessa forma @code{first (x + y)} retorna @code{x} se @code{inflag}
for @code{true} e @code{y} se @code{inflag} for @code{false}.
(@code{first (y + x)} fornece os mesmos resultados.)

Tamb@'{e}m, escolhendo @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} @'{e}
o mesmo que chamar @code{inpart} ou @code{substinpart}.

As fun@value{cedilha}@~{o}es afetadas pela posi@value{cedilha}@~{a}o do sinalizador @code{inflag} s@~{a}o:
@code{part}, @code{substpart}, @code{first}, @code{rest}, @code{last}, @code{length},
a estrutura @code{for} ... @code{in},
@code{map}, @code{fullmap}, @code{maplist}, @code{reveal} e @code{pickapart}.

@c NEED EXAMPLES HERE
@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})
@'{E} similar a @code{part} mas trabalha sobre a representa@value{cedilha}@~{a}o
interna da express@~{a}o em lugar da forma de exibi@value{cedilha}@~{a}o e
dessa forma pode ser mais r@'{a}pida uma vez que nenhuma formata@value{cedilha}@~{a}o @'{e} realizada.  Cuidado deve ser tomado
com rela@value{cedilha}@~{a}o @`a ordem de subexpress@~{o}es em adi@value{cedilha}@~{o}es e produtos
(uma vez que a ordem das vari@'{a}veis na forma interna @'{e} muitas vezes diferente
daquela na forma mostrada) e no manuseio com menos un@'{a}rio,
subtra@value{cedilha}@~{a}o, e divis@~{a}o (uma vez que esses operadores s@~{a}o removidos da
express@~{a}o). @code{part (x+y, 0)} ou @code{inpart (x+y, 0)} retorna @code{+}, embora com o objetivo de
referirse ao operador isso deva ser abra@value{cedilha}ado por aspas duplas.  Por exemplo
@code{... if inpart (%o9,0) = "+" then ...}.

Exemplos:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} isolate (@var{expr}, @var{x})
Retorna @var{expr} com subexpress@~{o}es que s@~{a}o adi@value{cedilha}@~{o}es e
que n@~{a}o possuem @var{x} substituido por r@'{o}tulos de express@~{a}o intermedi@'{a}ria
(esses sendo s@'{i}mbolos at@^{o}micos como @code{%t1}, @code{%t2}, ...).  Isso @'{e} muitas vezes @'{u}til
para evitar expans@~{o}es desnecess@'{a}rias de subexpress@~{o}es que n@~{a}o possuam
a vari@'{a}vel de interesse.  Uma vez que os r@'{o}tulos intermedi@'{a}rios s@~{a}o associados @`as
subexpress@~{o}es eles podem todos ser substitu@'{i}dos de volta por avalia@value{cedilha}@~{a}o da
express@~{a}o em que ocorrerem.

@code{exptisolate} (valor padr@~{a}o: @code{false}) se @code{true} far@'{a} com que @code{isolate} examine expoentes de
@'{a}tomos (como @code{%e}) que contenham @var{x}.

@code{isolate_wrt_times} se @code{true}, ent@~{a}o @code{isolate} ir@'{a} tamb@'{e}m isolar com rela@value{cedilha}@~{a}o a 
produtos. Veja @code{isolate_wrt_times}.

Fa@value{cedilha}a @code{example (isolate)} para exemplos.

@end deffn

@c NEEDS WORK
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} isolate_wrt_times
Valor padr@~{a}o: @code{false}

Quando @code{isolate_wrt_times} for @code{true}, @code{isolate}
ir@'{a} tamb@'{e}m isolar com rela@value{cedilha}@~{a}o a produtos.  E.g. compare ambas as escolhas do
comutador em

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@end defvr

@c NEEDS EXAMPLES
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} listconstvars
Valor padr@~{a}o: @code{false}

Quando @code{listconstvars} for @code{true}, isso far@'{a} com que @code{listofvars}
inclua @code{%e}, @code{%pi}, @code{%i}, e quaisquer vari@'{a}veis declaradas contantes na lista
seja retornado se aparecer na express@~{a}o que chamar @code{listofvars}.
O comportamento padr@~{a}o @'{e} omitir isso.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} listdummyvars
Valor padr@~{a}o: @code{true}

Quando @code{listdummyvars} for @code{false}, "vari@'{a}veis dummy" na
express@~{a}o n@~{a}o ser@~{a}o inclu@'{i}das na lista retornada por @code{listofvars}.
(O significado de "vari@'{a}vel dummy" @'{e} o mesmo que em @code{freeof}.
"Vari@'{a}veis dummy" s@~{a}o conceitos matem@'{a}ticos como o @'{i}ndice de um somat@'{o}rio ou
produt@'{o}rio, a vari@'{a}vel limite, e a vari@'{a}vel da integral definida.)
Exemplo:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} listofvars (@var{expr})
Retorna uma lista de vari@'{a}veis em @var{expr}.

@code{listconstvars} se @code{true} faz com que @code{listofvars} inclua @code{%e}, @code{%pi},
@code{%i}, e quaisquer vari@'{a}veis declaradas constantes na lista @'{e} retornada se
aparecer em @var{expr}.  O comportamento padr@~{a}o @'{e} omitir isso.

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} lfreeof (@var{lista}, @var{expr})
Para cada um dos membros @var{m} de lista, chama @code{freeof (@var{m}, @var{expr})}.
Retorna @code{false} se qualquer chamada a @code{freeof} for feita e @code{true} de outra forma.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lopow (@var{expr}, @var{x})
Retorna o menor expoente de @var{x} que explicitamente aparecer em
@var{expr}.  Dessa forma

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} lpart (@var{r@'{o}tulo}, @var{expr}, @var{n_1}, ..., @var{n_k})
@'{e} similar a @code{dpart} mas usa uma
caixa rotulada. Uma moldura rotulada @'{e} similar @`a que @'{e} produzida por @code{dpart}
mas a produzida por @code{lpart} tem o nome na linha do topo.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} multthru (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} multthru (@var{expr_1}, @var{expr_2})
Multiplica um fator (que pode ser uma adi@value{cedilha}@~{a}o) de @var{expr} pelos
outros fatores de @var{expr}.  Isto @'{e}, @var{expr} @'{e} @code{@var{f_1} @var{f_2} ... @var{f_n}}
onde ao menos
um fator, digamos @var{f_i}, @'{e} uma soma de termos.  Cada termo naquela soma @'{e}
multiplicado por outros fatores no produto.  (A saber todos os
fatores exceto @var{f_i}).  @code{multthru} n@~{a}o expande somas exponenciais.
Essa fun@value{cedilha}@~{a}o @'{e} o caminho mais r@'{a}pido para distribuir produtos (comutativos
ou n@~{a}o) sobre adi@value{cedilha}@~{o}es.  Uma vez que quocientes s@~{a}o representados como
produtos @code{multthru} podem ser usados para dividir adi@value{cedilha}@~{o}es por produtos tamb@'{e}m.

@code{multthru (@var{expr_1}, @var{expr_2})} multiplica cada termo em @var{expr_2} (que pode ser uma
adi@value{cedilha}@~{a}o ou uma equ@value{cedilha}@~{a}o) por @var{expr_1}.  Se @var{expr_1} n@~{a}o for por si mesmo uma adi@value{cedilha}@~{a}o ent@~{a}o essa
forma @'{e} equivalente a @code{multthru (@var{expr_1}*@var{expr_2})}.

@example
(%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                      1        x         f(x)
(%o1)             - ----- + -------- - --------
                    x - y          2          3
                            (x - y)    (x - y)
(%i2) multthru ((x-y)^3, %);
                           2
(%o2)             - (x - y)  + x (x - y) - f(x)
(%i3) ratexpand (%);
                           2
(%o3)                   - y  + x y - f(x)
(%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                        10  2              2  2
                 (b + a)   s  + 2 a b s + a  b
(%o4)            ------------------------------
                                  2
                             a b s
(%i5) multthru (%);  /* note que isso n@~{a}o expande (b+a)^10 */
                                        10
                       2   a b   (b + a)
(%o5)                  - + --- + ---------
                       s    2       a b
                           s
(%i6) multthru (a.(b+c.(d+e)+f));
(%o6)            a . f + a . c . (e + d) + a . b
(%i7) expand (a.(b+c.(d+e)+f));
(%o7)         a . f + a . c . e + a . c . d + a . b
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} nounify (@var{f})
Retorna a forma substantiva do nome da fun@value{cedilha}@~{a}o @var{f}.  Isso @'{e}
necess@'{a}rio se se quer referir ao nome de uma fun@value{cedilha}@~{a}o verbo como se esse nome
fosse um substantivo.  Note que algumas fun@value{cedilha}@~{o}es verbos ir@~{a}o retornar sua forma
substantiva sen@~{a}o puderem ser avaliadas para certos argumentos.  A forma substantiva @'{e} tamb@'{e}m
a forma retornada se uma chamada de fun@value{cedilha}@~{a}o @'{e} precedida por um ap@'{o}strofo.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} nterms (@var{expr})
Retorna o n@'{u}mero de termos que @var{expr} pode ter se for
completamente expandida e nenhum cancelamento ou combina@value{cedilha}@~{a}o de termos
acontecer.
Note express@~{o}es como @code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})}, etc.
contam como apenas um termo independentemente de quantos termos @var{expr} tenha (se @var{expr} for uma
adi@value{cedilha}@~{a}o).

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} op (@var{expr})
Retorna o operador principal da express@~{a}o @var{expr}.
@code{op (@var{expr})} @'{e} equivalente a @code{part (@var{expr}, 0)}. 

@code{op} retorna uma seq@"{u}@^{e}ncia de caracteres se o operador principal for uma
operador interno ou definido pelo usu@'{a}rio como
prefixado, bin@'{a}rio ou n-@'{a}rio infixo, posfixado, matchfix ou nofix.
De outra forma, se @var{expr} for uma express@~ao de fun@value{cedilha}@~ao subscrita,
@code{op} retorna uma fun@value{cedilha}@~ao subscrita;
nesse caso o valor de retorno n@~ao @'e um @'atomo.
De outro modo, @var{expr} @'e uma fun@value{cedilha}@~ao de array ou uma express@~ao de fun@value{cedilha}@~ao comum,
e @code{op} retorna um s@'imbolo.

@code{op} observa o valor do sinalizador global @code{inflag}.

@code{op} avalia seus argumentos.

Veja tamb@'{e}m @code{args}.

Exemplos:

@c ===beg===
@c stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c op (F [x, y] (a, b, c));
@c op (G [u, v, w]);
@c ===end===

@example
(%i1) stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
(%i12) op (F [x, y] (a, b, c));
(%o12)                        F
                               x, y
(%i13) op (G [u, v, w]);
(%o13)                          G
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} operatorp (@var{expr}, @var{op})
@deffnx {Fun@value{cedilha}@~{a}o} operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])

@code{operatorp (@var{expr}, @var{op})} retorna @code{true}
se @var{op} for igual ao operador de @var{expr}.

@code{operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])} retorna @code{true}
se algum elementos de @var{op_1}, ..., @var{op_n} for igual ao operador de @var{expr}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} optimize (@var{expr})
Retorna uma express@~{a}o que produz o mesmo valor e
efeito que @var{expr} mas faz de forma mais eficientemente por evitar a
recomputa@value{cedilha}@~{a}o de subexpress@~{o}es comuns.  @code{optimize} tamb@'{e}m tem o mesmo
efeito de "colapsar" seus argumentos de forma que todas as subexpress@~{o}es comuns
s@~{a}o compartilhadas.
Fa@value{cedilha}a @code{example (optimize)} para exemplos.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} optimprefix
Valor padr@~{a}o: @code{%}

@code{optimprefix} @'{e} o prefixo usado para s@'{i}mbolos gerados pelo
comando @code{optimize}.

@end defvr

@c NEEDS WORK
@c WHAT DOES ">" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~{a}o} ordergreat (@var{v_1}, ..., @var{v_n})
Escolhe aliases para as vari@'{a}veis @var{v_1}, ..., @var{v_n}
tais que @var{v_1} > @var{v_2} > ...  > @var{v_n},
e @var{v_n} > qualquer outra vari@'{a}vel n@~{a}o mencionada como um
argumento.

Veja tamb@'{e}m @code{orderless}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~{a}o} ordergreatp (@var{expr_1}, @var{expr_2})
Retorna @code{true} se @var{expr_2} precede @var{expr_1} na
ordena@value{cedilha}@~{a}o escolhida com a fun@value{cedilha}@~{a}o @code{ordergreat}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "<" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~{a}o} orderless (@var{v_1}, ..., @var{v_n})
Escolhe aliases para as vari@'{a}veis @var{v_1}, ..., @var{v_n}
tais que @var{v_1} < @var{v_2} < ...  < @var{v_n},
and @var{v_n} < qualquer outra vari@'{a}vel n@~{a}o mencionada como um
argumento.

@c EXPRESS THIS ORDER IN A MORE COMPREHENSIBLE FASHION
Dessa forma a escala de ordena@value{cedilha}@~{a}o completa @'{e}: constantes num@'{e}ricas <
constantes declaradas < escalares declarados < primeiro argumento para @code{orderless} <
...  < @'{u}ltimo argumento para @code{orderless} < vari@'{a}veis que come@value{cedilha}am com A < ...
< vari@'{a}veis que come@value{cedilha}am com Z < @'{u}ltimo argumento para @code{ordergreat} <
 ... < primeiro argumento para @code{ordergreat} < @code{mainvar}s - vari@'{a}veis principais declaradas.

Veja tamb@'{e}m @code{ordergreat} e @code{mainvar}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~{a}o} orderlessp (@var{expr_1}, @var{expr_2})
Retorna @code{true} se @var{expr_1} precede @var{expr_2} na
ordena@value{cedilha}@~{a}o escolhida pelo comando @code{orderless}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} part (@var{expr}, @var{n_1}, ..., @var{n_k})
Retorna partes da forma exibida de @code{expr}. Essa fun@value{cedilha}@~{a}o
obt@'{e}m a parte de @code{expr} como especificado pelos @'{i}ndices @var{n_1}, ..., @var{n_k}.  A primeira
parte @var{n_1} de @code{expr} @'{e} obtida, ent@~{a}o a parte @var{n_2} daquela  @'{e} obtida, etc.  O resultado @'{e}
parte @var{n_k} de ... parte @var{n_2} da parte @var{n_1} da @code{expr}.

@code{part} pode ser usada para obter um elemento de uma lista, uma linha de uma matriz, etc.

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
Se o @'{u}ltimo argumento para uma fun@value{cedilha}@~{a}o @code{part} for uma lista de @'{i}ndices ent@~{a}o
muitas subexpress@~{o}es ser@~{a}o pin@value{cedilha}adas, cada uma correspondendo a um
@'{i}ndice da lista.  Dessa forma @code{part (x + y + z, [1, 3])} @'{e} @code{z+x}.

@code{piece} mant@'{e}m a @'{u}ltima express@~{a}o selecionada quando usando as fun@value{cedilha}@~{o}es
@code{part}.  Isso @'{e} escolhido durante a execu@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o e dessa forma
pode referir-se @`a fun@value{cedilha}@~{a}o em si mesma como mostrado abaixo.

Se @code{partswitch} for escolhido para @code{true} ent@~{a}o @code{end} @'{e} retornado quando uma
parte selecionada de uma express@~{a}o n@~{a}o existir, de outra forma uma mensagem de
erro @'{e} forncecida.

@c NEED "SEE ALSO" POINTING TO ALL OTHER PART FUNCTIONS

Exemplo: @code{part (z+2*y, 2, 1)} retorna 2.

@c MERGE IN example (part) OUTPUT HERE
@code{example (part)} mostra exemplos adicionais.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} partition (@var{expr}, @var{x})
Retorna uma lista de duas express@~{o}es.  Elas s@~{a}o (1)
os fatores de @var{expr} (se essa express@~{a}o for um produto), os termos de @var{expr} (se isso for uma
adi@value{cedilha}@~{a}o), ou a lista (se isso for uma lsita) que n@~{a}o contiver @code{var} e, (2)
os fatores, termos, ou lista que faz.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@end deffn

@c NEEDS EXAMPLE
@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} partswitch
Valor padr@~{a}o: @code{false}

Quando @code{partswitch} for @code{true}, @code{end} @'{e} retornado
quando uma parte selecionada de uma express@~{a}o n@~{a}o existir, de outra forma uma
mensagem de erro @'{e} fornecida.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} pickapart (@var{expr}, @var{n})
Atribui r@'{o}tulos de express@~{a}o intermedi@'{a}ria a subexpress@~{o}es de
@var{expr} de comprimento @var{n}, um inteiro.
A subexpress@~{o}es maiores ou menores n@~{a}o s@~{a}o atribuidos r@'{o}tulos.
@code{pickapart} retorna uma express@~{a}o em termos de express@~{o}es intermedi@'{a}rias
equivalentes @`a express@~{a}o original @var{expr}.

Veja tamb@'{e}m @code{part}, @code{dpart}, @code{lpart}, @code{inpart}, e @code{reveal}.

Exemplos:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@end deffn

@c NEEDS WORK
@defvr {Vari@'{a}vel de sistema} piece
Mant@'{e}m a ultima express@~{a}o selecionada quando usando fun@value{cedilha}@~{o}es
@code{part}.
@c WHAT DOES THIS MEAN EXACTLY ??
Isso @'{e} escolhido durante a execu@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o e dessa forma
pode referir-se @`a fun@value{cedilha}@~{a}o em si mesma.

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@end defvr

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} polarform (@var{expr})
Retorna uma express@~{a}o @code{r %e^(%i theta)} equivalente a @var{expr},
tal que @code{r} e @code{theta} sejam puramente reais.

@end deffn

@c ISN'T THERE AN EQUIVALENT FUNCTION SOMEWHERE ??
@c NEEDS WORK (IF KEPT)
@deffn {Fun@value{cedilha}@~{a}o} powers (@var{expr}, @var{x})
Fornece os expoentes de @var{x} que ocorrem em express@~{a}o @var{expr}.

@code{load (powers)} chama essa fun@value{cedilha}@~{a}o.
@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Representa um produto dos velores de @code{expr} com
o @'{i}ndice @var{i} variando de @var{i_0} a @var{i_1}.
A forma substantiva @code{'product} @'{e} mostrada como um pi mai@'{i}sculo.

@code{product} avalia @var{expr} e os limites inferior e superior @var{i_0} e @var{i_1},
@code{product} coloca um ap@'{o}strofo (n@~{a}o avalia) o @'{i}ndice @var{i}.

Se os limites superiores e inferiores diferirem por um inteiro,
@var{expr} @'{e} avaliada para cada valor do @'{i}ndice @var{i},
e o resultado  um produto expl@'{i}cito.

de outra forma, o intervalo do @'{i}ndice @'{e} indefinido.
Algumas regras s@~{a}o aplicads para simplificar o produto.
Quando a vari@'{a}vel global @code{simpproduct} for @code{true}, regras adicionais s@~{a}o aplicadas.
Em alguns casos, simplifica@value{cedilha}@~{a}o um resultado que n@~{a}o @'{e} um produto;
de outra forma, o resultado @'{e} uma forma substantiva @code{'product}.

Veja tamb@'{e}m @code{nouns} e @code{evflag}.

Exemplos:

@c ===beg===
@c product (x + i*(i+1)/2, i, 1, 4);
@c product (i^2, i, 1, 7);
@c product (a[i], i, 1, 7);
@c product (a(i), i, 1, 7);
@c product (a(i), i, 1, n);
@c product (k, k, 1, n);
@c product (k, k, 1, n), simpproduct;
@c product (integrate (x^k, x, 0, 1), k, 1, n);
@c product (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example

@end deffn

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} realpart (@var{expr})
Retorna a parte real de @var{expr}. @code{realpart} e @code{imagpart} ir@~{a}o
trabalhar sobre express@~{o}es envolvendo fun@value{cedilha}@~{o}es trigonom@'{e}tricas e hiperb@'{o}licas,
bem como ra@'{i}zes quadradas, logar@'{i}tmos, e exponencia@value{cedilha}@~{a}o.

@end deffn

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} rectform (@var{expr})
Retorna uma express@~{a}o @code{a + b %i} equivalente a @var{expr},
tal que @var{a} e @var{b} sejam puramente reais.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rembox (@var{expr}, unlabelled)
@deffnx {Fun@value{cedilha}@~{a}o} rembox (@var{expr}, @var{r@'{o}tulo})
@deffnx {Fun@value{cedilha}@~{a}o} rembox (@var{expr})
Remove caixas de @var{expr}.

@code{rembox (@var{expr}, unlabelled)} remove todas as caixas sem r@'{o}tulos de @var{expr}.

@code{rembox (@var{expr}, @var{r@'{o}tulo})} remove somente caixas contendo @var{r@'{o}tulo}.

@code{rembox (@var{expr})} remove todas as caixas, rotuladas e n@~{a} rotuladas.

Caixas s@~{a}o desenhadas pelas fun@value{cedilha}@~{o}es @code{box}, @code{dpart}, e @code{lpart}.

Exemplos:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Representa um somat@'{o}rio dos valores de @var{expr} com
o @'{i}ndice @var{i} variando de @var{i_0} a @var{i_1}.
A forma substantiva @code{'sum} @'{e} mostrada com uma letra sigma mai@'{u}scula.
@code{sum} avalia seu somando @var{expr} e limites inferior e superior @var{i_0} e @var{i_1},
@code{sum} coloca ap@'{o}strofo (n@~{a}o avalia) o @'{i}ndice @var{i}.

Se os limites superiores e inferiores diferirem de um n@'{u}mero inteiro,
o somatoriando @var{expr} @'{e} avaliado para cada valor do @'{i}ndice do somat@'{o}rio @var{i},
e o resultado @'{e} uma adi@value{cedilha}@~{a}o expl@'{i}cita.

De outra forma, o intervalo dos @'{i}ndices @'{e} indefinido.
Algumas regras s@~{a}o aplicadas para simplificar o somat@'{o}rio.
Quando a vari@'{a}vel global @code{simpsum} for @code{true}, regras adicionais s@~{a}o aplicadas.
Em alguns casos, simplifica@value{cedilha}@~{o}es retornam um resultado que n@~{a}o @'{e} um somat@'{o}rio;
de outra forma, o resultado @'{e} uma forma substantiva @code{'sum}.

Quando o @code{evflag} (sinalizador de avalia@value{cedilha}@~{a}o) @code{cauchysum} for @code{true},
um produto de somat@'{o}rios @'{e} mostrado como um produto de Cauchy,
no qual o @'{i}ndice do somat@'{o}rio mais interno @'{e} uma fun@value{cedilha}@~{a}o de
@'{i}ndice de um n@'{i}vel acima, em lugar de variar independentemente.

A vari@'{a}vel global @code{genindex} @'{e} o prefixo alfab@'{e}tico usado para gerar o pr@'{o}ximo @'{i}ndice do somat@'{o}rio,
quando um @'{i}ndice automaticamente gerado for necess@'{a}rio.

@code{gensumnum} @'{e} o sufixo num@'{e}rico usando para gerar o pr@'{o}ximo @'{i}ndice do somat@'{o}rio,
quando um @'{i}ndice gerado automaticamente for necess@'{a}rio.
Quando @code{gensumnum} for @code{false}, um @'{i}ndice gerado automaticamente @'{e} somente
@code{genindex} sem sufixo num@'{e}rico.

Veja tamb@'{e}m @code{sumcontract}, @code{intosum},
@code{bashindices}, @code{niceindices},
@code{nouns}, @code{evflag}, e @code{zeilberger}.

Exemplos:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c sum (2^i + i^2, i, 0, n);
@c sum (2^i + i^2, i, 0, n), simpsum;
@c sum (1/3^i, i, 1, inf);
@c sum (1/3^i, i, 1, inf), simpsum;
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
@c sum (integrate (x^k, x, 0, 1), k, 1, n);
@c sum (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===

@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
Incorrect syntax: Too many )'s
else b^k, k, 1, 10))
                  ^
(%i12) linenum:11;
(%o11)                         11
(%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o12)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lsum (@var{expr}, @var{x}, @var{L})
Representas a adi@value{cedilha}@~{a}o de @var{expr} a cada elemento @var{x} em @var{L}.

Uma forma substantiva @code{'lsum} @'{e} retornada
se o argumento @var{L} n@~{a}o avaliar para uma lista.

Exemplos:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} verbify (@var{f})
Retorna a forma verbal da fun@value{cedilha}@~{a}o chamada @var{f}.

Veja tamb@'{e}m @code{verb}, @code{noun}, e @code{nounify}.

Exemplos:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@end deffn
