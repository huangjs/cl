@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Itensor.texi/1.41/Sat Jun  2 00:12:54 2007//
@c RECOMMEND REVISE TEXT THROUGHOUT TO LOSE NOTION OF TIME RELATIVE TO PRESENT
@c LOOK FOR "NOW", "OLD", "NEW", "RECENT", "EARLIER", DATES

@c RERUN EXAMPLES WITH ADDT'L WHITESPACE IN INPUT TO AID LEGIBILITY

@menu
* Introdu@value{cedilha}@~{a}o a itensor::
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para itensor::
@end menu

@node Introdu@value{cedilha}@~{a}o a itensor, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para itensor, itensor, itensor
@section Introdu@value{cedilha}@~{a}o a itensor

Maxima implementa a manipula@value{cedilha}@~{a}o de tensores simb@'{o}licos d dois tipos distintos:
manipula@value{cedilha}@~{a}o de componentes de tensores (pacote @code{ctensor}) e manipula@value{cedilha}@~{a}o de tensores indiciais (pacote @code{itensor}).

Note bem: Por favor veja a nota sobre 'nova nota@value{cedilha}@~{a}o de tensor' abaixo.

Manipula@value{cedilha}@~{a}o de componentes de tensores significa que objetos do tipo
tensor geom@'{e}trico s@~{a}o representados como arrays ou matrizes. Opera@value{cedilha}@~{o}es com tensores tais com
contra@value{cedilha}@~{a}o ou diferencia@value{cedilha}@~{a}o covariante s@~{a}o realizadas
sobre @'{i}ndices (que ocorrem exatamente duas vezes) repetidos com declara@value{cedilha}@~{o}es @code{do}.
Isto @'{e}, se executa explicitamente opera@value{cedilha}@~{o}es sobre as componentes apropriadas do
tensor armazenadas em um array ou uma matriz.

Manipula@value{cedilha}@~{a}o tensorial de @'{i}ndice @'{e} implementada atrav@'{e}s da representa@value{cedilha}@~{a}o
de tensores como fun@value{cedilha}@~{o}es e suas covariantes, contravariantes e @'{i}ndices de
deriva@value{cedilha}@~{a}o. Opera@value{cedilha}@~{o}es com tensores como contra@value{cedilha}@~{a}o ou diferencia@value{cedilha}@~{a}o
covariante s@~{a}o executadas atrav@'{e}s de manipula@value{cedilha}@~{a}o dos @'{i}ndices em si mesmos
em lugar das componentes para as quais eles correspondem.

Esses dois m@'{e}todos aproximam-se do tratamento de processos diferenciais, alg@'{e}bricos e
anal@'{i}ticos no contexto da geometria de Riemannian possuem v@'{a}rias
vantagens e desvantagens as quais se revelam por si mesmas somente apesar da
natureza particular e dificuldade dos problemas de usu@'{a}rio.  Todavia, se
pode ter em mente as seguintes caracter@'{i}sticas das duas
implementa@value{cedilha}@~{o}es:

As representa@value{cedilha}@~{o}es de tensores e de opera@value{cedilha}@~{o}es com tensores explicitamente em
termos de seus componntes tornam o pacote @code{ctensor} f@'{a}cil de usar. Especifica@value{cedilha}@~{a}o da
m@'{e}trica e o c@'{a}lculo de tensores induzidos e invariantes
@'{e} direto. Embora todas a capacidade de simplifica@value{cedilha}@~{a}o poderosa do
Maxima est@'{a} em manusear, uma m@'{e}trica complexa com intrincada depend@^{e}ncia funcional
e de coordenadas pode facilmente conduzir a express@~{o}es cujo tamanho @'{e}
excessivo e cuja estrutura est@'{a} escondida. Adicionalmente, muitos c@'{a}lculos
envolvem express@~{o}es intermedi@'{a}rias cujo crescimento fazem com que os programas
terminem antes de serem completados. Atrav@'{e}s da experi@^{e}ncia, um usu@'{a}rio pode evitar
muitas dessas dificuldade.

O motivo de caminhos especiais atrav@'{e}s dos quais tensores e opera@value{cedilha}@~{o}es de tensores
s@~{a}o representados em termos de opera@value{cedilha}@~{o}es simb@'{o}licas sobre seus @'{i}ndices,
express@~{o}es cujas representa@value{cedilha}@~{a}o de componentes podem ser
n@~{a}o gerenciaveis da forma comum podem algumas vezes serem grandemente simplificadas atrav@'{e}s do uso das rotinas
especiais para objetos sim@'{e}tricos em @code{itensor}. Nesse caminho a estrutura
de uma express@~{a}o grande pode ser mais transparente. Por outro lado, o motivo
da representa@value{cedilha}@~{a}o indicial especial em @code{itensor}, faz com que em alguns casos o
usu@'{a}rio possa encontrar dificuldade com a especifica@value{cedilha}@~{a}o da m@'{e}trica, defini@value{cedilha}@~{a}o
de fun@value{cedilha}@~{a}o, e a avalia@value{cedilha}@~{a}o de objetos "indexados" diferenciados.

@subsection Nova nota@value{cedilha}@~{a}o d tensores

At@'{e} agora, o pacote @code{itensor} no Maxima tinha usado uma nota@value{cedilha}@~{a}o que algumas vezes
conduzia a ordena@value{cedilha}@~{a}o incorreta de @'{i}ndices. Considere o seguinte, por exemplo:

@example
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
@end example

O resultado est@'{a} incorreto a menos que ocorra ser @code{a} um tensor sim@'{e}trico.
A raz@~{a}o para isso @'{e} que embora @code{itensor} mantenha corretamente
a ordem dentro do conjunto de @'{i}ndices covariantes e contravariantes, assim que um
@'{i}ndice @'{e} incrementado ou decrementado, sua posi@value{cedilha}@~{a}o relativa para o outro conjunto de
@'{i}ndices @'{e} perdida.

Para evitar esse problema, uma nova nota@value{cedilha}@~{a}o tem sido desenvolvida que mant@'{e}m total
compatibilidade com a nota@value{cedilha}@~{a}o existente e pode ser usada intercambiavelmente. Nessa
nota@value{cedilha}@~{a}o, @'{i}ndices contravariantes s@~{a}o inseridos na posi@value{cedilha}@~{a}o
apropriada na lista de @'{i}ndices covariantes, mas com um sinal de menos colocado antes.
Fun@value{cedilha}@~{o}es como @code{contract} e @code{ishow} est@~{a}o agora consciente dessa
nova nota@value{cedilha}@~{a}o de @'{i}ndice e podem processar tensores apropriadamente.

Nessa nova nota@value{cedilha}@~{a}o, o exemplo anterior retorna um resultado correto:

@example
(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
@end example

Presentemente, o @'{u}nico c@'{o}digo que faz uso dessa nota@value{cedilha}@~{a}o @'{e} a fun@value{cedilha}@~{a}o
@code{lc2kdt}. Atrav@'{e}s dessa nota@value{cedilha}@~{a}o, a fun@value{cedilha}@~{a}o @code{lc2kdt} encontra com @^{e}xito resultados consistentes como
a aplica@value{cedilha}@~{a}o do tensor m@'{e}trico para resolver os s@'{i}mbolos de Levi-Civita sem reordenar
para @'{i}ndices num@'{e}ricos.

Uma vez que esse c@'{o}digo @'{e} um tipo novo, provavelmente cont@'{e}m erros. Enquanto esse tipo novo n@~{a}o tiver sido
testado para garantir que ele n@~{a}o interrompe nada usando a "antiga" nota@value{cedilha}@~{a}o de
tensor, existe uma consider@'{a}vel chance que "novos" tensores ir@~{a}o falhar em
interoperar com certas fun@value{cedilha}@~{o}es ou recursos. Essas falhas ser@~{a}o corrigidas
@`a medida que forem encontradas... at@'{e} ent@~{a}o, seja cuidadoso!


@subsection Manipula@value{cedilha}@~{a}o de tensores indiciais

o pacote de manipula@value{cedilha}@~{a}o de tensores indiciais pode ser chamado atrav@'{e}s de
@code{load(itensor)}. Demonsta@value{cedilha}@~{o}es est@~{a}o tamb@'{e}m dispon@'{i}veis: tente @code{demo(tensor)}.
Em @code{itensor} um tensor @'{e} representado como um "objeto indexado" .  Um "objeto indexado" @'{e} uma
fun@value{cedilha}@~{a}o de 3 grupos de @'{i}ndices os quais representam o covariante,
o contravariante e o @'{i}ndice de deriva@value{cedilha}@~{a}o.  Os @'{i}ndices covariantes s@~{a}o
especificados atrav@'{e}s de uma lista com o primeiro argumento para o objeto indexado, e
os @'{i}ndices contravariantes atrav@'{e}s de uma lista como segundo argumento. Se o
objeto indexado carece de algum desses grupos de @'{i}ndices ent@~{a}o a lista
vazia @code{[]} @'{e} fornecida como o argumento correspondente.  Dessa forma, @code{g([a,b],[c])}
representa um objeto indexado chamado @code{g} o qual tem dois @'{i}ndices covariantes
@code{(a,b)}, um @'{i}ndice contravariante (@code{c}) e n@~{a}o possui @'{i}ndices de deriva@value{cedilha}@~{a}o.

Os @'{i}ndices de deriva@value{cedilha}@~{a}o, se estiverem presente, s@~{a}o anexados ao final como
argumentos adicionais para a fun@value{cedilha}@~{a}o num@'{e}rica representando o tensor.
Eles podem ser explicitamente especificado pelo usu@'{a}rio ou serem criados no
processo de diferencia@value{cedilha}@~{a}o com rela@value{cedilha}@~{a}o a alguma vari@'{a}vel coordenada.
Uma vez que diferencia@value{cedilha}@~{a}o ordin@'{a}ria @'{e} comutativa, os @'{i}ndices de deriva@value{cedilha}@~{a}o
s@~{a}o ordenados alfanumericamente, a menos que @code{iframe_flag} seja escolhida para @code{true},
indicando que uma moldura m@'{e}trica est@'{a} sendo usada. Essa ordena@value{cedilha}@~{a}o can@^{o}nica torna
poss@'{i}vel para Maxima reconhecer que, por exemplo, @code{t([a],[b],i,j)} @'{e}
o mesmo que @code{t([a],[b],j,i)}.  Diferencia@value{cedilha}@~{a}o de um objeto indexado com
rela@value{cedilha}@~{a}o a alguma coordenada cujos @'{i}ndices n@~{a}o aparecem como um argumento
para o objeto indexado podem normalmente retornar zero. Isso @'{e} porque
Maxima pode n@~{a}o saber que o tensor representado atrav@'{e}s do objeto
indexado poss@'{i}velmente depende implicitamente da respectiva coordenada.  Pela
modifica@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o existente no Maxima, @code{diff},  em @code{itensor}, Maxima sabe
assumir que todos os objetos indexados dependem de qualquer vari@'{a}vel de
diferencia@value{cedilha}@~{a}o a menos que seja declarado de outra forma.  Isso torna poss@'{i}vel para
a conven@value{cedilha}@`ao de somat@'{o}rio ser extendida para @'{i}ndices derivativos. Pode
ser verificado que @code{itensor} n@~{a}o possui a compatibilidade de
incrementar @'{i}ndices derivativos, e ent@~{a}o eles s@~{a}o sempre tratados como
covariantes.

As seguintes fun@value{cedilha}@~{o}es est@~{a}o dispon@'{i}veis no pacote tensor para
manipula@value{cedilha}@~{a}o de objetos.  Atualmente, com rela@value{cedilha}@~{a}o @`as
rotinas de simplifica@value{cedilha}@~{a}o, @'{e} assumido que objetos indexados n@~{a}o
possuem por padr@~{a}o propriedades sim@'{e}tricas. Isso pode ser modificado atrav@'{e}s
da escolha da vari@'{a}vel @code{allsym[false]} para @code{true}, o que ir@'{a}
resultar no tratamento de todos os objetos indexados completamente sim@'{e}tricos em suas
listas de @'{i}ndices covariantes e sim@'{e}tricos em suas listas de
@'{i}ndices contravariantes.

O pacote @code{itensor} geralmente trata tensores como objetos opacos. Equa@value{cedilha}@~{o}es
tensoriais s@~{a}o manipuladas baseadas em regras alg@'{e}bricas, especificamente simetria
e regras de contra@value{cedilha}@~{a}o. Adicionalmente, o pacote @code{itensor} n@~{a}o entende
diferencia@value{cedilha}@~{a}o covariante, curvatura, e tors@~{a}o. C@'{a}lculos podem ser
executados relativamente a um m@'{e}trica de molduras de movimento, dependendo da escolha para
a vari@'{a}vel @code{iframe_flag}.

Uma sess@~{a}o demonstrativa abaixo mostra como chamar o pacote @code{itensor},
especificando o nome da m@'{e}trica, e executando alguns c@'{a}lculos simples.

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
               %4 %5
(%t12) v    - g      v   (e p       + e   p     - e p       - e    p
        i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                + e p       + e   p    )/2
                                                     i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %8                    %6 %8
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %8 i             %6    i j %8      i,j

                                                    %6 %8
                                               - ifg      v   ifb      )/2
                                                           %6    %8 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
@end example



@c end concepts itensor

@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para itensor,  , Introdu@value{cedilha}@~{a}o a itensor, itensor

@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para itensor
@subsection Gerenciando objetos indexados

@deffn {Fun@value{cedilha}@~{a}o} entertensor (@var{nome})

@'{E} uma fun@value{cedilha}@~{a}o que, atrav@'{e}s da linha de comando, permite criar um objeto
indexado chamado @var{nome} com qualquer n@'{u}mero de @'{i}ndices de tensores e
derivativos. Ou um @'{i}ndice simples ou uma lista de @'{i}ndices (@`as quais podem ser
nulas) s@~{a}o entradas aceit@'{a}veis (veja o exemplo sob @code{covdiff}).

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} changename (@var{antigo}, @var{novo}, @var{expr})

Ir@'{a} mudar o nome de todos os objetos indexados chamados @var{antigo} para @var{novo}
em @var{expr}. @var{antigo} pode ser ou um s@'{i}mbolo ou uma lista da forma
@code{[@var{nome}, @var{m}, @var{n}]} nesse caso somente esses objetos indexados chamados
@var{nome} com @'{i}ndice covariante @var{m} e @'{i}ndice contravariante @var{n} ser@~{a}o
renomeados para @var{novo}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} listoftens

Lista todos os tensores em uma express@~{a}o tensorial, incluindo seus @'{i}ndices. E.g.,

@example

(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ishow (@var{expr})

Mostra @var{expr} com os objetos indexados tendo seus
@'{i}ndices covariantes como subscritos e @'{i}ndices contravariantes como
sobrescritos.  Os @'{i}ndices derivativos s@~{a}o mostrados como subscritos,
separados dos @'{i}ndices covariantes por uma v@'{i}rgula (veja os exemplos
atrav@'{e}s desse documento).

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} indices (@var{expr})

Retorna uma lista de dois elementos.  O primeiro @'{e} uma lista de @'{i}ndices
livres em @var{expr} (aqueles que ocorrem somente uma vez). O segundo @'{e} uma
lista de indices que ocorrem exatamente duas vezes em @var{expr} (dummy)
como demonstra o seguinte exemplo.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

@end example

Um produto de tensores contendo o mesmo @'{i}ndice mais que duas vezes @'{e} sintaticamente
ilegal. @code{indices} tenta lidar com essas express@~{o}es de uma
forma razo@'{a}vel; todavia, quando @code{indices} @'{e} chamada para operar sobre tal uma
express@~{a}o ilegal, seu comportamento pode ser considerado indefinido.


@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rename (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} rename (@var{expr}, @var{contador})

Retorna uma express@~{a}o equivalente para @var{expr} mas com @'{i}ndices que ocorrem exatamente duas vezes
em cada termo alterado do conjunto @code{[%1, %2,...]}, se o segundo argumento
opcional for omitido. De outra forma, os @'{i}ndices que ocorrem exatamente duas vezes s@~{a}o indexados
come@value{cedilha}ando no valor de @var{contador}.  Cada @'{i}ndice que ocorre exatamente duas vezes em um produto
ser@'{a} diferente. Para uma adi@value{cedilha}@~{a}o, @code{rename} ir@'{a} operar sobre cada termo na
a adi@value{cedilha}@~{a}o zerando o contador com cada termo. Nesse caminho @code{rename} pode
servir como um simplificador tensorial. Adicionalmente, os @'{i}ndices ser@~{a}o
ordenados alfanumericamente (se @code{allsym} for @code{true}) com rela@value{cedilha}@~{a}o a
@'{i}ndices covariantes ou contravariantes dependendo do valor de @code{flipflag}.
Se @code{flipflag} for @code{false} ent@~{a}o os @'{i}ndices ser@~{a}o renomeados conforme
a ordem dos @'{i}ndices contravariantes. Se @code{flipflag} for @code{true}
a renomea@value{cedilha}@~{a}o ocorrer@'{a} conforme a ordem dos @'{i}ndices
covariantes. Isso muitas vezes ajuda que o efeito combinado dos dois restantes sejam
reduzidos a uma express@~{a}o de valor um ou mais que um por si mesma.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

              %1 %2  %3 %4      %6         %5         %7        u
           - g      g      ichr2      ichr2      ichr2     ichr2
                                %1 %3      %2 %6      %4 r      %5 %7
@end example

@end deffn

@defvr {Vari@'{a}vel de Op@value{cedilha}@~{a}o} flipflag

Valor padr@~{a}o: @code{false}. Se @code{false} ent@~{a}o os @'{i}ndices ir@~{a}o ser
renomeados conforme a ordem dos @'{i}ndices contravariantes,
de outra forma ser@~{a}o ordenados conforme a ordem dos @'{i}ndices covariantes.

Se @code{flipflag} for @code{false} ent@~{a}o @code{rename} forma uma lista
de @'{i}ndices contravariantes na ordem em que forem encontrados da esquerda para a direita
(se @code{true} ent@~{a}o de @'{i}ndices contravariantes). O primeiro @'{i}ndice
que ocorre exatamente duas vezes na lista @'{e} renomeado para @code{%1}, o seguinte para @code{%2}, etc.
Ent@~{a}o a ordena@value{cedilha}@~{a}o ocorre ap@'{o}s a ocorr@^{e}ncia do @code{rename} (veja o exemplo
sob @code{rename}).

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} defcon (@var{tensor_1})
@deffnx {Fun@value{cedilha}@~{a}o} defcon (@var{tensor_1}, @var{tensor_2}, @var{tensor_3})
Dado @var{tensor_1} a propriedade que a
contra@value{cedilha}@~{a}o de um produto do @var{tensor_1} e do @var{tensor_2} resulta em @var{tensor_3}
com os @'{i}ndices apropriados.  Se somente um argumento, @var{tensor_1}, for
dado, ent@~{a}o a contra@value{cedilha}@~{a}o do produto de @var{tensor_1} com qualquer objeto
indexado tendo os @'{i}ndices apropriados (digamos @code{my_tensor}) ir@'{a} retornar como resultado um
objeto indexado com aquele nome, i.e. @code{my_tensor}, e com uma nova escolha de
@'{i}ndices refletindo as contra@value{cedilha}@~{o}es executadas.
Por exemplo, se @code{imetric:g}, ent@~{a}o @code{defcon(g)} ir@'{a} implementar o
incremento e decremento de @'{i}ndices atrav@'{e}s da contra@value{cedilha}@~{a}o com o tensor
m@'{e}trico.
Mais de uma @code{defcon} pode ser dada para o mesmo objeto indexado; o
@'{u}ltimo  fornecido que for aplicado a uma contra@value{cedilha}@~{a}o particular ser@'{a}
usado.
@code{contractions} @'{e} uma lista de objetos indexados que tenham fornecido
propriedades de contra@value{cedilha}@~{o}es com @code{defcon}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} remcon (@var{tensor_1}, ..., @var{tensor_n})
@deffnx {Fun@value{cedilha}@~{a}o} remcon (all)
Remove todas as propriedades de contra@value{cedilha}@~{a}o
de @var{tensor_1}, ..., @var{tensor_n}). @code{remcon(all)} remove todas as propriedades de
contra@value{cedilha}@~{a}o de todos os objetos indexados.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} contract (@var{expr})

Realiza contra@value{cedilha}@~{o}es tensoriais em @var{expr} a qual pode ser qualquer
combina@value{cedilha}@~{a}o de adi@value{cedilha}@~{o}es e produtos. Essa fun@value{cedilha}@~{a}o usa a informa@value{cedilha}@~{a}o
dada para a fun@value{cedilha}@~{a}o @code{defcon}. Para melhores resultados, @code{expr}
pode ser completamente expandida. @code{ratexpand} @'{e} o meio mais r@'{a}pido para expandir
produtos e expoentes de adi@value{cedilha}@~{o}es se n@~{a}o existirem vari@'{a}veis nos denominadores
dos termos. O comutador @code{gcd} pode ser @code{false} se cancelamentos de
m@'{a}ximo divisor comum forem desnecess@'{a}rios.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} indexed_tensor (@var{tensor})

Deve ser executada antes de atribuir componentes para um @var{tensor} para o qual
um valor interno j@'{a} existe como com @code{ichr1}, @code{ichr2},
@code{icurvature}. Veja o exemplo sob @code{icurvature}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} components (@var{tensor}, @var{expr})

Permite que se atribua um valor indicial a uma express@~{a}o
@var{expr} dando os valores das componentes do @var{tensor}. Esses
s@~{a}o automaticamente substitu@'{i}dos para o tensor mesmo que isso ocorra com
todos os seus @'{i}ndices. O tensor deve ser da forma @code{t([...],[...])}
onde qualquer lista pode ser vazia. @var{expr} pode ser qualquer express@~{a}o indexada
envolvendo outros objetos com os mesmos @'{i}ndices livres que @var{tensor}. Quando
usada para atribuir valores a um tensor m@'{e}trico no qual as componentes
possuem @'{i}ndices que ocorrem exatamente duas vezes se deve ser cuidadoso para definir esses @'{i}ndices de forma a
evitar a gera@value{cedilha}@~{a}o de @'{i}ndices que ocorrem exatamente duas vezes e que s@~{a}o multiplos. a remo@value{cedilha}@~{a}o dessas
atribui@value{cedilha}@~{o}es @'{e} dada para a fun@value{cedilha}@~{a}o @code{remcomps}.

@'{E} importante ter em mente que @code{components} cuida somente da
val@^{e}ncia de um tensor, e que ignora completamente qualquer ordena@value{cedilha}@~{a}o particular de @'{i}ndices. Dessa forma
atribuindo componentes a, digamos, @code{x([i,-j],[])}, @code{x([-j,i],[])}, ou
@code{x([i],[j])} todas essas atribui@value{cedilha}@~{o}es produzem o mesmo resultado, a saber componentes sendo
atribuidas a um tensor chamado @code{x} com val@^{e}ncia @code{(1,1)}.

Componentes podem ser atribuidas a uma express@~{a}o indexada por quatro caminhos, dois
dos quais envolvem o uso do comando @code{components}:

1) Como uma express@~{a}o indexada. Por exemplo:

@example

(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

@end example

2) Como uma matriz:

@example

(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([3,3],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

@end example

3) Como uma fun@value{cedilha}@~{a}o. Voc@^{e} pode usar uma fun@value{cedilha}@~{a}o Maxima para especificar as
componentes de um tensor baseado nesses @'{i}ndices. Por exemplo, os seguintes
c@'{o}digos atribuem @code{kdelta} a @code{h} se @code{h} tiver o mesmo n@'{u}mero de
@'{i}ndices covariantes e @'{i}ndices contravariantes e nenhum @'{i}ndice derivativo, e
atribui @code{kdelta} a @code{g} caso as condi@value{cedilha}@~{o}es anteriores n@~{a}o sejam atendidas:

@example

(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

@end example

4) Usando a compatibilidade dos modelos de coincid@^{e}ncia do Maxima, especificamente os
comandos @code{defrule} e @code{applyb1}:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} remcomps (@var{tensor})

Desassocia todos os valores de @var{tensor} que foram atribu@'{i}dos com a
fun@value{cedilha}@~{a}o @code{components}.

@end deffn

@c NEED LIST OF ARGUMENTS HERE
@deffn {Fun@value{cedilha}@~{a}o} showcomps (@var{tensor})

Mostra atribui@value{cedilha}@~{o}es de componentes de um tensor, feitas usando o comando
@code{components}. Essa fun@value{cedilha}@~{a}o pode ser particularmente @'{u}til quando uma matriz @'{e} atribu@'{i}da
a um tensor indicial usando @code{components}, como demonstrado atrav@'{e}s do
seguinte exemplo:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

@end example

O comando @code{showcomps} pode tamb@'{e}m mostrar componentes de um tensor de
categoria maior que 2.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} idummy ()

Incrementos @code{icounter} e retorno como seu valor um @'{i}ndice da forma
@code{%n} onde n @'{e} um inteiro positivo.  Isso garante que @'{i}ndices que ocorrem exatamente duas vezes
e que s@~{a}o necess@'{a}rios na forma@value{cedilha}@~{a}o de express@~{o}es n@~{a}o ir@~{a}o conflitar com @'{i}ndices
que j@'{a} estiverem sendo usados (veja o exemplo sob @code{indices}).

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} idummyx
Valor padr@~{a}o: @code{%}

@'{E} o prefixo para @'{i}ndices que ocorrem exatamente duas vezes (veja o exemplo sob @'{i}ndices @code{indices}).

@end defvr

@defvr {Vari@'{a}vel de Op@value{cedilha}@~{a}o} icounter
Valor padr@~{a}o: @code{1}

Determina o sufixo num@'{e}rico a ser usado na
gera@value{cedilha}@~{a}o do pr@'{o}ximo @'{i}ndice que ocorre exatamente duas vezes no pacote tensor.  O prefixo @'{e}
determinado atrav@'{e}s da op@value{cedilha}@~{a}o @code{idummy} (padr@~{a}o: @code{%}).
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} kdelta (@var{L1}, @var{L2})
@'{e} a fun@value{cedilha}@~{a}o delta generalizada de Kronecker definida no
pacote @code{itensor} com @var{L1} a lista de @'{i}ndices covariantes e @var{L2}
a lista de @'{i}ndices contravariantes.  @code{kdelta([i],[j])} retorna o delta de
Kronecker comum.  O comando @code{ev(@var{expr},kdelta)} faz com que a avalia@value{cedilha}@~{a}o de
uma express@~{a}o contendo @code{kdelta([],[])} se d@^{e} para a dimens@~{a}o de
multiplica@value{cedilha}@~{a}o.

No que conduzir a um abuso dessa nota@value{cedilha}@~{a}o, @code{itensor} tamb@'{e}m permite
@code{kdelta} ter 2 covariantes e nenhum contravariante, ou 2 contravariantes
e nenhum @'{i}ndice covariante, com efeito fornecendo uma compatibilidade para "matriz unit@'{a}ria" covariante ou
contravariante. Isso @'{e} estritamente considerado um recurso de programa@value{cedilha}@~{a}o e n@~{a}o significa
implicar que @code{kdelta([i,j],[])} seja um objeto tensorial v@'{a}lido.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} kdels (@var{L1}, @var{L2})

Delta de Kronecker simetrizado, usado em alguns c@'{a}lculos. Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} levi_civita (@var{L})
@'{e} o tensor de permuta@value{cedilha}@~{a}o (ou de Levi-Civita) que retorna 1 se
a lista @var{L} consistir de uma permuta@value{cedilha}@~{a}o par de inteiros, -1 se isso
consistir de uma permuta@value{cedilha}@~{a}o @'{i}mpar, e 0 se alguns @'{i}ndices em @var{L} forem
repetidos.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lc2kdt (@var{expr})
Simplifica express@~{o}es contendo os s@'{i}mbolos de Levi-Civita, convertendo esses
para express@~{o}es delta de Kronecker quando poss@'{i}vel. A principal diferen@value{cedilha}a entre
essa fun@value{cedilha}@~{a}o e simplesmente avaliar os simbolos de Levi-Civita @'{e} que a avalia@value{cedilha}@~{a}o
direta muitas vezes resulta em express@~{o}es Kronecker contendo @'{i}ndices
num@'{e}ricos. Isso @'{e} muitas vezes indesej@'{a}vel como na preven@value{cedilha}@~{a}o de simplifica@value{cedilha}@~{a}o adicional.
A fun@value{cedilha}@~{a}o @code{lc2kdt} evita esse problema, retornando express@~{o}es que
s@~{a}o mais facilmente simplificadas com @code{rename} ou @code{contract}.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

@end example

A fun@value{cedilha}@~{a}o @code{lc2kdt} algumas vezes faz uso de tensores m@'{e}tricos.
Se o tensor m@'{e}trico n@~{a}o tiver sido definido previamente com @code{imetric},
isso resulta em um erro.

@example

(%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j       k
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                    %3             %4               %3             %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i      l i
(%t11)                           a    - a g

@end example


@end deffn

@c HMM, WHICH CATEGORY DOES THIS FALL INTO -- FUNCTION, VARIABLE, OTHER ??
@deffn {Fun@value{cedilha}@~{a}o} lc_l

Regra de simplifica@value{cedilha}@~{a}o usada para express@~{o}es contendo s@'{i}mbolos n@~{a}o avaliados de
Levi-Civita (@code{levi_civita}). Juntamente com @code{lc_u}, pode ser usada para simplificar
muitas express@~{o}es mais eficientemente que a avalia@value{cedilha}@~{a}o de @code{levi_civita}.
Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
(%t4)                                  0
(%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
(%t5)                                  0

@end example

@end deffn

@c HMM, WHICH CATEGORY DOES THIS FALL INTO -- FUNCTION, VARIABLE, OTHER ??
@deffn {Fun@value{cedilha}@~{a}o} lc_u

Regra de simplifica@value{cedilha}@~{a}o usada para express@~{o}es contendo s@'{i}mbolos n@~{a}o avaliados de
Levi-Civita (@code{levi_civita}). Juntamente com @code{lc_u}, pode ser usada para simplificar
muitas express@~{o}es mais eficientemente que a avalia@value{cedilha}@~{a}o de @code{levi_civita}.
Para detalhes, veja @code{lc_l}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} canten (@var{expr})
Simplifica @var{expr} por renomea@value{cedilha}@~{a}o (veja @code{rename})
e permutando @'{i}ndices que ocorrem exatamente duas vezes. @code{rename} @'{e} restrito a adi@value{cedilha}@~{o}es de produto
de tensores nos quais nenhum @'{i}ndice derivativo estiver presente. Como tal isso @'{e} limitado
e pode somente ser usado se @code{canform} n@~{a}o for capaz de realizar a
simplifica@value{cedilha}@~{a}o requerida.

A fun@value{cedilha}@~{a}o @code{canten} retorna um resultado matematicamente correto somente
se seu argumento for uma express@~{a}o que @'{e} completamente sim@'{e}trica em seus @'{i}ndices.
Por essa raz@~{a}o, @code{canten} retorna um erro se @code{allsym} n@~{a}o for
posicionada em @code{true}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} concan (@var{expr})
Similar a @code{canten} mas tamb@'{e}m executa contra@value{cedilha}@~{a}o de @'{i}ndices.

@end deffn

@subsection Simetrias de tensores

@defvr {Vari@'{a}vel de Op@value{cedilha}@~{a}o} allsym

Valor padr@~{a}o: @code{false}. Se @code{true} ent@~{a}o todos os objetos indexados
s@~{a}o assumidos sim@'{e}tricos em todos os seus @'{i}ndices covariantes e
contravariantes. Se @code{false} ent@~{a}o nenhum sim@'{e}trico de qualquer tipo @'{e} assumidos
nesses @'{i}ndices. @'{I}ndices derivativos s@~{a}o sempre tomados para serem sim@'{e}tricos
a menos que @code{iframe_flag} seja escolhida para @code{true}.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} decsym (@var{tensor}, @var{m}, @var{n}, [@var{cov_1}, @var{cov_2}, ...], [@var{contr_1}, @var{contr_2}, ...])

Declara propriedades de simetria para @var{tensor} de covariante @var{m} e
@var{n} @'{i}ndices contravariantes. As @var{cov_i} e @var{contr_i} s@~{a}o
pseudofun@value{cedilha}@~{o}es expressando rela@value{cedilha}@~{o}es de simetrias em meio a @'{i}ndices covariante e
@'{i}ndices contravariantes respectivamente.  Esses s@~{a}o da forma
@code{symoper(@var{index_1}, @var{index_2},...)} onde @code{symoper} @'{e} um entre
@code{sym}, @code{anti} ou @code{cyc} e os @var{index_i} s@~{a}o inteiros
indicando a posi@value{cedilha}@~{a}o do @'{i}ndice no @var{tensor}.  Isso ir@'{a}
declarar @var{tensor} para ser sim@'{e}trico, antisim@'{e}trico ou c@'{i}clico respectivamente
nos @var{index_i}. @code{symoper(all)} @'{e} tamb@'{e}m forma permitida que
indica todos os @'{i}ndices obedecem @`a condi@value{cedilha}@~{a}o de simetria. Por exemplo, dado um
objeto @code{b} com 5 @'{i}ndices covariantes,
@code{decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])} declara @code{b}
sim@'{e}trico no seu primeiro e no seu segundo @'{i}ndices e antisim@'{e}trico no seu terceiro e
quarto @'{i}ndices covariantes, e c@'{i}clico em todos de seus @'{i}ndices contravariantes.
Qualquer lista de declara@value{cedilha}@~{o}es de simetria pode ser nula.  A fun@value{cedilha}@~{a}o que
executa as simplifica@value{cedilha}@~{o}es @'{e} @code{canform} como o exemplo abaixo
ilustra.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

@end example


@end deffn

@deffn {Fun@value{cedilha}@~{a}o} remsym (@var{tensor}, @var{m}, @var{n})
Remove todas as propriedades de simetria de @var{tensor} que tem @var{m}
@'{i}ndices covariantes e @var{n} @'{i}ndices contravariantes.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} canform (@var{expr})
Simplifica @var{expr} atrav@'{e}s de mudan@value{cedilha}a de nome de @'{i}ndices
que ocorrem exatamente duas vezes e reordena@value{cedilha}@~{a}o de todos os @'{i}ndices como ditados pelas condi@value{cedilha}@~{o}es de simetria
impostas sobre eles. Se @code{allsym} for @code{true} ent@~{a}o todos os @'{i}ndices s@~{a}o assumidos
sim@'{e}tricos, de outra forma a informa@value{cedilha}@~{a}o de simetria fornecida pelas declara@value{cedilha}@~{o}es
@code{decsym} ir@~{a}o ser usadas. Os @'{i}ndices que ocorrem exatamente duas vezes s@~{a}o renomeados da mesma
maneira que na fun@value{cedilha}@~{a}o @code{rename}. Quando @code{canform} @'{e} aplicada a uma express@~{a}o
larga o c@'{a}lculo pode tomar um consider@'{a}vel montante de tempo.
Esse tempo pode ser diminu@'{i}do atrav@'{e}s do uso de @code{rename} sobre a express@~{a}o em primeiro lugar.
Tamb@'{e}m veja o exemplo sob @code{decsym}. Nota: @code{canform} pode n@~{a}o estar apta a
reduzir um express@~{a}o completamente para sua forma mais simples embora
retorne sempre um resultado matem@'{a}ticamente correto.
@end deffn

@subsection C@'{a}lculo de tensores indiciais

@deffn {Fun@value{cedilha}@~{a}o} diff (@var{expr}, @var{v_1}, [@var{n_1}, [@var{v_2}, @var{n_2}] ...])

@'{E} a fun@value{cedilha}@~{a}o usual de diferencia@value{cedilha}@~{a}o do Maxima que tem sido expandida
nessas habilidades para @code{itensor}. @code{diff} toma a derivada de @var{expr}
 @var{n_1} vezes com rela@value{cedilha}@~{a}o a @var{v_1}, @var{n_2} vezes com rela@value{cedilha}@~{a}o a @var{v_2}
, etc. Para o pacote @code{tensor}, a fun@value{cedilha}@~{a}o tem sido modificada de
forma que os @var{v_i} possam ser inteiros de 1 at@'{e} o valor da vari@'{a}vel
@code{dim}.  Isso causar@'{a} a conclus@~{a}o da diferencia@value{cedilha}@~{a}o com
rela@value{cedilha}@~{a}o ao @var{v_i}@'{e}simo membro da lista @code{vect_coords}.  Se
@code{vect_coords} for associado a uma vari@'{a}vel at@^{o}mica, ent@~{a}o aquela vari@'{a}vel
subscrita atrav@'{e}s de @var{v_i} ser@'{a} usada para a vari@'{a}vel de
diferencia@value{cedilha}@~{a}o.  Isso permite que um array de nomes de coordenadas ou
nomes subscritos como @code{x[1]}, @code{x[2]}, ...  sejam usados.
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} idiff (@var{expr}, @var{v_1}, [@var{n_1}, [@var{v_2}, @var{n_2}] ...])
Diferencia@value{cedilha}@~{a}o indicial. A menos que @code{diff}, que diferencia
com rela@value{cedilha}@~{a}o a uma vari@'{a}vel independente, @code{idiff} possa ser usada
para diferenciar com rela@value{cedilha}@~{a}o a uma coordenada. Para um objeto indexado,
isso equivale a anexar ao final os @var{v_i} como @'{i}ndices derivativos.
Subseq@"{u}@^{e}ntemente, @'{i}ndices derivativos ir@~{a}o ser ordenados, a menos que @code{iframe_flag}
seja escolhida para @code{true}.

@code{idiff} pode tamb@'{e}m ser o determinante de um tensor
m@'{e}trico. Dessa forma, se @code{imetric} tiver sido associada a @code{G} ent@~{a}o
@code{idiff(determinant(g),k)} ir@'{a} retornar
@code{2*determinant(g)*ichr2([%i,k],[%i])} onde o @'{i}ndice que ocorre exatamente duas vezes @code{%i}
@'{e} escolhido apropriadamente.


@end deffn

@deffn {Fun@value{cedilha}@~{a}o} liediff (@var{v}, @var{ten})

Calcula a derivada de Lie da express@~{a}o tensorial @var{ten} com
rela@value{cedilha}@~{a}o ao campo vetorial @var{v}. @var{ten} pode ser qualquer express@~{a}o tensorial
indexada; @var{v} pode ser o nome (sem @'{i}ndices) de um campo
vetorial. Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                                %1  k        %1  k      %1  k
                            + (v   b      - b   v    + v   b   ) a
                                    ,%1 l    ,l  ,%1    ,l  ,%1   i j

@end example


@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rediff (@var{ten})

Avalia todas as ocorr@^{e}ncias do comando @code{idiff} na express@~{a}o
tensorial @var{ten}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} undiff (@var{expr})

Retorna uma express@~{a}o equivalente a @var{expr} mas com todas as derivadas
de objetos indexados substitu@'{i}das pela forma substantiva da fun@value{cedilha}@~{a}o @code{idiff}. Seu
argumento pode retornar aquele objeto indexado se a diferencia@value{cedilha}@~{a}o for
conclu@'{i}da.  Isso @'{e} @'{u}til quando for desejado substituir um
objeto indexado que sofreu diferencia@value{cedilha}@~{a}o com alguma defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o resultando
em @var{expr} e ent@~{a}o concluir a diferencia@value{cedilha}@~{a}o atrav@'{e}s de digamos
@code{ev(@var{expr}, idiff)}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} evundiff (@var{expr})

Equivalente @`a execu@value{cedilha}@~{a}o de @code{undiff}, seguida por @code{ev} e
@code{rediff}.

O ponto dessa opera@value{cedilha}@~{a}o @'{e} facilmente avaliar express@~{o}es que n@~{a}o possam
ser diretamente avaliadas na forma derivada. Por exemplo, o seguinte
causa um erro:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Todavia, se @code{icurvature} @'{e} informado em sua forma substantiva, pode ser avaliado
usando @code{evundiff}:

@example
(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

                l              l         %1           l           %1
         + ichr2        + ichr2     ichr2      + ichr2       ichr2
                i j,k m        %1 k      i j,m        %1 k,m      i j
@end example

Nota: Em vers@~{o}es anteriores do Maxima, formas derivadas dos
s@'{i}mbolos de Christoffel tamb@'{e}m n@~{a}o podiam ser avaliadas. Isso foi corrigido atualmente,
de forma que @code{evundiff} n@~{a}o mais @'{e} necess@'{a}ria para express@~{o}es como essa:

@example
(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
@end example


@end deffn

@deffn {Fun@value{cedilha}@~{a}o} flush (@var{expr}, @var{tensor_1}, @var{tensor_2}, ...)
Escolhe para zero, em
@var{expr}, todas as ocorr@^{e}ncias de @var{tensor_i} que n@~{a}o tiverem @'{i}ndices derivativos.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} flushd (@var{expr}, @var{tensor_1}, @var{tensor_2}, ...)
Escolhe para zero, em
@var{expr}, todas as ocorr@^{e}ncias de @var{tensor_i} que tiverem @'{i}ndices derivativos.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} flushnd (@var{expr}, @var{tensor}, @var{n})
Escolhe para zero, em @var{expr}, todas as
ocorr@^{e}ncias do objeto diferenciado @var{tensor} que tem @var{n} ou mais
@'{i}ndices derivativos como demonstra o seguinte exemplo.
@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
@end example
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} coord (@var{tensor_1}, @var{tensor_2}, ...)

Dados os @var{tensor_i} a propriedade de diferencia@value{cedilha}@~{a}o da coordenada que a
derivada do vetor contravariante cujo nome @'{e} um dos
@var{tensor_i} retorna um delta de Kronecker. Por exemplo, se @code{coord(x)} tiver
sido conclu@'{i}da ent@~{a}o @code{idiff(x([],[i]),j)} fornece @code{kdelta([i],[j])}.
@code{coord} que @'{e} uma lista de todos os objetos indexados tendo essa propriedade.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} remcoord (@var{tensor_1}, @var{tensor_2}, ...)
@deffnx {Fun@value{cedilha}@~{a}o} remcoord (all)

Remove a propriedade de coordenada de diferencia@value{cedilha}@~{a}o dos @code{tensor_i}
que foram estabelecidos atrav@'{e}s da fun@value{cedilha}@~{a}o @code{coord}.  @code{remcoord(all)}
remove essa propriedade de todos os objetos indexados.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} makebox (@var{expr})
Mostra @var{expr} da mesma maneira que @code{show}; todavia,
qualquer tensor d'Alembertiano ocorrendo em @var{expr} ser@'{a} indicado usando o
s@'{i}mbolo @code{[]}.  Por exemplo, @code{[]p([m],[n])} representa
@code{g([],[i,j])*p([m],[n],i,j)}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} conmetderiv (@var{expr}, @var{tensor})

Simplifica express@~{o}es contendo derivadas comuns de
ambas as formas covariantes e contravariantes do tensor m@'{e}trico (a
restri@value{cedilha}@~{a}o corrente).  Por exemplo, @code{conmetderiv} pode relatar a
derivada do tensor contravariante m@'{e}trico com s@'{i}mbolos de
Christoffel como visto adiante:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
@end example
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} simpmetderiv (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} simpmetderiv (@var{expr}[, @var{stop}])

Simplifica express@~{o}es contendo produtos de derivadas de
tensores m@'{e}tricos. Especificamente, @code{simpmetderiv} reconhece duas identidades:

@example

   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

@end example

conseq@"{u}@^{e}ntemente

@example

   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
@end example

e

@example

  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

@end example

que seguem de simetrias de s@'{i}mbolos de Christoffel.

A fun@value{cedilha}@~{a}o @code{simpmetderiv} toma um par@^{a}metro opcional que, quando
presente, faz com que a fun@value{cedilha}@~{a}o pare ap@'{o}s a primeira substitui@value{cedilha}@~{a}o feita com
sucesso em uma express@~{a}o produto. A fun@value{cedilha}@~{a}o @code{simpmetderiv}
tamb@'{e}m faz uso da vari@'{a}vel global @var{flipflag} que determina
como aplicar uma ordena@value{cedilha}@~{a}o ``canonica'' para os @'{i}ndices de produto.

Colocados juntos, essas compatibilidades podem ser usadas poderosamente para encontrar
simplifica@value{cedilha}@~{o}es que s@~{a}o dif@'{i}ceis ou imposs@'{i}veis de realizar de outra forma.
Isso @'{e} demonstrado atrav@'{e}s do seguinte exemplo que explicitamente usa o 
recurso de simplifica@value{cedilha}@~{a}o parcial de @code{simpmetderiv} para obter uma
express@~{a}o contract@'{i}vel:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

@end example

Veja tamb@'{e}m @code{weyl.dem} para um exemplo que usa @code{simpmetderiv}
e @code{conmetderiv} juntos para simplificar contra@value{cedilha}@~{o}es do tensor de Weyl.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} flush1deriv (@var{expr}, @var{tensor})

Escolhe para zero, em @code{expr}, todas as ocorr@^{e}ncias de @code{tensor} que possuem
exatamente um @'{i}ndice derivativo.

@end deffn

@subsection Tensores em espa@value{cedilha}os curvos

@deffn {Fun@value{cedilha}@~{a}o} imetric (@var{g})
@deffnx {Vari@'{a}vel de sistema} imetric

Especifica a m@'{e}trica atrav@'{e}s de atribui@value{cedilha}@~{a}o @`a vari@'{a}vel @code{imetric:@var{g}}
adicionalmente, as propriedades de contra@value{cedilha}@~{a}o da m@'{e}trica @var{g} s@~{a}o escolhidas atrav@'{e}s da
execu@value{cedilha}@~{a}o dos comandos @code{defcon(@var{g}),defcon(@var{g},@var{g},kdelta)}.
A vari@'{a}vel @code{imetric} (desassociada por padr@~{a}o), @'{e} associada @`a m@'{e}trica, atribuida pelo
comando @code{imetric(@var{g})}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} idim (@var{n})
Escolhe as dimens@~{o}es da m@'{e}trica. Tamb@'{e}m inicializa as propriedades de
antisimetria dos s@'{i}mbolos de Levi-Civita para as dimens@~{o}es dadas.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ichr1 ([@var{i}, @var{j}, @var{k}])
Retorna o s@'{i}mbolo de Christoffel de primeiro tipo via
defini@value{cedilha}@~{a}o
@example
       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
@end example
@noindent
Para avaliar os s@'{i}mbolos de Christoffel para uma m@'{e}trica particular, @`a
vari@'{a}vel @code{imetric} deve ser atribu@'{i}da um nome como no exemplo sob @code{chr2}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ichr2 ([@var{i}, @var{j}], [@var{k}])
Retorna o s@'{i}mbolo de Christoffel de segundo tipo
definido pela rela@value{cedilha}@~{a}o
@example
                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
@end example
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} icurvature ([@var{i}, @var{j}, @var{k}], [@var{h}])
Retorna o tensor da curvatura de
Riemann em termos de s@'{i}mbolos de Christoffel de segundo
tipo (@code{ichr2}).  A seguinte nota@value{cedilha}@~{a}o @'{e} usada:
@example
               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
@end example
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} covdiff (@var{expr}, @var{v_1}, @var{v_2}, ...)
Retorna a derivada da covariante de @var{expr} com
rela@value{cedilha}@~{a}o @`as vari@'{a}veis @var{v_i} em termos de s@'{i}mbolos de Christoffel de
segundo tipo (@code{ichr2}).  Com o objetivo de avaliar esses, se pode usar
@code{ev(@var{expr},ichr2)}.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the @'{i}ndices covariantes: [i,j];
Enter a list of the @'{i}ndices contravariantes: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k            k     %1
(%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
             i %1      j s    %1 j      i s    i j,s        %1 s  i j
(%i4) imetric:g;
(%o4)            g
(%i5) ishow(ev(%th(2),ichr2))$
  %1 %4  k
 g      a     (g       - g       + g  )
  i %1   s %4,j  j s,%4    j %4,s
(%t5) - ------------------------------------------
       2
    %1 %3  k
   g   a     (g       - g    + g     )
    %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
         2
    k %2  %1
   g     a    (g        - g    + g      )
   i j   s %2,%1    %1 s,%2    %1 %2,s   k
 + ------------------------------------------- + a
   2     i j,s
(%i6) 
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lorentz_gauge (@var{expr})
Imp@~{o}e a condi@value{cedilha}@~{a}o de Lorentz atrav@'{e}s da substitui@value{cedilha}@~{a}o de 0 para todos os
objetos indexados em @var{expr} que possui um @'{i}ndice de derivada id@^{e}ntico ao
@'{i}ndice contravariante.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} igeodesic_coords (@var{expr}, @var{nome})

Faz com que s@'{i}mbolos de Christoffel n@~{a}o diferenciados e
a primeira derivada do tensor m@'{e}trico tendam para zero em @var{expr}. O @var{nome}
na fun@value{cedilha}@~{a}o @code{igeodesic_coords} refere-se @`a m@'{e}trica @var{nome}
(se isso aparecer em @var{expr}) enquando os coeficientes de conec@value{cedilha}@~{a}o devem ser
chamados com os nomes @code{ichr1} e/ou @code{ichr2}. O seguinte exemplo
demonstra a verifica@value{cedilha}@~{a}o da identidade c@'{i}clica satisfeita atrav@'{e}s do tensor da
curvatura de Riemann usando a fun@value{cedilha}@~{a}o @code{igeodesic_coords}.

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u            u         %1
(%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
             r t,s        %1 s      r t        r s,t        %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t        r t,s

                                                                  u
                                                           + ichr2
                                                                  r s,t
(%i5) canform(%);
(%o5)                                  0

@end example

@end deffn

@subsection Molduras m@'{o}veis

Maxima atualmente tem a habilidade de executar c@'{a}lculos usando molduras m@'{o}veis.
Essas podem ser molduras ortonormais (tetrads, vielbeins) ou uma moldura arbitr@'{a}ria.

Para usar molduras, voc@^{e} primeiro escolhe @code{iframe_flag} para @code{true}. Isso
faz com que os s@'{i}mbolos de Christoffel, @code{ichr1} e @code{ichr2}, sejam substitu@'{i}dos
pelas molduras mais gerais de coeficientes de conec@value{cedilha}@~{a}o @code{icc1} e @code{icc2}
em c@'{a}lculos. Especialmente, o comportamento de @code{covdiff} e
@code{icurvature} s@~{a}o alterados.

A moldura @'{e} definida atrav@'{e}s de dois tensores: o campo de moldura inversa (@code{ifri}),
a base tetrad dual),
e a m@'{e}trica da moldura @code{ifg}. A m@'{e}trica da moldura @'{e} a matriz identidade para
molduras ortonormais, ou a m@'{e}trica de Lorentz para molduras ortonormais no espa@value{cedilha}o-tempo de
Minkowski. O campo de moldura inversa define a base da moldura (vetores unit@'{a}rios).
Propriedades de contra@value{cedilha}@~{a}o s@~{a}o definidas para o campo de moldura e para a m@'{e}trica da moldura.

Quando @code{iframe_flag} for @code{true}, muitas express@~{o}es @code{itensor} usam a m@'{e}trica da
moldura @code{ifg} em lugar da m@'{e}trica definida atrav@'{e}s de @code{imetric} para
o decremento e para o incremento de @'{i}ndices.

IMPORTANTE: Escolhendo a vari@'{a}vel @code{iframe_flag} para @code{true} N@~{A}O
remove a defini@value{cedilha}@~{a}o das propriedades de contra@value{cedilha}@~{a}o de uma m@'{e}trica definida atrav@'{e}s de uma chamada a
@code{defcon} ou @code{imetric}. Se um campo de moldura for usado, ele @'{e} melhor para
definir a m@'{e}trica atrav@'{e}s de atribui@value{cedilha}@~{a}o desse nome para a vari@'{a}vel @code{imetric}
e N@~{A}O invoque a fun@value{cedilha}@~{a}o @code{imetric}.

Maxima usa esses dois tensores para definir os coeficientes de moldura (@code{ifc1}
e @code{ifc2}) cuja forma parte dos coeficientes de conec@value{cedilha}@~{a}o (@code{icc1}
e @code{icc2}), como demonstra o seguinte exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                        %1      i           i        i
(%t4)                  v   (ifc2     + ichr2    ) + v
                                %1 j        %1 j     ,j
(%i5) ishow(ev(%,ifc2))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t5)      -------------------------------------------------- + v
                                   2                             ,j
(%i6) ishow(ifb([a,b,c]))$
                       %5    %4
(%t6)               ifr   ifr   (ifri        - ifri       )
                       a     b       c %4,%5       c %5,%4

@end example

Um m@'{e}todo alternativo @'{e} usado para calcular o suporte da moldura (@code{ifb}) se
o sinalizador @code{iframe_bracket_form} @'{e} escolhido para @code{false}:

@example

(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                       %7    %6        %6      %7
(%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                       a     b,%7      a,%7    b       c %6

@end example


@deffn {Fun@value{cedilha}@~{a}o} iframes ()

Uma vez que nessa vers@~{a}o do Maxima, identidades de contra@value{cedilha}@~{a}o para @code{ifr} e
@code{ifri} s@~{a}o sempre definidas, como @'{e} o suporte da moldura (@code{ifb}), essa
fun@value{cedilha}@~{a}o n@~{a}o faz nada.

@end deffn

@defvr {Vari@'{a}vel} ifb

O suporte da moldura. A contribui@value{cedilha}@~{a}o da m@'{e}trica da moldura para os coeficientes
de conec@value{cedilha}@~{a}o @'{e} expressa usando o suporte da moldura:

@example

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

@end example

O suporte da moldura por si mesmo @'{e} definido em termos de campo de moldura e m@'{e}trica da
moldura. Dois m@'{e}todos alternativos de c@'{a}lculo s@~{a}o usados dependendo do
valor de @code{frame_bracket_form}. Se @code{true} (o padr@~{a}o) ou se o sinalizador
@code{itorsion_flag} for @code{true}:

@example

          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


@end example

Otherwise:

@example

             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

@end example


@end defvr


@defvr {Vari@'{a}vel} icc1

Coeficientes de conec@value{cedilha}@~{a}o de primeiro tipo. Em @code{itensor}, definido como

@example

icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

@end example

Nessa express@~{a}o, se @code{iframe_flag} for @code{true}, o s@'{i}mbolo de Christoffel
@code{ichr1} @'{e} substitu@'{i}do com o coeficiente de conec@value{cedilha}@~{a}o da moldura @code{ifc1}.
Se @code{itorsion_flag} for @code{false}, @code{ikt1}
ser@'{a} omitido. @code{ikt1} @'{e} tamb@'{e}m omitido se uma base de moldura for usada, como a
tors@~{a}o est@'{a} j@'{a} calculada como parte do suporte da moldura.
Ultimamente, como @code{inonmet_flag} @'{e} @code{false},
@code{inmc1} n@~{a}o estar@'{a} presente.


@end defvr

@defvr {Vari@'{a}vel} icc2

Coeficientes de conec@value{cedilha}@~{a}o de segundo tipo. Em @code{itensor}, definido como

@example

    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

@end example

Nessa express@~{a}o, se @code{iframe_flag} for @code{true}, o s@'{i}mbolo de Christoffel
@code{ichr2} @'{e} substitu@'{i}do com o coeficiente de conec@value{cedilha}@~{a}o @code{ifc2}.
Se @code{itorsion_flag} for @code{false}, @code{ikt2}
ser@'{a} omitido. @code{ikt2} tamb@'{e}m ser@'{a} omitido se uma base de moldura for usada, uma vez que a
tors@~{a}o j@'{a} est@'{a} calculada como parte do suporte da moldura.
Ultimamente, como @code{inonmet_flag} @'{e} @code{false},
@code{inmc2} n@~{a}o estar@'{a} presente.

@end defvr

@defvr {Vari@'{a}vel} ifc1

Coeficiente de moldura de primeiro tipo (tamb@'{e}m conhecido como coeficientes de
rota@value{cedilha}@~{a}o de Ricci).  Esse tensor representa a contribui@value{cedilha}@~{a}o
da m@'{e}trica da moldura para o coeficiente de conec@value{cedilha}@~{a}o de primeiro tipo. Definido
como:

@example

          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


@end example

@end defvr

@defvr {Vari@'{a}vel} ifc2

Coeficiente de moldura de primeiro tipo. Esse tensor representa a contribui@value{cedilha}@~{a}o
da m@'{e}trica da moldura para o coeficiente de conec@value{cedilha}@~{a}o de primeiro tipo. Definido
como uma permuta@value{cedilha}@~{a}o de suporte de moldura (@code{ifb}) com os @'{i}ndices
apropriados incrementados e decrementados como necess@'{a}rio:

@example

    c       cd
ifc2   = ifg   ifc1
    ab             abd

@end example

@end defvr

@defvr {Vari@'{a}vel} ifr

O campo da moldura. Contrai (@code{ifri}) para e com a forma do campo inverso da
moldura para formar a m@'{e}trica da moldura (@code{ifg}).

@end defvr

@defvr {Vari@'{a}vel} ifri

O campo inverso da moldura. Especifica a base da moldura (vetores base duais). Juntamente
com a m@'{e}trica da moldura, forma a base de todos os c@'{a}lculos baseados em
molduras.

@end defvr

@defvr {Vari@'{a}vel} ifg

A m@'{e}trica da moldura. O valor padr@~{a}o @'{e} @code{kdelta}, mas pode ser mudada usando
@code{components}.

@end defvr

@defvr {Vari@'{a}vel} ifgi

O inverso da m@'{e}trica da moldura. Contrai com a m@'{e}trica da moldura (@code{ifg})
para @code{kdelta}.

@end defvr

@defvr {Vari@'{a}vel de Op@value{cedilha}@~{a}o} iframe_bracket_form
Valor padr@~{a}o: @code{true}

Especifica como o suporte da moldura (@code{ifb}) @'{e} calculado.

@end defvr

@subsection Tors@~{a}o e n@~{a}o metricidade

Maxima pode trabalhar com tors@~{a}o e n@~{a}o metricidade. Quando o sinalizador
@code{itorsion_flag} for escolhido para @code{true}, a contribui@value{cedilha}@~{a}o de tors@~{a}o
@'{e} adicionada aos coeficientes de conec@value{cedilha}@~{a}o. Similarmente, quando o sinalizador
@code{inonmet_flag} for @code{true}, componentes de n@~{a}o metricidades s@~{a}o inclu@'{i}dos.

@defvr {Vari@'{a}vel} inm

O vetor de n@~{a}o metricidade. Conforme a n@~{a}o metricidade est@'{a} definida atrav@'{e}s da
derivada covariante do tensor m@'{e}trico. Normalmente zero, o tensor da
m@'{e}trica derivada covariante ir@'{a} avaliar para o seguinte quando
@code{inonmet_flag} for escolhido para @code{true}:

@example

g     =- g  inm
 ij;k     ij  k

@end example

@end defvr


@defvr {Vari@'{a}vel} inmc1

Permuta@value{cedilha}@~{a}o covariante de componentes do vetor de n@~{a}o metricidade. Definida como

@example

           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

@end example

(Substitue @code{ifg} em lugar de @code{g} se uma moldura m@'{e}trica for usada.)

@end defvr

@defvr {Vari@'{a}vel} inmc2

Permuta@value{cedilha}@~{a}o covariante de componentes do vetor de n@~{a}o metricidade. Usada
nos coeficicientes de conec@value{cedilha}@~{a}o se @code{inonmet_flag} for @code{true}. Definida
como:

@example

                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

@end example

(Substitue @code{ifg} em lugar de @code{g} se uma moldura m@'{e}trica for usada.)

@end defvr

@defvr {Vari@'{a}vel} ikt1

Permuta@value{cedilha}@~{a}o covariante do tensor de tors@~{a}o (tamb@'{e}m conhecido como contors@~{a}o).
Definido como:

@example

                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

@end example

(Substitue @code{ifg} em lugar de @code{g} se uma moldura m@'{e}trica for usada.)

@end defvr

@defvr {Vari@'{a}vel} ikt2

Permuta@value{cedilha}@~{a}o contravariante do tensor de tors@~{a}o (tamb@'{e}m conhecida como contors@~{a}o).
Definida como:

@example

    c     cd
ikt2   = g   ikt1
    ab           abd

@end example

(Substitue @code{ifg} em lugar de @code{g} se uma moldura m@'{e}trica for usada.)

@end defvr

@defvr {Vari@'{a}vel} itr

O tensor de tors@~{a}o. Para uma m@'{e}trica com tors@~{a}o, diferencia@value{cedilha}@~{a}o covariante
repetida sobre uma fun@value{cedilha}@`ao escalar n@~{a}o ir@'{a} comutar,como demonstrado
atrav@'{e}s do seguinte exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

@end example

@end defvr

@subsection @'{A}lgebra externa (como em produto externo)

O pacote @code{itensor} pode executar opera@value{cedilha}@~{o}es sobre campos tensores
covariantes totalmente antisim@'{e}tricos. Um campo tensor totalmente antisim@'{e}trico de classe
(0,L) corresponde a uma forma diferencial L. Sobre esses objetos, uma
opera@value{cedilha}@~{a}o de multiplica@value{cedilha}@~{a}o funciona como um produto externo, ou produto cunha,
@'{e} definido.

Desafortunadamente, nem todos os autores concordam sobre a defini@value{cedilha}@~{a}o de produto
cunha. Alguns autores preferem uma defini@value{cedilha}@~{a}o que corresponde @`a
no@value{cedilha}@~{a}o de antisimetriza@value{cedilha}@~{a}o: nessas palavras, o produto cunha de
dois campos vetoriais, por exemplo, pode ser definido como

@example
            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
@end example

Mais geralmente, o produto de uma forma p e uma forma q pode ser definido como

@example
                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
@end example

onde @code{D} simboliza o delta de Kronecker.

Outros autores, todavia, preferem uma defini@value{cedilha}@~{a}o ``geom@'{e}trica'' que corresponde @`a
nota@value{cedilha}@~{a}o de elemento volume:

@example
a  /\ a  = a a  - a a
 i     j    i j    j i
@end example

e, no caso geral

@example
                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
@end example

Uma vez que @code{itensor} @'{e} um pacote de algebra de tensores, a primeira dessas duas
defini@value{cedilha}@~{o}es aparenta ser a mais natural por si mesma. Muitas aplica@value{cedilha}@~{o}es, todavia,
usam a segunda defini@value{cedilha}@~{a}o. Para resolver esse dilema, um sinalizador tem sido
implementado que controla o comportamento do produto cunha: se
@code{igeowedge_flag} for @code{false} (o padr@~{a}o), a primeira, defini@value{cedilha}@~{a}o
"tensorial" @'{e} usada, de outra forma a segunda, defini@value{cedilha}@~{a}o "geom@'{e}trica" ir@'{a}
ser aplicada.

@defvr {Operador} ~
@ifinfo
@fnindex Produto Externo
@end ifinfo
O operador do produto cunha @'{e} definido como sendo o acento til @code{~}. O til @'{e}
um operador bin@'{a}rio. Seus argumentos podem ser express@~{o}es envolvendo escalares,
tensores covariantes de categoria 1, ou tensores covariantes de categoria @code{l} que
tiverem sido declarados antisim@'{e}tricos em todos os @'{i}ndices covariantes.

O comportamento do operador do produto cunha @'{e} controlado atrav@'{e}s do
sinalizador @code{igeowedge_flag}, como no seguinte exemplo:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
@end example

@end defvr

@defvr {Operador} |
@ifinfo
@fnindex Contra@value{cedilha}@~{a}o com um vetor
@end ifinfo
A barra vertical @code{|} denota a opera@value{cedilha}@~{a}o bin@'{a}ria
"contra@value{cedilha}@~{a}o com um vetor". Quando um tensor covariante totalmente antisim@'{e}trico @'{e} contra@'{i}do
com um vetor contravariante, o resultado @'{e} o mesmo independente de qual @'{i}ndice
foi usado para a contra@value{cedilha}@~{a}o. Dessa forma, @'{e} poss@'{i}vel definir a
opera@value{cedilha}@~{a}o de contra@value{cedilha}@~{a}o de uma forma livre de @'{i}ndices.

No pacote @code{itensor}, contra@value{cedilha}@~{a}o com um vetor @'{e} sempre realizada
com rela@value{cedilha}@~{a}o ao primeiro @'{i}ndice na ordem literal de ordena@value{cedilha}@~{a}o. Isso garante
uma melhor simplifica@value{cedilha}@~{a}o de express@~{o}es envolvendo o operador @code{|}. Por exemplo:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
@end example

Note que isso @'{e} essencial que os tensores usado como o operador @code{|} seja
declarado totalmente antisim@'{e}trico em seus @'{i}ndices covariantes. De outra forma,
os resultados ser@~{a}o incorretos.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} extdiff (@var{expr}, @var{i})

Calcula a derivada externa de @var{expr} com rela@value{cedilha}@~{a}o ao @'{i}ndice
@var{i}. A derivada externa @'{e} formalmente definida como o produto
cunha do operador de derivada parcial e uma forma diferencial. Como
tal, essa opera@value{cedilha}@~{a}o @'{e} tamb@'{e}m controlada atrav@'{e}s da escolha de @code{igeowedge_flag}.
Por exemplo:

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                      a      - a      + a
                            j k,i    i k,j    i j,k
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} hodge (@var{expr})

Calcula o Hodge dual de @var{expr}. Por exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g        g
                                                     %1 %106  %2 %107
                                            g        g      A        /6
                                             %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

@end example

@end deffn

@defvr {Vari@'{a}vel de Op@value{cedilha}@~{a}o} igeowedge_flag
Valor padr@~{a}o: @code{false}

Controla o comportamento de produto cunha e derivada externa. Quando
for esconhida para @code{false} (o padr@~{a}o), a no@value{cedilha}@~{a}o de formas diferenciais ir@'{a}
corresponder @`aquela de um campo tensor covariante totalmente antisim@'{e}trico.
Quando escolhida para @code{true}, formas diferenciais ir@~{a}o concordar com a no@value{cedilha}@~{a}o do
elemento volume.

@end defvr


@subsection Exportando express@~{o}es TeX

O pacote @code{itensor} fornece suporte limitado @`a exporta@value{cedilha}@~{a}o de express@~{o}es
de tensores para o TeX.  Uma vez que express@~{o}es @code{itensor} aparecem como chamada a fun@value{cedilha}@~{o}es,
o comando regular @code{tex} do Maxima n@~{a}o produzir@'{a} a sa@'{i}da
esperada. Voc@^{e} pode tentar em seu lugar o comando @code{tentex}, o qual tenta
traduzir express@~{o}es de tensores dentro de objetos TeX indexados apropriadamente.

@deffn {Fun@value{cedilha}@~{a}o} tentex (@var{expr})

Para usar a fun@value{cedilha}@~{a}o @code{tentex}, voc@^{e} deve primeiro chamar @code{tentex},
como no seguinte exemplo:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(tentex);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i            i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
            j k      m1 l        j l      m1 k        j l,k        j k,l
(%i5) tentex(%)$
$$\Gamma_@{j\,k@}^@{m_1@}\,\Gamma_@{l\,m_1@}^@{i@}-\Gamma_@{j\,l@}^@{m_1@}\,
 \Gamma_@{k\,m_1@}^@{i@}-\Gamma_@{j\,l,k@}^@{i@}+\Gamma_@{j\,k,l@}^@{i@}$$

@end example

Note o uso da declara@value{cedilha}@~{a}o @code{idummyx}, para evitar o aparecimento
do sinal de porcentagem na express@~{a}o TeX, o qual pode induzir a erros de compila@value{cedilha}@~{a}o.

Note Bem: Essa ves@~{a}o da fun@value{cedilha}@~{a}o @code{tentex} @'{e} um tanto quanto experimental.

@end deffn

@subsection Interagindo com o pacote @code{ctensor}

O pacote @code{itensor} possui a habilidade de gerar c@'{o}digo Maxima que pode
ent@~{a}o ser executado no contexto do pacote @code{ctensor}. A fun@value{cedilha}@~{a}o que executa
essa tarefa @'{e} @code{ic_convert}.

@deffn {Fun@value{cedilha}@~{a}o} ic_convert (@var{eqn})

Converte a equa@value{cedilha}@~{a}o @var{eqn} na sintaxe @code{itensor} para uma declara@value{cedilha}@~{a}o de atribui@value{cedilha}@~{a}o @code{ctensor}.
Adi@value{cedilha}@~{o}es impl@'{i}citas sobre @'{i}ndices que ocorrem exatamente duas vezes s@~{a}o tornadas expl@'{i}citas enquanto objetos
indexados s@~{a}o transformados em arrays (os arrays subscritos est@~{a}o na
ordem de covari@^{a}ncia seguidos de @'{i}ndices contravariantes dos objetos
indexados). A derivada de um objeto indexado ser@'{a} substitu@'{i}da pela
forma substantiva de @code{diff} tomada com rela@value{cedilha}@~{a}o a @code{ct_coords} subscrita
pelo @'{i}ndice de deriva@value{cedilha}@~{a}o. Os s@'{i}mbolos de Christoffel @code{ichr1} e @code{ichr2}
ir@~{a}o ser traduzidos para @code{lcs} e @code{mcs}, respectivamente e se
@code{metricconvert} for @code{true} ent@~{a}o todas as ocorr@^{e}ncias da m@'{e}trica
com dois @'{i}ndices covariantes (ou contravariantes) ir@~{a}o ser renomeadas para @code{lg}
(ou @code{ug}). Adicionalmente, ciclos @code{do} ir@~{a}o ser introduzidos adicionando sobre
todos os @'{i}ndices livres de forma que a
declara@value{cedilha}@~{a}o de atribui@value{cedilha}@~{a}o transformada pode ser avaliada atrav@'{e}s de apenas fazendo
@code{ev}. Os seguintes exemplos demonstam os recursos dessa
fun@value{cedilha}@~{a}o.

@example
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
@end example

@end deffn

@subsection Palavras reservadas

As palavras seguintes do Maxima s@~{a}o usadas internamente pelo pacote @code{itensor} e
n@~{a}o podem ser redefinidas:

@c REFORMAT THIS TABLE USING TEXINFO MARKUP
@example
  Keyword    Comments
  ------------------------------------------
  indices2() vers@~{a}o interna de @code{indices()}
  conti      Lista de @'{i}ndices contravariantes
  covi       Lista de @'{i}ndices covariantes de um objeto indexado
  deri       Lista de @'{i}ndices de derivada de um objeto indexado
  name       Retorna o nome de um objeto indexado
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
@end example

