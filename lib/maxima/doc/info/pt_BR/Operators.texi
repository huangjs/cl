@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Operators.texi/1.39/Fri Jun  8 05:36:44 2007/-ko/
@iftex
@hyphenation{con-se-cu-ti-vos}
@hyphenation{u-san-do}
@end iftex
@menu
* N-Argumentos::                        
* Operador n@~{a}o fixado::                       
* Operador P@'{o}sfixado::                     
* Operador Pr@'{e}fixado::                      
* Operadores Aritm@'{e}ticos::   
* Operadores Relacionais::   
* Operadores Geral::   
@end menu


@node N-Argumentos, Operador n@~{a}o fixado, Operadores, Operadores
@section N-Argumentos
Um operador @code{nary} @'{e} usado para denotar uma fun@value{cedilha}@~{a}o com qualquer n@'{u}mero de
argumentos, cada um dos quais @'{e} separado por uma ocorr@^{e}ncia do
operador, e.g. A+B ou A+B+C.  A fun@value{cedilha}@~{a}o @code{nary("x")}  @'{e} uma fun@value{cedilha}@~{a}o
de extens@~{a}o sint@'{a}tica para declarar x como sendo um operador @code{nary}.
Fun@value{cedilha}@~{o}es podem ser declaradas para serem
@code{nary}.  Se @code{declare(j,nary);} @'{e} conclu@'{i}da, diz ao simplicador para
simplificar, e.g. @code{j(j(a,b),j(c,d))} para @code{j(a, b, c, d)}.

Veja tamb@'{e}m @code{syntax}.

@node Operador n@~{a}o fixado, Operador P@'{o}sfixado, N-Argumentos, Operadores
@section Operador n@~{a}o fixado
Operadores @code{nofix} s@~{a}o usados para denotar fun@value{cedilha}@~{o}es sem argumentos.
A mera presen@value{cedilha}a de tal operador em um comando far@'{a} com que a
fun@value{cedilha}@~{a}o correspondente seja avaliada.  Por exemplo, quando se digita
"exit;" para sair de uma parada do Maxima, "exit" tem comportamento similar a um
operador @code{nofix}.  A fun@value{cedilha}@~{a}o @code{nofix("x")} @'{e} uma fun@value{cedilha}@~{a}o de extens@~{a}o
sint@'{a}tica que declara x como sendo um operador @code{nofix}. 

Veja tamb@'{e}m @code{syntax}.

@node Operador P@'{o}sfixado, Operador Pr@'{e}fixado, Operador n@~{a}o fixado, Operadores
@section Operador P@'{o}sfixado
Operadores @code{postfix} como a variedade @code{prefix} denotam fun@value{cedilha}@~{o}es
de um argumento simples, mas nesse caso  o argumento sucede
imediatamente uma ocorr@^{e}ncia do operador na seq@"{u}@^{e}ncia de caracteres de entrada, e.g. 3! .
Uma fun@value{cedilha}@~{a}o @code{postfix("x")} @'{e} uma fun@value{cedilha}@~{a}o de extens@~{a}o
sint@'{a}tica que declara x como sendo um operador @code{postfix}.

Veja tamb@'{e}m @code{syntax}.

@node Operador Pr@'{e}fixado, Operadores Aritm@'{e}ticos, Operador P@'{o}sfixado, Operadores
@section Operador Pr@'{e}fixado
Um operador @code{prefix} @'{e} um que significa uma fun@value{cedilha}@~{a}o de um
argumento, o qual imediatamente segue uma ocorr@^{e}ncia do
operador.  @code{prefix("x")} @'{e} uma fun@value{cedilha}@~{a}o de extens@~{a}o
sint@'{a}tica que declara x como sendo um operador @code{prefix}.

Veja tamb@'{e}m @code{syntax}.

@node Operadores Aritm@'{e}ticos, Operadores Relacionais, Operador Pr@'{e}fixado, Operadores
@section Operadores Aritm@'{e}ticos

@deffn {Operador} +
@ifinfo
@fnindex Adi@value{cedilha}@~{a}o
@end ifinfo
@deffnx {Operador} -
@ifinfo
@fnindex Subtra@value{cedilha}@~{a}o
@end ifinfo
@deffnx {Operador} *
@ifinfo
@fnindex Multiplica@value{cedilha}@~{a}o
@end ifinfo
@deffnx {Operador} /
@ifinfo
@fnindex Divis@~{a}o
@end ifinfo
@deffnx {Operador} ^
@ifinfo
@fnindex Exponencia@value{cedilha}@~{a}o
@end ifinfo

Os s@'{i}mbolos @code{+} @code{*} @code{/} e @code{^} representam
adi@value{cedilha}@~{a}o, multiplica@value{cedilha}@~{a}o, divis@~{a}o, e exponencia@value{cedilha}@~{a}o, respectivamente.
O nome desses operadores s@~{a}o @code{"+"} @code{"*"} @code{"/"} e @code{"^"},
os quais podem aparecer em lugares onde o nome da fun@value{cedilha}@~{a}o ou operador @'{e} requerido.

Os s@'{i}mbolos @code{+} e @code{-} representam a adi@value{cedilha}@~{a}o un@'{a}ria e a nega@value{cedilha}@~{a}o un@'{a}ria, respectivamente,
e os nomes desses operadores s@~{a}o @code{"+"} e @code{"-"}, respectivamente.

A subtra@value{cedilha}@~{a}o @code{a - b} @'{e} representada dentro do Maxima como a adi@value{cedilha}@~{a}o, @code{a + (- b)}.
Express@~{o}es tais como @code{a + (- b)} s@~{a}o mostradas como subtra@value{cedilha}@~{a}o.
Maxima reconhece @code{"-"} somente como o nome do operador un@'{a}rio de nega@value{cedilha}@~{a}o,
e n@~{a}o como o nome do operador bin@'{a}rio de subra@value{cedilha}@~{a}o.

A divis@~{a}o @code{a / b} @'{e} representada dentro do Maxima como multiplica@value{cedilha}@~{a}o, @code{a * b^(- 1)}.
Express@~{o}es tais como @code{a * b^(- 1)} s@~{a}o mostradas como divis@~{a}o.
Maxima reconhece @code{"/"} como o nome do operador de divis@~{a}o.

A adi@value{cedilha}@~{a}o e a multiplica@value{cedilha}@~{a}o s@~{a}o operadores en@'{a}rios e comutativos.
a divis@~{a}o e a exponencia@value{cedilha}@~{a}o s@~{a}o operadores bin@'{a}rios e n@~{a}o comutativos.

Maxima ordena os operandos de operadores n@~{a}o comutativos para construir uma representa@value{cedilha}@~{a}o can@^{o}nica.
Para armazenamento interno, a ordem @'{e} determinada por @code{orderlessp}.
Para mostrar na tela, a ordem para adi@value{cedilha}@~{a}o @'{e} determinada por @code{ordergreatp},
e para a multiplica@value{cedilha}@~{a}o, a ordem @'{e} a mesma da ordena@value{cedilha}@~{a}o para armazenamento interno.

Computa@value{cedilha}@~{o}es aritim@'{e}ticas s@~{a}o realizadas sobre n@'{u}meros literais
(inteiro, racionais, n@'{u}meros comuns em ponto flutuante, e grandes n@'{u}meros em ponto flutuante de dupla precis@~{a}o).
Execto a exponencia@value{cedilha}@~{a}o, todas as opera@value{cedilha}@~{o}es aritm@'{e}ticas sobre n@'{u}meros s@~{a}o simplificadas para n@'{u}meros.
A exponencia@value{cedilha}@~{a}o @'{e} simplificada para um n@'{u}mero se ou o operando @'{e} um n@'{u}mero comum em ponto flutuante ou um grande n@'{u}mero em ponto flutuante de dupla precis@~{a}o
ou se o resultado for um inteiro exato ou um racional exato;
de outra forma uma exponencia@value{cedilha}@~{a}o pode ser simplificada para @code{sqrt} ou outra exponencia@value{cedilha}@~{a}o ou permanecer inalterada.

A propaga@value{cedilha}@~{a}o de n@'{u}meros em ponto flutuante aplica-se a computa@value{cedilha}@~{o}es aritim@'{e}ticas:
Se qualquer operando for um grande n@'{u}mero em ponto flutuante, o resultado @'{e} um grande n@'{u}mero em ponto flutuante;
de outra forma, se qualquer operando for um n@'{u}mero em ponto flutuante comum, o resultado @'{e} um n@'{u}mero comum em ponto flutuante;
de outra forma, se os operandos forem racioanis ou inteiros e o resultado ser@'{a} um racional ou inteiro.

Computa@value{cedilha}@~{a}oes aritim@'{e}ticas s@~{a}o uma simplifica@value{cedilha}@~{a}o, n@~{a}o uma avalia@value{cedilha}@~{a}o.
Dessa forma a aritm@'{e}tica @'{e} realizada em  express@~{o}es com ap@'{o}strofo (mas simplificadas).

Opera@value{cedilha}@~{o}es aritm@'{e}ticas s@~{a}o aplicadas elemento-por-elemento
para listas quando a vari@'{a}vel global @code{listarith} for @code{true},
e sempre aplicada elemento-por-elemento para matrizes.
Quando um operando for uma lista ou uma matriz e outro for um operando de algum outro tipo,
o outro operando @'{e} combinado com cada um dos elementos da lista ou matriz.

Exemplos:

Adi@value{cedilha}@~{a}o e multiplica@value{cedilha}@~{a}o s@~{a}o opeadores en@'{a}rios comutativos.
Maxima ordena os operandos para construir uma representa@value{cedilha}@~{a}o can@^{o}nica.
Os nomes desses operadores s@~{a}o @code{"+"} e @code{"*"}.
@c ===beg===
@c c + g + d + a + b + e + f;
@c [op (%), args (%)];
@c c * g * d * a * b * e * f;
@c [op (%), args (%)];
@c apply ("+", [a, 8, x, 2, 9, x, x, a]);
@c apply ("*", [a, 8, x, 2, 9, x, x, a]);
@c ===end===

@example
(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
@end example

Divis@~{a}o e exponencia@value{cedilha}@~{a}o s@~{a}o operadores bin@'{a}rios e n@~{a}o comutativos.
Os nomes desses operadores s@~{a}o @code{"/"} e @code{"^"}.
@c ===beg===
@c [a / b, a ^ b];
@c [map (op, %), map (args, %)];
@c [apply ("/", [a, b]), apply ("^", [a, b])];
@c ===end===

@example
(%i1) [a / b, a ^ b];
                              a   b
(%o1)                        [-, a ]
                              b
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
@end example

Subtra@value{cedilha}@~{a}o e divis@~{a}o s@~{a}o representados internamente
em termos de adi@value{cedilha}@~{a}o e multiplica@value{cedilha}@~{a}o, respectivamente.
@c ===beg===
@c [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
@c [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
@c ===end===

@example
(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
@end example

C@'{a}lculos s@~{a}o realizados sobre n@'{u}meros lterais.
A propaga@value{cedilha}@~{a}o de n@'{u}meros em poto flutuante aplica-se.
@c ===beg===
@c 17 + b - (1/2)*29 + 11^(2/4);
@c [17 + 29, 17 + 29.0, 17 + 29b0];
@c ===end===

@example
(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
@end example

Computa@value{cedilha}@~oes aritm@'{e}ticas s@~{a}o uma simplifica@value{cedilha}@~{a}o, n@~{a}o uma avalia@value{cedilha}@~{a}o.
@c ===beg===
@c simp : false;
@c '(17 + 29*11/7 - 5^3);
@c simp : true;
@c '(17 + 29*11/7 - 5^3);
@c ===end===

@example
(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
@end example

A aritm@'{e}tica @'{e} realizada elemento-por-elemento para listas lists (dependendo de @code{listarith}) e dependendo de matrizes.
@c ===beg===
@c matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
@c 5 * matrix ([a, x], [h, u]);
@c listarith : false;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c listarith : true;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c ===end===

@example
(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
(%i2) 5 * matrix ([a, x], [h, u]);
                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
@end example

@end deffn

@deffn {Operador} **

Operador de exponencia@value{cedilha}@~{a}o.
Maxima reconhece @code{**} como o mesmo operador que @code{^} em entrada,
e @code{**} @'{e} mostrado como @code{^} em sa@'{i}da unidimensional,
ou colocando o expoente  como sobrescrito em sa@'{i}da bidimensional.

A fun@value{cedilha}@~{a}o @code{fortran} mostra o operador de exponencia@value{cedilha}@~{a}o com como @code{**},
independente de a entrada ter sido na forma @code{**} ou a forma @code{^}.

Exemplos:

@c ===beg===
@c is (a**b = a^b);
@c x**y + x^z;
@c string (x**y + x^z);
@c fortran (x**y + x^z);
@c ===end===
@example
(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
@end example

@end deffn

@node Operadores Relacionais, Operadores Geral, Operadores Aritm@'{e}ticos, Operadores
@section Operadores Relacionais

@deffn {Operador} <
@ifinfo
@fnindex Menor que
@end ifinfo
@deffnx {Operador} <=
@ifinfo
@fnindex Menor que ou igual a
@end ifinfo
@deffnx {Operador} >=
@ifinfo
@fnindex Maior que ou igual a
@end ifinfo
@deffnx {Operador} >
@ifinfo
@fnindex Maior que
@end ifinfo

@end deffn

@node Operadores Geral, , Operadores Relacionais, Operadores
@section Operadores Geral

@deffn {Operador} ^^
@ifinfo
@fnindex exponencia@value{cedilha}@~{a}o n@~{a}o comutativa
@end ifinfo

@end deffn

@deffn {Operador} !
@ifinfo
@fnindex Fatorial
@end ifinfo
O operador fatorial.
Para qualquer n@'{u}mero complexo @code{x} (inclu@'{i}ndo n@'{u}meros inteiros, racionais, e reais) exceto para
inteiros negativos, @code{x!} @'{e} definido como @code{gamma(x+1)}.

Para um inteiro @code{x}, @code{x!} simplifica para o produto de inteiros de 1 a @code{x} inclusive.
@code{0!} simplifica para 1.
Para um n@'{u}mero em ponto flutuante @code{x}, @code{x!} simplifica para o valor de @code{gamma (x+1)}.
Para @code{x} igual a @code{n/2} onde @code{n} @'{e} um inteiro @'{i}mpar,
@code{x!} simplifica para um fator racional vezes @code{sqrt (%pi)}
(uma vez que @code{gamma (1/2)} @'{e} igual a @code{sqrt (%pi)}).
Se @code{x} for qualquer outra coisa,
@code{x!} n@~{a}o @'{e} simplificado.

As vari@'{a}veis
@code{factlim}, @code{minfactorial}, e @code{factcomb} controlam a simplifica@value{cedilha}@~{a}o
de express@~{o}es contendo fatoriais.

As fun@value{cedilha}@~{o}es @code{gamma}, @code{bffac}, e @code{cbffac}
s@~{a}o variedades da fun@value{cedilha}@~{a}o @code{gamma}. 
@code{makegamma} substitui @code{gamma} para fun@value{cedilha}@~{o}es relacionadas a fatoriais.

Veja tamb@'{e}m @code{binomial}.

O fatorial de um inteiro, inteiro dividido por dois, ou argumento em ponto flutuante @'{e} simplificado
a menos que o operando seja maior que @code{factlim}.

@c ===beg===
@c factlim : 10;
@c [0!, (7/2)!, 4.77!, 8!, 20!];
@c ===end===
@example
(%i1) factlim : 10;
(%o1)                          10
(%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
+            105 sqrt(%pi)
+(%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
+                 16
@end example

O fatorial de um n@'{u}mero complexo, constante conhecida, ou express@~{a}o geral n@~{a}o @'{e} simplificado.
Ainda assim pode ser poss@'{i}vel simplificar o fatorial ap@'{o}s avaliar o operando.

@c ===beg===
@c [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
@c ev (%, numer, %enumer);
@c ===end===
@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357, 
                                               1.227580202486819]
@end example

O fatorial de um s@'{i}mbolo n@~{a}o associado n@~{a}o @'{e} simplificado.

@c ===beg===
@c kill (foo);
@c foo!;
@c ===end===
@example
(%i1) kill (foo);
(%o1)                         done
(%i2) foo!;
(%o2)                         foo!
@end example

Fatoriais s@~{a}o simplificados, n@~{a}o avaliados.
Dessa forma @code{x!} pode ser substitu@'{i}do mesmo em uma express@~{a}o com ap@'{o}strofo.

@c ===beg===
@c '([0!, (7/2)!, 4.77!, 8!, 20!]);
@c ===end===
@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                                             2432902008176640000]
@end example

@end deffn

@deffn {Operador} !!
@ifinfo
@fnindex Duplo fatorial
@end ifinfo
O operador de duplo fatorial.

Para um n@'{u}mero inteiro, n@'{u}mero em ponto flutuante, ou n@'{u}mero racional @code{n},
@code{n!!} avalia para o produto @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
onde @code{k} @'{e} igual a @code{entier (n/2)},
que @'{e}, o maior inteiro menor que ou igual a @code{n/2}.
Note que essa defini@value{cedilha}@~{a}o n@~{a}o coincide com outras defini@value{cedilha}@~{o}es publicadas
para argumentos que n@~{a}o s@~{a}o inteiros.
@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para um inteiro par (ou @'{i}mpar) @code{n}, @code{n!!} avalia para o produto de
todos os inteiros consecutivos pares (ou @'{i}mpares) de 2 (ou 1) at@'{e} @code{n} inclusive.

Para um argumento @code{n} que n@~{a}o @'{e} um n@'{u}mero inteiro, um n@'{u}mero em ponto flutuante, ou um n@'{u}mero racional,
@code{n!!} retorna uma forma substantiva @code{genfact (n, n/2, 2)}.
@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn

@deffn {Operador} #
@ifinfo
@fnindex N@~{a}o igual (desigualdade sint@'{a}tica)
@end ifinfo
Representa a nega@value{cedilha}@~{a}o da igualdade sint@'{a}tica @code{=}.

Note que pelo fato de as regras de avalia@value{cedilha}@~{a}o de express@~{o}es predicadas
(em particular pelo fato de @code{not @var{expr}} fazer com que ocorra a avalia@value{cedilha}@~{a}o de @var{expr}),
a forma @code{not @var{a} = @var{b}} n@~{a}o @'{e} equivalente @`a forma @code{@var{a} # @var{b}} em alguns casos.

Note que devido @`as regras para avalia@value{cedilha}@~{a}o de express@~{o}es predicadas
(em particular devido a @code{not @var{expr}} fazer com que a avalia@value{cedilha}@~{a}o de @var{expr} ocorra),
@code{not @var{a} = @var{b}} @'{e} equivalente a @code{is(@var{a} # @var{b})},
em lugar de ser equivalente a @code{@var{a} # @var{b}}.

Exemplos:
@c ===beg===
@c a = b;
@c @'{e} (a = b);
@c a # b;
@c not a = b;
@c @'{e} (a # b);
@c @'{e} (not a = b);
@c ===end===
@example
(%i1) a = b;
(%o1)                         a = b
(%i2) @'{e} (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) @'{e} (a # b);
(%o5)                         true
(%i6) @'{e} (not a = b);
(%o6)                         true
@end example

@end deffn

@deffn {Operador} .
@ifinfo
@fnindex Multiplica@value{cedilha}@~{a}o n@~{a}o comutativa matricial
@end ifinfo
O operador ponto, para multiplica@value{cedilha}@~{a}o (n@~{a}o comutativa) de matrizes.
Quando "." @'{e} usado com essa finalidade, espa@value{cedilha}os devem ser colocados em ambos os lados desse
operador, e.g. A . B.  Isso disting@"{u}e o operador ponto plenamente de um ponto decimal em
um n@'{u}mero em ponto flutuante.

Veja tamb@'{e}m
@code{dot},
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident},
e
@code{dotscrules}.

@end deffn

@deffn {Operador} :
@ifinfo
@fnindex Operador de atribui@value{cedilha}@~{a}o
@end ifinfo
O operador de atribui@value{cedilha}@~{a}o.  E.g. A:3 escolhe a vari@'{a}vel A para 3.

@end deffn

@deffn {Operador} ::
@ifinfo
@fnindex Operador de atribui@value{cedilha}@~{a}o (avalia o lado esquerdo da igualdade)
@end ifinfo
Operador de atribui@value{cedilha}@~{a}o.  :: atribui o valor da express@~{a}o
em seu lado direito para o valor da quantidade na sua esquerda, que pode
avaliar para uma vari@'{a}vel at@^{o}mica ou vari@'{a}vel subscrita.

@end deffn

@deffn {Operador} ::=
@ifinfo
@fnindex Operador de defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o de macro
@end ifinfo
Operador de defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o de macro.
@code{::=} define uma fun@value{cedilha}@~{a}o (chamada uma "macro" por raz@~{o}es hist@'{o}ricas)
que coloca um ap@'{o}strofo em seus argumentos (evitando avalia@value{cedilha}@~{a}o),
e a express@~{a}o que @'{e} retornada (chamada a "expans@~{a}o de macro")
@'{e} avaliada no contexto a partir do qual a macro foi chamada.
Uma fun@value{cedilha}@~{a}o de macro @'{e} de outra forma o mesmo que uma fun@value{cedilha}@~{a}o comum.

@code{macroexpand} retorna uma expans@~{a}o de macro (sem avaliar a expans@~{a}o).
@code{macroexpand (foo (x))} seguida por @code{''%} @'{e} equivalente a @code{foo (x)}
quando @code{foo} for uma fun@value{cedilha}@~{a}o de macro.

@code{::=} coloca o nome da nova fun@value{cedilha}@~{a}o de macro dentro da lista global @code{macros}.
@code{kill}, @code{remove}, e @code{remfunction} desassocia defini@value{cedilha}@~{o}es de fun@value{cedilha}@~{a}o de macro
e remove nomes de @code{macros}.

@code{fundef} e @code{dispfun} retornam respectivamente uma defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o de macro
e uma atribui@value{cedilha}@~{a}o dessa defini@value{cedilha}@~{a}o a um r@'{o}tulo, respectivamente.

Fun@value{cedilha}@~{o}es de macro comumente possuem express@~{o}es @code{buildq} e
@code{splice} para construir uma express@~{a}o,
que @'{e} ent@~{a}o avaliada.

Exemplos

Uma fun@value{cedilha}@~{a}o de macro coloca um ap@'{o}strofo em seus argumentos evitando ent@~{a}o a avalia@value{cedilha}@~{a}o,
ent@~{a}o mensagem (1) mostra @code{y - z}, n@~{a}o o valor de @code{y - z}.
A expans@~{a}o de macro (a express@~{a}o com ap@'{o}strofo @code{'(print ("(2) x is equal to", x))}
@'{e} avaliada no contexto a partir do qual a macro for chamada,
mostrando a mensagem (2).

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c printq1 (x) ::= block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
@c printq1 (y - z);
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printq1 (x) ::= block (print ("(1) x @'{e} igual a", x), '(print ("(2) x @'{e} igual a", x)));
(%o4) printq1(x) ::= block(print("(1) x @'{e} igual a", x), 
                                '(print("(2) x @'{e} igual a", x)))
(%i5) printq1 (y - z);
(1) x @'{e} igual a y - z 
(2) x @'{e} igual a %pi 
(%o5)                          %pi
@end example

Uma fun@value{cedilha}@~{a}o comum avalia seus argumentos, ent@~{a}o message (1) mostra o valor de @code{y - z}.
O valor de retorno n@~{a}o @'{e} avaliado, ent@~{a}o mensagem (2) n@~{a}o @'{e} mostrada
at@'{e} a avalia@value{cedilha}@~{a}o expl@'{i}cita @code{''%}.

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c printe1 (x) := block (print ("(1) x @'{e} igual a", x), '(print ("(2) x @'{e} igual a", x)));
@c printe1 (y - z);
@c ''%;
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printe1 (x) := block (print ("(1) x @'{e} igual a", x), '(print ("(2) x @'{e} igual a", x)));
(%o4) printe1(x) := block(print("(1) x @'{e} igual a", x), 
                                '(print("(2) x @'{e} igual a", x)))
(%i5) printe1 (y - z);
(1) x @'{e} igual a 1234 - 1729 w 
(%o5)              print((2) x @'{e} igual a, x)
(%i6) ''%;
(2) x @'{e} igual a %pi 
(%o6)                          %pi
@end example

@code{macroexpand} retorna uma expans@~{a}o de macro.
@code{macroexpand (foo (x))} seguido por @code{''%} @'{e} equivalente a @code{foo (x)}
quando @code{foo} for uma fun@value{cedilha}@~{a}o de macro.

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c g (x) ::= buildq ([x], print ("x @'{e} igual a", x));
@c macroexpand (g (y - z));
@c ''%;
@c g (y - z);
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) g (x) ::= buildq ([x], print ("x @'{e} igual a", x));
(%o4)    g(x) ::= buildq([x], print("x @'{e} igual a", x))
(%i5) macroexpand (g (y - z));
(%o5)              print(x @'{e} igual a, y - z)
(%i6) ''%;
x @'{e} igual a 1234 - 1729 w 
(%o6)                     1234 - 1729 w
(%i7) g (y - z);
x @'{e} igual a 1234 - 1729 w 
(%o7)                     1234 - 1729 w
@end example

@end deffn

@deffn {Operador} :=
@ifinfo
@fnindex Operador de defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o
@end ifinfo
O operador de defini@value{cedilha}@~{a}o de fun@value{cedilha}@~{a}o.  E.g. @code{f(x):=sin(x)} define
uma fun@value{cedilha}@~{a}o @code{f}.

@end deffn

@deffn {Operador} =
@ifinfo
@fnindex Operador de equa@value{cedilha}@~{a}o
@fnindex Igual (igualdade sint@'{a}tica)
@end ifinfo
O operador de equa@value{cedilha}@~{a}o.

Uma express@~{a}o @code{@var{a} = @var{b}}, por si mesma, representa
uma equa@value{cedilha}@~{a}o n@~{a}o avaliada, a qual pode ou n@~{a}o se manter.
Equa@value{cedilha}@~{o}es n@~{a}o avaliadas podem aparecer como argumentos para @code{solve} e @code{algsys}
ou algumas outras fun@value{cedilha}@~{o}es.

A fun@value{cedilha}@~{a}o @code{is} avalia @code{=} para um valor Booleano.
@code{is(@var{a} = @var{b})} avalia @code{@var{a} = @var{b}} para @code{true} quando @var{a} e @var{b}
forem id@^{e}nticos. Isto @'{e}, @var{a} e @var{b} forem @'{a}tomos que s@~{a}o id@^{e}nticos,
ou se eles n@~{a}o forem @'{a}tomos e seus operadores forem id@^{e}nticos e seus argumentos forem id@^{e}nticos.
De outra forma, @code{is(@var{a} = @var{b})} avalia para @code{false};
@code{is(@var{a} = @var{b})} nunca avalia para @code{unknown}.
Quando @code{is(@var{a} = @var{b})} for @code{true}, @var{a} e @var{b} s@~{a}o ditos para serem sintaticamente iguais,
em contraste para serem express@~{o}es equivalentes, para as quais @code{is(equal(@var{a}, @var{b}))} @'{e} @code{true}.
Express@~{o}es podem ser equivalentes e n@~{a}o sint@'{a}ticamente iguais.

A nega@value{cedilha}@~{a}o de @code{=} @'{e} representada por @code{#}.
Da mesma forma que com @code{=}, uma express@~{a}o @code{@var{a} # @var{b}}, por si mesma, n@~{a}o @'{e} avaliada.
@code{is(@var{a} # @var{b})} avalia @code{@var{a} # @var{b}} para
@code{true} ou @code{false}.

Complementando a fun@value{cedilha}@~{a}o @code{is},
alguns outros operadores avaliam @code{=} e @code{#} para @code{true} ou @code{false},
a saber @code{if}, @code{and}, @code{or}, e @code{not}.

Note que pelo fato de as regras de avalia@value{cedilha}@~{a}o de express@~{o}es predicadas
(em particular pelo fato de @code{not @var{expr}} fazer com que ocorra a avalia@value{cedilha}@~{a}o de @var{expr}),
a forma @code{not @var{a} = @var{b}} @'{e} equivalente a @code{is(@var{a} # @var{b})},
em lugar de ser equivalente a @code{@var{a} # @var{b}}.

@code{rhs} e @code{lhs} retornam o primeiro membro e o segundo membro de uma equa@value{cedilha}@~{a}o,
respectivamente, de uma equa@value{cedilha}@~{a}o ou inequa@value{cedilha}@~{a}o.

Veja tamb@'{e}m @code{equal} e @code{notequal}.

Exemplos:

Uma express@~{a}o @code{@var{a} = @var{b}}, por si mesma, representa
uma equa@value{cedilha}@~{a}o n@~{a}o avaliada, a qual pode ou n@~{a}o se manter.

@c ===beg===
@c eq_1 : a * x - 5 * y = 17;
@c eq_2 : b * x + 3 * y = 29;
@c solve ([eq_1, eq_2], [x, y]);
@c subst (%, [eq_1, eq_2]);
@c ratsimp (%);
@c ===end===
@example
(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
@end example

@code{is(@var{a} = @var{b})} avalia @code{@var{a} = @var{b}} para @code{true} quando @var{a} e @var{b}
s@~{a}o sintaticamente iguais (isto @'{e}, identicos).
Express@~{o}es podem ser equivalentes e n@~{a}o sintaticamente iguais.

@c ===beg===
@c a : (x + 1) * (x - 1);
@c b : x^2 - 1;
@c [is (a = b), is (a # b)];
@c [is (equal (a, b)), is (notequal (a, b))];
@c ===end===
@example
(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
@end example

Alguns operadores avaliam @code{=} e @code{#} para @code{true} ou @code{false}.

@c ===beg===
@c if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
@c eq_3 : 2 * x = 3 * x;
@c eq_4 : exp (2) = %e^2;
@c [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
@c ===end===
@example
(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
@end example

Devido a @code{not @var{expr}} fazer com que a avalia@value{cedilha}@~{a}o de @var{expr} ocorra,
@code{not @var{a} = @var{b}} @'{e} equivalente a @code{is(@var{a} # @var{b})}.

@c ===beg===
@c [2 * x # 3 * x, not (2 * x = 3 * x)];
@c is (2 * x # 3 * x);
@c ===end===
@example
(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
@end example

@end deffn

@c NEEDS EXAMPLES
@deffn {Operador} and
@ifinfo
@fnindex Conjun@value{cedilha}@~{a}o l@'{o}gica
@end ifinfo
O operador l@'{o}gico de conjun@value{cedilha}@~{a}o.
@code{and} @'{e} um operador n-@'{a}rio infixo;
seus operandos s@~{a}o express@~{o}es Booleanas, e seu resultado @'{e} um valor Booleano.

@code{and} for@value{cedilha}a avalia@value{cedilha}@~{a}o (como @code{is}) de um ou mais operandos,
e pode for@value{cedilha}ar a avalia@value{cedilha}@~{a}o de todos os operandos.

Operandos s@~{a}o avaliados na ordem em que aparecerem.
@code{and} avalia somente quantos de seus operandos forem necess@'{a}rios para determinar o resultado.
Se qualquer operando for @code{false},
o resultado @'{e} @code{false} e os operandos restantes n@~{a}o s@~{a}o avaliados.

O sinalizador global @code{prederror} governa o comportamento de @code{and}
quando um operando avaliado n@~{a}o pode ser determinado como sendo @code{true} ou @code{false}.
@code{and} imprime uma mensagem de erro quando @code{prederror} for @code{true}.  
De outra forma, operandos que n@~{a}o avaliam para @code{true} ou para @code{false} s@~{a}o aceitos,
and o resultado @'{e} uma express@~{a}o Booleana.

@code{and} n@~{a}o @'{e} comutativo:
@code{a and b} pode n@~{a}o ser igual a @code{b and a} devido ao tratamento de operandos indeterminados.

@end deffn

@c NEEDS EXAMPLES
@deffn {Operador} or
@ifinfo
@fnindex Disjun@value{cedilha}@~{a}o l@'{o}gica
@end ifinfo
O operador l@'{o}gico de disjun@value{cedilha}@~{a}o.
@code{or} @'{e} um operador n-@'{a}rio infixo;
seus operandos s@~{a}o express@~{o}es Booleanas, e seu resultado @'{e} um valor Booleano.

@code{or} for@value{cedilha}a avalia@value{cedilha}@~{a}o (como @code{is}) de um ou mais operandos,
e pode for@value{cedilha}ar a avalia@value{cedilha}@~{a}o de todos os operandos.

Operandos s@~{a}o avaliados na ordem em que aparecem.
@code{or} avalia somente quantos de seus operandos forem necess@'{a}rios para determinar o resultado.
Se qualquer operando for @code{true},
o resultado @'{e} @code{true} e os operandos restantes n@~{a}o s@~{a}o avaliados.

O sinalizador global @code{prederror} governa o comportamento de @code{or}
quando um operando avaliado n@~{a}o puder ser determinado como sendo @code{true} ou @code{false}.
@code{or} imprime uma mensagem de erro quando @code{prederror} for @code{true}.
De outra forma, operandos que n@~{a}o avaliam para @code{true} ou para @code{false} s@~{a}o aceitos,
E o resultado @'{e} uma express@~{a}o Booleana.

@code{or} n@~{a}o @'{e} comutativo:
@code{a or b} pode n@~{a}o ser igual a @code{b or a} devido ao tratamento de operando indeterminados.

@end deffn

@c NEEDS EXAMPLES
@deffn {Operador} not
@ifinfo
@fnindex Nega@value{cedilha}@~{a}o l@'{o}gica
@end ifinfo
O operador l@'{o}gico de nega@value{cedilha}@~{a}o.
@code{not} @'{e} operador prefixado;
Seu operando @'{e} uma express@~{a}o Booleana, e seu resultado @'{e} um valor Booleano.

@code{not} for@value{cedilha}a a avalia@value{cedilha}@~{a}o (como @code{is}) de seu operando.

O sinalizador global @code{prederror} governa o comportamento de @code{not}
quando seu operando n@~{a}o pode ser determinado em termos de @code{true} ou @code{false}.
@code{not} imprime uma mensagem de erro quando @code{prederror} for @code{true}.
De outra forma, operandos que n@~{a}o avaliam para @code{true} ou para @code{false} s@~{a}o aceitos,
e o resultado @'{e} uma express@~{a}o Booleana.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} abs (@var{expr})
Retorna o valor absoluto de @var{expr}.  Se @var{expr} for um n@'{u}mero complexo, retorna o m@'{o}dulo
complexo de @var{expr}.

@end deffn

@defvr {Palavra chave} additive
Se @code{declare(f,additive)} tiver sido executado, ent@~{a}o:

(1) Se @code{f} for uma fun@value{cedilha}@~{a}o de uma @'{u}nica vari@'{a}vel, sempre que o simplificador encontrar @code{f} aplicada
a uma adi@value{cedilha}@~{a}o, @code{f} ser@'{a} distribu@'{i}do sobre aquela adi@value{cedilha}@~{a}o.  I.e. @code{f(y+x)} ir@'{a}
simplificar para @code{f(y)+f(x)}.

(2) Se @code{f} for uma fun@value{cedilha}@~{a}o de 2 ou mais argumentos, a adi@value{cedilha}@~{a}o @'{e} definida como 
adi@value{cedilha}@~{a}o no primeiro argumento para @code{f}, como no caso de @code{sum} ou  
@code{integrate}, i.e. @code{f(h(x)+g(x),x)} ir@'{a} simplificar para @code{f(h(x),x)+f(g(x),x)}.
Essa simplifica@value{cedilha}@~{a}o n@~{a}o ocorre quando @code{f} @'{e} aplicada para express@~{o}es da
forma @code{sum(x[i],i,lower-limit,upper-limit)}.

@end defvr

@c NEEDS TO BE REWORKED. NOT CONVINCED THIS SYMBOL NEEDS ITS OWN ITEM
@c (SHOULD BE DESCRIBED IN CONTEXT OF EACH FUNCTION WHICH RECOGNIZES IT)
@defvr {Palavra chave} allbut
trabalha com os comandos @code{part} (i.e. @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart}, e @code{lpart}).  Por exemplo,

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, [2, 5]);
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

enquanto

@c ===beg===
@c expr : e + d + c + b + a;
@c part (expr, allbut (2, 5));
@c ===end===
@example
(%i1) expr : e + d + c + b + a;
(%o1)                   e + d + c + b + a
(%i2) part (expr, allbut (2, 5));
(%o2)                       e + c + b
@end example

@code{allbut} @'{e} tamb@'{e}m reconhecido por @code{kill}.
 
@c ===beg===
@c [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
@c kill (allbut (cc, dd));
@c [aa, bb, cc, dd];
@c ===end===
@example
(%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
(%o1)                 [11, 22, 33, 44, 55]
(%i2) kill (allbut (cc, dd));
(%o0)                         done
(%i1) [aa, bb, cc, dd];
(%o1)                   [aa, bb, 33, 44]
@end example

@code{kill(allbut(@var{a_1}, @var{a_2}, ...))} tem o mesmo efeito que @code{kill(all)}
exceto que n@~{a}o elimina os s@'{i}mbolos @var{a_1}, @var{a_2}, ... .

@end defvr

@defvr {Declara@value{cedilha}@~{a}o} antisymmetric
Se @code{declare(h,antisymmetric)} @'{e} conclu@'{i}da, diz ao
simplicador que @code{h} @'{e} uma fun@value{cedilha}@~{a}o antisim@'{e}trica.  E.g. @code{h(x,z,y)} simplificar@'{a} para
@code{- h(x, y, z)}.  Isto @'{e}, dar@'{a} (-1)^n vezes o resultado dado por
@code{symmetric} ou @code{commutative}, quando n for o n@'{u}mero de interescolhas de dois
argumentos necess@'{a}rios para converter isso naquela forma.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} cabs (@var{expr})
Retorna o valor absoluto complexo (o m@'{o}dulo complexo) de
@var{expr}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ceiling (@var{x})

Quando @var{x} for um n@'{u}mero real, retorna o @'{u}ltimo inteiro que 
@'{e} maior que ou igual a @var{x}.  

Se @var{x} for uma express@~{a}o constante (@code{10 * %pi}, por exemplo), 
@code{ceiling} avalia @var{x} usando grandes n@'{u}meros em ponto flutuante, e 
aplica @code{ceiling} para o grande n@'{u}mero em ponto flutuante resultante. Porque @code{ceiling} usa
avalia@value{cedilha}@~{a}o de ponto flutuante, @'{e} poss@'{i}vel, embora improv@'{a}vel, 
que @code{ceiling} possa retornar uma valor err@^{o}neo para entradas
constantes. Para prevenir erros, a avalia@value{cedilha}@~{a}o de ponto flutuante
@'{e} conclu@'{i}da usando tr@^{e}s valores para @code{fpprec}.

Para entradas n@~{a}o constantes, @code{ceiling} tenta retornar um valor
simplificado.  Aqui est@'{a} um exemplo de simplifica@value{cedilha}@~{o}es que @code{ceiling}
conhece:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                         false
@end example

A fun@value{cedilha}@~{a}o @code{ceiling} n@~{a}o mapeia automaticamente sobre listas ou matrizes.
Finalmente, para todas as entradas que forem manifestamente complexas, @code{ceiling} retorna 
uma forma substantiva.

Se o intervalo de uma fun@value{cedilha}@~{a}o @'{e} um subconjunto dos inteiros, o intervalo pode ser
declarado @code{integervalued}. Ambas as fun@value{cedilha}@~{o}es @code{ceiling} e @code{floor}
podem usar essa informa@value{cedilha}@~{a}o; por exemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} charfun (@var{p})

Retorna 0 quando o predicado @var{p} avaliar para @code{false}; retorna
1 quando o predicado avaliar para @code{true}.  Quando o predicado
avaliar para alguma coisa que n@~{a}o @code{true} ou @code{false} (@code{unknown}), 
retorna uma forma substantiva.

Exemplos:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun (x < 1);
(%o1)                    charfun(x < 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('"and" (-1 < x, x < 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
@end example

@end deffn

@defvr {Declara@value{cedilha}@~{a}o} commutative
Se @code{declare(h,commutative)} @'{e} conclu@'{i}da, diz ao
simplicador que @code{h} @'{e} uma fun@value{cedilha}@~{a}o comutativa.  E.g. @code{h(x,z,y)} ir@'{a}
simplificar para @code{h(x, y, z)}.  Isto @'{e} o mesmo que @code{symmetric}.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} compare (@var{x}, @var{y})

Retorna um operador de compara@value{cedilha}@~{a}o @var{op}
(@code{<}, @code{<=}, @code{>}, @code{>=}, @code{=}, ou @code{#}) tal que
@code{is (@var{x} @var{op} @var{y})} avalia para @code{true};
quando ou @var{x} ou @var{y} dependendo de @code{%i} e
@code{@var{x} # @var{y}}, retorna @code{notcomparable};
Quando n@~{a}o existir tal operador ou
Maxima n@~{a}o estiver apto a determinar o operador, retorna @code{unknown}.

Exemplos:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare (1, 2);
(%o1)                           <
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          <=
@end example

A fun@value{cedilha}@~{a}o @code{compare} n@~{a}o tenta de terminar se o dom@'{i}nio real de
seus argumentos @'{e} n@~{a}o vazio; dessa forma

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           <
@end example

O dom@'{i}nio real de @code{acos (x^2 + 1)} @'{e} vazio.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} entier (@var{x})
Retorna o @'{u}ltimo inteiro menor que ou igual a @var{x} onde @var{x} @'{e} num@'{e}rico.  @code{fix} (como em
@code{fixnum}) @'{e} um sin@^{o}nimo disso, ent@~{a}o @code{fix(@var{x})} @'{e} precisamente o mesmo.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~{a}o} equal (@var{a}, @var{b})

Representa a equival@^{e}ncia, isto @'{e}, valor igual.
 
Por si mesma, @code{equal} n@~{a}o avalia ou simplifica.
A fun@value{cedilha}@~{a}o @code{is} tenta avaliar @code{equal} para um valor Booleano.
@code{is(equal(@var{a}, @var{b}))} 
retorna @code{true} (ou @code{false}) se
e somente se @var{a} e @var{b} forem iguais (ou n@~{a}o iguais) para todos os poss@'{i}veis
valores de suas vari@'{a}veis, como determinado atrav@'{e}s da avalia@value{cedilha}@~{a}o de @code{ratsimp(@var{a} - @var{b})};
se @code{ratsimp} retornar 0, as duas express@~{o}es s@~{a}o consideradas equivalentes.
Duas express@~{o}es podem ser equivalentes mesmo se mesmo se elas n@~{a}o forem sintaticamente iguais (i.e., identicas).

Quando @code{is} falhar em reduzir @code{equal} a @code{true} ou @code{false},
o resultado @'{e} governado atrav@'{e}s do sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
@code{is} reclama com uma mensagem de erro.
De outra forma, @code{is} retorna @code{unknown}.

Complementando @code{is},
alguns outros operadores avaliam @code{equal} e @code{notequal} para @code{true} ou @code{false},
a saber @code{if}, @code{and}, @code{or}, e @code{not}.

@c FOLLOWING STATEMENT IS MORE OR LESS TRUE BUT I DON'T THINK THE DETAILS ARE CORRECT
@c Declarations (integer, complex, etc)
@c for variables appearing in @var{a} and @var{b} are ignored by @code{equal}.
@c All variables are effectively assumed to be real-valued.

A nega@value{cedilha}@~{a}o de @code{equal} @'{e} @code{notequal}.

Exemplos:

Por si mesmo, @code{equal} n@~{a}o avalia ou simplifica.

@c ===beg===
@c equal (x^2 - 1, (x + 1) * (x - 1));
@c equal (x, x + 1);
@c equal (x, y);
@c ===end===
@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

A fun@value{cedilha}@~{a}o @code{is} tenta avaliar @code{equal} para um valor Booleano.
@code{is(equal(@var{a}, @var{b}))} retorna @code{true} quando @code{ratsimp(@var{a} - @var{b})} retornar 0.
Duas express@~{o}es podem ser equivalentes mesmo se n@~{a}o forem sintaticamente iguais (i.e., identicas).

@c ===beg===
@c ratsimp (x^2 - 1 - (x + 1) * (x - 1));
@c is (equal (x^2 - 1, (x + 1) * (x - 1)));
@c is (x^2 - 1 = (x + 1) * (x - 1));
@c ratsimp (x - (x + 1));
@c is (equal (x, x + 1));
@c is (x = x + 1);
@c ratsimp (x - y);
@c is (equal (x, y));
@c is (x = y);
@c ===end===
@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
@end example
 
Quando @code{is} falha em reduzir @code{equal} a @code{true} ou @code{false},
o resultado @'{e} governado atrav@'{e}s do sinalizador global @code{prederror}.
 
@c ===beg===
@c [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
@c ratsimp (aa - bb);
@c prederror : true;
@c is (equal (aa, bb));
@c prederror : false;
@c is (equal (aa, bb));
@c ===end===
 @example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
 (%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

Alguns operadores avaliam @code{equal} e @code{notequal} para @code{true} ou @code{false}.

@c ===beg===
@c if equal (y, y - 1) then FOO else BAR;
@c eq_1 : equal (x, x + 1);
@c eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
@c [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
@c ===end===
@example
(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

Devido a @code{not @var{expr}} fazer com que ocorra a avalia@value{cedilha}@~{a}o de @var{expr},
@code{not equal(@var{a}, @var{b})} @'{e} equivalente a @code{is(notequal(@var{a}, @var{b}))}.

@c ===beg===
@c [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
@c is (notequal (2*z, 2*z - 1));
@c ===end===
@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} floor (@var{x})

Quando @var{x} for um n@'{u}mero real, retorna o maior inteiro que 
@'{e} menor que ou igual a @var{x}.

Se @var{x} for uma express@~{a}o constante (@code{10 * %pi}, for exemplo), 
@code{floor} avalia @var{x} usando grandes n@'{u}meros em ponto flutuante, e 
aplica @code{floor} ao grande n@'{u}mero em ponto flutuante resultante. Porque @code{floor} usa
avalia@value{cedilha}@~{a}o em ponto flutuante, @'{e} poss@'{i}vel, embora improv@'{a}vel, 
que @code{floor} n@~{a}o possa retornar um valor err@^{o}neo para entradas
constantes.  Para prevenir erros, a avalia@value{cedilha}@~{a}o de ponto flutuante
@'{e} conclu@'{i}da usando tr@^{e}s valores para @code{fpprec}.

Para entradas n@~{a}o constantes, @code{floor} tenta retornar um valor
simplificado.  Aqui est@'{a} exemplos de simplifica@value{cedilha}@~{o}es que @code{floor}
conhece:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a));
@c ===end===
@example
(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
@end example

A fun@value{cedilha}@~{a}o @code{floor} n@~{a}o mapeia automaticamente sobre listas ou matrizes.
Finalmente, para todas as entradas que forem manifestamente complexas, @code{floor} retorna
uma forma substantiva.

Se o intervalo de uma fun@value{cedilha}@~{a}o for um subconjunto dos inteiros, o intervalo pode ser
declarado @code{integervalued}. Ambas as fun@value{cedilha}@~{o}es @code{ceiling} e @code{floor}
podem usar essa informa@value{cedilha}@~{a}o; por exemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} notequal (@var{a}, @var{b})
Represents the negation of @code{equal(@var{a}, @var{b})}.

Exemplos:

@c ===beg===
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c maybe (notequal (a, b));
@c ===end===
@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a > b);
(%o6)                        [a > b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c NOTE THAT eval IS RECOGNIZED ONLY AS AN ARGUMENT TO ev,
@c BUT FOR SOME REASON eval DOES NOT HAVE THE evflag PROPERTY
@deffn {Operador} eval
Como um argumento em uma chamada a @code{ev (@var{expr})},
@code{eval} causa uma avalia@value{cedilha}@~{a}o extra de @var{expr}.
Veja @code{ev}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} evenp (@var{expr})
Retorna @code{true} se @var{expr} for um inteiro sempre.
@c THIS IS STRANGE -- SHOULD RETURN NOUN FORM IF INDETERMINATE
@code{false} @'{e} retornado em todos os outros casos.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} fix (@var{x})
Um sin@^{o}nimo para @code{entier (@var{x})}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} fullmap (@var{f}, @var{expr_1}, ...)
Similar a @code{map}, mas @code{fullmap} mant@'{e}m mapeadas para
baixo todas as subexpress@~{o}es at@'{e} que os operadores principais n@~{a}o mais sejam os
mesmos.

@code{fullmap} @'{e} usada pelo simplificador do
Maxima para certas manipula@value{cedilha}@~{o}es de matrizes; dessa forma, Maxima algumas vezes gera
uma mensagem de erro concernente a @code{fullmap} mesmo apesar de @code{fullmap} n@~{a}o ter sido
explicitamente chamada pelo usu@'{a}rio.

Exemplos:

@c ===beg===
@c a + b * c;
@c fullmap (g, %);
@c map (g, %th(2));
@c ===end===
@example
(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} fullmapl (@var{f}, @var{list_1}, ...)
Similar a @code{fullmap}, mas @code{fullmapl} somente mapeia sobre
listas e matrizes.

Exemplo:

@c ===beg===
@c fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
@c ===end===
@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} is (@var{expr})
Tenta determinar se a @var{expr} predicada (express@~{o}es que avaliam para @code{true}
ou @code{false}) @'{e} dedut@'{i}vel de fatos localizados na base de dados de @code{assume}.

Se a dedutibilidade do predicado for @code{true} ou @code{false},
@code{is} retorna @code{true} ou @code{false}, respectivamente.
De outra forma, o valor de retorno @'{e} governado atrav@'{e}s do sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
@code{is} reclama com uma mensagem de erro.
De outra forma, @code{is} retorna @code{unknown}.

@code{ev(@var{expr}, pred)}
(que pode ser escrita da forma  @code{@var{expr}, pred} na linha de comando interativa)
@'{e} equivalente a @code{is(@var{expr})}.

Veja tamb@'{e}m @code{assume}, @code{facts}, e @code{maybe}.

Exemplos:

@code{is} causa avalia@value{cedilha}@~{a}o de predicados.
@c GENERATED FROM:
@c %pi > %e;
@c @'{e} (%pi > %e);

@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) @'{e} (%pi > %e);
(%o2)                         true
@end example

@code{is} tenta derivar predicados da base de dados do @code{assume}.

@c ===beg===
@c assume (a > b);
@c assume (b > c);
@c @'{e} (a < b);
@c @'{e} (a > c);
@c @'{e} (equal (a, c));
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) @'{e} (a < b);
(%o3)                         false
(%i4) @'{e} (a > c);
(%o4)                         true
(%i5) @'{e} (equal (a, c));
(%o5)                         false
@end example

Se @code{is} n@~{a}o puder nem comprovar nem refutar uma forma predicada a partir da base de dados de @code{assume},
o sinalizador global @code{prederror} governa o comportamento de @code{is}.

@c ===beg===
@c assume (a > b);
@c prederror: true$
@c @'{e} (a > 0);
@c prederror: false$
@c @'{e} (a > 0);
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) @'{e} (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) @'{e} (a > 0);
(%o5)                        unknown
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} maybe (@var{expr})
Tenta determinar se a @var{expr} predicada
@'{e} dedut@'{i}vel dos fatos na base de dados de @code{assume}.

Se a dedutibilidade do predicado for @code{true} ou @code{false},
@code{maybe} retorna @code{true} ou @code{false}, respectivamente.
De outra forma, @code{maybe} retorna @code{unknown}.

@code{maybe} @'{e} funcinalmente equivalente a @code{is} com @code{prederror: false},
mas o resultado @'{e} computado sem atualmente atribuir um valor a @code{prederror}.

Veja tamb@'{e}m @code{assume}, @code{facts}, e @code{is}.

Exemplos:

@c ===beg===
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);
@c ===end===
@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} isqrt (@var{x})
Retorna o "inteiro ra@'{i}z quadrada"
do valor absoluto de @var{x},
que @'{e} um inteiro.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lmax (@var{L})

Quando @var{L} for uma lista ou um conjunto, retorna @code{apply ('max, args (@var{L}))}.  Quando @var{L} n@~{a}o for uma
lista ou tamb@'{e}m n@~{a}o for um conjunto, sinaliza um erro.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} lmin (@var{L})

Quando @var{L} for uma lista ou um conjunto, retorna @code{apply ('min, args (@var{L}))}. Quando @var{L} n@~{a}o for uma
lista ou ou tamb@'{e}m n@~{a}o for um conjunto, sinaliza um erro.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} max (@var{x_1}, ..., @var{x_n})

Retorna um valor simplificado para o m@'{a}ximo entre as express@~{o}es @var{x_1} a @var{x_n}.
Quando @code{get (trylevel, maxmin)}, for dois ou mais, @code{max} usa a simplifica@value{cedilha}@~{a}o 
@code{max (e, -e) --> |e|}.  Quando @code{get (trylevel, maxmin)} for 3 ou mais, @var{max} tenta
eliminar express@~{o}es que estiverem entre dois outros argumentos; por exemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}. Para escolher o valor de @code{trylevel} para 2, use
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} min (@var{x_1}, ..., @var{x_n})

Retorna um valor simplificado para o m@'{i}nimo entre as express@~{o}es @code{x_1} at@'{e} @code{x_n}.
Quando @code{get (trylevel, maxmin)}, for 2 ou mais, @code{min} usa a simplifica@value{cedilha}@~{a}o 
@code{min (e, -e) --> -|e|}.  Quando @code{get (trylevel, maxmin)} for 3 ou mais, @code{min} tenta
eliminar express@~{o}es que estiverem entre dois outros argumentos; por exemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}. Para escolher o valor de @code{trylevel} para 2, use
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} polymod (@var{p})
@deffnx {Fun@value{cedilha}@~{a}o} polymod (@var{p}, @var{m})
Converte o polin@^{o}mio @var{p} para uma representa@value{cedilha}@~{a}o modular
com rela@value{cedilha}@~{a}o ao m@'{o}dulo corrente que @'{e} o valor da vari@'{a}vel
@code{modulus}.  

@code{polymod (@var{p}, @var{m})} especifica um m@'{o}dulo @var{m} para ser usado 
em lugar do valor corrente de @code{modulus}.

Veja @code{modulus}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} mod (@var{x}, @var{y})

Se @var{x} e @var{y} forem n@'{u}meros reais e @var{y} for n@~{a}o nulo,
retorna @code{@var{x} - @var{y} * floor(@var{x} / @var{y})}.
Adicionalmente para todo real @var{x}, n@'{o}s temos @code{mod (@var{x}, 0) = @var{x}}. Para uma discurs@~{a}o da
defini@value{cedilha}@~{a}o @code{mod (@var{x}, 0) = @var{x}}, veja a Se@value{cedilha}@~{a}o 3.4, de "Concrete Mathematics," 
por Graham, Knuth, e Patashnik. A fun@value{cedilha}@~{a}o @code{mod (@var{x}, 1)} 
@'{e} uma fun@value{cedilha}@~{a}o dente de serra com per@'{i}odo 1 e com @code{mod (1, 1) = 0} e 
@code{mod (0, 1) = 0}.

Para encontrar o argumento (um n@'{u}mero no intervalo @code{(-%pi, %pi]}) de um 
n@'{u}mero complexo, use a fun@value{cedilha}@~{a}o @code{@var{x} |-> %pi - mod (%pi - @var{x}, 2*%pi)}, onde 
@var{x} @'{e} um argumento.

Quando @var{x} e @var{y} forem express@~{o}es constantes (@code{10 * %pi}, por exemplo), @code{mod}
usa o mesmo esquema de avalia@value{cedilha}@~{a}o em ponto flutuante que @code{floor} e @code{ceiling} usam.
Novamente, @'{e} poss@'{i}vel, embora improv@'{a}vel, que @code{mod} possa retornar um
valor err@^{o}neo nesses casos.

Para argumentos n@~{a}o num@'{e}ricos @var{x} ou @var{y}, @code{mod }conhece muitas regras de
simplifica@value{cedilha}@~{a}o:

@c ===beg===
@c mod (x, 0);
@c mod (a*x, a*y);
@c mod (0, x);
@c ===end===
@example
(%i1) mod (x, 0);
(%o1)                           x
(%i2) mod (a*x, a*y);
(%o2)                      a mod(x, y)
(%i3) mod (0, x);
(%o3)                           0
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} oddp (@var{expr})
@'{e} @code{true} se @var{expr} for um inteiro @'{i}mpar.
@c THIS IS STRANGE -- SHOULD RETURN NOUN FORM IF INDETERMINATE
@code{false} @'{e} retornado em todos os outros casos.

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c NOTE THAT pred IS RECOGNIZED ONLY AS AN ARGUMENT TO ev,
@c BUT FOR SOME REASON pred DOES NOT HAVE THE evflag PROPERTY
@deffn {Operador} pred
Como um argumento em uma chamada a @code{ev (@var{expr})},
@code{pred} faz com que predicados (express@~{o}es que avaliam para @code{true}
ou @code{false}) sejam avaliados.
Veja @code{ev}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} make_random_state (@var{n})
@deffnx {Fun@value{cedilha}@~{a}o} make_random_state (@var{s})
@deffnx {Fun@value{cedilha}@~{a}o} make_random_state (true)
@deffnx {Fun@value{cedilha}@~{a}o} make_random_state (false)
@c OMIT THIS FOR NOW. SEE COMMENT BELOW.
@c @defunx make_random_state (@var{a})
Um objeto de estado rand@^{o}mico representa o estado do gerador de n@'{u}meros rand@^{o}micos (aleat@'{o}rios).
O estado compreende 627 palavras de 32 bits.

@code{make_random_state (@var{n})} retorna um novo objeto de estado rand@^{o}mico
criado de um valor inteiro semente igual a @var{n} modulo 2^32.  
@var{n} pode ser negativo.

@c OMIT THIS FOR NOW. NOT SURE HOW THIS IS SUPPOSED TO WORK.
@c @code{make_random_state (@var{a})} returns a new random state object
@c created from an array @var{a}, which must be a Lisp array of 32 unsigned bytes.

@code{make_random_state (@var{s})} retorna uma copia do estado rand@^{o}mico @var{s}.

@code{make_random_state (true)} retorna um novo objeto de estado rand@^{o}mico,
usando a hora corrente  do rel@'{o}gio do computador como semente.

@code{make_random_state (false)} retorna uma c@'{o}pia do estado corrente
do gerador de n@'{u}meros rand@^{o}micos.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} set_random_state (@var{s})
Copia @var{s} para o estado do gerador de n@'{u}meros rand@^{o}micos.

@code{set_random_state} sempre retorna @code{done}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} random (@var{x})
Retorna um n@'{u}mero pseudorand@^{o}mico. Se @var{x} @'{e} um inteiro, @code{random (@var{x})} retorna um
inteiro de 0 a @code{@var{x} - 1} inclusive. Se @var{x} for um n@'{u}mero em ponto flutuante,
@code{random (@var{x})} retorna um n@'{u}mero n@~{a}o negativo em ponto flutuante menor que @var{x}.
@code{random} reclama com um erro se @var{x} n@~{a}o for nem um inteiro nem um n@'{u}mero em ponto flutuante,
ou se @var{x} n@~{a}o for positivo.

As fun@value{cedilha}@~{o}es @code{make_random_state} e @code{set_random_state}
mant@'{e}m o estado do gerador de n@'{u}meros rand@^{o}micos.

O gerador de n@'{u}meros rand@^{o}micos do Maxima @'{e} uma implementa@value{cedilha}@~{a}o do algor@'{i}tmo de Mersenne twister MT 19937.

Exemplos:

@c ===beg===
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c ===end===
@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rationalize (@var{expr})

Converte todos os n@'{u}meros em ponto flutuante de precis@~{a}o dupla e grandes n@'{u}meros em ponto flutuante na express@~{a}o do Maxima
@var{expr} para seus exatos equivalentes racionais. Se voc@^{e} n@~{a}o estiver faminilarizado com
a representa@value{cedilha}@~{a}o bin@'{a}ria de n@'{u}meros em ponto flutuante, voc@^{e} pode se
surpreender que @code{rationalize (0.1)} n@~{a}o seja igual a 1/10.  Esse comportamento
n@~{a}o @'{e} especial para o Maxima -- o n@'{u}mero 1/10 tem uma representa@value{cedilha}@~{a}o bin@'{a}ria
repetitiva e n@~{a}o terminada.

@c ===beg===
@c rationalize (0.5);
@c rationalize (0.1);
@c fpprec : 5$
@c rationalize (0.1b0);
@c fpprec : 20$
@c rationalize (0.1b0);
@c rationalize (sin (0.1*x + 5.6));
@c ===end===
@example
(%i1) rationalize (0.5);
                                1
(%o1)                           -
                                2
(%i2) rationalize (0.1);
                               1
(%o2)                          --
                               10
 (%i3) fpprec : 5$
(%i4) rationalize (0.1b0);
                             209715
(%o4)                        -------
                             2097152
(%i5) fpprec : 20$
(%i6) rationalize (0.1b0);
                     236118324143482260685
(%o6)                ----------------------
                     2361183241434822606848
(%i7) rationalize (sin (0.1*x + 5.6));
                              x    28
(%o7)                     sin(-- + --)
                              10   5
@end example

Exemplo de utiliza@value{cedilha}@~{a}o:

@c ===beg===
@c unitfrac(r) := block([uf : [], q],
@c     if not(ratnump(r)) then error("A entrada para 'unitfrac' deve ser um n@'{u}mero racional"),
@c     while r # 0 do (
@c         uf : cons(q : 1/ceiling(1/r), uf),
@c         r : r - q),
@c     reverse(uf)); 
@c unitfrac (9/10);
@c apply ("+", %);
@c unitfrac (-9/10);
@c apply ("+", %);
@c unitfrac (36/37);
@c apply ("+", %);
@c ===end===
@example
(%i1) unitfrac(r) := block([uf : [], q],
    if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
    while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
    reverse(uf)); 
(%o1) unitfrac(r) := block([uf : [], q], 
if not ratnump(r) then error("The input to 'unitfrac' must be a rational number"
                                     1
), while r # 0 do (uf : cons(q : ----------, uf), r : r - q), 
                                         1
                                 ceiling(-)
                                         r
reverse(uf))
(%i2) unitfrac (9/10);
                            1  1  1
(%o2)                      [-, -, --]
                            2  3  15
(%i3) apply ("+", %);
                               9
(%o3)                          --
                               10
(%i4) unitfrac (-9/10);
                                  1
(%o4)                       [- 1, --]
                                  10
(%i5) apply ("+", %);
                                9
(%o5)                         - --
                                10
(%i6) unitfrac (36/37);
                        1  1  1  1    1
(%o6)                  [-, -, -, --, ----]
                        2  3  8  69  6808
(%i7) apply ("+", %);
                               36
(%o7)                          --
                               37
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} sign (@var{expr})
Tenta determinar o sinal de @var{expr}
a partir dos fatos na base de dados corrente.  Retorna uma das
seguintes respostar: @code{pos} (positivo), @code{neg} (negativo), @code{zero}, @code{pz}
(positivo ou zero), @code{nz} (negativo ou zero), @code{pn} (positivo ou negativo),
ou @code{pnz} (positivo, negativo, ou zero, i.e. nada se sabe sobre o sinal da epress@~{a}o).

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} signum (@var{x})
Para um @var{x} num@'{e}rico retorna 0 se @var{x} for 0, de outra forma retorna -1 ou +1
@`a medida que @var{x} seja menor ou maior que 0, respectivamente.

Se @var{x} n@~{a}o for num@'{e}rico ent@~{a}o uma forma simplificada mas equivalente @'{e} retornada.
Por exemplo, @code{signum(-x)} fornece @code{-signum(x)}.
@c UMM, THIS ISN'T THE WHOLE STORY, AS IT APPEARS signum CONSULTS THE assume DATABASE FOR SYMBOLIC ARGUMENT

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} sort (@var{L}, @var{P})
@deffnx {Fun@value{cedilha}@~{a}o} sort (@var{L})
Organiza uma lista @var{L} coforme o predicado @code{P} de dois argumentos,
de forma que @code{@var{P} (@var{L}[k], @var{L}[k + 1])} seja @code{true}
para qualquer dois elementos sucessivos.
O predicado pode ser especificado como o nome de uma fun@value{cedilha}@~{a}o ou operador bin@'{a}rio infixo,
ou como uma express@~{a}o @code{lambda}.
Se especificado como o nome de um operador,
o nome deve ser contido entre "aspas duplas".

A lista ordenada @'{e} retornada como novo objeto;
o argumento @var{L} n@~{a}o @'{e} modificado.
Para construir o valor de retorno,
@code{sort} faz uma c@'{o}pia superficial dos elementos de @var{L}.
@c DUNNO IF WE NEED TO GO INTO THE IMPLICATIONS OF SHALLOW COPY HERE ...
@c MIGHT CONSIDER A REF FOR TOTAL ORDER HERE
Se o predicado @var{P} n@~{a}o for uma ordem total sobre os elementos de @var{L},
ent@~{a}o @code{sort} possivelvente pode executar para concluir sem error,
mas os resultados s@~{a}o indefinidos.
@code{sort} reclama se o predicado avaliar para alguma outra coisa
que n@~{a}o seja @code{true} ou @code{false}.

@code{sort (@var{L})} @'{e} equivalente a @code{sort (@var{L}, orderlessp)}.
Isto @'{e}, a ordem padr@~{a}o de organiza@value{cedilha}@~{a}o @'{e} ascendente,
como determinado por @code{orderlessp}.
Todos os @'{a}tomos do Maxima e express@~{o}es s@~{a}o compar@'{a}veis sob @code{orderlessp},
embora exista exemplos isolados de express@~{o}es para as quais @code{orderlessp} n@~{a}o @'{e} transitiva;
isso @'{e} uma falha.
 
Exemplos:
 
@c ===beg===
@c sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
@c sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
@c sort ([%pi, 3, 4, %e, %gamma]);
@c sort ([%pi, 3, 4, %e, %gamma], "<");
@c my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
@c sort (my_list);
@c sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
@c ===end===
@example
(%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
               5
(%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
               2
(%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                   5
(%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                   2
(%i3) sort ([%pi, 3, 4, %e, %gamma]);
(%o3)                [3, 4, %e, %gamma, %pi]
(%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
(%o4)                [%gamma, %e, 3, %pi, 4]
(%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
(%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
(%i6) sort (my_list);
(%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
(%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
(%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]
@end example
 
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} sqrt (@var{x})
A ra@'{i}z quadrada de @var{x}. @'{E} representada internamente por
@code{@var{x}^(1/2)}.  Veja tamb@'{e}m @code{rootscontract}.

@code{radexpand} se @code{true} far@'{a} com que n-@'{e}simas ra@'{i}zes de fatores de um produto
que forem pot@^{e}ncias de n sejam colocados fora do radical, e.g.
@code{sqrt(16*x^2)} retonar@'{a} @code{4*x} somente se @code{radexpand} for @code{true}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} sqrtdispflag
Valor padr@~{a}o: @code{true}

Quando @code{sqrtdispflag} for @code{false},
faz com que @code{sqrt} seja mostrado como expoente 1/2.
@c AND OTHERWISE ... ??

@end defvr

@c NEEDS EXPANSION, CLARIFICATION, MORE EXAMPLES
@c sublis CAN ONLY SUBSTITUTE FOR ATOMS, RIGHT ?? IF SO, SAY SO
@deffn {Fun@value{cedilha}@~{a}o} sublis (@var{lista}, @var{expr})
Faz multiplas substitui@value{cedilha}@~{o}es paralelas dentro de uma express@~{a}o.

A vari@'{a}vel @code{sublis_apply_lambda} controla a simplifica@value{cedilha}@~{a}o ap@'{o}s
@code{sublis}.

Exemplo:

@example
@c ===beg===
@c sublis ([a=b, b=a], sin(a) + cos(b));
@c ===end===
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} sublist (@var{lista}, @var{p})
Retorna a lista de elementos da @var{lista} da qual o
predicado @code{p} retornar @code{true}.

Exemplo:

@c ===beg===
@c L: [1, 2, 3, 4, 5, 6];
@c sublist (L, evenp);
@c ===end===
@example
(%i1) L: [1, 2, 3, 4, 5, 6];
(%o1)                  [1, 2, 3, 4, 5, 6]
(%i2) sublist (L, evenp);
(%o2)                       [2, 4, 6]
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} sublis_apply_lambda
Valor padr@~{a}o: @code{true} - controla se os substitutos de
@code{lambda} s@~{a}o aplicados na simplifica@value{cedilha}@~{a}o ap@'{o}s as @code{sublis} serem usadas ou
se voc@^{e} tem que fazer um @code{ev} para pegar coisas para aplicar.  @code{true} significa fa@value{cedilha}a a
aplica@value{cedilha}@~{a}o.

@end defvr

@c NEEDS CLARIFICATION, MORE EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} subst (@var{a}, @var{b}, @var{c})
Substitue @var{a} por @var{b} em @var{c}.  @var{b} deve ser um @'{a}tomo ou uma
subexpress@~{a}o completa de @var{c}.  Por exemplo, @code{x+y+z} @'{e} uma subexpress@~{a}o
completa de @code{2*(x+y+z)/w} enquanto @code{x+y} n@~{a}o @'{e}. Quando @var{b} n@~{a}o tem
essas caracter@'{i}sticas, pode-se algumas vezes usar @code{substpart} ou @code{ratsubst}
(veja abaixo).  Alternativamente, se @var{b} for da forma de @code{e/f} ent@~{a}o se poder@'{a}
usar @code{subst (a*f, e, c)} enquanto se @var{b} for da forma @code{e^(1/f)} ent@~{a}o se poder@'{a}
usar @code{subst (a^f, e, c)}.  O comando @code{subst} tamb@'{e}m discerne o @code{x^y} de @code{x^-y}
de modo que @code{subst (a, sqrt(x), 1/sqrt(x))} retorna @code{1/a}.  @var{a} e @var{b} podem tamb@'{e}m ser
operadores de uma express@~{a}o contida entre aspas duplas @code{"} ou eles podem ser nomes de
fun@value{cedilha}@~{a}o.  Se se desejar substituir por uma vari@'{a}vel independente em
formas derivadas ent@~{a}o a fun@value{cedilha}@~{a}o @code{at} (veja abaixo) poder@'{a} ser usada.

@c UMM, REVERSE THIS AND MOVE IT TO substitute ??
@code{subst} @'{e} um @'{a}lias para @code{substitute}.

@code{subst (@var{eq_1}, @var{expr})} ou @code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
s@~{a}o outras formas
permitidas.  As @var{eq_i} s@~{a}o equa@value{cedilha}@~{o}es indicando substitui@value{cedilha}@~{o}es a serem feitas.
Para cada equa@value{cedilha}@~{a}o, o lado direito ser@'{a} substitu@'{i}do pelo lado esquerdo na
express@~{a}o @var{expr}.

@code{exptsubst} se @code{true} permite que substitui@value{cedilha}@~{o}es
como @code{y} por @code{%e^x} em @code{%e^(a*x)} ocorram.

@c WHAT IS THIS ABOUT ??
Quando @code{opsubst} for @code{false},
@code{subst} tentar@'{a} substituir dentro do operador de uma express@~{a}o.
E.g. @code{(opsubst: false, subst (x^2, r, r+r[0]))} trabalhar@'{a}.

Exemplos:

@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
Para exemplos adicionais, fa@value{cedilha}a @code{example (subst)}.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~{a}o} substinpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Similar a @code{substpart}, mas @code{substinpart} trabalha sobre a
representa@value{cedilha}@~{a}o interna de @var{expr}.

Exemplos:

@c ===beg===
@c x . 'diff (f(x), x, 2);
@c substinpart (d^2, %, 2);
@c substinpart (f1, f[1](x + 1), 0);
@c ===end===
@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             d
(%o1)                   x . (--- (f(x)))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x + 1), 0);
(%o3)                       f1(x + 1)
@end example

Se o @'{u}ltimo argumento para a fun@value{cedilha}@~{a}o @code{part} for uma lista de @'{i}ndices ent@~{a}o
muitas subexpress@~{o}es s@~{a}o escolhidas, cada uma correspondendo a um
@'{i}ndice da lista.  Dessa forma

@c ===beg===
@c part (x + y + z, [1, 3]);
@c ===end===
@example
(%i1) part (x + y + z, [1, 3]);
(%o1)                         z + x
@end example

@code{piece} recebe o valor da @'{u}ltima express@~{a}o selecionada quando usando as
fun@value{cedilha}@~{o}es @code{part}.  @code{piece} @'{e} escolhida durante a execu@value{cedilha}@~{a}o da fun@value{cedilha}@~{a}o e
dessa forma pode ser referenciada para a pr@'{o}pria fun@value{cedilha}@~{a}o como mostrado abaixo.
Se @code{partswitch} for escolhida para @code{true} ent@~{a}o @code{end} @'{e} retornado quando uma
parte selecionada de uma express@~{a}o n@~{a}o existir, de outra forma uma mensagem
de erro @'{e} fornecida.

@c ===beg===
@c expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
@c part (expr, 2, [1, 3]);
@c sqrt (piece/54);
@c substpart (factor (piece), expr, [1, 2, 3, 5]);
@c expr: 1/x + y/x - 1/z;
@c substpart (xthru (piece), expr, [2, 3]);
@c ===end===
@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Tamb@'{e}m, escolhendo a op@value{cedilha}@~{a}o @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} @'{e}
o mesmo que chamando @code{inpart} ou @code{substinpart}.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@value{cedilha}@~{a}o} substpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Substitue @var{x} para a subexpress@~{a}o
selecionada pelo resto dos argumentos como em @code{part}.  Isso retorna o
novo valor de @var{expr}.  @var{x} pode ser algum operador a ser substitu@'{i}do por um
operador de @var{expr}.  Em alguns casos @var{x} precisa ser contido em aspas duplas @code{"}
(e.g.  @code{substpart ("+", a*b, 0)} retorna @code{b + a}).

@c ===beg===
@c 1/(x^2 + 2);
@c substpart (3/2, %, 2, 1, 2);
@c a*x + f(b, y);
@c substpart ("+", %, 1, 0);
@c ===end===
@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Tamb@'{e}m, escolhendo a op@value{cedilha}@~{a}o @code{inflag} para @code{true} e chamando @code{part} ou @code{substpart} @'{e}
o mesmo que chamando @code{inpart} ou @code{substinpart}.

@end deffn

@c NEEDS EXPANSION AND EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} subvarp (@var{expr})
Retorna @code{true} se @var{expr} for uma vari@'{a}vel subscrita (i.e. que possui @'{i}ndice ou subscrito em sua grafia), por exemplo
@code{a[i]}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} symbolp (@var{expr})
Retorna @code{true} se @var{expr} for um s@'{i}mbolo, de outra forma retorna @code{false}.
com efeito, @code{symbolp(x)} @'{e} equivalente ao predicado @code{atom(x) and not numberp(x)}.

@c FOLLOWING REALLY WANTS TO BE @xref{Identiifers} BUT THAT
@c LEAVES THE UNPLEASANT RESIDUE *Note ...:: IN THE OUTPUT OF describe
Veja tamb@'{e}m @ref{Identificadores}

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} unorder ()
Disabilita a a@value{cedilha}@~{a}o de alias criada pelo @'{u}ltimo uso dos comandos
de ordena@value{cedilha}@~{a}o @code{ordergreat} e @code{orderless}. @code{ordergreat} e @code{orderless} n@~{a}o podem
ser usados mais que uma vez cada sem chamar @code{unorder}. 
Veja tamb@'{e}m @code{ordergreat} e @code{orderless}.

Exemplos:

@c HMM, IN THIS EXAMPLE, WHY ISN'T %o5 EQUAL TO ZERO ???
@c ===beg===
@c unorder();
@c b*x + a^2;
@c ordergreat (a);
@c b*x + a^2;
@c  %th(1) - %th(3);
@c unorder();
@c ===end===
@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
 %th(1) - %th(3);
                             2
(%o4)                       a  + b x
(%i5) unorder();
                              2    2
(%o5)                        a  - a
@end example

@end deffn

@c THIS ITEM SEEMS OUT OF PLACE -- IS IT FROM A SHARE PACKAGE ??
@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~{a}o} vectorpotential (@var{givencurl})
Retorna o potencial do vetor de um dado
vetor de tor@value{cedilha}@~{a}o, no sistema de coordenadas corrente.
@code{potentialzeroloc} tem um papel similar ao de @code{potential}, mas a ordem dos
lados esquerdos das equa@value{cedilha}@~{o}es deve ser uma permuta@value{cedilha}@~{a}o c@'{i}clica das
vari@'{a}veis de coordenadas.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} xthru (@var{expr})
Combina todos os termos de @var{expr} (o qual pode ser uma adi@value{cedilha}@~{a}o) sobre um
denominador comum sem produtos e somas exponenciadas
como @code{ratsimp} faz.  @code{xthru} cancela fatores comuns no numerador e
denominador de express@~{o}es racionais mas somente se os fatores s@~{a}o
expl@'{i}citos.

@c REPHRASE IN NEUTRAL TONE (GET RID OF "IT IS BETTER")
Algumas vezes @'{e} melhor usar @code{xthru} antes de @code{ratsimp} em uma
express@~{a}o com o objetivo de fazer com que fatores explicitos do m@'{a}ximo divisor comum entre o
numerador e o denominador seja cancelado simplificando dessa forma a
express@~{a}o a ser aplicado o @code{ratsimp}.

@c ===beg===
@c ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
@c xthru (%);
@c ===end===
@example
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
@end example

@end deffn

@c THIS FUNCTION APPEARS TO BE A HACK; SEE 4'TH ITEM BELOW
@c DUNNO WHETHER WE CAN CLEAR THIS UP
@deffn {Fun@value{cedilha}@~{a}o} zeroequiv (@var{expr}, @var{v})
Testa se a express@~{a}o @var{expr} na vari@'{a}vel
@var{v} @'{e} equivalente a zero, retornando @code{true}, @code{false}, ou
@code{dontknow} (n@~{a}o sei).

@code{zeroequiv} Tem essas restri@value{cedilha}@~{o}es:
@enumerate
@item
N@~{a}o use fun@value{cedilha}@~{o}es que o Maxima n@~{a}o sabe como
diferenciar e avaliar.
@item
Se a express@~{a}o tem postes sobre o eixo real, podem existir erros
no resultado (mas isso @'{e} improv@'{a}vel ocorrer).
@item
Se a express@~{a}o contem fun@value{cedilha}@~{o}es que n@~{a}o s@~{a}o solu@value{cedilha}@~{o}es para
equa@value{cedilha}@~{o}es diferenciais de primeira ordem (e.g.  fun@value{cedilha}@~{o}es de Bessel) pode ocorrer
resultados incorretos.
@item
O algor@'{i}tmo usa avalia@value{cedilha}@~{a}o em pontos aleat@'{o}riamente escolhidos para
subexpress@~{o}es selecionadas cuidadosamente.  Isso @'{e} sempre neg@'{o}cio um tanto
quanto perigoso, embora o algor@'{i}tmo tente minimizar o
potencial de erro.
@end enumerate

Por exemplo
 @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} retorna
@code{true} e @code{zeroequiv (%e^x + x, x)} retorna @code{false}.
Por outro lado @code{zeroequiv (log(a*b) - log(a) - log(b), a)} retorna @code{dontknow} devido @`a
presen@value{cedilha}a de um par@^{a}metro extra @code{b}.

@end deffn
