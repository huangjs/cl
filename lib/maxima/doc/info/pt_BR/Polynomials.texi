@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Polynomials.texi/1.23/Sat Jun  2 00:13:03 2007/-ko/
@c FOR THE FUNCTIONS WHICH RETURN A CRE, BE SURE TO MENTION THAT
@menu
* Introdu@value{cedilha}@~{a}o a Polin@^{o}mios::  
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Polin@^{o}mios::  
@end menu

@node Introdu@value{cedilha}@~{a}o a Polin@^{o}mios, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Polin@^{o}mios, Polin@^{o}mios, Polin@^{o}mios
@section Introdu@value{cedilha}@~{a}o a Polin@^{o}mios

Polin@^{o}mios s@~{a}o armazenados no Maxima ou na forma geral ou na
forma de Express@~{o}es Racionais Can@^{o}nicas (CRE).  Essa @'{u}ltima @'{e} uma forma
padr@~{a}o, e @'{e} usada internamente por opera@value{cedilha}@~{o}es tais como @code{factor}, @code{ratsimp}, e
assim por diante.

Express@~{o}es Racionais Can@^{o}nicas constituem um tipo de representa@value{cedilha}@~{a}o
que @'{e} especialmente adequado para polin@^{o}mios expandidos e fun@value{cedilha}@~{o}es
racionais (tamb@'{e}m para polin@^{o}mios parcialmente fatorados e fun@value{cedilha}@~{o}es
racionais quando RATFAC for escolhida para @code{true}).  Nessa forma CRE uma
ordena@value{cedilha}@~{a}o de vari@'{a}veis (da mais para a menos importante) @'{e} assumida para cada
express@~{a}o.  Polin@^{o}mios s@~{a}o representados recursivamente por uma lista
consistindo da vari@'{a}vel principal seguida por uma s@'{e}rie de pares de
express@~{o}es, uma para cada termo do polin@^{o}mio.  O primeiro membro de
cada par @'{e} o expoente da vari@'{a}vel principal naquele termo e o
segundo membro @'{e} o coeficiente daquele termo que pode ser um n@'{u}mero ou
um polin@^{o}mio em outra vari@'{a}vel novamente respresentado nessa forma.  Sendo assim
a parte principal da forma CRE de 3*X^2-1 @'{e} (X 2 3 0 -1) e que a parte principal da
forma CRE de 2*X*Y+X-3 @'{e} (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assumindo Y como sendo a
vari@'{a}vel principal, e @'{e} (X 1 (Y 1 2 0 1) 0 -3) assumindo X como sendo a
vari@'{a}vel principal. A vari@'{a}vel principal @'{e} usualmente determineda pela ordem alfab@'{e}tica
reversa.  As "vari@'{a}veis" de uma express@~{a}o CRE n@~{a}o necessariamente devem ser at@^{o}micas.  De fato
qualquer subexpress@~{a}o cujo principal operador n@~{a}o for + - * / or ^ com expoente
inteiro ser@'{a} considerado uma "vari@'{a}vel" da express@~{a}o (na forma CRE) na
qual essa ocorrer.  Por exemplo as vari@'{a}veis CRE da express@~{a}o
X+SIN(X+1)+2*SQRT(X)+1 s@~{a}o X, SQRT(X), e SIN(X+1).  Se o usu@'{a}rio
n@~{a}o especifica uma ordem de vari@'{a}veis pelo uso da fun@value{cedilha}@~{a}o RATVARS
Maxima escolher@'{a} a alfab@'{e}tica por conta pr@'{o}pria.  Em geral, CREs representam
express@~{o}es racionais, isto @'{e}, raz@~{o}es de polin@^{o}mios, onde o
numerador e o denominador n@~{a}o possuem fatores comuns, e o denominador for
positivo.  A forma interna @'{e} essencialmente um par de polin@^{o}mios (o
numerador e o denominador) precedidos pela lista de ordena@value{cedilha}@~{a}o de vari@'{a}vel.  Se
uma express@~{a}o a ser mostrada estiver na forma CRE ou se contiver quaisquer
subexpress@~{o}es na forma CRE, o s@'{i}mbolo /R/ seguir@'{a} o r@'{o}tulo da linha.
Veja a fun@value{cedilha}@~{a}o RAT para saber como converter uma express@~{a}o para a forma CRE.  Uma
forma CRE extendida @'{e} usada para a representa@value{cedilha}@~{a}o de s@'{e}ries de Taylor.  A
no@value{cedilha}@~{a}o de uma express@~{a}o racional @'{e} extendida de modo que os expoentes das
vari@'{a}veis podem ser n@'{u}meros racionais positivos ou negativos em lugar de apenas
inteiros positivos e os coeficientes podem eles mesmos serem express@~{o}es
racionais como descrito acima em lugar de apenas polin@^{o}mios.  Estes s@~{a}o
representados internamente por uma forma polinomial recursiva que @'{e} similar
@`a forma CRE e @'{e} a generaliza@value{cedilha}@~{a}o dessa mesma forma CRE, mas carrega informa@value{cedilha}@~{a}o
adicional tal com o grau de trunca@value{cedilha}@~{a}o.  Do mesmo modo que na forma CRE, o
s@'{i}mbolo /T/ segue o r@'{o}tulo de linha que cont@'{e}m as tais express@~{o}es.

@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Polin@^{o}mios,  , Introdu@value{cedilha}@~{a}o a Polin@^{o}mios, Polin@^{o}mios
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Polin@^{o}mios

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} algebraic
Valor Padr@~{a}o: @code{false}

@code{algebraic} deve ser escolhida para @code{true} com o objetivo de que a
simplifica@value{cedilha}@~{a}o de inteiros alg@'{e}bricos tenha efeito.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} berlefact
Valor Padr@~{a}o: @code{true}

Quando @code{berlefact} for @code{false} ent@~{a}o o algor@'{i}tmo de fatora@value{cedilha}@~{a}o de
Kronecker ser@'{a} usado.  De outra forma o algor@'{i}tmo de Berlekamp, que @'{e} o
padr@~{a}o, ser@'{a} usado.

@end defvr

@c WHAT IS THIS ABOUT EXACTLY ??
@deffn {Fun@value{cedilha}@~{a}o} bezout (@var{p1}, @var{p2}, @var{x})
uma alternativa para o comando @code{resultant}.  Isso
retorna uma matriz.  @code{determinant} dessa matriz @'{e} o resultante desejado.

@end deffn

@c REWORD THIS ITEM -- COULD BE MORE CONCISE
@deffn {Fun@value{cedilha}@~{a}o} bothcoef (@var{expr}, @var{x})
Retorna uma lista da qual o primeiro membro @'{e} o
coeficiente de @var{x} em @var{expr} (como achado por @code{ratcoef} se @var{expr} est@'{a} na forma CRE
de outro modo por @code{coeff}) e cujo segundo membro @'{e} a parte restante de
@var{expr}.  Isto @'{e}, @code{[A, B]} onde @code{@var{expr} = A*@var{x} + B}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         @'{e} (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);

@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        @'{e} (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} coeff (@var{expr}, @var{x}, @var{n})
Retorna o coeficiente de @code{@var{x}^@var{n}} em @var{expr}.  @var{n} pode ser
omitido se for 1.  @var{x} pode ser um @'{a}tomo, ou subexpress@~{a}o completa de
@var{expr} e.g., @code{sin(x)}, @code{a[i+1]}, @code{x + y}, etc. (No @'{u}ltimo caso a
express@~{a}o @code{(x + y)} pode ocorrer em @var{expr}).  Algumas vezes isso pode ser necess@'{a}rio
para expandir ou fatorar @var{expr} com o objetivo de fazer @code{@var{x}^@var{n}} explicito.  Isso n@~{a}o @'{e}
realizado por @code{coeff}.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
@c coeff (y + x*%e^x + 1, x, 0);

@example
(%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
(%o1)                      2 a + 1 = 5
(%i2) coeff (y + x*%e^x + 1, x, 0);
(%o2)                         y + 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} combine (@var{expr})
Simplifica a adi@value{cedilha}@~{a}o @var{expr} por termos combinados com o mesmo
denominador dentro de um termo simples.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} content (@var{p_1}, @var{x_1}, ..., @var{x_n})
Retorna uma lista cujo primeiro elemento @'{e}
o m@'{a}ximo divisor comum dos coeficientes dos termos do
polin@^{o}mio @var{p_1} na vari@'{a}vel @var{x_n} (isso @'{e} o conte@'{u}do) e cujo
segundo elemento @'{e} o polin@^{o}mio @var{p_1} dividido pelo conte@'{u}do.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c content (2*x*y + 4*x^2*y^2, y);

@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} denom (@var{expr})
Retorna o denominador da express@~{a}o racional @var{expr}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} divide (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
calcula o quocietne e o resto
do polin@^{o}mio @var{p_1} dividido pelo polin@^{o}mio @var{p_2}, na vari@'{a}vel
principal do polin@^{o}mio, @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
As outras vari@'{a}veis s@~{a}o como na fun@value{cedilha}@~{a}o @code{ratvars}.
O resultado @'{e} uma lista cujo primeiro elemento @'{e} o quociente
e cujo segundo elemento @'{e} o resto.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@noindent
Note que @code{y} @'{e} a vari@'{a}vel principal no segundo exemplo.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} eliminate ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_k}])
Elimina vari@'{a}veis de
equa@value{cedilha}@~{o}es (ou express@~{o}es assumidas iguais a zero) pegando resultantes
sucessivos. Isso retorna uma lista de @code{@var{n} - @var{k}} express@~{o}es com @var{k}
vari@'{a}veis @var{x_1}, ..., @var{x_k} eliminadas.  Primeiro @var{x_1} @'{e} eliminado retornando @code{@var{n} - 1}
express@~{o}es, ent@~{a}o @code{x_2} @'{e} eliminado, etc.  Se @code{@var{k} = @var{n}} ent@~{a}o uma express@~{a}o simples em uma
lista @'{e} retornada livre das vari@'{a}veis @var{x_1}, ..., @var{x_k}.  Nesse caso @code{solve}
@'{e} chamado para resolver a @'{u}ltima resultante para a @'{u}ltima vari@'{a}vel.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);

@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, ...)
Retorna uma lista cujo primeiro elemento @'{e} o m.d.c. dos
polin@^{o}mios @var{p_1}, @var{p_2}, @var{p_3}, ...  e cujos restantes elementos s@~{a}o os
polin@^{o}mios divididos pelo mdc.  Isso sempre usa o algor@'{i}tmo
@code{ezgcd}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} facexpand
Valor Padr@~{a}o: @code{true}

@code{facexpand} controla se os fatores irredut@'{i}veis
retornados por @code{factor} est@~{a}o na forma expandida (o padr@~{a}o) ou na forma recursiva
(CRE normal).

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} factcomb (@var{expr})
Tenta combinar os coeficientes de fatoriais em @var{expr}
com os pr@'{o}prios fatoriais convertendo, por exemplo, @code{(n + 1)*n!}
em @code{(n + 1)!}.

@code{sumsplitfact} se escolhida para @code{false} far@'{a} com que @code{minfactorial} seja
aplicado ap@'{o}s um @code{factcomb}.

@c Example:
@c UH, THESE ARE THE EXPRESSIONS WHICH WERE GIVEN IN 
@c THE PREVIOUS REVISION OF THIS FILE, BUT IN THIS CASE
@c factcomb HAS NO EFFECT -- I GUESS A DIFFERENT EXAMPLE IS CALLED FOR
@c (n + 1)^b*n!^b;
@c factcomb (%);
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} factor (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} factor (@var{expr}, @var{p})

Fatora a express@~{a}o @var{expr}, contendo qualquer n@'{u}mero de
vari@'{a}veis ou fun@value{cedilha}@~{o}es, em fatores irredut@'{i}veis sobre os inteiros.
@code{factor (@var{expr}, @var{p})} fatora @var{expr} sobre o campo dos inteiros com um elemento
adjunto cujo menor polin@^{o}mio @'{e} @var{p}.

@code{factor} usa a fun@value{cedilha}@~{a}o @code{ifactors} para fatorar inteiros.

@code{factorflag} se @code{false} suprime a fatora@value{cedilha}@~{a}o de fatores inteiros
de express@~{o}es racionais.

@code{dontfactor} pode ser escolhida para uma lista de vari@'{a}veis com rela@value{cedilha}@~{a}o @`a qual
fatora@value{cedilha}@~{a}o n@~{a}o @'{e} para ocorrer.  (Essa @'{e} inicialmente vazia).  Fatora@value{cedilha}@~{a}o tamb@'{e}m
n@~{a}o acontece com rela@value{cedilha}@~{a}o a quaisquer vari@'{a}veis que s@~{a}o menos
importantes (usando a ordena@value{cedilha}@~{a}o de vari@'{a}vel assumida pela forma CRE) como
essas na lista @code{dontfactor}.

@code{savefactors} se @code{true} faz com que os fatores de uma express@~{a}o que
@'{e} um produto de fatores seja guardada por certas fun@value{cedilha}@~{o}es com o objetivo de
aumentar a velocidade de futuras fatora@value{cedilha}@~{o}es de express@~{o}es contendo alguns dos
mesmos fatores.

@code{berlefact} se @code{false} ent@~{a}o o algor@'{i}tmo de fatora@value{cedilha}@~{a}o de Kronecker ser@'{a}
usado de outra forma o algor@'{i}tmo de Berlekamp, que @'{e} o padr@~{a}o, ser@'{a}
usado.

@code{intfaclim} se @code{true} maxima ir@'{a} interromper a fatora@value{cedilha}@~{a}o de
inteiros se nenhum fator for encontrado ap@'{o}s tentar divis@~{o}es e o m@'{e}todo rho de
Pollard.  Se escolhida para @code{false} (esse @'{e} o caso quando o usu@'{a}rio chama
@code{factor} explicitamente), a fatora@value{cedilha}@~{a}o completa do inteiro ser@'{a}
tentada.  A escolha do usu@'{a}rio para @code{intfaclim} @'{e} usada para chamadas
internas a @code{factor}. Dessa forma, @code{intfaclim} pode ser resetada para evitar que o
Maxima gaste um tempo muito longo fatorando inteiros grandes.

Exemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} factorflag
Valor Padr@~{a}o: @code{false}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{factorflag} for @code{false}, suprime a fatora@value{cedilha}@~{a}o de
fatores inteiros em express@~{o}es racionais.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} factorout (@var{expr}, @var{x_1}, @var{x_2}, ...)
Rearranja a adi@value{cedilha}@~{a}o @var{expr} em uma adi@value{cedilha}@~{a}o de
parcelas da forma @code{f (@var{x_1}, @var{x_2}, ...)*g} onde @code{g} @'{e} um produto de
express@~{o}es que n@~{a}o possuem qualquer @var{x_i} e @code{f} @'{e} fatorado.
@c NEED EXAMPLE HERE

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} factorsum (@var{expr})
Tenta agrupar parcelas em fatores de @var{expr} que s@~{a}o adi@value{cedilha}@~{o}es
em grupos de parcelas tais que sua adi@value{cedilha}@~{a}o @'{e} fator@'{a}vel.  @code{factorsum} pode
recuperar o resultado de @code{expand ((x + y)^2 + (z + w)^2)} mas n@~{a}o pode recuperar
@code{expand ((x + 1)^2 + (x + y)^2)} porque os termos possuem vari@'{a}veis em comum.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} fasttimes (@var{p_1}, @var{p_2})
Retorna o produto dos polin@^{o}mios @var{p_1} e @var{p_2} usando um
algor@'{i}tmo especial para a multiplica@value{cedilha}@~{a}o de polin@^{o}mios.  @code{p_1} e @code{p_2} podem ser
de v@'{a}rias vari@'{a}veis, densos, e aproximadamente do mesmo tamanho.  A multiplica@value{cedilha}@~{a}o
cl@'{a}ssica @'{e} de ordem @code{n_1 n_2} onde
@code{n_1} @'{e} o grau de @code{p_1}
and @code{n_2} @'{e} o grau de @code{p_2}.
@code{fasttimes} @'{e} da ordem @code{max (n_1, n_2)^1.585}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} fullratsimp (@var{expr})
@code{fullratsimp} aplica
repetidamente @code{ratsimp} seguido por simplifica@value{cedilha}@~{a}o n@~{a}o racional a uma
express@~{a}o at@'{e} que nenhuma mudan@value{cedilha}a adicional ocorra,
e retorna o resultado.

Quando express@~{o}es n@~{a}o racionais est@~{a}o envolvidas, uma chamada
a @code{ratsimp} seguida como @'{e} usual por uma simplifica@value{cedilha}@~{a}o n@~{a}o racional
("geral") pode n@~{a}o ser suficiente para retornar um resultado simplificado.
Algumas vezes, mais que uma tal chamada pode ser necess@'{a}ria. 
@code{fullratsimp} faz esse processo convenientemente.

@code{fullratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} pega um ou mais argumentos similar
a @code{ratsimp} e @code{rat}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end deffn

@c SPELL OUT WHAT fullratsubst DOES INSTEAD OF ALLUDING TO ratsubst AND lratsubst
@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~{a}o} fullratsubst (@var{a}, @var{b}, @var{c})
@'{e} o mesmo que @code{ratsubst} exceto que essa chama
a si mesma recursivamente sobre esse resultado at@'{e} que o resultado para de mudar.
Essa fun@value{cedilha}@~{a}o @'{e} @'{u}til quando a express@~{a}o de substitui@value{cedilha}@~{a}o e a
express@~{a}o substitu@'{i}da tenham uma ou mais vari@'{a}veis em comum.

@code{fullratsubst} ir@'{a} tamb@'{e}m aceitar seus argumentos no formato de
@code{lratsubst}.  Isto @'{e}, o primeiro argumento pode ser uma substitui@value{cedilha}@~{a}o simples
de equa@value{cedilha}@~{a}o ou uma lista de tais equa@value{cedilha}@~{o}es, enquanto o segundo argumento @'{e} a
express@~{a}o sendo processada.

@code{load ("lrats")} chama @code{fullratsubst} e @code{lratsubst}.

Exemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c CAN PROBABLY CUT OUT THE lratsubst STUFF (lratsubst HAS ITS OWN DESCRIPTION)
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c errcatch (fullratsubst (b*a^2, a^2, a^3));

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} pode realizar multiplas substitui@value{cedilha}@~{o}es.
@code{lratsubst} @'{e} analogo a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Se somente uma substitui@value{cedilha}@~{a}o @'{e} desejada, ent@~{a}o uma equa@value{cedilha}@~{a}o
simples pode ser dada como primeiro argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@itemize @bullet
@item
@code{fullratsubst} @'{e} equivalente a @code{ratsubst}
exceto que essa executa recursivamente at@'{e} que seu resultado para de mudar.
@end itemize
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example
@itemize @bullet
@item
@code{fullratsubst} tamb@'{e}m aceita uma lista de equa@value{cedilha}@~{o}es ou uma equa@value{cedilha}@~{a}o
simples como primeiro argumento.
@end itemize
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example
@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} pode causar uma recurs@~{a}o infinita.
@end itemize
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end deffn

@c GCD IS A VARIABLE AND A FUNCTION
@c THIS ITEM NEEDS A LOT OF WORK
@deffn {Fun@value{cedilha}@~{a}o} gcd (@var{p_1}, @var{p_2}, @var{x_1}, ...)
Retorna o m@'{a}ximo divisor comum entre @var{p_1} e @var{p_2}.
O sinalizador @code{gcd} determina qual algor@'{i}tmo @'{e} empregado.
Escolhendo @code{gcd} para @code{ez}, @code{subres}, @code{red}, ou @code{spmod} seleciona o algor@'{i}tmo @code{ezgcd},
subresultante @code{prs}, reduzido, ou modular,
respectivamente.  Se @code{gcd} for @code{false} ent@~{a}o @code{gcd (@var{p_1}, @var{p_2}, @var{x})} sempre retorna 1
para todo @var{x}.  Muitas fun@value{cedilha}@~{o}es (e.g.  @code{ratsimp}, @code{factor}, etc.) fazem com que mdc's
sejam feitos implicitamente.  Para polin@^{o}mios homog@^{e}neos @'{e} recomendado
que @code{gcd} igual a @code{subres} seja usado.  Para pegar o mdc quando uma express@~{a}o alg@'{e}brica est@'{a}
presente, e.g. @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))}, @code{algebraic} deve ser
@code{true} e @code{gcd} n@~{a}o deve ser @code{ez}.  @code{subres} @'{e} um novo algor@'{i}tmo, e pessoas
que tenham estado usando a op@value{cedilha}@~{a}o @code{red} podem provavelmente alterar isso para
@code{subres}.

O sinalizador @code{gcd}, padr@~{a}o: @code{subres}, se @code{false} ir@'{a} tamb@'{e}m evitar o m@'{a}ximo
divisor comum de ser usado quando express@~{o}es s@~{a}o convertidas para a forma de express@~{a}o racional
can@^{o}nica (CRE).  Isso ir@'{a} algumas vezes aumentar a velocidade dos c@'{a}lculos se mdc's n@~{a}o s@~{a}o
requeridos.
@c NEEDS EXAMPLES HERE

@end deffn

@c IN NEED OF SERIOUS CLARIFICATION HERE
@deffn {Fun@value{cedilha}@~{a}o} gcdex (@var{f}, @var{g})
@deffnx {Fun@value{cedilha}@~{a}o} gcdex (@var{f}, @var{g}, @var{x})
Retornam uma lista @code{[@var{a}, @var{b}, @var{u}]}
onde @var{u} @'{e} o m@'{a}ximo divisor comum (mdc) entre @var{f} e @var{g},
e @var{u} @'{e} igual a @code{@var{a} @var{f} + @var{b} @var{g}}.
Os argumentos @var{f} e @var{g} podem ser polin@^{o}mios de uma vari@'{a}vel,
ou de outra forma polin@^{o}mios em @var{x} uma @b{main}(principal) vari@'{a}vel suprida
desde que n@'{o}s precisamos estar em um dom@'{i}nio de ideal principal para isso trabalhar.
O mdc significa o mdc considerando @var{f} e @var{g} como polin@^{o}mios de uma @'{u}nica vari@'{a}vel com coeficientes
sendo fun@value{cedilha}@~{o}es racionais em outras vari@'{a}veis.

@code{gcdex} implementa o algor@'{i}tmo Euclideano,
onde temos a seq@"{u}@^{e}ncia
of @code{L[i]: [a[i], b[i], r[i]]} que s@~{a}o todos perpendiculares
a @code{[f, g, -1]} e o pr@'{o}ximo se @'{e} constru@'{i}do como
se @code{q = quotient(r[i]/r[i+1])} ent@~{a}o @code{L[i+2]: L[i] - q L[i+1]}, e isso
encerra em @code{L[i+1]} quando o resto @code{r[i+2]} for zero.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

@c SORRY FOR BEING DENSE BUT WHAT IS THIS ABOUT EXACTLY
Note que o mdc adiante @'{e} @code{1}
uma vez que trabalhamos em @code{k(y)[x]}, o @code{y+1} n@~{a}o pode ser esperado em @code{k[y, x]}.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x*(y + 1), y^2 - 1, x);

@example
(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
@end example

@end deffn


@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Fun@value{cedilha}@~{a}o} gcfactor (@var{n})
Fatora o inteiro Gaussiano @var{n} sobre os inteiros Gaussianos, i.e.,
n@'{u}meros da forma @code{@var{a} + @var{b} @code{%i}} onde @var{a} e @var{b} s@~{a}o inteiros raconais
(i.e.,  inteiros comuns).  Fatora@value{cedilha}@~{o}es s@~{a}o normalizadas fazendo @var{a} e @var{b}
n@~{a}o negativos.
@c NEED EXAMPLES HERE

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@deffn {Fun@value{cedilha}@~{a}o} gfactor (@var{expr})
Fatora o polin@^{o}mio @var{expr} sobre os inteiros de Gauss
(isto @'{e}, os inteiros com a unidade imagin@'{a}ria @code{%i} adjunta).
@c "This is like" -- IS IT THE SAME OR NOT ??
Isso @'{e} como @code{factor (@var{expr}, @var{a}^2+1)} trocando @var{a} por @code{%i}.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@end deffn

@c DESCRIBE THIS INDEPENDENTLY OF factorsum
@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~{a}o} gfactorsum (@var{expr})
@'{e} similar a @code{factorsum} mas aplica @code{gfactor} em lugar
de @code{factor}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} hipow (@var{expr}, @var{x})
Retorna o maior expoente expl@'{i}cito de @var{x} em @var{expr}.
@var{x} pode ser uma vari@'{a}vel ou uma express@~{a}o geral.
Se @var{x} n@~{a}o aparece em @var{expr},
@code{hipow} retorna @code{0}.

@code{hipow} n@~{a}o considera express@~{o}es equivalentes a @code{expr}.
Em particular, @code{hipow} n@~{a}o expande @code{expr},
ent@~{a}o @code{hipow (@var{expr}, @var{x})} e @code{hipow (expand (@var{expr}, @var{x}))}
podem retornar diferentes resultados.

Exemplos:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} intfaclim
Valor padr@~{a}o: true

Se @code{true}, maxima ir@'{a} interromper a fatora@value{cedilha}@~{a}o de
inteiros se nenhum fator for encontrado ap@'{o}s tentar divis@~{o}es e o m@'{e}todo rho de
Pollard e a fatora@value{cedilha}@~{a}o n@~{a}o ser@'{a} completada.

Quando @code{intfaclim} for @code{false} (esse @'{e} o caso quando o usu@'{a}rio
chama @code{factor} explicitamente), a fatora@value{cedilha}@~{a}o completa ser@'{a}
tentada.  @code{intfaclim} @'{e} escolhida para @code{false} quando fatores s@~{a}o
calculados em @code{divisors}, @code{divsum} e @code{totient}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Chamadas internas a @code{factor} respeitam o valor especificado pelo usu@'{a}rio para
@code{intfaclim}. Setting @code{intfaclim} to @code{true} may reduce
@code{intfaclim}. Escolhendo @code{intfaclim} para @code{true} podemos reduzir
o tempo gasto fatorando grandes inteiros.
@c NEED EXAMPLES HERE

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} keepfloat
Valor Padr@~{a}o: @code{false}

Quando @code{keepfloat} for @code{true}, evitamos que n@'{u}meros
em ponto flutuante sejam racionalizados quando express@~{o}es que os possuem
s@~{a}o ent@~{a}o convertidas para a forma de express@~{a}o racional can@^{o}nica (CRE).
@c NEED EXAMPLES HERE

@end defvr

@c DESCRIBE lratsubst INDEPENDENTLY OF subst
@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~{a}o} lratsubst (@var{L}, @var{expr})
@'{e} an@'{a}logo a @code{subst (@var{L}, @var{expr})}
exceto que esse usa @code{ratsubst} em lugar de @code{subst}.

O primeiro argumento de
@code{lratsubst} @'{e} uma equa@value{cedilha}@~{a}o ou uma lista de equa@value{cedilha}@~{o}es id@^{e}nticas em
formato para que sejam aceitas por @code{subst}.  As
substitui@value{cedilha}@~{o}es s@~{a}o feitas na ordem dada pela lista de equa@value{cedilha}@~{o}es,
isto @'{e}, da esquerda para a direita.

@code{load ("lrats")} chama @code{fullratsubst} e @code{lratsubst}.

Exemplos:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} pode realizar multiplas substitui@value{cedilha}@~{o}es.
@code{lratsubst} @'{e} analoga a @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
Se somente uma substitui@value{cedilha}@~{a}o for desejada, ent@~{a}o uma equa@value{cedilha}@~{a}o
simples pode ser dada como primeiro argumento.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} modulus
Valor Padr@~{a}o: @code{false}

Quando @code{modulus} for um n@'{u}mero positivo @var{p},
opera@value{cedilha}@~{o}es sobre os n@'{u}meros racionais (como retornado por @code{rat} e fun@value{cedilha}@~{o}es relacionadas)
s@~{a}o realizadas m@'{o}dulo @var{p},
usando o ent@~{a}o chamado sistema de m@'{o}dulo "balanceado"
no qual @code{@var{n} m@'{o}dulo @var{p}} @'{e} definido como 
um inteiro @var{k} em @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
quando @var{p} for @'{i}mpar, ou @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} quando @var{p} for par,
tal que @code{@var{a} @var{p} + @var{k}} seja igual a @var{n} para algum inteiro @var{a}.
@c NEED EXAMPLES OF "BALANCED MODULUS" HERE

@c WHAT CAN THIS MEAN ?? IS THE MODULUS STORED WITH THE EXPRESSION ??
@c "... in order to get correct results" -- WHAT DO YOU GET IF YOU DON'T RE-RAT ??
Se @var{expr} j@'{a} estiver na forma de express@~{a}o racional can@^{o}nica (CRE) quando @code{modulus} for colocado em seu valor original,
ent@~{a}o voc@^{e} pode precisar repetir o rat @var{expr}, e.g., @code{expr: rat (ratdisrep (expr))},
com o objetivo de pegar resultados corretos.

Tipicamente @code{modulus} @'{e} escolhido para um n@'{u}mero primo.
Se @code{modulus} for escolhido para um inteiro n@~{a}o primo positivo,
essa escolha @'{e} aceita, mas uma mensagem de alerta @'{e} mostrada.
Maxima permitir@'{a} que zero ou um inteiro negativo seja atribu@'{i}do a @code{modulus},
embora isso n@~{a}o seja limpo se aquele tiver quaisquer conseq@"{u}@^{e}ncias @'{u}teis.

@c NEED EXAMPLES HERE
@end defvr

@c APPARENTLY OBSOLETE: ONLY EFFECT OF $newfac COULD BE TO CAUSE NONEXISTENT FUNCTION NMULTFACT
@c TO BE CALLED (IN FUNCTION FACTOR72 IN src/factor.lisp CIRCA LINE 1400)
@c $newfac NOT USED IN ANY OTHER CONTEXT (ASIDE FROM DECLARATIONS)
@c COMMENT IT OUT NOW, CUT IT ON THE NEXT PASS THROUGH THIS FILE
@c @defvar newfac
@c Default value: @code{false}
@c 
@c When @code{newfac} for @code{true}, @code{factor} will use the new factoring
@c routines.
@c 
@c @end defvar

@deffn {Fun@value{cedilha}@~{a}o} num (@var{expr})
Retorna o numerador de @var{expr} se isso for uma raz@~{a}o.
Se @var{expr} n@~{a}o for uma raz@~{a}o, @var{expr} @'{e} retornado.

@code{num} avalia seu argumento.

@c NEED SOME EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} polydecomp (@var{p}, @var{x})

Decomp@~{o}es o polin@^{o}mio @var{p} na vari@'{a}vel  @var{x}
em uma composi@value{cedilha}@~{a}o funcional de polin@^{o}mios em @var{x}.
@code{polydecomp} retorna uma lista @code{[@var{p_1}, ..., @var{p_n}]} tal que

@example
lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))
@end example

seja igual a @var{p}.
O grau de @var{p_i} @'{e} maior que 1 para @var{i} menor que @var{n}.

Tal decomposi@value{cedilha}@~{a}o n@~{a}o @'{e} @'{u}nica.

Exemplos:

@c ===beg===
@c polydecomp (x^210, x);
@c p : expand (subst (x^3 - x - 1, x, x^2 - a));
@c polydecomp (p, x);
@c ===end===
@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

As seguintes fun@value{cedilha}@~{o}es comp@~{o}em @code{L = [e_1, ..., e_n]} como fun@value{cedilha}@~{o}es em @code{x};
essa fun@value{cedilha}@`ao @'{e} a inversa de @code{polydecomp}:

@c ===beg===
@c compose (L, x) :=
@c   block ([r : x], for e in L do r : subst (e, x, r), r) $
@c ===end===
@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

Re-exprimindo o exemplo acima usando @code{compose}:

@c ===beg===
@c polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
@c ===end===
@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

Note que apesar de @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
sempre retornar @var{p} (n@~{a}o expandido),
@code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})} @i{n@~{a}o}
necess@'{a}riamente retorna @code{[@var{p_1}, ..., @var{p_n}]}:

@c ===beg===
@c polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
@c polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@c ===end===
@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} quotient (@var{p_1}, @var{p_2})
@deffnx {Fun@value{cedilha}@~{a}o} quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Retorna o polin@^{o}mio @var{p_1} dividido pelo polin@^{o}mio @var{p_2}.
Os argumentos @var{x_1}, ..., @var{x_n} s@~{a}o interpretados como em @code{ratvars}.

@code{quotient} retorna o primeiro elemento de uma lista de dois elementos retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@c THIS ITEM CAN PROBABLY BE IMPROVED
@deffn {Fun@value{cedilha}@~{a}o} rat (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} rat (@var{expr}, @var{x_1}, ..., @var{x_n})
Converte @var{expr} para a forma de express@~{a}o racional can@^{o}nica (CRE) expandindo e
combinando todos os termos sobre um denominador comum e cancelando para fora o
m@'{a}ximo divisor comum entre o numerador e o denominador, tamb@'{e}m
convertendo n@'{u}meros em ponto flutuante para n@'{u}meros racionais dentro da
toler@^{a}ncia de @code{ratepsilon}.
As vari@'{a}veis s@~{a}o ordenadas de acordo com
@var{x_1}, ..., @var{x_n}, se especificado, como em @code{ratvars}.

@code{rat} geralmente n@~{a}o simplifica fun@value{cedilha}@~{o}es outras que n@~{a}o sejam
adi@value{cedilha}@~{a}o @code{+}, subtra@value{cedilha}@~{a}o @code{-}, multiplica@value{cedilha}@~{a}o @code{*}, divis@~{a}o @code{/}, e
exponencia@value{cedilha}@~{a}o com expoente inteiro,
uma vez que @code{ratsimp} n@~{a}o manuseia esses casos.
Note que @'{a}tomos (n@'{u}meros e vari@'{a}veis) na forma CRE n@~{a}o s@~{a}o os
mesmos que eles s@~{a}o na forma geral.
Por exemplo, @code{rat(x)- x} retorna 
@code{rat(0)} que tem uma representa@value{cedilha}@~{a}o interna diferente de 0.

@c WHAT'S THIS ABOUT EXACTLY ??
Quando @code{ratfac} for @code{true}, @code{rat} retorna uma forma parcialmente fatorada para CRE.
Durante opera@value{cedilha}@~{o}es racionais a express@~{a}o @'{e}
mantida como totalmente fatorada como poss@'{i}vel sem uma chamada ao
pacote de fatora@value{cedilha}@~{a}o (@code{factor}).  Isso pode sempre economizar espa@value{cedilha}o de mem@'{o}ria e algum tempo
em algumas computa@value{cedilha}@~{o}es.  O numerador e o denominador s@~{a}o ainda tidos como
relativamente primos
(e.g.  @code{rat ((x^2 - 1)^4/(x + 1)^2)} retorna @code{(x - 1)^4 (x + 1)^2)},
mas os fatores dentro de cada parte podem n@~{a}o ser relativamente primos.

@code{ratprint} se @code{false} suprime a impress@~{a}o de mensagens
informando o usu@'{a}rio de convers@~{o}es de n@'{u}meros em ponto flutuante para
n@'{u}meros racionais.

@code{keepfloat} se @code{true} evita que n@'{u}meros em ponto flutuante sejam
convertidos para n@'{u}meros racionais.

Veja tamb@'{e}m @code{ratexpand} e  @code{ratsimp}.

Exemplos:
@c FOLLOW GENERATED FROM THESE EXPRESSIONS
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
@c rat (%, y, a, x);

@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratalgdenom
Valor Padr@~{a}o: @code{true}

Quando @code{ratalgdenom} for @code{true}, permite racionaliza@value{cedilha}@~{a}o de
denominadores com respeito a radicais tenham efeito.
@code{ratalgdenom} tem efeito somente quando express@~{o}es racionais can@^{o}nicas (CRE) forem usadas no modo alg@'{e}brico.

@end defvr

@c THIS ITEM NEEDS MORE WORK
@deffn {Fun@value{cedilha}@~{a}o} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Fun@value{cedilha}@~{a}o} ratcoef (@var{expr}, @var{x})
Retorna o coeficiente da express@~{a}o @code{@var{x}^@var{n}}
dentro da express@~{a}o @var{expr}.
Se omitido, @var{n} @'{e} assumido ser 1.

O valor de retorno est@'{a} livre
(exceto possivelmente em um senso n@~{a}o racional) das vari@'{a}veis em @var{x}.
Se nenhum coeficiente desse tipo existe, 0 @'{e} retornado.

@code{ratcoef}
expande e simplifica racionalmente seu primeiro argumento e dessa forma pode
produzir respostas diferentes das de @code{coeff} que @'{e} puramente
sint@'{a}tica.
@c MOVE THIS TO EXAMPLES SECTION
Dessa forma @code{ratcoef ((x + 1)/y + x, x)} retorna @code{(y + 1)/y} ao passo que @code{coeff} retorna 1.

@code{ratcoef (@var{expr}, @var{x}, 0)}, visualiza @var{expr} como uma adi@value{cedilha}@~{a}o,
retornando uma soma desses termos que n@~{a}o possuem @var{x}.
@c "SHOULD NOT" -- WHAT DOES THIS MEAN ??
portanto se @var{x} ocorre para quaisquer expoentes negativos, @code{ratcoef} pode n@~{a}o ser usado.

@c WHAT IS THE INTENT HERE ??
Uma vez que @var{expr} @'{e} racionalmente
simplificada antes de ser examinada, coeficientes podem n@~{a}o aparecer inteiramente
no caminho que eles foram pensados.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ratdenom (@var{expr})
Retorna o denominador de @var{expr},
ap@'{o}s for@value{cedilha}ar a convers@~{a}o de @var{expr} para express@~{a}o racional can@^{o}nica (CRE).
O valor de retorno @'{e} a CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} @'{e} for@value{cedilha}ada para uma CRE por @code{rat}
se n@~{a}o for j@'{a} uma CRE.
Essa convers@~{a}o pode mudar a forma de @var{expr} colocando todos os termos
sobre um denominador comum.

@code{denom} @'{e} similar, mas retorna uma express@~{a}o comum em lugar de uma CRE.
Tamb@'{e}m, @code{denom} n@~{a}o tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas express@~{o}es que s@~{a}o consideradas raz@~{o}es por @code{ratdenom}
n@~{a}o s@~{a}o consideradas raz@~{o}es por @code{denom}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratdenomdivide
Valor Padr@~{a}o: @code{true}

Quando @code{ratdenomdivide} for @code{true},
@code{ratexpand} expande uma raz@~{a}o cujo o numerador for uma adi@value{cedilha}@~{a}o 
dentro de uma soma de raz@~{o}es,
tendo todos um denominador comum.
De outra forma, @code{ratexpand} colapsa uma adi@value{cedilha}@~{a}o de raz@~{o}es dentro de uma raz@~{a}o simples,
cujo numerador seja a adi@value{cedilha}@~{a}o dos numeradores de cada raz@~{a}o.

Exemplos:

@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} ratdiff (@var{expr}, @var{x})
Realiza a deriva@value{cedilha}@~{a}o da express@~{a}o racional @var{expr} com rela@value{cedilha}@~{a}o a @var{x}.
@var{expr} deve ser uma raz@~{a}o de polin@^{o}mios ou um polin@^{o}mio em @var{x}.
O argumento @var{x} pode ser uma vari@'{a}vel ou uma subexpress@~{a}o de @var{expr}.
@c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
@c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
@c HOW TO DESCRIBE THAT ??

O resultado @'{e} equivalente a @code{diff}, embora talvez em uma forma diferente.
@code{ratdiff} pode ser mais r@'{a}pida que @code{diff}, para express@~{o}es racionais.

@code{ratdiff} retorna uma express@~{a}o racional can@^{o}nica (CRE) se @code{expr} for uma CRE.
De outra forma, @code{ratdiff} retorna uma express@~{a}o geral.

@code{ratdiff} considera somente as depend@^{e}ncias de @var{expr} sobre @var{x},
e ignora quaisquer depend@^{e}ncias estabelecidas por @code{depends}.

@c WHAT THIS IS ABOUT -- ratdiff (rat (factor (expr)), x) AND ratdiff (factor (rat (expr)), x) BOTH SUCCEED
@c COMMENTING THIS OUT UNTIL SOMEONE CAN ESTABLISH SOME CRE'S FOR WHICH ratdiff FAILS
@c However, @code{ratdiff} should not be used on factored CRE forms;
@c use @code{diff} instead for such express@~{o}es.

Exemplo:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c ratdiff (expr, x);
@c expr: f(x)^3 - f(x)^2 + 7;
@c ratdiff (expr, f(x));
@c expr: (a + b)^3 + (a + b)^2;
@c ratdiff (expr, a + b);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ratdisrep (@var{expr})
Retorna seu argumento como uma express@~{a}o geral.
Se @var{expr} for uma express@~{a}o geral, @'{e} retornada inalterada.

Tipicamente @code{ratdisrep} @'{e} chamada para converter uma express@~{a}o racional can@^{o}nica (CRE)
em uma express@~{a}o geral.
@c NOT REALLY FOND OF YOU-CAN-DO-THIS-YOU-CAN-DO-THAT STATEMENTS
Isso @'{e} algumas vezes conveniente se deseja-se parar o "cont@'{a}gio", ou
caso se esteja usando fun@value{cedilha}@~{o}es racionais em contextos n@~{a}o racionais.

Veja tamb@'{e}m @code{totaldisrep}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratepsilon
Valor Padr@~{a}o: 2.0e-8

@code{ratepsilon} @'{e} a toler@^{a}ncia usada em convers@~{o}es
de n@'{u}meros em ponto flutuante para n@'{u}meros racionais.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} ratexpand (@var{expr})
@deffnx {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratexpand
Expande @var{expr} multiplicando para fora produtos de somas e
somas exponenciadas, combinando fra@value{cedilha}@~{o}es sobre um denominador comum,
cancelando o m@'{a}ximo divisor comum entre entre o numerador e o
denominador, ent@~{a}o quebrando o numerador (se for uma soma) dentro de suas
respectivas parcelas divididas pelo denominador.

O valor de retorno de @code{ratexpand} @'{e} uma express@~{a}o geral,
mesmo se @var{expr} for uma express@~{a}o racional can@^{o}nica (CRE).

@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
O comutador @code{ratexpand} se @code{true} far@'{a} com que express@~{o}es
CRE sejam completamente expandidas quando forem convertidas de volta para
a forma geral ou mostradas, enquanto se for @code{false} ent@~{a}o elas ser@~{a}o colocadas
na forma recursiva.
Veja tamb@'{e}m @code{ratsimp}.

Quando @code{ratdenomdivide} for @code{true},
@code{ratexpand} expande uma raz@~{a}o na qual o numerador @'{e} uma adi@value{cedilha}@~{a}o
dentro de uma adi@value{cedilha}@~{a}o de raz@~{o}es,
todas tendo um denominador comum.
De outra forma, @code{ratexpand} contrai uma soma de raz@~{o}es em uma raz@~{a}o simples,
cujo numerador @'{e} a soma dos numeradores de cada raz@~{a}o.

Quando @code{keepfloat} for @code{true}, evita que n@'{u}meros
em ponto flutuante sejam racionalizados quando express@~{o}es que contenham
n@'{u}meros em ponto flutuante forem convertidas para a forma de express@~{a}o racional can@^{o}nica (CRE).

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratfac
Valor Padr@~{a}o: @code{false}

Quando @code{ratfac} for @code{true},
express@~{o}es racionais can@^{o}nicas (CRE) s@~{a}o manipuladas na forma parcialmente fatorada.

Durante opera@value{cedilha}@~{o}es racionais a
express@~{a}o @'{e} mantida como completamente fatorada como foi poss@'{i}vel sem chamadas a @code{factor}.
Isso pode sempre economizar espa@value{cedilha}o e pode economizar tempo em algumas computa@value{cedilha}@~{o}es.
O numerador e o denominador s@~{a}o feitos relativamente primos, por exemplo
@code{rat ((x^2 - 1)^4/(x + 1)^2)} retorna @code{(x - 1)^4 (x + 1)^2)},
mas o fator dentro de cada parte pode n@~{a}o ser relativamente primo.

No pacote @code{ctensor} (Manipula@value{cedilha}@~{a}o de componentes de tensores),
tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura escalar 
s@~{a}o fatorados automaticamente quando @code{ratfac} for @code{true}.
@i{@code{ratfac} pode somente ser
escolhido para casos onde as componentes tensoriais sejam sabidametne consistidas de
poucos termos.}

Os esquemas de @code{ratfac} e de @code{ratweight} s@~{a}o incompat@'{i}veis e n@~{a}o podem
ambos serem usados ao mesmo tempo.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} ratnumer (@var{expr})
Retorna o numerador de @var{expr},
ap@'{o}s for@value{cedilha}ar @var{expr} para uma express@~{a}o racional can@^{o}nica (CRE).
O valor de retorno @'{e} uma CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} @'{e} for@value{cedilha}ada para uma CRE por @code{rat}
se isso n@~{a}o for j@'{a} uma CRE.
Essa convers@~{a}o pode alterar a forma de @var{expr} pela coloca@value{cedilha}@~{a}o de todos os termos
sobre um denominador comum.

@code{num} @'{e} similar, mas retorna uma express@~{a}o comum em lugar de uma CRE.
Tamb@'{e}m, @code{num} n@~{a}o tenta colocar todos os termos sobre um denominador comum,
e dessa forma algumas express@~{o}es que s@~{a}o consideradas raz@~{o}es por @code{ratnumer}
n@~{a}o s@~{a}o consideradas raz@~{o}es por @code{num}.

@c NEEDS AN EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ratnump (@var{expr})
Retorna @code{true} se @var{expr} for um inteiro literal ou raz@~{a}o de inteiros literais,
de outra forma retorna @code{false}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ratp (@var{expr})
Retorna @code{true} se @var{expr} for uma express@~{a}o racional can@^{o}nica (CRE) ou CRE extendida,
de outra forma retorna @code{false}.

CRE s@~{a}o criadas por @code{rat} e fun@value{cedilha}@~{o}es relacionadas.
CRE extendidas s@~{a}o criadas por @code{taylor} e fun@value{cedilha}@~{o}es relacionadas.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratprint
Valor Padr@~{a}o: @code{true}

Quando @code{ratprint} for @code{true},
uma mensagem informando ao usu@'{a}rio da convers@~{a}o de n@'{u}meros em ponto flutuante
para n@'{u}meros racionais @'{e} mostrada.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} ratsimp (@var{expr})
@deffnx {Fun@value{cedilha}@~{a}o} ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})
Simplifica a express@~{a}o @var{expr} e todas as suas subexpress@~{o}es,
incluindo os argumentos para fun@value{cedilha}@~{o}es n@~{a}o racionais.
O resultado @'{e} retornado como o quociente de dois polin@^{o}mios na forma recursiva,
isto @'{e}, os coeficientes de vari@'{a}vel principal s@~{a}o polin@^{o}mios em outras vari@'{a}veis.
Vari@'{a}veis podem incluir fun@value{cedilha}@~{o}es n@~{a}o racionais (e.g., @code{sin (x^2 + 1)})
e os argumentos para quaisquer tais fun@value{cedilha}@~{o}es s@~{a}o tamb@'{e}m simplificados racionalmente.

@code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})}
habilita simplifica@value{cedilha}@~{a}o racional com a
especiica@value{cedilha}@~{a}o de vari@'{a}vel ordenando como em @code{ratvars}.

Quando @code{ratsimpexpons} for @code{true},
@code{ratsimp} @'{e} aplicado para os expoentes de express@~{o}es durante a simplifica@value{cedilha}@~{a}o.

Veja tamb@'{e}m @code{ratexpand}.
Note que @code{ratsimp} @'{e} afetado por algum dos
sinalizadores que afetam @code{ratexpand}.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratsimpexpons
Valor Padr@~{a}o: @code{false}

Quando @code{ratsimpexpons} for @code{true},
@code{ratsimp} @'{e} aplicado para os expoentes de express@~{o}es durante uma simplifica@value{cedilha}@~{a}o.

@c NEED AN EXAMPLE HERE -- RECYCLE THE ratsimpexpons EXAMPLE FROM ratsimp ABOVE
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} ratsubst (@var{a}, @var{b}, @var{c})
Substitue @var{a} por @var{b} em @var{c} e retorna a express@~{a}o resultante. 
@c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE -- NOT LIKELY THE CASE
@var{b} pode tamb@'{e}m ser uma adi@value{cedilha}@~{a}o, produto, expoente, etc.

@c WHAT, EXACTLY, DOES ratsubst KNOW ??
@code{ratsubst} sabe alguma coisa do significado de express@~{o}es
uma vez que @code{subst} n@~{a}o @'{e} uma substitui@value{cedilha}@~{a}o puramente sint@'{a}tica.
Dessa forma @code{subst (a, x + y, x + y + z)} retorna @code{x + y + z}
ao passo que @code{ratsubst} retorna @code{z + a}.

Quando @code{radsubstflag} for @code{true},
@code{ratsubst} faz substitui@value{cedilha}@~{a}o de radicais em express@~{o}es
que explicitamente n@~{a}o possuem esses radicais.

Exemplos:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c WITH SOME ADDITIONAL STUFF
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@c radsubstflag: false$
@c ratsubst (u, sqrt(x), x);
@c radsubstflag: true$
@c ratsubst (u, sqrt(x), x);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ratvars (@var{x_1}, ..., @var{x_n})
@deffnx {Fun@value{cedilha}@~{a}o} ratvars ()
@deffnx {Vari@'{a}vel de sistema} ratvars
Declara vari@'{a}veis principais @var{x_1}, ..., @var{x_n} para express@~{o}es racionais.
@var{x_n}, se presente em uma express@~{a}o racional, @'{e} considerada a vari@'{a}vel principal.
De outra forma, @var{x_[n-1]} @'{e} considerada a vari@'{a}vel principal se presente,
e assim por diante at@'{e} as vari@'{a}veis precedentes para @var{x_1},
que @'{e} considerada a vari@'{a}vel principal somente se nenhuma das vari@'{a}veis que a sucedem estiver presente.

Se uma vari@'{a}vel em uma express@~{a}o racional n@~{a}o est@'{a} presente na lista @code{ratvars},
a ela @'{e} dada uma prioridade menor que @var{x_1}.

Os argumentos para @code{ratvars} podem ser ou vari@'{a}veis ou fun@value{cedilha}@~{o}es n@~{a}o racionais
tais como @code{sin(x)}.

A vari@'{a}vel @code{ratvars} @'{e} uma lista de argumentos da
fun@value{cedilha}@~{a}o @code{ratvars} quando ela foi chamada mais recentemente.
Cada chamada para a fun@value{cedilha}@~{a}o @code{ratvars} sobre-grava a lista apagando seu conte@'{u}do anterior.
@code{ratvars ()} limpa a lista.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ratweight (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})
@deffnx {Fun@value{cedilha}@~{a}o} ratweight ()
Atribui um peso @var{w_i} para a vari@'{a}vel @var{x_i}.
Isso faz com que um termo seja substitu@'{i}do por 0 se seu peso exceder o
valor da vari@'{a}vel @code{ratwtlvl} (o padr@~{a}o retorna sem trunca@value{cedilha}@~{a}o).
O peso de um termo @'{e} a soma dos produtos dos
pesos de uma vari@'{a}vel no termo vezes seu expoente.
Por exemplo, o peso de @code{3 x_1^2 x_2} @'{e} @code{2 w_1 + w_2}.
A trunca@value{cedilha}@~{a}o de acordo com @code{ratwtlvl} @'{e} realizada somente quando multiplicando
ou exponencializando express@~{o}es racionais can@^{o}nicas (CRE).

@code{ratweight ()} retorna a lista cumulativa de atribui@value{cedilha}@~{o}es de pesos.

Nota: Os esquemas de @code{ratfac} e @code{ratweight} s@~{a}o incompat@'{i}veis e n@~{a}o podem
ambo serem usados ao mesmo tempo.

Exemplos:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

@end deffn

@defvr {Vari@'{a}vel de sistema} ratweights
Valor Padr@~{a}o: @code{[]}

@code{ratweights} @'{e} a lista de pesos atribu@'{i}dos por @code{ratweight}.
A lista @'{e} cumulativa:
cada chamada a @code{ratweight} coloca @'{i}tens adicionais na lista.

@c DO WE REALLY NEED TO MENTION THIS ??
@code{kill (ratweights)} e @code{save (ratweights)} ambos trabalham como esperado.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratwtlvl
Valor Padr@~{a}o: @code{false}

@code{ratwtlvl} @'{e} usada em combina@value{cedilha}@~{a}o com a fun@value{cedilha}@~{a}o 
@code{ratweight} para controlar a trunca@value{cedilha}@~{a}o de express@~{a}o racionais can@^{o}nicas (CRE).
Para o valor padr@~{a}o @code{false}, nenhuma trunca@value{cedilha}@~{a}o ocorre.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} remainder (@var{p_1}, @var{p_2})
@deffnx {Fun@value{cedilha}@~{a}o} remainder (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Retorna o resto do polin@^{o}mio @var{p_1} dividido pelo polin@^{o}mio @var{p_2}.
Os argumentos @var{x_1}, ..., @var{x_n} s@~{a}o interpretados como em @code{ratvars}.

@code{remainder} retorna o segundo elemento
de uma lista de dois elementos retornada por @code{divide}.

@c NEED SOME EXAMPLES HERE
@end deffn

@c CAN PROBABLY BE CLARIFIED
@deffn {Fun@value{cedilha}@~{a}o} resultant (@var{p_1}, @var{p_2}, @var{x})
@deffnx {Vari@'{a}vel} resultant
Calcula o resultante de dois polin@^{o}mios @var{p_1} e @var{p_2},
eliminando a vari@'{a}vel @var{x}.
O resultante @'{e} um determinante dos coeficientes de @var{x}
em @var{p_1} e @var{p_2},
que @'{e} igual a zero
se e somente se @var{p_1} e @var{p_2} tiverem um fator em comum n@~{a}o constante.

Se @var{p_1} ou @var{p_2} puderem ser fatorados,
pode ser desej@'{a}vel chamar @code{factor} antes de chamar @code{resultant}.

A vari@'{a}vel @code{resultant} controla que algor@'{i}tmo ser@'{a} usado para calcular
o resultante.
@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@code{subres} para o prs subresultante,
@code{mod} para o algor@'{i}tmo resultante modular,
e @code{red} para prs reduzido.
Para muitos problemas @code{subres} pode ser melhor.
Para alguns problemas com valores grandes de grau de uma @'{u}nica vari@'{a}vel ou de duas vari@'{a}veis @code{mod} pode ser melhor.

A fun@value{cedilha}@~{a}o @code{bezout} pega os mesmos argumentos que @code{resultant} e retorna
uma matriz.  O determinante do valor de retorno @'{e} o resultante desejado.

@c NEED AN EXAMPLE HERE
@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} savefactors
Valor Padr@~{a}o: @code{false}

@c "certain functions" -- WHICH ONES ??
Quando @code{savefactors} for @code{true}, faz com que os fatores de uma
express@~{a}o que @'{e} um produto de fatores sejam gravados por certas
fun@value{cedilha}@~{o}es com o objetivo de aumentar a velocidade em posteriores fatora@value{cedilha}@~{o}es de express@~{o}es
contendo algum desses mesmos fatores.

@end defvr

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO BE ABOUT
@deffn {Fun@value{cedilha}@~{a}o} sqfr (@var{expr})
@'{e} similar a @code{factor} exceto que os fatores do polin@^{o}mio s@~{a}o "livres de ra@'{i}zes".
Isto @'{e}, eles possuem fatores somente de grau um.
Esse algor@'{i}tmo, que @'{e} tamb@'{e}m usado no primeiro est@'{a}gio de @code{factor}, utiliza
o fato que um polin@^{o}mio tem em comum com sua n'@'{e}sima derivada todos
os seus fatores de grau maior que n.  Dessa forma pegando o maior divisor comum
com o polin@^{o}mio das
derivadas com rela@value{cedilha}@~{a}o a cada vari@'{a}vel no polin@^{o}mio, todos
os fatores de grau maior que 1 podem ser achados.

Exemplo:
@c FOLLOWING GENERATED FROM THIS EXPRESSION
@c sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);

@example
(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
@end example

@end deffn

@c THIS ITEM STILL NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} tellrat (@var{p_1}, ..., @var{p_n})
@deffnx {Fun@value{cedilha}@~{a}o} tellrat ()
Adiciona ao anel dos inteiros alg@'{e}bricos conhecidos do Maxima
os elementos que s@~{a}o as solu@value{cedilha}@~{o}es dos polin@^{o}mios @var{p_1}, ..., @var{p_n}.
Cada argumento @var{p_i} @'{e} um polin@^{o}mio concoeficientes inteiros.

@code{tellrat (@var{x})} efetivamente significa substituir 0 por @var{x} em fun@value{cedilha}@~{o}es
racionais.

@code{tellrat ()} retorna uma lista das substitui@value{cedilha}@~{o}es correntes.

@code{algebraic} deve ser escolhida para @code{true} com o objetivo de que a simplifica@value{cedilha}@~{a}o de
inteiros alg@'{e}bricos tenha efeito.

Maxima inicialmente sabe sobre a unidade imagin@'{a}ria @code{%i}
e todas as ra@'{i}zes de inteiros.

Existe um comando @code{untellrat} que pega kernels (n@'{u}cleos) e
remove propriedades @code{tellrat}.

Quando fazemos @code{tellrat} em um polin@^{o}mio
de v@'{a}rias vari@'{a}veis, e.g., @code{tellrat (x^2 - y^2)}, pode existir uma ambig@"{u}idade como para
ou substituir @code{@var{y}^2} por @code{@var{x}^2}
ou vice-versa.  
Maxima seleciona uma ordena@value{cedilha}@~{a}o particular, mas se o usu@'{a}rio desejar especificar qual e.g.
@code{tellrat (y^2 = x^2)} forne@value{cedilha}e uma sintaxe que diga para substituir
@code{@var{y}^2} por @code{@var{x}^2}.

@c CAN'T TELL WHAT THIS IS ABOUT -- tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w));
@c DOES NOT YIELD AN ERROR, SO WHAT IS THE POINT ABOUT ratalgdenom ??
@c When you @code{tellrat} reducible polinomials, you want to be careful not to
@c attempt to rationalize a denominador with a zero divisor.  E.g.
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w)); will give "quotient by
@c zero".  This error can be avoided by setting @code{ratalgdenom} to @code{false}.

Exemplos:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} totaldisrep (@var{expr})
Converte toda subexpress@~{a}o de @var{expr} da forma de express@~{a}o racionais can@^{o}nicas (CRE) para
a forma geral e retorna o resultado.
Se @var{expr} @'{e} em s@'{i} mesma na forma CRE ent@~{a}o @code{totaldisrep} @'{e} identica a
@code{ratdisrep}.

@code{totaldisrep} pode ser usada para
fazer um @code{ratdisrep} em express@~{o}es tais como equa@value{cedilha}@~{o}es, listas, matrizes, etc., que
tiverem algumas subexpress@~{o}es na forma CRE.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} untellrat (@var{x_1}, ..., @var{x_n})
Remove propriedades @code{tellrat} de @var{x_1}, ..., @var{x_n}.

@c NEED EXAMPLES HERE
@end deffn
