@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /nset.texi/1.21/Sat Jun  9 01:31:23 2007//
@menu
* Introdu@value{cedilha}@~{a}o a Conjuntos::       
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Conjuntos::       
@end menu

@node Introdu@value{cedilha}@~{a}o a Conjuntos, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Conjuntos, Conjuntos, Conjuntos
@section Introdu@value{cedilha}@~{a}o a Conjuntos

Maxima fornece fun@value{cedilha}@~{o}es de conjunto, tais como intersec@value{cedilha}@~{a}o e
uni@~{a}o, para conjuntos finitos que s@~{a}o definidos por enumera@value{cedilha}@~{a}o expl@'{i}citamente.
Maxima trata
listas e conjuntos como objetos distintos. Esse recurso torna poss@'{i}vel
trabalhar com conjuntos que possuem elementos que s@~{a}o ou listas ou conjuntos.

Adicionalmente para fun@value{cedilha}@~{o}es de conjuntos finitos, Maxima fornece algumas
funoes relacionadas a an@'{a}lise combinat@'{o}ria; essas incluem os n@'{u}meros de
Stirling de primero e de segundo tipo, os n@'{u}meros de Bell, coefincientes
multinomiais, parti@value{cedilha}@~{o}es de inteiros n@~{a}o negativos, e umas poucas outras. 
Maxima tamb@'{e}m define uma fun@value{cedilha}@~{a}o delta de Kronecker.

@subsection Utiliza@value{cedilha}@~{a}o

Para construir um conjunto com elementos @code{a_1, ..., a_n}, escreva
@code{set(a_1, ..., a_n)} ou @code{@{a_1, ..., a_n@}};
para construir o conjunto vazio, escreva @code{set()} ou @code{@{@}}.
Para inser@value{cedilha}@~{a}o de dados, @code{set(...)} e @code{@{ ... @}} s@~{a}o equivalentes.
Conjuntos s@~{a}o sempre mostrados entre chaves (@code{@{ ... @}}).

Se um elemento @'{e} listado mais de uma
vez, a simplifica@value{cedilha}@~{a}o elimina o elemento redundante.

@c ===beg===
@c set();
@c set(a, b, a);
@c set(a, set(b));
@c set(a, [b]);
@c {};
@c {a, b, a};
@c {a, {b}};
@c {a, [b]};
@c ===end===
@example
(%i1) set();
(%o1)                          @{@}
(%i2) set(a, b, a);
(%o2)                        @{a, b@}
(%i3) set(a, set(b));
(%o3)                       @{a, @{b@}@}
(%i4) set(a, [b]);
(%o4)                       @{a, [b]@}
(%i5) @{@};
(%o5)                          @{@}
(%i6) @{a, b, a@};
(%o6)                        @{a, b@}
(%i7) @{a, @{b@}@};
(%o7)                       @{a, @{b@}@}
(%i8) @{a, [b]@};
(%o8)                       @{a, [b]@}
@end example

Dois elementos @var{x} e @var{y} s@~{a}o redundantes
(i.e., considerados o mesmo para prop@'{o}sito de constru@value{cedilha}@~{a}o de conjuntos)
se e somente se @code{is(@var{x} = @var{y})} retornar @code{true}.
@c THAT IS BECAUSE o conjunto SIMPLIFICATION CODE CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
Note que @code{is(equal(@var{x}, @var{y}))} pode retornar @code{true}
enquanto @code{is(@var{x} = @var{y})} retorna @code{false};
nesse caso os elementos @var{x} e @var{y} s@~{a}o considerados distintos.

@c ===beg===
@c x: a/c + b/c;
@c y: a/c + b/c;
@c z: (a + b)/c;
@c is (x = y);
@c is (y = z);
@c is (equal (y, z));
@c y - z;
@c ratsimp (%);
@c {x, y, z};
@c ===end===
@example
(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) @{x, y, z@};
                          b + a  b   a
(%o9)                    @{-----, - + -@}
                            c    c   c
@end example

Para construir um conjunto dos elementos de uma lista, use @code{setify}.

@c ===beg===
@c setify ([b, a]);
@c ===end===
@example
(%i1) setify ([b, a]);
(%o1)                        @{a, b@}
@end example

Os elementos de conjuntos @code{x} e @code{y} s@~{a}o iguais fornecendo @code{is(x = y)} 
avaliando para @code{true}. Dessa forma @code{rat(x)} e @code{x} s@~{a}o iguais como elementos de conjuntos;
conseq@"{u}entemente, 

@c ===beg===
@c {x, rat(x)};
@c ===end===
@example
(%i1) @{x, rat(x)@};
(%o1)                          @{x@}
@end example

Adicionalmente, uma vez que @code{is((x - 1)*(x + 1) = x^2 - 1)} avalia para @code{false}, 
@code{(x - 1)*(x + 1)} e @code{x^2 - 1} s@~{a}o distintos elementos de conjunto; dessa forma 

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
@end example

Para reduzir esse conjunto a um conjunto simples, apliquemos @code{rat} a cada elemeto do conjunto

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c map (rat, %);
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
(%i2) map (rat, %);
                              2
(%o2)/R/                    @{x  - 1@}
@end example

Para remover redund@^ancias de outros conjuntos, voc@^{e} pode precisar usar outras
fun@value{cedilha}@~{o}es de simplifica@value{cedilha}@~{a}o. Aqui est@'{a} um exemplo que usa @code{trigsimp}:

@c ===beg===
@c {1, cos(x)^2 + sin(x)^2};
@c map (trigsimp, %);
@c ===end===
@example
(%i1) @{1, cos(x)^2 + sin(x)^2@};
                            2         2
(%o1)                @{1, sin (x) + cos (x)@}
(%i2) map (trigsimp, %);
(%o2)                          @{1@}
@end example

Um conjunto esta'simplificado quando seus elementos n@~{a}o s@~{a}o redundantes e
o conjunto est@'{a} ordenado. A vers@~{a}o corrente das fun@value{cedilha}@~{o}es de conjunto usam a fun@value{cedilha}@~{a}o do M@'{a}xima
@code{orderlessp} para ordenar conjuntos; odavia, @i{vers@~{o}es futuras das 
fun@value{cedilha}@~{o}es de conjunto podem usar uma fun@value{cedilha}@~{a}o de ordena@value{cedilha}@~{a}o diferente}.

Algumas opera@value{cedilha}@~{o}es sobre conjuntos, tais como substitui@value{cedilha}@~{o}es, for@value{cedilha}am automaticamente a uma 
re-simplifica@value{cedilha}@~{a}o; por exemplo,

@c ===beg===
@c s: {a, b, c}$
@c subst (c=a, s);
@c subst ([a=x, b=x, c=x], s);
@c map (lambda ([x], x^2), set (-1, 0, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@}$
(%i2) subst (c=a, s);
(%o2)                        @{a, b@}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          @{x@}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        @{0, 1@}
@end example

Maxima trata listas e conjuntos como objetos distintos;
fun@value{cedilha}@~{o}es tais como @code{union} e @code{intersection} reclamam
se qualquer argumetno n@~{a}o for um conjunto. se voc@^{e} precisar aplicar uma fun@value{cedilha}@~{a}o
de conjunto a uma lista, use a fun@value{cedilha}@~{a}o @code{setify} para converter essa lsita
para um conjunto. dessa forma

@c ===beg===
@c union ([1, 2], {a, b});
@c union (setify ([1, 2]), {a, b});
@c ===end===
@example
(%i1) union ([1, 2], @{a, b@});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), @{a, b@});
(%o2)                     @{1, 2, a, b@}
@end example

Para extrair todos os elemetnos de conjunto de um conjunto @code{s} que satisfazem um predicado
@code{f}, use @code{subset(s, f)}. (Um @i{predicado} @'{e} um 
uma fun@value{cedilha}@~{a}o que avalia para os valores booleanos @code{true}/@code{false}.) Por exemplo, para encontrar as equa@value{cedilha}@~{o}es 
em um dado conjunto que n@~{a}o depende de uma vari@'{a}vel @code{z}, use

@c ===beg===
@c subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
@c ===end===
@example
(%i1) subset (@{x + y + z, x - y + 4, x + y - 5@}, lambda ([e], freeof (z, e)));
(%o1)               @{- y + x + 4, y + x - 5@}
@end example

A se@value{cedilha}@~{a}o @ref{Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Conjuntos} passui uma lista completa das
fun@value{cedilha}@~{o}es de conjunto no Maxima.

@subsection Itera@value{cedilha}@~{o}es entre Elementos de Conjuntos

Existem dois camainhos para fazer itera@value{cedilha}@~{o}es sobre elementos de conjuntos. Um caminho @'{e} usar
@code{map}; por exemplo:

@c ===beg===
@c map (f, {a, b, c});
@c ===end===
@example
(%i1) map (f, @{a, b, c@});
(%o1)                  @{f(a), f(b), f(c)@}
@end example

O outro caminho @'{e} usar @code{for @var{x} in @var{s} do}

@c ===beg===
@c s: {a, b, c};
@c for si in s do print (concat (si, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
@end example

A fun@value{cedilha}@~{a}o Maxima @code{first} e @code{rest} trabalham
atualmente sobre conjuntos. Aplicada a um conjunto, @code{first} retorna o primeiro
elemento mostrado de um conjunto; qual @'{e}lemento que @'{e} mostrado pode ser
dependente da implementa@value{cedilha}@~{a}o. Se @code{s} for um conjunto, ent@~{a}o
@code{rest(s)} @'{e} equivalente a @code{disjoin(first(s), s)}.
Atualmente, existem outras fun@value{cedilha}@~{o}es do Maxima que trabalham corretamente
sobre conjuntos.
Em futuras vers@~{o}es das fun@value{cedilha}@~{o}es de conjunto,
@code{first} e @code{rest} podem vir a funcionar diferentemente ou n@~{a}o completamente.

@subsection Erros

As fun@value{cedilha}@~{o}es de conjunto usam a fun@value{cedilha}@~{a}o Maxima @code{orderlessp} para 
organizar os elementos de cum conjunto e a fun@value{cedilha}@~{a}o (a n@'{i}vel de Lisp) @code{like} para testar a
igualdade entre elementos de conjuntos. Ambas essas fun@value{cedilha}@~{o}es possuem falhas conhecidas
que podem se manifestar se voc@^{e} tentar usar
conjuntos com elementos que s@~{a}o listas ou matrizes que contenham express@~{o}es
na forma racional can@^{o}nica (CRE). Um exemplo @'{e}

@c ===beg===
@c {[x], [rat (x)]};
@c ===end===
@example
(%i1) @{[x], [rat (x)]@};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Essa express@~{a}o faz com que o Maxima fique exitante com um erro (a mensagem de erro
depende de qual a vers@~{a}o do Lisp seu Maxima est@'{a} usando). Outro
exemplo @'{e}

@c ===beg===
@c setify ([[rat(a)], [rat(b)]]);
@c ===end===
@example
(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Essas falhas s@~{a}o causadas por falhas em @code{orderlessp} e @code{like}; elas
n@~{a}o s@~{a}o caudadas por falhas nas fun@value{cedilha}@~{o}es de conjunto. Para ilustrar, tente as express@~{o}es

@c ===beg===
@c orderlessp ([rat(a)], [rat(b)]);
@c is ([rat(a)] = [rat(a)]);
@c ===end===
@example
(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
@end example

At@'{e} que essas falhas sejam corrigidas, n@~{a}o construa conjuntos com com elementos que
sejam listas ou matrizes contendo express@~{o}es na forma racional can@^{o}nica (CRE); um conjunto com um 
elemento na forma CRE, todavia, pode n@~{a}o ser um problema:

@c ===beg===
@c {x, rat (x)};
@c ===end===
@example
(%i1) @{x, rat (x)@};
(%o1)                          @{x@}
@end example

A @code{orderlessp} do Maxima possui outra falha que pode causr problemas
com fun@value{cedilha}@~{o}es de conjunto, sabidamente o predicado de ordena@value{cedilha}@~{a}o @code{orderlessp} @'{e}
n@~{a}o transitivo. o mais simples exemplo conhecido que mostra isso @'{e}

@c ===beg===
@c q: x^2$
@c r: (x + 1)^2$
@c s: x*(x + 2)$
@c orderlessp (q, r);
@c orderlessp (r, s);
@c orderlessp (q, s);
@c ===end===
@example
(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
@end example

Essa falha pode causar problemas com todas as fun@value{cedilha}@~{o}es de conjutno bem como com
fun@value{cedilha}@~{o}es Maxima em geral. @'{E} prov@'{a}vel, mas n@~{a}o certo, que 
essa falha possa ser evitada
se todos os elementos do conjunto estiverem ou na forma CRE ou tiverem sido simplificado
usando @code{ratsimp}.

@c WHAT EXACTLY IS THE EFFECT OF ordergreat AND orderless ON o conjunto FUNCTIONS ??
Os mecanismos @code{orderless} e @code{ordergreat} do Maxima s@~{a}o 
incompat@'{i}veis com as fun@value{cedilha}@~{o}es de conjunto. Se voc@^{e} rpecisar usar ou @code{orderless}
ou @code{ordergreat}, chame todas essas fun@value{cedilha}@~{o}es antes de construir quaisquer conjuntos,
e n@~{a}o chame @code{unorder}. 

@c APPARENTLY THIS NEXT BIT REFERS TO BUG REPORT 798571
@c EXAMPLE WITH kron_delta (1/sqrt(2), sqrt(2)/2); NOW WORKS AS EXPECTED
@c COMMENT OUT PENDING CONSTRUCTION OF ANOTHER EXAMPLE WHICH TRIGGERS THE BUG
@c
@c Maxima's sign function has a bug that may cause the Kronecker
@c delta function to misbehave; for example:
@c 
@c @c ===beg===
@c @c kron_delta (1/sqrt(2), sqrt(2)/2);
@c @c ===end===
@c @example
@c (%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
@c (%o1)                           0
@c @end example
@c 
@c The correct value is 1; the bug is related to the @code{sign} bug
@c 
@c @c ===beg===
@c @c sign (1/sqrt(2) - sqrt(2)/2);
@c @c ===end===
@c @example
@c (%i1) sign (1/sqrt(2) - sqrt(2)/2);
@c (%o1)                          pos
@c @end example

Se voc@^{e} encontrar alguma coisa que voc@^{e} pense ser uma falha em alguma fun@value{cedilha}@~{o} de conjunto, por favor 
relate isso para a base de dados de falhas do Maxima. Veja @code{bug_report}.

@subsection Autores

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da 
Universidade e Nebraska e Kearney (UNK) escreveram as fn@value{cedilha}@~{o}es de conjunto do Maxima e sua
documenta@value{cedilha}@~{a}o. 

@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Conjuntos,  , Introdu@value{cedilha}@~{a}o a Conjuntos, Conjuntos
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Conjuntos

@anchor{adjoin}
@deffn {Fun@value{cedilha}@~{a}o} adjoin (@var{x}, @var{a}) 

Retorna a uni@~{a}o do conjunto @var{a} com @code{@{@var{x}@}}.

@code{adjoin} reclama se @var{a} n@~{a}o for um conjunto literal.

@code{adjoin(@var{x}, @var{a})} e @code{union(set(@var{x}), @var{a})}
s@~{a}o equivalentes;
todavia, @code{adjoin} pode ser um pouco mais r@'{a}pida que @code{union}.

Veja tamb@'{e}m @code{disjoin}.

Exemplos:

@c ===beg===
@c adjoin (c, {a, b});
@c adjoin (a, {a, b});
@c ===end===
@example
(%i1) adjoin (c, @{a, b@});
(%o1)                       @{a, b, c@}
(%i2) adjoin (a, @{a, b@});
(%o2)                        @{a, b@}
@end example

@end deffn

@anchor{belln}
@deffn {Fun@value{cedilha}@~{a}o} belln (@var{n})

Representa o @math{n}-@'{e}simo n@'{u}mero de Bell number.
@code{belln(n)} @'{e} o n@'{u}mero de parti@value{cedilha}@~{o}es de um conjunto @var{n} elementos.

Para inteiros n@~{a}o negativos @var{n},
@code{belln(@var{n})} simplifica para o @math{n}-@'{e}simo n@'{u}mero de Bell.
@code{belln} n@~{a}o simplifica para qualquer outro tipo de argumento.

@code{belln} distribui sobre equa@value{cedilha}@~{o}es, listas, matrizes e conjuntos.

Exemplos:

@code{belln} aplicado a inteiros n@~{a}o negativos.

@c ===beg===
@c makelist (belln (i), i, 0, 6);
@c is (cardinality (set_partitions ({})) = belln (0));
@c is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
@c ===end===
@example
(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions (@{@})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions (@{1, 2, 3, 4, 5, 6@})) = belln (6));
(%o3)                         true
@end example

@code{belln} aplicado a argumentos que n@~{a}o s@~{a}o inteiros n@~{a}o negativos.

@c ===beg===
@c [belln (x), belln (sqrt(3)), belln (-9)];
@c ===end===
@example
(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
@end example

@end deffn

@anchor{cardinality}
@deffn {Fun@value{cedilha}@~{a}o} cardinality (@var{a})

Retorna o n@'{u}mero de elementos distintos do conjunto @var{a}. 

@code{cardinality} ignora elementos redundantes
mesmo quando a simplifica@value{cedilha}@~{a}o est@'{a} dessabilitada.

Exemplos:

@c ===beg===
@c cardinality ({});
@c cardinality ({a, a, b, c});
@c simp : false;
@c cardinality ({a, a, b, c});
@c ===end===
@example
(%i1) cardinality (@{@});
(%o1)                           0
(%i2) cardinality (@{a, a, b, c@});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality (@{a, a, b, c@});
(%o4)                           3
@end example

@end deffn

@anchor{cartesian_product}
@deffn {Fun@value{cedilha}@~{a}o} cartesian_product (@var{b_1}, ... , @var{b_n})
Retorna um conjunto de listas da forma @code{[@var{x_1}, ..., @var{x_n}]}, onde
@var{x_1}, ..., @var{x_n} s@~{a}o elementos dos conjuntos @var{b_1}, ... , @var{b_n},
respectivamente.

@code{cartesian_product} reclama se qualquer argumento n@~{a}o for um conjunto literal.

Exemplos:

@c ===beg===
@c cartesian_product ({0, 1});
@c cartesian_product ({0, 1}, {0, 1});
@c cartesian_product ({x}, {y}, {z});
@c cartesian_product ({x}, {-1, 0, 1});
@c ===end===
@example
(%i1) cartesian_product (@{0, 1@});
(%o1)                      @{[0], [1]@}
(%i2) cartesian_product (@{0, 1@}, @{0, 1@});
(%o2)           @{[0, 0], [0, 1], [1, 0], [1, 1]@}
(%i3) cartesian_product (@{x@}, @{y@}, @{z@});
(%o3)                      @{[x, y, z]@}
(%i4) cartesian_product (@{x@}, @{-1, 0, 1@});
(%o4)              @{[x, - 1], [x, 0], [x, 1]@}
@end example
@end deffn


@anchor{disjoin}
@deffn {Fun@value{cedilha}@~{a}o} disjoin (@var{x}, @var{a})
Retorna o conjunto @var{a} sem o elemento @var{x}.
Se @var{x} n@~{a}o for um elemento de @var{a}, retorna @var{a} sem modifica@value{cedilha}@~{o}es.

@code{disjoin} reclama se @var{a} n@~{a}o for um conjunto literal.

@code{disjoin(@var{x}, @var{a})}, @code{delete(@var{x}, @var{a})}, e
@code{setdifference(@var{a}, set(@var{x}))} s@~{a}o todos equivalentes. 
Desses, @code{disjoin} @'{e} geralmente mais r@'{a}pido que os outros.

Exemplos:

@c ===beg===
@c disjoin (a, {a, b, c, d});
@c disjoin (a + b, {5, z, a + b, %pi});
@c disjoin (a - b, {5, z, a + b, %pi});
@c ===end===
@example
(%i1) disjoin (a, @{a, b, c, d@});
(%o1)                       @{b, c, d@}
(%i2) disjoin (a + b, @{5, z, a + b, %pi@});
(%o2)                      @{5, %pi, z@}
(%i3) disjoin (a - b, @{5, z, a + b, %pi@});
(%o3)                  @{5, %pi, b + a, z@}
@end example

@end deffn

@anchor{disjointp}
@deffn {Fun@value{cedilha}@~{a}o} disjointp (@var{a}, @var{b}) 
Retorna @code{true} se e somente se os conjuntos @var{a} e @var{b} forem disjuntos.

@code{disjointp} reclama se ou @var{a} ou @var{b} n@~{a}o forem conjuntos literais.

Exemplos:

@c ===beg===
@c disjointp ({a, b, c}, {1, 2, 3});
@c disjointp ({a, b, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) disjointp (@{a, b, c@}, @{1, 2, 3@});
(%o1)                         true
(%i2) disjointp (@{a, b, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example

@end deffn

@anchor{divisors}
@deffn {Fun@value{cedilha}@~{a}o} divisors (@var{n})

Representa o conjunto dos divisores de @var{n}.

@code{divisors(@var{n})} simplifica para um conjunto de inteiros
quando @var{n} for um inteiro n@~{a}o nulo.
O cojunto dos divisores inclui os elementos 1 e @var{n}.
Os divisores de um inteiro negativo s@~{a}o os divisores de seu valor absoluto.

@code{divisors} distribui sobre equa@value{cedilha}@~{o}es, listas, matrizes, e conjuntos.

Exemplos:

Podemos verificar que 28 @'{e} um n@'{u}mero perfeito:
a adi@value{cedilha}@~{a}o de seus divisores (exceto o pr@'{o}prio 28) @'{e} 28.

@c ===beg===
@c s: divisors(28);
@c lreduce ("+", args(s)) - 28;
@c ===end===
@example
(%i1) s: divisors(28);
(%o1)                 @{1, 2, 4, 7, 14, 28@}
(%i2) lreduce ("+", args(s)) - 28;
(%o2)                          28
@end example

@code{divisors} @'{e} uma fun@value{cedilha}@~{a}o de simplifica@value{cedilha}@~{a}o.
Substituindo 8 por @code{a} em @code{divisors(a)}
retorna os divisores sem fazer a reavalia@value{cedilha}@~{a}o de @code{divisors(8)}.

@c ===beg===
@c divisors (a);
@c subst (8, a, %);
@c ===end===
@example
(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     @{1, 2, 4, 8@}
@end example

@code{divisors} distribui sobre equa@value{cedilha}@~{o}es, listas, matrizes, e conjuntos.

@c ===beg===
@c divisors (a = b);
@c divisors ([a, b, c]);
@c divisors (matrix ([a, b], [c, d]));
@c divisors ({a, b, c});
@c ===end===
@example
(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors (@{a, b, c@});
(%o4)        @{divisors(a), divisors(b), divisors(c)@}
@end example
@end deffn

@anchor{elementp}
@deffn {Fun@value{cedilha}@~{a}o} elementp (@var{x}, @var{a})
Retorna @code{true} se e somente se @var{x} for um elemento do 
conjunto @var{a}.

@code{elementp} reclama se @var{a} n@~{a}o for um conjunto literal.

Exemplos:

@c ===beg===
@c elementp (sin(1), {sin(1), sin(2), sin(3)});
@c elementp (sin(1), {cos(1), cos(2), cos(3)});
@c ===end===
@example
(%i1) elementp (sin(1), @{sin(1), sin(2), sin(3)@});
(%o1)                         true
(%i2) elementp (sin(1), @{cos(1), cos(2), cos(3)@});
(%o2)                         false
@end example

@end deffn

@anchor{emptyp}
@deffn {Fun@value{cedilha}@~{a}o} emptyp (@var{a})
Retorna @code{true} se e somente se @var{a} for o conjunto vazio ou
a lista vazia.

Exemplos:

@c ===beg===
@c map (emptyp, [{}, []]);
@c map (emptyp, [a + b, {{}}, %pi]);
@c ===end===
@example
(%i1) map (emptyp, [@{@}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, @{@{@}@}, %pi]);
(%o2)                 [false, false, false]
@end example
@end deffn
       
@anchor{equiv_classes}
@deffn {Fun@value{cedilha}@~{a}o} equiv_classes (@var{s}, @var{F})
Retorna um conjunto das classes de equival@^{e}ncias do conjunto @var{s} com rela@value{cedilha}@~{a}o
@`a rela@value{cedilha}@~{a}o de equival@^{e}ncia @var{F}.

@var{F} @'{e} uma fun@value{cedilha}@~{a}o de duas vari@'{a}veis definida sobre o produto cartesiano @var{s} por @var{s}.
O valor de retorno de @var{F} @'{e} ou @code{true} ou @code{false},
ou uma express@~{a}o @var{expr} tal que @code{is(@var{expr})} @'{e} ou @code{true} ou @code{false}.

Quando @var{F} n@~{o} for um rela@value{cedilha}@~{a}o de equival@^{e}ncia,
@code{equiv_classes} aceita sem reclama@value{cedilha}@~{a}o,
mas o resultado @'{e} geralmente incorreto nesse caso.

@c EXCESSIVE DETAIL HERE. PROBABLY JUST CUT THIS
@c @var{F} may be a relational operator (built-in or user-defined),
@c an ordinary Maxima function, a Lisp function, a lambda expression,
@c a macro, or a subscripted function.

Exemplos:

A rela@value{cedilha}@~{a}o de equival@^{e}ncia @'{e} uma express@~{a}o lambda a qual retorna @code{true} ou @code{false}.

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, lambda ([x, y], is (equal (x, y))));
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

A rela@value{cedilha}@~{a}o de equival@^{e}ncia @'{e} o nome de uma fun@value{cedilha}@~{a}o relacional
que avalia para @code{true} ou @code{false}.

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, equal);
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

As classes de equival@^{e}ncia s@~{a}o n@'{u}meros que diferem por um multiplo de 3.

@c ===beg===
@c equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
@c ===end===
@example
(%i1) equiv_classes (@{1, 2, 3, 4, 5, 6, 7@}, lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              @{@{1, 4, 7@}, @{2, 5@}, @{3, 6@}@}
@end example
@end deffn

@anchor{every}
@deffn {Fun@value{cedilha}@~{a}o} every (@var{f}, @var{s})
@deffnx {Fun@value{cedilha}@~{a}o} every (@var{f}, @var{L_1}, ..., @var{L_n})

Retorna @code{true} se o predicado @var{f} for @code{true} para todos os argumentos fornecidos.

Dado um conjunto como sgundo argumento, 
@code{every(@var{f}, @var{s})} retorna @code{true}
se @code{is(@var{f}(@var{a_i}))} retornar @code{true} para todos os @var{a_i} em @var{s}.
@code{every} pode ou n@~{a}o avaliar @var{f} para todos os @var{a_i} em @var{s}.
Uma vez que conjuntos s@~{a}o desordenados,
@code{every} pode avaliar @code{@var{f}(@var{a_i})} em qualquer ordem.

Dada uma ou mais listas como argumentos,
@code{every(@var{f}, @var{L_1}, ..., @var{L_n})} retorna @code{true}
se @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} retornar @code{true} 
para todos os @var{x_1}, ..., @var{x_n} em @var{L_1}, ..., @var{L_n}, respectivamente.
@code{every} pode ou n@~{a}o avaliar 
@var{f} para toda combina@value{cedilha}@~{a}o @var{x_1}, ..., @var{x_n}.
@code{every} avalia listas na ordem de incremento do @'{i}ndice.

Dado um conjunto vazio @code{@{@}} ou uma lista vazia @code{[]} como argumentos,
@code{every} retorna @code{false}.

Quando o sinalizador global @code{maperror} for @code{true}, todas as listas 
@var{L_1}, ..., @var{L_n} devem ter o mesmo comprimento. 
Quando @code{maperror} for @code{false}, argumentos listas s@~{a}o
efetivamente truncados para o comprimento da menor lista. 

Retorna valores do predicado @var{f} que avaliam (via @code{is})
para alguma coisa outra que n@~{a}o @code{true} ou @code{false}
s@~{a}o governados atrav@'{e}s do sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
tais valores s@~{a}o tratados como @code{false},
e o valor de retorno de @code{every} @'{e} @code{false}.
Quando @code{prederror} for @code{false},
tais valores s@~{a}o tratados como @code{unknown},
e o valor de retorno de @code{every} @'{e} @code{unknown}.

Exemplos:

@code{every} aplicada a um conjunto simples.
O predicado @'{e} uma fun@value{cedilha}@~{a}o de um argumento.

@c ===beg===
@c every (integerp, {1, 2, 3, 4, 5, 6});
@c every (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) every (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) every (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         false
@end example

@code{every} aplicada a duas listas.
O predicado @'{e} uma fun@value{cedilha}@~{a}o de dois argumentos.

@c ===beg===
@c every ("=", [a, b, c], [a, b, c]);
@c every ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) every ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Retorna valores do predicado @var{f} que avalia
para alguma coisa outra que n@~{a}o @code{true} ou @code{false}
s@~{a}o governados por meio do sinalizador global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c prederror : true;
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
@end example

@end deffn
 
@anchor{extremal_subset}
@deffn {Fun@value{cedilha}@~{a}o} extremal_subset (@var{s}, @var{f}, max)
@deffnx {Fun@value{cedilha}@~{a}o} extremal_subset (@var{s}, @var{f}, min)

Retorna o subconjunto de @var{s} para o qual a fun@value{cedilha}@~{a}o @var{f} toma valore m@'{a}ximos ou m@'{i}nimos.

@code{extremal_subset(@var{s}, @var{f}, max)} retorna o subconjunto do conjunto ou 
lista @var{s} para os quais a fun@value{cedilha}@~{a}o real @var{f} assume valor maximo.

@code{extremal_subset(@var{s}, @var{f}, min)} retorna o subconjuno do conjunto ou 
lista @var{s} para a qual a fun@value{cedilha}@~{a}o real @var{f} assume valor m@'{i}nimo.

Exemplos:

@c ===beg===
@c extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
@c extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
@c ===end===
@example
(%i1) extremal_subset (@{-2, -1, 0, 1, 2@}, abs, max);
(%o1)                       @{- 2, 2@}
(%i2) extremal_subset (@{sqrt(2), 1.57, %pi/2@}, sin, min);
(%o2)                       @{sqrt(2)@}
@end example
@end deffn

@anchor{flatten}
@deffn {Fun@value{cedilha}@~{a}o} flatten (@var{expr})

Recebe argumentos de subexpress@~{o}es que possuem o mesmo operator como @var{expr}
e constr@'{o}i uma express@~{a}o a partir desses argumentos coletados.

subexpress@~{o}es nas quais o operador @'{e} diferente do operador principal de @code{expr}
s@~{a}o copiadas sem modifica@value{cedilha}@~{a}o,
mesmo se elas, in turn, contiverem a mesma subexpress@~{a}o na qual o operador seja o mesmo que em @code{expr}.

Pode ser poss@'{i}vel para @code{flatten} construir express@~{o}es nas quais o n@'{u}mero
de argumentos difira dos argumentos declarados para um operador;
isso pode provocar uma mensagem de erro do simplificador ou do avaliador.
@code{flatten} n@~{a}o tenta detectar tais situa@value{cedilha}@~{o}es.

Express@~{o}es com representa@value{cedilha}@~{o}es especiais, por exemplo, express@~{a}oes racionais can@^{o}nicas (CRE), 
n@~{a}o podem usar a fun@value{cedilha}@~{a}o @code{flatten}; nesses casos, @code{flatten} retorna seus argumentos sem modifica@value{cedilha}@~{a}o.

Exemplos:

Aplicado a uma lista, @code{flatten} reune todos os elementos de lista que s@~{a}o listas.

@c ===beg===
@c flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
@c ===end===
@example
(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
@end example

Aplicado a um conjunto, @code{flatten} reune todos os elementos de conjunto que s@~{a}o conjuntos.

@c ===beg===
@c flatten ({a, {b}, {{c}}});
@c flatten ({a, {[a], {a}}});
@c ===end===
@example
(%i1) flatten (@{a, @{b@}, @{@{c@}@}@});
(%o1)                       @{a, b, c@}
(%i2) flatten (@{a, @{[a], @{a@}@}@});
(%o2)                       @{a, [a]@}
@end example

@code{flatten} @'{e} similar ao efeito de declarar o operador principal para ser en@'{a}rio.
Todavia, @code{flatten} n@~{a}o faz efeito sobre subexpress@~{o}es que possuem um operador
diferente do operador principal, enquanto uma declara@value{cedilha}@~{a}o en@'{a}ria faz efeito.

@c ===beg===
@c expr: flatten (f (g (f (f (x)))));
@c declare (f, nary);
@c ev (expr);
@c ===end===
@example
(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
@end example

@code{flatten} trata fun@value{cedilha}@~{o}es subscritas da mesma forma que qualquer outro operador.

@c ===beg===
@c flatten (f[5] (f[5] (x, y), z));
@c ===end===
@example
(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
@end example

Pode ser poss@'{i}vel para @code{flatten} construir express@~{o}es nas quais o n@'{u}mero de
argumentos difira dos argumentos declarados  para um operador;

@c ===beg===
@c 'mod (5, 'mod (7, 4));
@c flatten (%);
@c ''%, nouns;
@c ===end===
@example
(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example
@end deffn

@anchor{full_listify}
@deffn {Fun@value{cedilha}@~{a}o} full_listify (@var{a})
Substitui todo oeradr de conjutno em @var{a} por um operadro de lista,
e retorna o resultado.
@code{full_listify} substitui operadores de conjunto em subexpress@~{o}es restantes,
mesmo se o operadro principal n@~{a}o for conjunto (@code{set}).

@code{listify} substitui somente o operador principal.

Exemplos:

@c ===beg===
@c full_listify ({a, b, {c, {d, e, f}, g}});
@c full_listify (F (G ({a, b, H({c, d, e})})));
@c ===end===
@example
(%i1) full_listify (@{a, b, @{c, @{d, e, f@}, g@}@});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G (@{a, b, H(@{c, d, e@})@})));
(%o2)              F(G([a, b, H([c, d, e])]))
@end example

@end deffn

@anchor{fullsetify}
@deffn {Fun@value{cedilha}@~{a}o} fullsetify (@var{a})
Quando @var{a} for uma lista, substitui o operador de lista por um operador de conjunto,
e aplica @code{fullsetify} a cada elemento que for um conjunto.
Quando @var{a} n@~{a}o for uma lista, essa n@~{a}o lista @'{e} retornada em sua forma original e sem modifica@value{cedilha}@~{o}es.

@code{setify} substitui somente o operador principal.

Exemplos:

Na linha (%o2), o argumento de @code{f} n@~{a}o @'{e} convertido para um conjunto
porque o operador principal de @code{f([b])} n@~{a}o @'{e} uma lista.

@c ===beg===
@c fullsetify ([a, [a]]);
@c fullsetify ([a, f([b])]);
@c ===end===
@example
(%i1) fullsetify ([a, [a]]);
(%o1)                       @{a, @{a@}@}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      @{a, f([b])@}
@end example

@end deffn

@anchor{identity}
@deffn {Fun@value{cedilha}@~{a}o} identity (@var{x})

Retorna @var{x} para qualquer argumento @var{x}.

Exemplos:

@code{identity} pode ser usado como um predicado quando os argumentos
forem  valores Booleanos.

@c ===beg===
@c every (identity, [true, true]);
@c ===end===
@example
(%i1) every (identity, [true, true]);
(%o1)                         true
@end example
@end deffn

@anchor{integer_partitions}
@deffn {Fun@value{cedilha}@~{a}o} integer_partitions (@var{n})
@deffnx {Fun@value{cedilha}@~{a}o} integer_partitions (@var{n}, @var{len})

Retorna parti@value{cedilha}@~{o}es inteiras de @var{n}, isto @'{e},
listas de inteiros cuja soma dos elementos de cada lista @'{e} @var{n}.

@code{integer_partitions(@var{n})} retorna o conjunto de
todas as parti@value{cedilha}@~{o}es do inteiro @var{n}.
Cada parti@value{cedilha}@~{a}o @'{e} uma lista ordenada do maior para o menor.

@code{integer_partitions(@var{n}, @var{len})}
retorna todas as parti@value{cedilha}@~{o}es que possuem comprimento @var{len} ou menor; nesse
caso, zeros s@~{a}o anexado ao final de cada parti@value{cedilha}@~{a}o de comprimento menor que @var{len}
terms to make each partition have exactly @var{len} terms.
Each partition is a list sorted from greatest to least.

Uma lista @math{[a_1, ..., a_m]} @'{e} uma parti@value{cedilha}@~{a}o de inteiros n@~{a}o negativos
@math{n} quando (1) cada @math{a_i} @'{e} um inteiro n@~{a}o nulo, e (2) 
@math{a_1 + ... + a_m = n.} Dessa forma 0 n@~{a}o tem parti@value{cedilha}@~{a}oes.

Exemplos:

@c ===beg===
@c integer_partitions (3);
@c s: integer_partitions (25)$
@c cardinality (s);
@c map (lambda ([x], apply ("+", x)), s);
@c integer_partitions (5, 3);
@c integer_partitions (5, 2);
@c ===end===
@example
(%i1) integer_partitions (3);
(%o1)               @{[1, 1, 1], [2, 1], [3]@}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply ("+", x)), s);
(%o4)                         @{25@}
(%i5) integer_partitions (5, 3);
(%o5) @{[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]@}
(%i6) integer_partitions (5, 2);
(%o6)               @{[3, 2], [4, 1], [5, 0]@}
@end example

Para encontrar todas as parti@value{cedilha}@~{o}es que satisfazem uma condi@value{cedilha}@~{a}o, use a fun@value{cedilha}@~{a}o @code{subset};
aqui est@'{a} um exemplo que encontra todas as parti@value{cedilha}@~{o}es de 10 cujos elementos da lista s@~{a}o n@'{u}meros primos.

@c ===beg===
@c s: integer_partitions (10)$
@c cardinality (s);
@c xprimep(x) := integerp(x) and (x > 1) and primep(x)$
@c subset (s, lambda ([x], every (xprimep, x)));
@c ===end===
@example
(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) @{[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]@}
@end example

@end deffn

@anchor{intersect}
@deffn {Fun@value{cedilha}@~{a}o} intersect (@var{a_1}, ..., @var{a_n})

@code{intersect} @'{e} o mesmo que @code{intersection}, como veremos.

@end deffn

@anchor{intersection}
@deffn {Fun@value{cedilha}@~{a}o} intersection (@var{a_1}, ..., @var{a_n})
Retorna um conjunto contendo os elementos que s@~{a}o comuns aos 
conjuntos @var{a_1} at@'{e} @var{a_n}.

@code{intersection} reclama se qualquer argumento n@~{a}o for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c, d};
@c S_2 : {d, e, f, g};
@c S_3 : {c, d, e, f};
@c S_4 : {u, v, w};
@c intersection (S_1, S_2);
@c intersection (S_2, S_3);
@c intersection (S_1, S_2, S_3);
@c intersection (S_1, S_2, S_3, S_4);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, d@};
(%o1)                     @{a, b, c, d@}
(%i2) S_2 : @{d, e, f, g@};
(%o2)                     @{d, e, f, g@}
(%i3) S_3 : @{c, d, e, f@};
(%o3)                     @{c, d, e, f@}
(%i4) S_4 : @{u, v, w@};
(%o4)                       @{u, v, w@}
(%i5) intersection (S_1, S_2);
(%o5)                          @{d@}
(%i6) intersection (S_2, S_3);
(%o6)                       @{d, e, f@}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          @{d@}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          @{@}
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} kron_delta (@var{x}, @var{y})

Representa a fun@value{cedilha}@~{a}o delta de Kronecker.

@code{kron_delta} simplifica para 1 quando @var{x} e @var{y} forem identicos ou demonstadamente equivalentes,
e simplifica para 0 quando @var{x} e @var{y} demonstradamente n@~{a}o equivalentes.
De outra forma,
se n@~{a}o for certo que @var{x} e @var{y} s@~{a}o equivalentes,
e @code{kron_delta} simplifica para uma express@~{a}o substantiva.
@code{kron_delta} implementa uma pol@'{i}tica de seguran@value{cedilha}a para express@~{o}es em ponto flutuante:
se a diferen@value{cedilha}a @code{@var{x} - @var{y}} for um n@'{u}mero em ponto flutuante,
@code{kron_delta} simplifica para uma express@~{a}o substantiva quando @var{x} for aparentemente equivalente a @var{y}.

Specificamente,
@code{kron_delta(@var{x}, @var{y})} simplifica para 1
quando @code{is(x = y)} for @code{true}.
@code{kron_delta} tamb@'{e}m simplifica para 1
quando @code{sign(abs(@var{x} - @var{y}))} for @code{zero}
e @code{@var{x} - @var{y}} n@~{a}o for um n@'{u}mero em ponto flutuante
(e tamb@'{e}m n@~{a}o for um n@'{u}mero de precis@~{a}o simples em ponto flutuante e tamb@'{e}m n@~{a}o for um n@'{u}mero de precis@~{a}o dupla em poto flutuante, isto @'{e}, n@~{a}o for um bigfloat).
@code{kron_delta} simplifica para 0
quando @code{sign(abs(@var{x} - @var{y}))} for @code{pos}.

De outra forma, @code{sign(abs(@var{x} - @var{y}))} @'{e}
alguma coisa outra que n@~{a}o @code{pos} ou @code{zero},
ou se for @code{zero} e @code{@var{x} - @var{y}}
for umn@'{u}mero em ponto flutuante.
Nesses casos, @code{kron_delta} retorna um express@~{a}o substantiva.

@code{kron_delta} @'{e} declarada para ser sim@'{e}trica.
Isto @'{e},
@code{kron_delta(@var{x}, @var{y})} @'{e} igual a @code{kron_delta(@var{y}, @var{x})}.

Exemplos:

Os argumentos de @code{kron_delta} s@~{a}o identicos.
@code{kron_delta} simplifica para 1.

@c ===beg===
@c kron_delta (a, a);
@c kron_delta (x^2 - y^2, x^2 - y^2);
@c float (kron_delta (1/10, 0.1));
@c ===end===
@example
(%i1) kron_delta (a, a);
(%o1)                           1
(%i2) kron_delta (x^2 - y^2, x^2 - y^2);
(%o2)                           1
(%i3) float (kron_delta (1/10, 0.1));
(%o3)                           1
@end example

Os argumentos de @code{kron_delta} s@~{a}o equivalentes,
e a diferen@value{cedilha}a entre eles n@~{a}o @'{e} um n@'{u}mero em ponto flutuante.
@code{kron_delta} simplifica para 1.

@c ===beg===
@c assume (equal (x, y));
@c kron_delta (x, y);
@c ===end===
@example
(%i1) assume (equal (x, y));
(%o1)                     [equal(x, y)]
(%i2) kron_delta (x, y);
(%o2)                           1
@end example

Os argumentos de @code{kron_delta} n@~{a}o s@~{a}o equivalentes.
@code{kron_delta} simplifica para 0.

@c ===beg===
@c kron_delta (a + 1, a);
@c assume (a > b)$
@c kron_delta (a, b);
@c kron_delta (1/5, 0.7);
@c ===end===
@example
(%i1) kron_delta (a + 1, a);
(%o1)                           0
(%i2) assume (a > b)$
(%i3) kron_delta (a, b);
(%o3)                           0
(%i4) kron_delta (1/5, 0.7);
(%o4)                           0
@end example

Os argumentos de @code{kron_delta} podem ou n@~{a}o serem equivalentes.
@code{kron_delta} simplifica para uma express@~{a}o substantiva.

@c ===beg===
@c kron_delta (a, b);
@c assume(x >= y)$
@c kron_delta (x, y);
@c ===end===
@example
(%i1) kron_delta (a, b);
(%o1)                   kron_delta(a, b)
(%i2) assume(x >= y)$
(%i3) kron_delta (x, y);
(%o3)                   kron_delta(x, y)
@end example

Os argumentos de @code{kron_delta} s@~{a}o equivalentes,
mas a diferen@value{cedilha}a entre eles @'{e} um n@'{u}mero em ponto flutuante.
@code{kron_delta} simplifica para uma express@~{a}o substantiva.

@c ===beg===
@c 1/4 - 0.25;
@c 1/10 - 0.1;
@c 0.25 - 0.25b0;
@c kron_delta (1/4, 0.25);
@c kron_delta (1/10, 0.1);
@c kron_delta (0.25, 0.25b0);
@c ===end===
@example
(%i1) 1/4 - 0.25;
(%o1)                          0.0
(%i2) 1/10 - 0.1;
(%o2)                          0.0
(%i3) 0.25 - 0.25b0;
Warning:  Float to bigfloat conversion of 0.25
(%o3)                         0.0b0
(%i4) kron_delta (1/4, 0.25);
                                  1
(%o4)                  kron_delta(-, 0.25)
                                  4
(%i5) kron_delta (1/10, 0.1);
                                  1
(%o5)                  kron_delta(--, 0.1)
                                  10
(%i6) kron_delta (0.25, 0.25b0);
Warning:  Float to bigfloat conversion of 0.25
(%o6)               kron_delta(0.25, 2.5b-1)
@end example

@code{kron_delta} @'{e} sim@'{e}trica.

@c ===beg===
@c kron_delta (x, y);
@c kron_delta (y, x);
@c kron_delta (x, y) - kron_delta (y, x);
@c is (equal (kron_delta (x, y), kron_delta (y, x)));
@c is (kron_delta (x, y) = kron_delta (y, x));
@c ===end===
@example
(%i1) kron_delta (x, y);
(%o1)                   kron_delta(x, y)
(%i2) kron_delta (y, x);
(%o2)                   kron_delta(x, y)
(%i3) kron_delta (x, y) - kron_delta (y, x);
(%o3)                           0
(%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
(%o4)                         true
(%i5) is (kron_delta (x, y) = kron_delta (y, x));
(%o5)                         true
@end example

@end deffn

@anchor{listify}
@deffn {Fun@value{cedilha}@~{a}o} listify (@var{a})

Retorna uma lista contendo os elementos de @var{a} quando @var{a} for um conjunto.
De outra forma, @code{listify} retorna @var{a}.

@code{full_listify} substitui todos os operadores de conjunto em @var{a} por operadores de lista.

Exemplos:

@c ===beg===
@c listify ({a, b, c, d});
@c listify (F ({a, b, c, d}));
@c ===end===
@example
(%i1) listify (@{a, b, c, d@});
(%o1)                     [a, b, c, d]
(%i2) listify (F (@{a, b, c, d@}));
(%o2)                    F(@{a, b, c, d@})
@end example

@end deffn

@anchor{lreduce}
@deffn {Fun@value{cedilha}@~{a}o} lreduce (@var{F}, @var{s})
@deffnx {Fun@value{cedilha}@~{a}o} lreduce (@var{F}, @var{s}, @var{s_0})

Extende a fun@value{cedilha}@~{a}o de dois operadores @var{F} para uma fun@value{cedilha}@~{a}o de @code{n} operadores usando composi@value{cedilha}@~{a}o,
onde @var{s} @'{e} uma lista.

@code{lreduce(@var{F}, @var{s})} returns @code{F(... F(F(s_1, s_2), s_3), ... s_n)}.
Quando o argumento opcional @var{s_0} estiver presente,
o resultado @'{e} equivalente a @code{lreduce(@var{F}, cons(@var{s_0}, @var{s}))}.

A fun@value{cedilha}@~{a}o @var{F} @'{e} primeiramente aplicada @`a
lista de elementos @i{leftmost - mais @`a esquerda}, da@'{i} o nome "lreduce". 

Veja tamb@'{e}m @code{rreduce}, @code{xreduce}, e @code{tree_reduce}.

Exemplos:

@code{lreduce} sem o argumento opcional.

@c ===beg===
@c lreduce (f, [1, 2, 3]);
@c lreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
@end example

@code{lreduce} com o argumento opcional.

@c ===beg===
@c lreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
@end example

@code{lreduce} aplicada a operadores de dois argumentos internos (j@'{a} definidos por padr@~{a}o) do Maxima.
@code{/} @'{e} o operador de divis@~{a}o.

@c ===beg===
@c lreduce ("^", args ({a, b, c, d}));
@c lreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) lreduce ("^", args (@{a, b, c, d@}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce ("/", args (@{a, b, c, d@}));
                                a
(%o2)                         -----
                              b c d
@end example

@end deffn

@anchor{makeset}
@deffn {Fun@value{cedilha}@~{a}o} makeset (@var{expr}, @var{x}, @var{s})

Retorna um conjunto com elementos gerados a partir da express@~{a}o @var{expr},
onde @var{x} @'{e} uma lista de vari@'{a}veis em @var{expr},
e @var{s}@'{e} um conjunto ou lista de listas.
Para gerar cada elemento do conjunto,
@var{expr} @'{e} avaliada com as vari@'{a}veis @var{x} paralelamente a um elemento de @var{s}.

Cada elemento de @var{s} deve ter o mesmo comprimento que @var{x}.
A lista de vari@'{a}veis @var{x} deve ser uma lista de s@'{i}mbolos, sem subscritos.
Mesmo se existir somente um s@'{i}mbolo, @var{x} deve ser uma lista de um elemento,
e cada elemento de @var{s} deve ser uma lista de um elemento.

@c FOLLOWING EQUIVALENT EXPRESSION IS REALLY TOO COMPLICATED, JUST SKIP IT FOR NOW
@c @code{makeset(@var{expr}, @var{x}, @var{s})} returns the same result as
@c @code{setify(map(lambda([L], sublis(map("=", ''@var{x}, L), ''@var{expr})), args(@var{s})))}.

Veja tamb@'{e}m @code{makelist}.

Exemplos:

@c ===beg===
@c makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
@c S : {x, y, z}$
@c S3 : cartesian_product (S, S, S);
@c makeset (i + j + k, [i, j, k], S3);
@c makeset (sin(x), [x], {[1], [2], [3]});
@c ===end===
@example
(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     @{-, -, -, -@}
                           a  b  c  d
(%i2) S : @{x, y, z@}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) @{[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]@}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) @{3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y@}
(%i5) makeset (sin(x), [x], @{[1], [2], [3]@});
(%o5)               @{sin(1), sin(2), sin(3)@}
@end example
@end deffn

@anchor{moebius}
@deffn {Fun@value{cedilha}@~{a}o} moebius (@var{n})

Representa a fun@value{cedilha}@~{a}o de Moebius.

Quando @var{n} for o produto de @math{k} primos distintos,
@code{moebius(@var{n})} simplifica para @math{(-1)^k};
quando @math{@var{n} = 1}, simplifica para 1;
e simplifica para 0 para todos os outros inteiros positivos. 

@code{moebius} distribui sobre equa@value{cedilha}@~{o}es, listas, matrizes, e conjuntos.

Exemplos:

@c ===beg===
@c moebius (1);
@c moebius (2 * 3 * 5);
@c moebius (11 * 17 * 29 * 31);
@c moebius (2^32);
@c moebius (n);
@c moebius (n = 12);
@c moebius ([11, 11 * 13, 11 * 13 * 15]);
@c moebius (matrix ([11, 12], [13, 14]));
@c moebius ({21, 22, 23, 24});
@c ===end===
@example
(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius (@{21, 22, 23, 24@});
(%o9)                      @{- 1, 0, 1@}
@end example

@end deffn
 
@anchor{multinomial_coeff}
@deffn {Fun@value{cedilha}@~{a}o} multinomial_coeff (@var{a_1}, ..., @var{a_n})
@deffnx {Fun@value{cedilha}@~{a}o} multinomial_coeff ()

Retorna o coeficiente multinomial.

Quando cada @var{a_k} for um inteiro n@~{a}o negativo, o coeficiente multinomial
fornece o n@'{u}mero de formas poss@'{i}veis de colocar @code{@var{a_1} + ... + @var{a_n}} 
objetos distintos em @math{n} caixas com @var{a_k} elementos na
@math{k}'@'{e}sima caixa. Em geral, @code{multinomial_coeff (@var{a_1}, ..., @var{a_n})}
avalia para @code{(@var{a_1} + ... + @var{a_n})!/(@var{a_1}! ... @var{a_n}!)}.

@code{multinomial_coeff()} (sem argumentos) avalia para 1.

@code{minfactorial} pode estar apta a simplificar o valor retornado por @code{multinomial_coeff}.

Exemplos:

@c ===beg===
@c multinomial_coeff (1, 2, x);
@c minfactorial (%);
@c multinomial_coeff (-6, 2);
@c minfactorial (%);
@c ===end===
@example
(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
@end example
@end deffn

@anchor{num_distinct_partitions}
@deffn {Fun@value{cedilha}@~{a}o} num_distinct_partitions (@var{n})
@deffnx {Fun@value{cedilha}@~{a}o} num_distinct_partitions (@var{n}, list)

Retorna o n;umero de parti@value{cedilha}@~{o}es de inteiros distintos de @var{n}
quando @var{n} for um inteiro n@~{a}o negativo.
De outra forma, @code{num_distinct_partitions} retorna uma express@~{a}o substantiva.

@code{num_distinct_partitions(@var{n}, list)} retorna uma 
lista do n@'{u}mero de parti@value{cedilha}@~{o}es distintas de 1, 2, 3, ..., @var{n}. 

Uma parti@value{cedilha}@~{a}o distinta de @var{n} @'{e}
uma lista de inteiros positivos distintos @math{k_1}, ..., @math{k_m}
tais que @math{@var{n} = k_1 + ... + k_m}.

Exemplos:

@c ===beg===
@c num_distinct_partitions (12);
@c num_distinct_partitions (12, list);
@c num_distinct_partitions (n);
@c ===end===
@example
(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
@end example

@end deffn

@anchor{num_partitions}
@deffn {Fun@value{cedilha}@~{a}o} num_partitions (@var{n})
@deffnx {Fun@value{cedilha}@~{a}o} num_partitions (@var{n}, list)

Retorna o n@'{u}mero das parti@value{cedilha}@~{o}es inteiras de @var{n}
quando @var{n} for um inteiro n@~{a}o negativo.
De outra forma, @code{num_partitions} retorna uma express@~{a}o substantiva.

@code{num_partitions(@var{n}, list)} retorna uma
lista do n@'{u}mero de parti@value{cedilha}@~{o}es inteiras de 1, 2, 3, ..., @var{n}.

Para um inteiro n@~{a}o negativo @var{n}, @code{num_partitions(@var{n})} @'{e} igual a
@code{cardinality(integer_partitions(@var{n}))}; todavia, @code{num_partitions} 
n@~{a}o constr@'{o}i atualmente o conjunto das parti@value{cedilha}@~{o}es, nesse sentido @code{num_partitions} @'{e} mais r@'{a}pida.

Exemplos:

@c ===beg===
@c num_partitions (5) = cardinality (integer_partitions (5));
@c num_partitions (8, list);
@c num_partitions (n);
@c ===end===
@example
(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
@end example

@end deffn



@anchor{partition_set}
@deffn {Fun@value{cedilha}@~{a}o} partition_set (@var{a}, @var{f})

Parti@value{cedilha}@~{o}es do conjunto @var{a} que satisfazem o predicado @var{f}.

@code{partition_set} retorna uma lista de dois conjuntos.
O primeiro conjunto compreende os elementos de @var{a} para os quais @var{f} avalia para @code{false},
e o segundo conjunto compreende quaisquer outros elementos de @var{a}.
@code{partition_set} n@~{a}o aplica @code{is} ao valor de retorno de @var{f}.

@code{partition_set} reclama se @var{a} n@~{a}o for um conjunto literal.

Veja tamb@'{e}m @code{subset}.

Exemplos:

@c ===beg===
@c partition_set ({2, 7, 1, 8, 2, 8}, evenp);
@c partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
@c ===end===
@example
(%i1) partition_set (@{2, 7, 1, 8, 2, 8@}, evenp);
(%o1)                   [@{1, 7@}, @{2, 8@}]
(%i2) partition_set (@{x, rat(y), rat(y) + z, 1@}, lambda ([x], ratp(x)));
(%o2)/R/              [@{1, x@}, @{y, y + z@}]
@end example
@end deffn

@anchor{permutations}
@deffn {Fun@value{cedilha}@~{a}o} permutations (@var{a})

Retorna um conjunto todas as permuta@value{cedilha}@~{o}es distintas dos elementos da 
lista ou do conjunto @var{a}. Cada permuta@value{cedilha}@~{a}o @'{e} uma lista, n@~{a}o um conjunto. 

Quando @var{a} for uma lista, elementos duplicados de @var{a} s@~{a}o inclu@'{i}dos
nas permuta@value{cedilha}@~{o}es.

@code{permutations} reclama se @var{a} n@~{a}o for um conjunto literal ou uma lista literal.

Veja tamb@'{e}m @code{random_permutation}.

Exemplos:

@c ===beg===
@c permutations ([a, a]);
@c permutations ([a, a, b]);
@c ===end===
@example
(%i1) permutations ([a, a]);
(%o1)                       @{[a, a]@}
(%i2) permutations ([a, a, b]);
(%o2)           @{[a, a, b], [a, b, a], [b, a, a]@}
@end example

@end deffn

@anchor{powerset}
@deffn {Fun@value{cedilha}@~{a}o} powerset (@var{a})
@deffnx {Fun@value{cedilha}@~{a}o} powerset (@var{a}, @var{n})

Retorna o conjunto de todos os dubconjuntos de @var{a}, ou um subconjunto de @var{a}.

@code{powerset(@var{a})} retorna o conjunto de todos os subconjuntos do conjunto @var{a}.
@code{powerset(@var{a})} tem @code{2^cardinality(@var{a})} elementos.

@code{powerset(@var{a}, @var{n})} retorna o conjunto de todos os subconjuntos de @var{a} que possuem 
cardinalidade @var{n}.

@code{powerset} reclama se @var{a} n@~{a}o for um conjunto literal,
ou se @var{n} n@~{a}o for um inteiro n@~{a}o negativo.

Exemplos:

@c ===beg===
@c powerset ({a, b, c});
@c powerset ({w, x, y, z}, 4);
@c powerset ({w, x, y, z}, 3);
@c powerset ({w, x, y, z}, 2);
@c powerset ({w, x, y, z}, 1);
@c powerset ({w, x, y, z}, 0);
@c ===end===
@example
(%i1) powerset (@{a, b, c@});
(%o1) @{@{@}, @{a@}, @{a, b@}, @{a, b, c@}, @{a, c@}, @{b@}, @{b, c@}, @{c@}@}
(%i2) powerset (@{w, x, y, z@}, 4);
(%o2)                    @{@{w, x, y, z@}@}
(%i3) powerset (@{w, x, y, z@}, 3);
(%o3)     @{@{w, x, y@}, @{w, x, z@}, @{w, y, z@}, @{x, y, z@}@}
(%i4) powerset (@{w, x, y, z@}, 2);
(%o4)   @{@{w, x@}, @{w, y@}, @{w, z@}, @{x, y@}, @{x, z@}, @{y, z@}@}
(%i5) powerset (@{w, x, y, z@}, 1);
(%o5)                 @{@{w@}, @{x@}, @{y@}, @{z@}@}
(%i6) powerset (@{w, x, y, z@}, 0);
(%o6)                         @{@{@}@}
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} random_permutation (@var{a})

Retorna uma permuta@value{cedilha}@~{a}o aleat@'{o}ria do conjunto ou da lista @var{a},
como constru@'{i}do pelo algor@'{i}timo de embaralhar desenvolvido por Knuth.

O valor de retorno @'{e} uma nova lista, que @'{e} diferente
da lista/conjunto original podendo inclusive ser a propria lista repetida.
Todavia, os elementos do argumento n@~{a}o s@~{a}o copiados.

Exemplos:

@c ===beg===
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ({x + 1, y + 2, z + 3});
@c random_permutation ({x + 1, y + 2, z + 3});
@c ===end===
@example
(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation (@{x + 1, y + 2, z + 3@});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation (@{x + 1, y + 2, z + 3@});
(%o4)                 [x + 1, y + 2, z + 3]
@end example

@end deffn

@anchor{rreduce}
@deffn {Fun@value{cedilha}@~{a}o} rreduce (@var{F}, @var{s})
@deffnx {Fun@value{cedilha}@~{a}o} rreduce (@var{F}, @var{s}, @var{s_@{n + 1@}})

Extende a fun@value{cedilha}@~{a}o de dois argumentos @var{F} para uma fun@value{cedilha}@~{a}o de @var{n} argumentos usando composi@value{cedilha}@~{a}o de fun@value{cedilha}@~{o}es,
onde @var{s} @'{e} uma lista.

@code{rreduce(@var{F}, @var{s})} retorna @code{F(s_1, ... F(s_@{n - 2@}, F(s_@{n - 1@}, s_n)))}.
Quando o argumetno opcional @var{s_@{n + 1@}} estiver presente,
o resultado @'{e} equivalente a @code{rreduce(@var{F}, endcons(@var{s_@{n + 1@}}, @var{s}))}.

A fun@value{cedilha}@~{a}o @var{F} @'{e} primeiro aplicada @`a
lista de elementos @i{mais @`a direita - rightmost}, da@'{i} o nome "rreduce". 

Veja tamb@'{e}m @code{lreduce}, @code{tree_reduce}, e @code{xreduce}.

Exemplos:

@code{rreduce} sem o argumento opcional.

@c ===beg===
@c rreduce (f, [1, 2, 3]);
@c rreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
@end example

@code{rreduce} com o argumetno opcional.

@c ===beg===
@c rreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
@end example

@code{rreduce} aplicada a operadores de dois argumentos internos ( definidos por padr@~{a}o) ao Maxima.
@code{/} @'{e} o operadro de divis@~{a}o.

@c ===beg===
@c rreduce ("^", args ({a, b, c, d}));
@c rreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) rreduce ("^", args (@{a, b, c, d@}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce ("/", args (@{a, b, c, d@}));
                               a c
(%o2)                          ---
                               b d
@end example

@end deffn

@anchor{setdifference}
@deffn {Fun@value{cedilha}@~{a}o}  setdifference (@var{a}, @var{b})

Retorna um conjunto contendo os elementos no conjunto @var{a} que
n@~{a}o est@~{a}ono conjunto @var{b}.

@code{setdifference} reclama se ou @var{a} ou @var{b} n@~{a}o for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c, x, y, z};
@c S_2 : {aa, bb, c, x, y, zz};
@c setdifference (S_1, S_2);
@c setdifference (S_2, S_1);
@c setdifference (S_1, S_1);
@c setdifference (S_1, {});
@c setdifference ({}, S_1);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, x, y, z@};
(%o1)                  @{a, b, c, x, y, z@}
(%i2) S_2 : @{aa, bb, c, x, y, zz@};
(%o2)                 @{aa, bb, c, x, y, zz@}
(%i3) setdifference (S_1, S_2);
(%o3)                       @{a, b, z@}
(%i4) setdifference (S_2, S_1);
(%o4)                     @{aa, bb, zz@}
(%i5) setdifference (S_1, S_1);
(%o5)                          @{@}
(%i6) setdifference (S_1, @{@});
(%o6)                  @{a, b, c, x, y, z@}
(%i7) setdifference (@{@}, S_1);
(%o7)                          @{@}
@end example

@end deffn

@anchor{setequalp}
@deffn {Fun@value{cedilha}@~{a}o} setequalp (@var{a}, @var{b})

Retorna @code{true} se os conjuntos @var{a} e @var{b} possuirem o mesmo n@'{u}mero de elementos
@c $SETEQUALP CALLS THE LISP Fun@value{cedilha}@~{a}o LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
e @code{is(@var{x} = @var{y})} for @code{true}
para @code{x} nos elementos de @var{a}
e @code{y} nos elementos de @var{b},
considerados na ordem determinada por @code{listify}.
De outra forma, @code{setequalp} retorna @code{false}.

Exemplos:

@c ===beg===
@c setequalp ({1, 2, 3}, {1, 2, 3});
@c setequalp ({a, b, c}, {1, 2, 3});
@c setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
@c ===end===
@example
(%i1) setequalp (@{1, 2, 3@}, @{1, 2, 3@});
(%o1)                         true
(%i2) setequalp (@{a, b, c@}, @{1, 2, 3@});
(%o2)                         false
(%i3) setequalp (@{x^2 - y^2@}, @{(x + y) * (x - y)@});
(%o3)                         false
@end example

@end deffn

@anchor{setify}
@deffn {Fun@value{cedilha}@~{a}o} setify (@var{a})

Constr@'{o}i um conjunto de elementos a partir da lista @var{a}. Elementos
duplicados da lista @var{a} s@~{a}o apagados e os elementos
s@~{a}o ordenados de acordo com o predicado @code{orderlessp}.

@code{setify} reclama se @var{a} n@~{a}o for uma lista literal.

Exemplos:

@c ===beg===
@c setify ([1, 2, 3, a, b, c]);
@c setify ([a, b, c, a, b, c]);
@c setify ([7, 13, 11, 1, 3, 9, 5]);
@c ===end===
@example
(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  @{1, 2, 3, a, b, c@}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       @{a, b, c@}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                @{1, 3, 5, 7, 9, 11, 13@}
@end example

@end deffn

@anchor{setp}
@deffn {Fun@value{cedilha}@~{a}o} setp (@var{a})

Retorna @code{true} se e somente se @var{a} for um conjunto na interpreta@value{cedilha}@~{a}o do Maxima.

@code{setp} retorna @code{true} para conjuntos n@~{a}o simplificados (isto @'{e}, conjuntos com elementos redundantes)
e tamb@'{e}m para conjuntos simplificados.

@c NOT SURE WE NEED TO MENTION THIS. OK FOR NOW
@code{setp} @'{e} equivalente @`a fun@value{cedilha}@~{a}o do Maxima
@code{setp(a) := not atom(a) and op(a) = 'set}.

Exemplos:

@c ===beg===
@c simp : false;
@c {a, a, a};
@c setp (%);
@c ===end===
@example
(%i1) simp : false;
(%o1)                         false
(%i2) @{a, a, a@};
(%o2)                       @{a, a, a@}
(%i3) setp (%);
(%o3)                         true
@end example

@end deffn

@anchor{set_partitions}
@deffn {Fun@value{cedilha}@~{a}o} set_partitions (@var{a})
@deffnx {Fun@value{cedilha}@~{a}o} set_partitions (@var{a}, @var{n})

Retorna o conjunto de todas as parti@value{cedilha}@~{o}es de @var{a}, ou um subconjunto daquele conjunto de parti@value{cedilha}@~{o}es.

@code{set_partitions(@var{a}, @var{n})} retorna um conjunto de todas as
decomposi@value{cedilha}@~{o}es de @var{a} em @var{n} subconjutnos disjuntos n@~{a}o vazios.

@code{set_partitions(@var{a})} retorna o conjunto de todas as parti@value{cedilha}@~{o}es.

@code{stirling2} retorna a cardinalidade de um conjuntode parti@value{cedilha}@~{o}es de um conjunto.

Um conjunto de conjuntos @math{P} @'{e} uma parti@value{cedilha}@~{a}o de um conjunto @math{S} quando

@enumerate
@item
cada elemento de @math{P} @'{e} um conjunto n@~{a}o vazio,
@item
elementos distintos de @math{P} s@~{a}o disjuntos,
@item
a uni@~{a}o dos elementos de @math{P} @'{e} igual a @math{S}.
@end enumerate

Exemplos:

O conjunto vazio @'{e} uma parti@value{cedilha}@~{a}o de si mesmo, as ondi@value{cedilha}@~{o}es 1 e 2 s@~{a}o "vaziamente" verdadeiras.

@c ===beg===
@c set_partitions ({});
@c ===end===
@example
(%i1) set_partitions (@{@});
(%o1)                         @{@{@}@}
@end example

A cardinalidade do conjunto de parti@value{cedilha}@~{o}es de um conjunto pode ser encontrada usando @code{stirling2}.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c cardinality(p) = stirling2 (6, 3);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
@end example

Cada elemento de @code{p} pode ter @var{n} = 3 elementos; vamos verificar.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (cardinality, p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          @{3@}
@end example

Finalmente, para cada elementos de @code{p}, a uni@~{a}o de seus elementos possivelmente ser@'{a} 
igua a @code{s}; novamente vamos comprovar.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (lambda ([x], apply (union, listify (x))), p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 @{@{0, 1, 2, 3, 4, 5@}@}
@end example
@end deffn

@anchor{some}
@deffn {Fun@value{cedilha}@~{a}o} some (@var{f}, @var{a})
@deffnx {Fun@value{cedilha}@~{a}o} some (@var{f}, @var{L_1}, ..., @var{L_n})

Retorna @code{true} se o predicado @var{f} for @code{true} para um ou mais argumentos dados.

Given one set as the second argument, 
@code{some(@var{f}, @var{s})} returns @code{true}
if @code{is(@var{f}(@var{a_i}))} returns @code{true} for one or more @var{a_i} in @var{s}.
@code{some} may or may not evaluate @var{f} for all @var{a_i} in @var{s}.
Since sets are unordered,
@code{some} may evaluate @code{@var{f}(@var{a_i})} in any order.

Dadas uma ou mais listas como argumentos,
@code{some(@var{f}, @var{L_1}, ..., @var{L_n})} retorna @code{true}
se @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} retornar @code{true} 
para um ou mais @var{x_1}, ..., @var{x_n} em @var{L_1}, ..., @var{L_n}, respectivamente.
@code{some} pode ou n@~{a}o avaliar 
@var{f} para algumas combina@value{cedilha}@~{o}es @var{x_1}, ..., @var{x_n}.
@code{some} avalia listas na ordem do @'{i}ndice de incremento.

Dado um conjunto vazio @code{@{@}} ou uma lista vazia @code{[]} como argumentos,
@code{some} retorna @code{false}.

Quando o sinalizador global @code{maperror} for @code{true}, todas as listas
@var{L_1}, ..., @var{L_n} devem ter obrigat@'{o}riamente comprimentos iguais.
Quando @code{maperror} for @code{false}, argumentos do tipo lista s@~{a}o
efetivamente truncados para o comprimento da menor lista. 

Retorna o valor de um predicado @var{f} o qual avalia (por meio de @code{is})
para alguma coisa outra que n@~{a}o @code{true} ou @code{false}
e s@~{a}o governados pelo sinalizador global @code{prederror}.
Quando @code{prederror} for @code{true},
tais valores s@~{a}o tratados como @code{false}.
Quando @code{prederror} for @code{false},
tais valores s@~{a}o tratados como @code{unknown} (desconhecidos).

Exemplos:

@code{some} aplicado a um conjunto simples.
O predicado @'{e} uma fun@value{cedilha}@~{a}o de um argumento.

@c ===beg===
@c some (integerp, {1, 2, 3, 4, 5, 6});
@c some (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) some (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) some (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         true
@end example

@code{some} aplicada a duas listas.
O predicado @'{e} uma fun@value{cedilha}@~{a}o de dois argumentos.

@c ===beg===
@c some ("=", [a, b, c], [a, b, c]);
@c some ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) some ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Retorna o valor do predicado @var{f} o qual avalia
para alguma coisa que n@~{a}o @code{true} ou @code{false}
e s@~{a}o governados atrav@'{e}s do sinalizador global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c prederror : true;
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
@end example
@end deffn

@anchor{stirling1}
@deffn {Fun@value{cedilha}@~{a}o} stirling1 (@var{n}, @var{m})

Representa o n@'{u}mero de Stirling de primeiro tipo.

Quando @var{n} e @var{m} forem n@~{a}o negativos 
inteiros, a magnitude de @code{stirling1 (@var{n}, @var{m})} @'{e} o n@'{u}mero de 
permuta@value{cedilha}@~{o}es de um conjunto com @var{n} elementos que possui @var{m} ciclos.
Para detalhes, veja Graham, Knuth e Patashnik @i{Concrete Mathematics}.
Maxima utiliza uma rela@value{cedilha}@~{a}o recursiva para definir @code{stirling1 (@var{n}, @var{m})} para
@var{m} menor que 0; @code{stirling1} n@~{a}o @'{e} definida para @var{n} menor que 0 e para argumetnos
n@~{a}o inteiros.

@code{stirling1} @'{e} uma fun@value{cedilha}@~{a}o de simplifica@value{cedilha}@~{a}o.
Maxima conhece as seguintes identidades:

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling1(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling1(n, n) = 1} (Ref. [1])
@item
@math{stirling1(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling1(n + 1, 0) = 0} (Ref. [1])
@item
@math{stirling1(n + 1, 1) = n!} (Ref. [1])
@item
@math{stirling1(n + 1, 2) = 2^n  - 1} (Ref. [1])
@end enumerate

Essas identidades s@~{a}o aplicadas quando os argumentos forem inteiros literais
ou s@'{i}mbolos declarados como inteiros, e o primeiro argumento for n@~{a}o negativo.
@code{stirling1} n@~{a}o simplififca para argumentos n@~{a}o inteiros.

Refer@^{e}ncias:

[1] Donald Knuth, @i{The Art of Computer Programming,}
terceira edi@value{cedilha}@~{a}o, Volume 1, Se@value{cedilha}@~{a}o 1.2.6, Equa@value{cedilha}@~{o}es 48, 49, e 50.

Exemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
@end example

@code{stirling1} n@~{a}o simplifica para argumentos n@~{a}o inteiros.

@c ===beg===
@c stirling1 (sqrt(2), sqrt(2));
@c ===end===
@example
(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
@end example

Maxima aplica identidades a @code{stirling1}.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n + 1, n);
@c stirling1 (n + 1, 1);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
@end example
@end deffn

@anchor{stirling2}
@deffn {Fun@value{cedilha}@~{a}o} stirling2 (@var{n}, @var{m})

Representa o n@'{u}mero de Stirling de segundo tipo.

Quando @var{n} e @var{m} forem inteiros
n@~{a}o negativos, @code{stirling2 (@var{n}, @var{m})} @'{e} o n@'{u}mero de maneiras atrav@'{e}s dos quais um conjunto com
cardinalidade @var{n} pode ser particionado em @var{m} subconjuntos disjuntos.
Maxima utiliza uma rela@value{cedilha}@~{a}o recursiva para definir @code{stirling2 (@var{n}, @var{m})} para
@var{m} menor que 0; @code{stirling2} @'{e} indefinida para @var{n} menor que 0 e para argumentos
n@~{a}o inteiros.

@code{stirling2} @'{e} uma fun@value{cedilha}@~{a}o de simplifica@value{cedilha}@~{a}o.
Maxima conhece as seguintes identidades.

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling2(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling2(n, n) = 1} (Ref. [1])
@item
@math{stirling2(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling2(n + 1, 1) = 1} (Ref. [1])
@item
@math{stirling2(n + 1, 2) = 2^n  - 1} (Ref. [1])
@item
@math{stirling2(n, 0) = kron_delta(n, 0)} (Ref. [2])
@item
@math{stirling2(n, m) = 0} when @math{m > n} (Ref. [2])
@item
@math{stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!}
onde @math{m} e @math{n} s@~{a}o inteiros, e @math{n} @'{e} n@~{a}o negativo. (Ref. [3])
@end enumerate

Essas identidades s@~{a}o aplicadas quando os argumentos forem inteiros literais
ou s@'{i}mbolos declarados como inteiros, e o primeiro argumento for n@~{a}o negativo.
@code{stirling2} n@~{a}o simplifica para argumentos n@~{a}o inteiros.

Refer@^{e}ncias:

[1] Donald Knuth. @i{The Art of Computer Programming},
terceira edi@value{cedilha}@~{a}o, Volume 1, Se@value{cedilha}@~{a}o 1.2.6, Equa@value{cedilha}@~{o}es 48, 49, e 50.

[2] Graham, Knuth, e Patashnik. @i{Concrete Mathematics}, Tabela 264.

[3] Abramowitz e Stegun. @i{Handbook of Mathematical Fun@value{cedilha}@~{a}os}, Se@value{cedilha}@~{a}o 24.1.4.

Exemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
@end example

@code{stirling2} n@~{a}o simplifica para argumentos n@~{a}o inteiros.

@c ===beg===
@c stirling2 (%pi, %pi);
@c ===end===
@example
(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
@end example

Maxima aplica identidades a @code{stirling2}.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n + 9, n + 8);
@c stirling2 (n + 1, 2);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
@end example
@end deffn

@anchor{subset}
@deffn {Fun@value{cedilha}@~{a}o} subset (@var{a}, @var{f})

Retorna o subconjuntode um conjunto @var{a} que satisfaz o predicado @var{f}. 

@code{subset} returns um conjunto which comprises the elements of @var{a}
for which @var{f} returns anything other than @code{false}.
@code{subset} does not apply @code{is} to the return value of @var{f}.

@code{subset} reclama se @var{a} n@~{a}o for um conjunto literal.

See also @code{partition_set}.

Exemplos:

@c ===beg===
@c subset ({1, 2, x, x + y, z, x + y + z}, atom);
@c subset ({1, 2, 7, 8, 9, 14}, evenp);
@c ===end===
@example
(%i1) subset (@{1, 2, x, x + y, z, x + y + z@}, atom);
(%o1)                     @{1, 2, x, z@}
(%i2) subset (@{1, 2, 7, 8, 9, 14@}, evenp);
(%o2)                      @{2, 8, 14@}
@end example

@end deffn

@anchor{subsetp}
@deffn {Fun@value{cedilha}@~{a}o} subsetp (@var{a}, @var{b})

Retorna @code{true} se e somente se o conjunto @var{a} for um subconjunto de @var{b}.

@code{subsetp} reclama se ou @var{a} ou @var{b} n@~{a}o forem um conjunto literal.

Exemplos:

@c ===beg===
@c subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
@c subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) subsetp (@{1, 2, 3@}, @{a, 1, b, 2, c, 3@});
(%o1)                         true
(%i2) subsetp (@{a, 1, b, 2, c, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example

@end deffn

@anchor{symmdifference}
@deffn {Fun@value{cedilha}@~{a}o} symmdifference (@var{a_1}, ..., @var{a_n})

Retorna a diferen@value{cedilha}a sim@'{e}trica, isto @'{e},
o conjunto dos elemetnos que ocorrem em exatamente um conjunto @var{a_k}.

Given two arguments, @code{symmdifference(@var{a}, @var{b})} is
the same as @code{union(setdifference(@var{a}, @var{b}), setdifference(@var{b}, @var{a}))}.

@code{symmdifference} reclama se any argument n@~{a}o for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c};
@c S_2 : {1, b, c};
@c S_3 : {a, b, z};
@c symmdifference ();
@c symmdifference (S_1);
@c symmdifference (S_1, S_2);
@c symmdifference (S_1, S_2, S_3);
@c symmdifference ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) S_2 : @{1, b, c@};
(%o2)                       @{1, b, c@}
(%i3) S_3 : @{a, b, z@};
(%o3)                       @{a, b, z@}
(%i4) symmdifference ();
(%o4)                          @{@}
(%i5) symmdifference (S_1);
(%o5)                       @{a, b, c@}
(%i6) symmdifference (S_1, S_2);
(%o6)                        @{1, a@}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                        @{1, z@}
(%i8) symmdifference (@{@}, S_1, S_2, S_3);
(%o8)                        @{1, z@}
@end example

@end deffn

@c TREE_REDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE
@anchor{tree_reduce}
@deffn {Fun@value{cedilha}@~{a}o} tree_reduce (@var{F}, @var{s})
@deffnx {Fun@value{cedilha}@~{a}o} tree_reduce (@var{F}, @var{s}, @var{s_0})

Extende a fun@value{cedilha}@~{a}o bin@'{a}ria @var{F} a uma fun@value{cedilha}@~{a}o en@'{a}ria atrav@'{e}s de composi@value{cedilha}@~{a}o,
onde @var{s} @'{e} um conjunto ou uma lista.

@code{tree_reduce} @'{e} equivalente ao seguinte:
Aplicar @var{F} a sucessivos pares de elementos
para formar uma nova lista @code{[@var{F}(@var{s_1}, @var{s_2}), @var{F}(@var{s_3}, @var{s_4}), ...]},
mantendo o elemento final inalterado caso haja um n@'{u}mero @'{i}mpar de elementos.
Repetindo ent@~{a}o o processo at@'{e} que a lista esteja reduzida a um elemento simples, o qual @'{e} o valor de retorno da fun@value{cedilha}@~{a}o.

Quando o argumento opcional @var{s_0} estiver presente,
o resultado @'{e} equivalente a @code{tree_reduce(@var{F}, cons(@var{s_0}, @var{s})}.

Para adi@value{cedilha}@~{o}es em ponto flutuante,
@code{tree_reduce} pode retornar uma soma que possui um menor ero de arredondamento
que @code{rreduce} ou @code{lreduce}.

Os elementos da lista @var{s} e os resultados parciais podem ser arranjados em uma @'{a}rvore bin@'{a}ria de profundidade m@'{i}nima,
da@'{i} o nome "tree_reduce".

Exemplos:

@code{tree_reduce} aplicada a uma lista com um n@'{u}mero par de elementos.

@c ===beg===
@c tree_reduce (f, [a, b, c, d]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
@end example

@code{tree_reduce} aplicada a uma lista com um n@'{u}mero @'{i}mpar de elementos.

@c ===beg===
@c tree_reduce (f, [a, b, c, d, e]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
@end example

@end deffn

@anchor{union}
@deffn {Fun@value{cedilha}@~{a}o} union (@var{a_1}, ..., @var{a_n})
Retorna a uni@~{a}o dos conjuntos de @var{a_1} a @var{a_n}. 

@code{union()} (sem argumentos) retorna o conjunto vazio.

@code{union} reclama se qualquer argumento n@~{a}o for um conjunto literal.

Exemplos:

@c ===beg===
@c S_1 : {a, b, c + d, %e};
@c S_2 : {%pi, %i, %e, c + d};
@c S_3 : {17, 29, 1729, %pi, %i};
@c union ();
@c union (S_1);
@c union (S_1, S_2);
@c union (S_1, S_2, S_3);
@c union ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c + d, %e@};
(%o1)                   @{%e, a, b, d + c@}
(%i2) S_2 : @{%pi, %i, %e, c + d@};
(%o2)                 @{%e, %i, %pi, d + c@}
(%i3) S_3 : @{17, 29, 1729, %pi, %i@};
(%o3)                @{17, 29, 1729, %i, %pi@}
(%i4) union ();
(%o4)                          @{@}
(%i5) union (S_1);
(%o5)                   @{%e, a, b, d + c@}
(%i6) union (S_1, S_2);
(%o6)              @{%e, %i, %pi, a, b, d + c@}
(%i7) union (S_1, S_2, S_3);
(%o7)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
(%i8) union (@{@}, S_1, S_2, S_3);
(%o8)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
@end example

@end deffn

@c XREDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE
@anchor{xreduce}
@deffn {Fun@value{cedilha}@~{a}o} xreduce (@var{F}, @var{s})
@deffnx {Fun@value{cedilha}@~{a}o} xreduce (@var{F}, @var{s}, @var{s_0})

Extendendo a fun@value{cedilha}@~{a}o @var{F} para uma fun@value{cedilha}@~{a}o en@'{a}ria por composi@value{cedilha}@~{a}o,
ou, se @var{F} j@'{a} for en@'{a}ria, aplica-se @var{F} a @var{s}.
Quando @var{F} n@~{a}o for en@'{a}ria, @code{xreduce} funciona da mesma forma que @code{lreduce}.
O argumento @var{s} @'{e} uma lista.

Fun@value{cedilha}@~{o}es sabidamente en@'{a}rias inclui
adi@value{cedilha}@~{a}o @code{+}, multiplica@value{cedilha}@~{a}o @code{*}, @code{and}, @code{or}, @code{max},
@code{min}, e @code{append}.
Fun@value{cedilha}@~{o}es podem tamb@'{e}m serem declaradas en@'{a}rias por meio de @code{declare(@var{F}, nary)}.
Para essas fun@value{cedilha}@~{o}es,
@'{e} esperado que @code{xreduce} seja mais r@'{a}pida que ou @code{rreduce} ou @code{lreduce}.

Quando o argumento opcional @var{s_0} estiver presente,
o resultado @'{e} equivalente a @code{xreduce(@var{s}, cons(@var{s_0}, @var{s}))}.

@c NOT SURE WHAT IS THE RELEVANCE OF THE FOLLOWING COMMENT
@c MAXIMA IS NEVER SO CAREFUL ABOUT FLOATING POINT ASSOCIATIVITY SO FAR AS I KNOW
Adi@value{cedilha}@~{o}es em ponto flutuante n@~{a}o s@~{a}o exatamente associativas; quando a associatividade ocorrer,
@code{xreduce} aplica a adi@value{cedilha}@~{a}o en@'{a}ria do Maxima quando @var{s} contiver n@'{u}meros em ponto flutuante.

Exemplos:

@code{xreduce} aplicada a uma fun@value{cedilha}@~{a}o sabidamente en@'{a}ria.
@code{F} @'{e} chamada uma vez, com todos os argumentos.

@c ===beg===
@c declare (F, nary);
@c F ([L]) := L;
@c xreduce (F, [a, b, c, d, e]);
@c ===end===
@example
(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[("[", simp), a], b], c], d], e]
@end example

@code{xreduce} aplicada a uma fun@value{cedilha}@~{a}o n@~{a}o sabidamente en@'{a}ria.
@code{G} @'{e} chamada muitas vezes, com dois argumentos de cada vez.

@c ===beg===
@c G ([L]) := L;
@c xreduce (G, [a, b, c, d, e]);
@c lreduce (G, [a, b, c, d, e]);
@c ===end===
@example
(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[("[", simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
@end example

@end deffn
