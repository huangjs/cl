<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html> 

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>CL-PPCRE - portable Perl-compatible regular expressions for Common Lisp</title>
  <style type="text/css">
  pre { padding:5px; background-color:#e0e0e0 }
  a.none { text-decoration: none; color:black }
  a { text-decoration: none; }
  a:visited { text-decoration: none; }
  a:active { text-decoration: underline; }
  a:hover { text-decoration: underline; }
  </style>
</head>

<body bgcolor=white>

<h2>CL-PPCRE - portable Perl-compatible regular expressions for Common Lisp</h2>

<blockquote>
<br>&nbsp;<br><h3>Abstract</h3>

CL-PPCRE is a portable regular expression library for Common Lisp
which has the following features:

<ul>

<li>It is <b>compatible with Perl</b>. (Well - as far as you can be compatible
with a language defined by its ever-changing
implementation. Currently, as of December 2002, CL-PPCRE is more
compatible with the regex semantics of Perl 5.8.0 than, say, Perl
5.6.1 is...) It even correctly parses and applies <a
href="http://www.oreilly.com/catalog/regex2/">Jeffrey Friedl's</a>
famous 6600-byte long RFC822 address pattern.

<li>It is <b>fast</b>. If compiled with <a
href="http://www.cons.org/cmucl/">CMUCL</a> it <a
href="#performance">outperforms</a> Perl's highly optimized regex engine (written
in C) which to my knowledge is faster than most other regex engines
around. If compiled with <a
href="http://clisp.sourceforge.net/">CLISP</a> it is still comparable
to CLISP's own regex implementation which is also written in
C.

<li>It is <b>portable</b>, i.e. the code aims to be strictly <a
href="http://www.lispworks.com/reference/HyperSpec/Front/index.htm">ANSI-compliant</a>. If
you encounter any deviations this is an error and should be
reported to <a
href="mailto:edi@agharta.de">edi@agharta.de</a>. CL-PPCRE has been
successfully tested with the following Common Lisp implementations:

<ul>

<li><a href="http://www.cons.org/cmucl/">CMUCL</a> 18d+ on Gentoo Linux 1.1a

<li><a href="http://sbcl.sourceforge.net/">SBCL</a> 0.7.10 on Gentoo Linux 1.1a

<li><a href="http://www.scieneer.com/scl/">Scieneer Common Lisp</a> 1.1.1 evaluation on Gentoo Linux 1.1a

<li><a href="http://clisp.sourceforge.net/">CLISP</a> 2.30 on Gentoo Linux 1.1a

<li><a href="http://www.lispworks.com/">Xanalys LispWorks</a> 4.2.7 professional on Gentoo Linux 1.1a

<li><a href="http://www.franz.com/products/allegrocl/">Allegro Common Lisp</a> 6.2 trial on Gentoo Linux 1.1a

<li><a href="http://clisp.sourceforge.net/">CLISP</a> 2.29 on Windows XP pro

<li><a href="http://www.lispworks.com/">Xanalys LispWorks</a> 4.2.7 professional on Windows XP pro

<li><a href="http://openmcl.clozure.com/">OpenMCL</a> 0.13.1 on MacOS X 10.2.2

<li><a href="http://www.digitool.com/">Macintosh Common Lisp</a> 4.3 demo on MacOS 9.1

</ul>

I'll gladly <a href="mailto:edi@agharta.de">accept patches</a> to make
it work on <a href="http://www.cormanlisp.com/">Corman Lisp</a>, <a
href="http://ecls.sourceforge.net/">ECL</a>, or <a
href="http://www.gnu.org/software/gcl/gcl.html">GCL</a>.  If you
succeed in using CL-PPCRE on other platforms please <a
href="mailto:edi@agharta.de">let me know</a>.  <br> (Note that the
tests mainly made sure that the package compiled without errors and
that the <a href="#test">test suite</a> - which compiles about 1,500
regex strings into scanners and applies these to target strings with
the <a href="#scan"><code>SCAN</code></a> function - yields the
expected results. Other functions like <a
href="#split"><code>SPLIT</code></a>, <a
href="#all-matches"><code>ALL-MATCHES</code></a>, <a
href="#regex-replace"><code>REGEX-REPLACE</code></a>, <a
href="#regex-apropos"><code>REGEX-APROPOS</code></a>, or <a
href="#do-scans">the <code>DO</code>-macros</a> have only been tested
on CMUCL and LispWorks which were my main development platforms.)

<li>It is <b>thread-safe</b>. Although the code uses closures
extensively, no state which dynamically changes during the scanning
process is stored in the lexical environments of the closures, so it
should be safe to use CL-PPCRE in a multi-threaded program. Tests with
LispWorks and Scieneer Common Lisp seem to confirm this.

<li>It comes with <b>convenient features</b> like a <a
href="#split"><code>SPLIT</code></a> function, a couple of <a
href="#do-scans"><code>DO</code>-like loop constructs</a>, and a <a
href="#regex-apropos"><code>regex-based APROPOS feature</code></a>
similar to the one found in <a
href="http://www.gnu.org/software/emacs/emacs.html">Emacs</a>.

<li>In addition to specifying regular expressions as strings like in
Perl you can also use <a
href="#create-scanner2"><b>S-expressions</b></a> which obviously is
more Lisp-y.

<li>Is it is fully <b>documented</b> so I might have a chance to
understand my own code in about six months... :)

<li>It comes with a <a
href="http://www.opensource.org/licenses/bsd-license.php"><b>BSD-style
license</b></a> so you can basically do with it whatever you want.

</ul>

</blockquote>

<br>&nbsp;<br><h3><a class=none name="contents">Contents</a></h3>
<ol>
  <li><a href="#howto">How to use CL-PPCRE</a>
  <ol>
    <li><a href="#create-scanner1"><code>create-scanner</code></a> (for Perl regex strings)
    <li><a href="#create-scanner2"><code>create-scanner</code></a> (for parse trees)
    <li><a href="#scan"><code>scan</code></a>
    <li><a href="#scan-to-strings"><code>scan-to-strings</code></a>
    <li><a href="#do-scans"><code>do-scans</code></a>
    <li><a href="#do-matches"><code>do-matches</code></a>
    <li><a href="#do-matches-as-strings"><code>do-matches-as-strings</code></a>
    <li><a href="#all-matches"><code>all-matches</code></a>
    <li><a href="#all-matches-as-strings"><code>all-matches-as-strings</code></a>
    <li><a href="#split"><code>split</code></a>
    <li><a href="#regex-replace"><code>regex-replace</code></a>
    <li><a href="#regex-replace-all"><code>regex-replace-all</code></a>
    <li><a href="#regex-apropos"><code>regex-apropos</code></a>
    <li><a href="#regex-apropos-list"><code>regex-apropos-list</code></a>
  </ol>
  <li><a href="#install">Download and installation</a>
  <li><a href="#test">Testing CL-PPCRE</a>
  <li><a href="#perl">Compatibility with Perl</a>
    <ol>
      <li><a href="#empty">Empty strings instead of <code>undef</code> in <code>$1</code>, <code>$2</code>, etc.</a>
      <li><a href="#scope">Strange scoping of embedded modifiers</a>
      <li><a href="#inconsistent">Inconsistent capturing of <code>$1</code>, <code>$2</code>, etc.</a>
      <li><a href="#lookaround">Captured groups not available outside of look-aheads and look-behinds</a>
      <li><a href="#order">Alternations don't always work from left to right</a>
      <li><a href="#mac"><code>&quot;\r&quot;</code> doesn't work with MCL</a>
      <li><a href="#alpha">What about <code>&quot;\w&quot;</code>?</a>
    </ol>
  <li><a href="#performance">Performance</a>
    <ol>
      <li><a href="#bench">Benchmarking</a>
      <li><a href="#other">Other performance issues</a>
    </ol>
  <li><a href="#bugs">Bugs and problems</a>
  <ol>
    <li><a href="#stack">Stack overflow</a>
    <li><a href="#strange">Strange-looking output of <code>regex-apropos</code> with CLISP</a>
  </ol>
  <li><a href="#remarks">Remarks</a>
  <li><a href="#ack">Acknowledgements</a>
</ol>

<br>&nbsp;<br><h3><a class=none name="howto">How to use CL-PPCRE</a></h3>

CL-PPCRE exports the following symbols:

<p><br>[Function]
<br><a class=none name="create-scanner1"><b>create-scanner</b> <i>string <tt>&amp;key</tt> case-insensitive-mode multi-line-mode single-line-mode extended-mode</i> =&gt; <i>scanner</i></a>

<blockquote><br> Accepts a string which is a regular expression in
Perl syntax and returns a closure which will scan strings for this
regular expression. The mode keyboard arguments are equivalent to the
embedded <code>&quot;imsx&quot;</code> modifiers in Perl.
<p>
The function accepts most of the regex syntax of Perl 5 as described
in <a
href="http://www.perldoc.com/perl5.8.0/pod/perlre.html"><code>man
perlre</code></a> including extended features like non-greedy
repetitions, positive and negative look-ahead and look-behind
assertions, &quot;standalone&quot; subexpressions, and conditional
subpatterns. The following Perl features are (currently) <b>not</b>
supported:

<ul>

<li><code>(?{ code })</code> and <code>(??{ code })</code> because
they obviously don't make sense in Lisp.

<li><code>\N{name}</code> (named characters), <code>\x{263a}</code>
(wide hex characters), <code>\l</code>, <code>\u</code>,
<code>\L</code>, <code>\U</code>, <code>\E</code>, and <code>\Q</code>
because they're actually not part of Perl's regex syntax and
(honestly) because I was too lazy. I might implement <code>\Q</code>
in the future but don't hold your breath.

<li><code>\pP</code> and <code>\PP</code> (named properties),
<code>\X</code> (extended Unicode), and <code>\C</code> (single
character). But you can of course use all characters
supported by your CL implementation.

<li>Posix character classes like <code>[[:alpha]]</code>. I
<em>might</em> add this in the future.

<li><code>\G</code> for Perl's <code>pos()</code> because we don't have it.

</ul>

Note, however, that <code>\t</code>, <code>\n</code>, <code>\r</code>,
<code>\f</code>, <code>\a</code>, <code>\e</code>, <code>\033</code>
(octal character codes), <code>\x1B</code> (hexadecimal character
codes), <code>\c[</code> (control characters), <code>\w</code>,
<code>\W</code>, <code>\s</code>, <code>\S</code>, <code>\d</code>,
<code>\D</code>, <code>\b</code>, <code>\B</code>, <code>\A</code>,
<code>\Z</code>, and <code>\z</code> <b>are</b> supported.
<p>
The keyword arguments are just for your
convenience. You can always use embedded modifiers like
<code>&quot;(?i-s)&quot;</code> instead.</blockquote>




<p><br>[Function]
<br><a class=none name="create-scanner2"><b>create-scanner</b> <i>parse-tree <tt>&amp;key</tt> case-insensitive-mode multi-line-mode single-line-mode extended-mode</i> =&gt; <i>scanner</i></a>
<blockquote><br>
This is similar to <a
href="#create-scanner1"><code>create-scanner</code></a> above but
accepts a <em>parse tree</em> as its first argument. A parse tree is an S-expression
conforming to the following syntax:

<ul>

<li>Every string and character is a parse tree and is treated
<em>literally</em> as a part of the regular expression,
i.e. parentheses, brackets, asterisks and such aren't special.

<li>The symbol <code>:VOID</code> is equivalent to the empty string.

<li>The symbol <code>:EVERYTHING</code> is equivalent to Perl's dot,
i.e it matches everything (except maybe a newline character depending
on the mode).

<li>The symbols <code>:WORD-BOUNDARY</code> and
<code>:NON-WORD-BOUNDARY</code> are equivalent to Perl's
<code>&quot;\b&quot;</code> and <code>&quot;\B&quot;</code>.

<li>The symbols <code>:DIGIT-CLASS</code>,
<code>:NON-DIGIT-CLASS</code>, <code>:WORD-CHAR-CLASS</code>,
<code>:NON-WORD-CHAR-CLASS</code>,
<code>:WHITESPACE-CHAR-CLASS</code>, and
<code>:NON-WHITESPACE-CHAR-CLASS</code> are equivalent to Perl's
<em>special character classes</em> <code>&quot;\d&quot;</code>,
<code>&quot;\D&quot;</code>, <code>&quot;\w&quot;</code>,
<code>&quot;\W&quot;</code>, <code>&quot;\s&quot;</code>, and
<code>&quot;\S&quot;</code> respectively.

<li>The symbols <code>:START-ANCHOR</code>, <code>:END-ANCHOR</code>,
<code>:MODELESS-START-ANCHOR</code>,
<code>:MODELESS-END-ANCHOR</code>, and
<code>:MODELESS-END-ANCHOR-NO-NEWLINE</code> are equivalent to Perl's
<code>&quot;^&quot;</code>, <code>&quot;$&quot;</code>,
<code>&quot;\A&quot;</code>, <code>&quot;\Z&quot;</code>, and
<code>&quot;\z&quot;</code> respectively.

<li>The symbols <code>:CASE-INSENSITIVE-P</code>,
<code>:CASE-SENSITIVE-P</code>, <code>:MULTI-LINE-MODE-P</code>,
<code>:NOT-MULTI-LINE-MODE-P</code>, <code>:SINGLE-LINE-MODE-P</code>,
and <code>:NOT-SINGLE-LINE-MODE-P</code> are equivalent to Perl's
<em>embedded modifiers</em> <code>&quot;(?i)&quot;</code>,
<code>&quot;(?-i)&quot;</code>, <code>&quot;(?m)&quot;</code>,
<code>&quot;(?-m)&quot;</code>, <code>&quot;(?s)&quot;</code>, and
<code>&quot;(?-s)&quot;</code>. As usual, changes applied to modes are
kept local to the innermost enclosing grouping or clustering
construct.

<li><code>(:FLAGS {&lt;modifier&gt;}*)</code> where
<code>&lt;modifier&gt;</code> is one of the modifier symbols from
above is used to group modifier symbols. The modifiers are applied
from left to right. (This construct is obviously redundant. It is only
there because it's used by the parser.)

<li><code>(:SEQUENCE {&lt;<i>parse-tree</i>&gt;}*)</code> means a
sequence of parse trees, i.e. the parse trees must match one after
another. Example: <code>(:SEQUENCE #\f #\o #\o)</code> is equivalent
to the parse tree <code>&quot;foo&quot;</code>.

<li><code>(:GROUP {&lt;<i>parse-tree</i>&gt;}*)</code> is like
<code>:SEQUENCE</code> but changes applied to modifier flags (see
above) are kept local to the parse trees enclosed by this
construct. Think of it as the S-expression variant of Perl's
<code>&quot;(?:&lt;<i>pattern</i>&gt;)&quot;</code> construct.

<li><code>(:ALTERNATION {&lt;<i>parse-tree</i>&gt;}*)</code> means an
alternation of parse trees, i.e. one of the parse trees must
match. Example: <code>(:ALTERNATION #\b #\a #\z)</code> is equivalent
to the Perl regex string <code>&quot;b|a|z&quot;</code>.

<li><code>(:BRANCH &lt;<i>test</i>&gt;
&lt;<i>parse-tree</i>&gt;)</code> is for conditional regular
expressions. <code>&lt;<i>test</i>&gt;</code> is either a number which
stands for a register or a parse tree which is a look-ahead or
look-behind assertion. See the entry for
<code>(?(&lt;<i>condition</i>&gt;)&lt;<i>yes-pattern</i>&gt;|&lt;<i>no-pattern</i>&gt;)</code>
in <a
href="http://www.perldoc.com/perl5.8.0/pod/perlre.html#Extended-Patterns"><code>man
perlre</code></a> for the semantics of this construct. If
<code>&lt;<i>parse-tree</i>&gt;</code> is an alternation is
<em>must</em> enclose exactly one or two parse trees where the second
one (if present) will be treated as the &quot;no-pattern&quot; - in
all other cases <code>&lt;<i>parse-tree</i>&gt;</code> will be treated
as the &quot;yes-pattern&quot;.

<li><code>(:POSITIVE-LOOKAHEAD|:NEGATIVE-LOOKAHEAD|:POSITIVE-LOOKBEHIND|:NEGATIVE-LOOKBEHIND
&lt;<i>parse-tree</i>&gt;)</code> should be pretty obvious...

<li><code>(:GREEDY-REPETITION|:NON-GREEDY-REPETITION
&lt;<i>min</i>&gt; &lt;<i>max</i>&gt;
&lt;<i>parse-tree</i>&gt;)</code> where
<code>&lt;<i>min</i>&gt;</code> is a non-negative integer and
<code>&lt;<i>max</i>&gt;</code> is either a non-negative integer not
smaller than <code>&lt;<i>min</i>&gt;</code> or <code>NIL</code> will
result in a regular expression which tries to match
<code>&lt;<i>parse-tree</i>&gt;</code> at least
<code>&lt;<i>min</i>&gt;</code> times and at most
<code>&lt;<i>max</i>&gt;</code> times (or as often as possible if
<code>&lt;<i>max</i>&gt;</code> is <code>NIL</code>). So, e.g.,
<code>(:NON-GREEDY-REPETITION 0 1 &quot;ab&quot;)</code> is equivalent
to the Perl regex string <code>&quot;(?:ab)??&quot;</code>.

<li><code>(:STANDALONE &lt;<i>parse-tree</i>&gt;)</code> is an
&quot;independent&quot; subexpression, i.e. <code>(:STANDALONE
&quot;bar&quot;)</code> is equivalent to the Perl regex string
<code>&quot;(?>bar)&quot;</code>.

<li><code>(:REGISTER &lt;<i>parse-tree</i>&gt;)</code> is a capturing
register group. As usual, registers are counted from left to right
beginning with 1.

<li><code>(:BACK-REFERENCE &lt;<i>number</i>&gt;)</code> where
<code>&lt;<i>number</i>&gt;</code> is a positive integer is a back-reference to a
register group.

<li><code>(:CHAR-CLASS|:INVERTED-CHAR-CLASS
{&lt;<i>item</i>&gt;}*)</code> where <code>&lt;<i>item</i>&gt;</code>
is either a character, a <em>character range</em>, or a symbol for a
special character class (see above) will be translated into a (one
character wide) character class. A <em>character range</em> looks like
<code>(:RANGE &lt;<i>char1</i>&gt; &lt;<i>char2</i>&gt;)</code> where
<code>&lt;<i>char1</i>&gt;</code> and
<code>&lt;<i>char2</i>&gt;</code> are characters such that
<code>(CHAR&lt;= &lt;<i>char1</i>&gt; &lt;<i>char2</i>&gt;)</code> is
true. Example: <code>(:INVERTED-CHAR-CLASS #\a (:RANGE #\D #\G) :DIGIT-CLASS)</code> is equivalent to the Perl regex string <code>&quot;[^aD-G\d]&quot;</code>.

</ul>

Because <code>CREATE-SCANNER</code> is defined as a generic function
which dispatches on its first argument there's a certain ambiguity:
Although strings are valid parse trees they will be interpreted as
Perl regex strings when given to <code>CREATE-SCANNER</code>. To
circumvent this you can always use the equivalent parse tree <code>(:GROUP
&lt;<i>string</i>&gt;)</code> instead.
<p>
Note that currently <code>create-scanner</code> doesn't always check
for the well-formedness of its first argument, i.e. you are expected
to provide <em>correct</em> parse trees. This will most likely change in
future releases.
<p>
The usage of the keyword argument <code>extended-mode</code> obviously
doesn't make sense if <code>CREATE-SCANNER</code> is applied to parse
trees and will signal an error.
<p>
If you want to find out how parse trees are related to Perl regex
strings you should play around with
<code>CL-PPCRE::PARSE-STRING</code> - a function which converts Perl
regex strings to parse trees. Here are some examples:

<pre>
* (cl-ppcre::parse-string "(ab)*")
(:GREEDY-REPETITION 0 NIL (:REGISTER (:SEQUENCE #\a #\b)))

* (cl-ppcre::parse-string "(a(b))")
(:REGISTER (:SEQUENCE #\a (:REGISTER #\b)))

* (cl-ppcre::parse-string "(?:abc){3,5}")
(:GREEDY-REPETITION 3 5 (:GROUP (:SEQUENCE #\a (:SEQUENCE #\b #\c))))
;; (:GREEDY-REPETITION 3 5 (:SEQUENCE #\a #\b #\c)) would also be OK,
;; or even (:GREEDY-REPETITION 3 5 "abc")

* (cl-ppcre::parse-string "a(?i)b(?-i)c")
(:SEQUENCE #\a
 (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P)
  (:SEQUENCE #\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\c))))
;; same as (:SEQUENCE #\a :CASE-INSENSITIVE-P #\b :CASE-SENSITIVE-P #\c)

* (cl-ppcre::parse-string "(?=a)b")
(:SEQUENCE (:POSITIVE-LOOKAHEAD #\a) #\b)
</pre></blockquote>

<p><br>
<b>For the rest of this section </b><code><i>regex</i></code><b> can always be a string (which is interpreted as a Perl regular expression), a parse tree, or a scanner created by </b><code>CREATE-SCANNER</code><b>. The </b><code><i>start</i></code><b> and </b><code><i>end</i></code><b> keyword parameters are always used as in </b><a href="#scan"><code>SCAN</code></a><b>.</b>




<p><br>[Function]
<br><a class=none name="scan"><b>scan</b> <i>regex target-string <tt>&amp;key</tt> start end</i> =&gt; <i>match-start, match-end, reg-starts, reg-ends</i></a>

<blockquote><br>
Searches the string <code><i>target-string</i></code> from
<code><i>start</i></code> (which defaults to 0) to
<code><i>end</i></code> (which default to the length of
<code><i>target-string</i></code>) and tries to match
<code><i>regex</i></code>. On success returns four values - the start
of the match, the end of the match, and two arrays denoting the
beginnings and ends of register matches. On failure returns
<code>NIL</code>.  <code><i>target-string</i></code> will be coerced to a
simple string if it isn't one already.
<p>
<code>SCAN</code> acts as if the part of <code><i>target-string</i></code> between <code><i>start</i></code> and <code><i>end</i></code> were a standalone string, i.e. look-aheads and look-behinds can't look beyond these boundaries.
<p>
Examples:
<pre>
* (cl-ppcre:scan "(a)*b" "xaaabd")
1
5
#(3)
#(4)

* (cl-ppcre:scan "(a)*b" "xaaabd" :start 1)
1
5
#(3)
#(4)

* (cl-ppcre:scan "(a)*b" "xaaabd" :start 2)
2
5
#(3)
#(4)

* (cl-ppcre:scan "(a)*b" "xaaabd" :end 4)
NIL

* (cl-ppcre:scan '(:GREEDY-REPETITION 0 NIL #\b) "bbbc")
0
3
#()
#()

* (cl-ppcre:scan '(:GREEDY-REPETITION 4 6 #\b) "bbbc")
NIL

* (let ((s (cl-ppcre:create-scanner "(([a-c])+)x")))
    (cl-ppcre:scan s "abcxy"))
0
4
#(0 2)
#(3 3)
</pre></blockquote>



<p><br>[Function]
<br><a class=none name="scan-to-strings"><b>scan-to-strings</b> <i>regex target-string <tt>&amp;key</tt> start end</i> =&gt; <i>match, regs</i></a>

<blockquote><br>
Like <a href="#scan"><code>SCAN</code></a> but returns substrings of
<code><i>target-string</i></code> instead of positions, i.e. this
function returns two values on success: the whole match as a string
plus an array of substrings (or <code>NIL</code>s) corresponding to
the matched registers.
<p>
Examples:
<pre>
* (cl-ppcre:scan-to-strings "[^b]*b" "aaabd")
"aaab"
#()

* (cl-ppcre:scan-to-strings "([^b])*b" "aaabd")
"aaab"
#("a")

* (cl-ppcre:scan-to-strings "(([^b])*)b" "aaabd")
"aaab"
#("aaa" "a")
</pre></blockquote>




<p><br>[Macro]
<br><a class=none name="do-scans"><b>do-scans</b> <i>(match-start match-end reg-starts reg-ends regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
A macro which iterates over <code><i>target-string</i></code> and
tries to match <code><i>regex</i></code> as often as possible
evaluating <code><i>statement*</i></code> with
<code><i>match-start</i></code>, <code><i>match-end</i></code>,
<code><i>reg-starts</i></code>, and <code><i>reg-ends</i></code> bound
to the four return values of each match (see <a
href="#scan"><code>SCAN</code></a>) in turn. After the last match,
returns <code><i>result-form</i></code> if provided or
<code>NIL</code> otherwise. An implicit block named <code>NIL</code>
surrounds <code>DO-SCANS</code>; <code>RETURN</code> may be used to
terminate the loop immediately. If <code><i>regex</i></code> matches
an empty string the scan is continued one position behind this match.
<p>
This is the most general macro to iterate over all matches in a target
string. See the source code of <a
href="#do-matches"><code>DO-MATCHES</code></a>, <a
href="#all-matches"><code>ALL-MATCHES</code></a>, <a
href="#split"><code>SPLIT</code></a>, or <a
href="#regex-replace-all"><code>REGEX-REPLACE-ALL</code></a> for examples of its
usage.</blockquote>




<p><br>[Macro]
<br><a class=none name="do-matches"><b>do-matches</b> <i>(match-start match-end regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
Like <a href="#do-scans"><code>DO-SCANS</code></a> but doesn't bind
variables to the register arrays.
<p>Example:
<pre>
* (defun foo (regex target-string &amp;key (start 0) (end (length target-string)))
    (let ((sum 0))
      (cl-ppcre:do-matches (s e regex target-string nil :start start :end end)
        (incf sum (- e s)))
      (format t "~,2F% of the string was inside of a match~%"
                ;; note: doesn't check for division by zero
                (float (* 100 (/ sum (- end start)))))))

FOO

* (foo "a" "abcabcabc")
33.33% of the string was inside of a match
NIL
* (foo "aa|b" "aacabcbbc")
55.56% of the string was inside of a match
NIL
</pre></blockquote>




<p><br>[Macro]
<br><a class=none name="do-matches-as-strings"><b>do-matches-as-strings</b> <i>(match-var regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
Like <a href="#do-matches"><code>DO-MATCHES</code></a> but binds
<code><i>match-var</i></code> to the substring of
<code><i>target-string</i></code> corresponding to each match in turn.
<p>
Example:
<pre>
* (defun crossfoot (target-string &amp;key (start 0) (end (length target-string)))
    (let ((sum 0))
      (cl-ppcre:do-matches-as-strings (m :digit-class
                                         target-string nil
                                         :start start :end end)
        (incf sum (parse-integer m)))
      (if (< sum 10)
        sum
        (crossfoot (format nil "~A" sum)))))

CROSSFOOT

* (crossfoot "bar")
0

* (crossfoot "a3x")
3

* (crossfoot "12345")
6
</pre></blockquote>




<p><br>[Function]
<br><a class=none name="all-matches"><b>all-matches</b> <i>regex target-string <tt>&amp;key</tt> start end</i> =&gt; <i>list</i></a>

<blockquote><br>
Returns a list containing the start and end positions of all matches
of <code><i>regex</i></code> against
<code><i>target-string</i></code>, i.e. if there are <code>N</code>
matches the list contains <code>(* 2 N)</code> elements. If
<code><i>regex</i></code> matches an empty string the scan is
continued one position behind this match.
<p>
Examples:
<pre>
* (cl-ppcre:all-matches "a" "foo bar baz")
(5 6 9 10)

* (cl-ppcre:all-matches "\\w*" "foo bar baz")
(0 3 3 3 4 7 7 7 8 11 11 11)
</pre></blockquote>




<p><br>[Function]
<br><a class=none name="all-matches-as-strings"><b>all-matches-as-strings</b> <i>regex target-string <tt>&amp;key</tt> start end</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a href="#all-matches"><code>ALL-MATCHES</code></a> but
returns a list of substrings instead.
<p>
Examples:
<pre>
* (cl-ppcre:all-matches-as-strings "a" "foo bar baz")
("a" "a")

* (cl-ppcre:all-matches-as-strings "\\w*" "foo bar baz")
("foo" "" "bar" "" "baz" "")
</pre></blockquote>






<p><br>[Function]
<br><a class=none name="split"><b>split</b> <i>regex target-string <tt>&amp;key</tt> start end with-registers-p</i> =&gt; <i>list</i></a>

<blockquote><br>
Matches <code><i>regex</i></code> against
<code><i>target-string</i></code> as often as possible and returns a
list of the substrings between the matches. If
<code><i>with-registers-p</i></code> is true, substrings corresponding
to matched registers (if any) are inserted into the list as well. If
<code><i>regex</i></code> matches an empty string the scan is
continued one position behind this match. Empty matches at the start
or the end of the target string are always left out.
<p>
Examples:
<pre>
* (cl-ppcre:split "\\s+" "foo   bar baz
frob")
("foo" "bar" "baz" "frob")

* (cl-ppcre:split "\\s*" "foo bar   baz")
("f" "o" "o" "b" "a" "r" "b" "a" "z")

* (cl-ppcre:split "(\\s+)" "foo bar   baz")
("foo" "bar" "baz")

* (cl-ppcre:split "(\\s+)" "foo bar   baz" :with-registers-p t)
("foo" " " "bar" "   " "baz")

* (cl-ppcre:split "(\\s)(\\s*)" "foo bar   baz" :with-registers-p t)
("foo" " " "" "bar" " " "  " "baz")
</pre></blockquote>





<p><br>[Function]
<br><a class=none name="regex-replace"><b>regex-replace</b> <i>regex target-string replacement <tt>&amp;key</tt> start end preserve-case</i> =&gt; <i>list</i></a>

<blockquote><br> Try to match <code><i>target-string</i></code>
between <code><i>start</i></code> and <code><i>end</i></code> against
<code><i>regex</i></code> and replace the first match with the string
<code><i>replacement</i></code>. <code><i>replacement</i></code> can
contain the special substrings <code>&quot;\&amp;&quot;</code> for the
whole match, <code>&quot;\`&quot;</code> for the part of
<code><i>target-string</i></code> before the match,
<code>&quot;\'&quot;</code> for the part of
<code><i>target-string</i></code> after the match,
<code>&quot;\N&quot;</code> or <code>&quot;\{N}&quot;</code> for the
<code>N</code>th register where <code>N</code> is a positive
integer. If <code><i>preserve-case</i></code> is true (default is
<code>NIL</code>), the replacement will try to preserve the case (all
upper case, all lower case, or capitalized) of the match. The result
will always be a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_f.htm#fresh">fresh</a>
string, even if <code><i>regex</i></code> doesn't match.
<p>
Examples:

<pre>
* (cl-ppcre:regex-replace "fo+" "foo bar" "frob")
"frob bar"

* (cl-ppcre:regex-replace "fo+" "FOO bar" "frob")
"FOO bar"

* (cl-ppcre:regex-replace "(?i)fo+" "FOO bar" "frob")
"frob bar"

* (cl-ppcre:regex-replace "(?i)fo+" "FOO bar" "frob" :preserve-case t)
"FROB bar"

* (cl-ppcre:regex-replace "(?i)fo+" "Foo bar" "frob" :preserve-case t)
"Frob bar"

* (cl-ppcre:regex-replace "bar" "foo bar baz" "[frob (was '\\&' between '\\`' and '\\'')]")
"foo [frob (was 'bar' between 'foo ' and ' baz')] baz"
</pre></blockquote>





<p><br>[Function]
<br><a class=none name="regex-replace-all"><b>regex-replace-all</b> <i>regex target-string replacement <tt>&amp;key</tt> start end preserve-case</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a href="#regex-replace"><code>REGEX-REPLACE</code></a> but replaces all matches.
<p>
Examples:

<pre>
* (cl-ppcre:regex-replace-all "(?i)fo+" "foo Fooo FOOOO bar" "frob" :preserve-case t)
"frob Frob FROB bar"

* (cl-ppcre:regex-replace-all "(?i)f(o+)" "foo Fooo FOOOO bar" "fr\\1b" :preserve-case t)
"froob Frooob FROOOOB bar"
</pre></blockquote>




<p><br>[Function]
<br><a class=none name="regex-apropos"><b>regex-apropos</b> <i>regex <tt>&amp;optional</tt> packages <tt>&amp;key</tt> case-insensitive</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_apropo.htm"><code>APROPOS</code></a>
but searches for interned symbols which match the regular expression
<code><i>regex</i></code>. The output is implementation-dependent. If
<code><i>case-insensitive</i></code> is true (which is the default)
and <code><i>regex</i></code> isn't already a scanner, a
case-insensitive scanner is used.
<p>
Here are examples for CMUCL:

<pre>
* *package*
#&lt;The COMMON-LISP-USER package, 16/21 internal, 0/9 external&gt;

* (defun foo (n &amp;optional (k 0)) (+ 3 n k))
FOO

* (defparameter foo "bar")
FOO

* (defparameter |foobar| 42)
|foobar|

* (defparameter fooboo 43)
FOOBOO

* (defclass frobar () ())
#&lt;STANDARD-CLASS FROBAR {4874E625}&gt;

* (cl-ppcre:regex-apropos "foo(?:bar)?")
FOO [variable] value: "bar"
    [compiled function] (N &amp;OPTIONAL (K 0))
FOOBOO [variable] value: 43
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "(?:foo|fro)bar")
PCL::|COMMON-LISP-USER::FROBAR class predicate| [compiled closure]
FROBAR [class] #&lt;STANDARD-CLASS FROBAR {4874E625}&gt;
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "(?:foo|fro)bar" 'cl-user)
FROBAR [class] #&lt;STANDARD-CLASS FROBAR {4874E625}&gt;
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "(?:foo|fro)bar" '(pcl ext))
PCL::|COMMON-LISP-USER::FROBAR class predicate| [compiled closure]

* (cl-ppcre:regex-apropos "foo")
FOO [variable] value: "bar"
    [compiled function] (N &amp;OPTIONAL (K 0))
FOOBOO [variable] value: 43
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "foo" nil :case-insensitive nil)
|foobar| [variable] value: 42
</pre></blockquote>




<p><br>[Function]
<br><a class=none name="regex-apropos-list"><b>regex-apropos-list</b> <i>regex <tt>&amp;optional</tt> packages <tt>&amp;key</tt> upcase</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_apropo.htm"><code>APROPOS-LIST</code></a>
but searches for interned symbols which match the regular expression
<code><i>regex</i></code>. If <code><i>case-insensitive</i></code> is
true (which is the default) and <code><i>regex</i></code> isn't
already a scanner, a case-insensitive scanner is used.
<p>
Example (continued from above):

<pre>
* (cl-ppcre:regex-apropos-list "foo(?:bar)?")
(|foobar| FOOBOO FOO)
</pre></blockquote>



<br>&nbsp;<br><h3><a name="install" class=none>Download and installation</a></h3>

CL-PPCRE together with this documentation can be downloaded from <a href="http://weitz.de/files/cl-ppcre.tgz">http://weitz.de/files/cl-ppcre.tgz</a>.
<p>
CL-PPCRE comes with a simple system definition for <a href="http://www.cliki.net/mk-defsystem">MK:DEFSYSTEM</a> so you can either adapt it to your needs or just unpack the archive and from within the CL-PPCRE directory start your Lisp image and evaluate the form <code>(mk:compile-system &quot;cl-ppcre&quot;)</code> which should compile and load the whole system.
<p>
If for the some reason you don't want to use MK:DEFSYSTEM you can also get away with something like this:

<pre>
(loop for name in '("packages" "specials" "util" "lexer"
                    "parser" "regex-class" "convert" "optimize"
                    "closures" "repetition-closures" "scanner" "api")
      do (compile-file (make-pathname :name name
                                      :type "lisp"))
         (load name))
</pre>

Note that on CL implementations which use the Python compiler (i.e. CMUCL, SBCL, SCL) you can concatenate the compiled object files to create one single object file which you can load afterwards:

<pre>
cat {packages,specials,util,lexer,parser,regex-class,convert,optimize,closures,repetition-closures,scanner,api}.x86f > cl-ppcre.x86f
</pre>

(Replace &quot;.<code>x86f</code>&quot; with the correct suffix for your platform.)


<br>&nbsp;<br><h3><a name="test" class=none>Testing CL-PPCRE</a></h3>

CL-PPCRE comes with a comprehensive test suite most of which is stolen from the <a href="http://www.pcre.org/">PCRE</a> library. You can use it like this:

<pre>
* (mk:compile-system "cl-ppcre-test")
; Loading #p"/home/edi/cl-ppcre/cl-ppcre.system".
; Loading #p"/home/edi/cl-ppcre/packages.x86f".
; Loading #p"/home/edi/cl-ppcre/specials.x86f".
; Loading #p"/home/edi/cl-ppcre/util.x86f".
; Loading #p"/home/edi/cl-ppcre/lexer.x86f".
; Loading #p"/home/edi/cl-ppcre/parser.x86f".
; Loading #p"/home/edi/cl-ppcre/regex-class.x86f".
; Loading #p"/home/edi/cl-ppcre/convert.x86f".
; Loading #p"/home/edi/cl-ppcre/optimize.x86f".
; Loading #p"/home/edi/cl-ppcre/closures.x86f".
; Loading #p"/home/edi/cl-ppcre/repetition-closures.x86f".
; Loading #p"/home/edi/cl-ppcre/scanner.x86f".
; Loading #p"/home/edi/cl-ppcre/api.x86f".
; Loading #p"/home/edi/cl-ppcre/ppcre-tests.x86f".
NIL

* (load "testdata")
T

* (cl-ppcre-test:test)

;; ....
;; (a list of <a href="#perl">incompatibilities with Perl</a>)
</pre>

With LispWorks and SCL you can also call <code>CL-PPCRE-TEST:TEST</code> with a keyword argument argument <code>THREADED</code> which - in addition to the usual tests - will also check whether the scanners created by CL-PPCRE are thread-safe.
<p>
Note that the file <code>testdata.lisp</code> provided with CL-PPCRE was created on a Linux system with Perl 5.8.0. You can (and you <em>should</em> if you're on Mac OS or Windows) create your own <code>testdata.lisp</code> with the Perl script <code>perltest.pl</code>:

<pre>
edi@bird:~/cl-ppcre &gt; perl perltest.pl &lt; testinput &gt; testdata.lisp
</pre>

Of course you can also create your own tests - the format accepted by <code>perltest.pl</code> should be rather clear from looking at the file <code>testinput</code>. Note that the target strings are wrapped in double quotes and then fed to Perl's <code>eval</code> so you can use ugly Perl constructs like, say, <code>a@{['b' x 10]}c</code> which will result in the target string <code>&quot;abbbbbbbbbbc&quot;</code>.

<br>&nbsp;<br><h3><a name="perl" class=none>Compatibility with Perl</a></h3>

Depending on your Perl version you might encounter a couple of small incompatibilities with Perl most of which aren't due to CL-PPCRE:

<h4><a name="empty" class=none>Empty strings instead of <code>undef</code> in <code>$1</code>, <code>$2</code>, etc.</a></h4>

(Cf. case #629 of <a href="#test"><code>testdata.lisp</code></a>.) This is <a href="http://groups.google.com/groups?threadm=87u1kw8hfr.fsf%40dyn164.dbdmedia.de">a bug</a> in Perl 5.6.1 and earlier which has been fixed in 5.8.0.

<h4><a name="scope" class=none>Strange scoping of embedded modifiers</a></h4>

(Cf. case #430 of <a href="#test"><code>testdata.lisp</code></a>.) This is <a href="http://groups.google.com/groups?threadm=871y80dpqh.fsf%40bird.agharta.de">a bug</a> in Perl 5.6.1 and earlier which has been fixed in 5.8.0.

<h4><a name="inconsistent" class=none>Inconsistent capturing of <code>$1</code>, <code>$2</code>, etc.</a></h4>

(Cf. case #662 of <a href="#test"><code>testdata.lisp</code></a>.) This is <a href="http://bugs6.perl.org/rt2/Ticket/Display.html?id=18708">a bug</a> in Perl which hasn't been fixed yet.

<h4><a name="lookaround" class=none>Captured groups not available outside of look-aheads and look-behinds</a></h4>

(Cf. case #1439 of <a href="#test"><code>testdata.lisp</code></a>.) Well, OK, this ain't a Perl bug. I just can't quite understand why captured groups should only be seen within the scope of a look-ahead or look-behind. For the moment, CL-PPCRE and Perl agree to disagree... :)

<h4><a name="order" class=none>Alternations don't always work from left to right</a></h4>

(Cf. case #790 of <a href="#test"><code>testdata.lisp</code></a>.) I also think this a Perl bug but I currently have lost the drive to report it.

<h4><a name="mac" class=none><code>&quot;\r&quot;</code> doesn't work with MCL</a></h4>

(Cf. case #9 of <a href="#test"><code>testdata.lisp</code></a>.) For some strange reason that I don't understand MCL translates <code>#\Return</code> to <code>(CODE-CHAR 10)</code> while MacPerl translates <code>&quot;\r&quot;</code> to <code>(CODE-CHAR 13)</code>. Hmmm...

<h4><a name="alpha" class=none>What about <code>&quot;\w&quot;</code>?</a></h4>

CL-PPCRE uses <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_alphan.htm"><code>ALPHANUMERICP</code></a> to decide whether a character matches Perl's <code>&quot;\w&quot;</code>, so depending on your CL implementation you might encounter differences between Perl and CL-PPCRE when matching non-ASCII characters.

<br>&nbsp;<br><h3><a name="performance" class=none>Performance</a></h3>

<h4><a name="bench" class=none>Benchmarking</a></h4>

The <a href="">CL-PPCRE test suite</a> can also be used for benchmarking purposes: If you call <code>perltest.pl</code> with a command line argument it will be interpreted as the number of seconds each test should run. Perl will time its tests accordingly and create output which, when fed to <code>CL-PPCRE-TEST:TEST</code>, will result in a benchmark. Here's an example:

<pre>
edi@bird:~/cl-ppcre > echo &quot;/((a{0,5}){0,5})*[c]/
aaaaaaaaaaaac

/((a{0,5})*)*[c]/
aaaaaaaaaaaac&quot; | perl perltest.pl .5 > timedata.lisp
1
2

edi@bird:~/cl-ppcre > cmucl -quiet
; Loading #p"/home/edi/.cmucl-init".

* (mk:compile-system "cl-ppcre-test")
; Loading #p"/home/edi/cl-ppcre/cl-ppcre.system".
; Loading #p"/home/edi/cl-ppcre/packages.x86f".
; Loading #p"/home/edi/cl-ppcre/specials.x86f".
; Loading #p"/home/edi/cl-ppcre/util.x86f".
; Loading #p"/home/edi/cl-ppcre/lexer.x86f".
; Loading #p"/home/edi/cl-ppcre/parser.x86f".
; Loading #p"/home/edi/cl-ppcre/regex-class.x86f".
; Loading #p"/home/edi/cl-ppcre/convert.x86f".
; Loading #p"/home/edi/cl-ppcre/optimize.x86f".
; Loading #p"/home/edi/cl-ppcre/closures.x86f".
; Loading #p"/home/edi/cl-ppcre/repetition-closures.x86f".
; Loading #p"/home/edi/cl-ppcre/scanner.x86f".
; Loading #p"/home/edi/cl-ppcre/api.x86f".
; Loading #p"/home/edi/cl-ppcre/ppcre-tests.x86f".
NIL

* (load "timedata")
T

* (cl-ppcre-test:test)
   1: 0.5559 (1000000 repetitions, Perl: 4.5330 seconds, CL-PPCRE: 2.5200 seconds)
   2: 0.4573 (1000000 repetitions, Perl: 4.5922 seconds, CL-PPCRE: 2.1000 seconds)
NIL
</pre>

We gave two test cases to <code>perltest.pl</code> and asked it to repeat those tests often enough so that it takes at least 0.5 seconds to run each of them. In both cases, CMUCL was about twice as fast as Perl.
<p>
Here are some more benchmarks (done with Perl 5.6.1 and CMUCL 18d+):
<p>

<table border=1>
<tr><td><b>Test case</b></td><td><b>Repetitions</b></td><td><b>Perl (sec)</b></td><td><b>CL-PPCRE (sec)</b></td><td><b>Ratio CL-PPCRE/Perl</b></td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(.)*/s</code></td><td align=right>100000</td><td align=right>0.1394</td><td align=right>0.0700</td><td align=right>0.5022</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(.)*/s</code></td><td align=right>100000</td><td align=right>0.1628</td><td align=right>0.0600</td><td align=right>0.3685</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(.)*/s</code></td><td align=right>100000</td><td align=right>0.5071</td><td align=right>0.0600</td><td align=right>0.1183</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(.)*/s</code></td><td align=right>10000</td><td align=right>0.3902</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /.*/</code></td><td align=right>100000</td><td align=right>0.1520</td><td align=right>0.0800</td><td align=right>0.5262</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /.*/</code></td><td align=right>100000</td><td align=right>0.3786</td><td align=right>0.5400</td><td align=right>1.4263</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /.*/</code></td><td align=right>10000</td><td align=right>0.2709</td><td align=right>0.5100</td><td align=right>1.8826</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /.*/</code></td><td align=right>1000</td><td align=right>0.2734</td><td align=right>0.5100</td><td align=right>1.8656</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /.*/s</code></td><td align=right>100000</td><td align=right>0.1320</td><td align=right>0.0300</td><td align=right>0.2274</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /.*/s</code></td><td align=right>100000</td><td align=right>0.1634</td><td align=right>0.0300</td><td align=right>0.1836</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /.*/s</code></td><td align=right>100000</td><td align=right>0.5304</td><td align=right>0.0300</td><td align=right>0.0566</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /.*/s</code></td><td align=right>10000</td><td align=right>0.3966</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /x*/</code></td><td align=right>100000</td><td align=right>0.1507</td><td align=right>0.0900</td><td align=right>0.5970</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /x*/</code></td><td align=right>100000</td><td align=right>0.3782</td><td align=right>0.6300</td><td align=right>1.6658</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /x*/</code></td><td align=right>10000</td><td align=right>0.2730</td><td align=right>0.6000</td><td align=right>2.1981</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /x*/</code></td><td align=right>1000</td><td align=right>0.2708</td><td align=right>0.5900</td><td align=right>2.1790</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /[xy]*/</code></td><td align=right>100000</td><td align=right>0.2637</td><td align=right>0.1500</td><td align=right>0.5688</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /[xy]*/</code></td><td align=right>10000</td><td align=right>0.1449</td><td align=right>0.1200</td><td align=right>0.8282</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /[xy]*/</code></td><td align=right>1000</td><td align=right>0.1344</td><td align=right>0.1100</td><td align=right>0.8185</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /[xy]*/</code></td><td align=right>100</td><td align=right>0.1355</td><td align=right>0.1200</td><td align=right>0.8857</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(.)*/</code></td><td align=right>100000</td><td align=right>0.1523</td><td align=right>0.1100</td><td align=right>0.7220</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(.)*/</code></td><td align=right>100000</td><td align=right>0.3735</td><td align=right>0.5700</td><td align=right>1.5262</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(.)*/</code></td><td align=right>10000</td><td align=right>0.2735</td><td align=right>0.5100</td><td align=right>1.8647</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(.)*/</code></td><td align=right>1000</td><td align=right>0.2598</td><td align=right>0.5000</td><td align=right>1.9242</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(x)*/</code></td><td align=right>100000</td><td align=right>0.1565</td><td align=right>0.1300</td><td align=right>0.8307</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(x)*/</code></td><td align=right>100000</td><td align=right>0.3783</td><td align=right>0.6600</td><td align=right>1.7446</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(x)*/</code></td><td align=right>10000</td><td align=right>0.2720</td><td align=right>0.6000</td><td align=right>2.2055</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(x)*/</code></td><td align=right>1000</td><td align=right>0.2725</td><td align=right>0.6000</td><td align=right>2.2020</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(y|x)*/</code></td><td align=right>10000</td><td align=right>0.2411</td><td align=right>0.1000</td><td align=right>0.4147</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(y|x)*/</code></td><td align=right>1000</td><td align=right>0.2313</td><td align=right>0.0900</td><td align=right>0.3891</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(y|x)*/</code></td><td align=right>100</td><td align=right>0.2336</td><td align=right>0.0900</td><td align=right>0.3852</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(y|x)*/</code></td><td align=right>10</td><td align=right>0.4165</td><td align=right>0.0900</td><td align=right>0.2161</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /([xy])*/</code></td><td align=right>100000</td><td align=right>0.2678</td><td align=right>0.1800</td><td align=right>0.6721</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /([xy])*/</code></td><td align=right>10000</td><td align=right>0.1459</td><td align=right>0.1200</td><td align=right>0.8227</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /([xy])*/</code></td><td align=right>1000</td><td align=right>0.1372</td><td align=right>0.1100</td><td align=right>0.8017</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /([xy])*/</code></td><td align=right>100</td><td align=right>0.1358</td><td align=right>0.1100</td><td align=right>0.8098</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /((x){2})*/</code></td><td align=right>10000</td><td align=right>0.1073</td><td align=right>0.0400</td><td align=right>0.3727</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /((x){2})*/</code></td><td align=right>10000</td><td align=right>0.9146</td><td align=right>0.2400</td><td align=right>0.2624</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /((x){2})*/</code></td><td align=right>1000</td><td align=right>0.9020</td><td align=right>0.2300</td><td align=right>0.2550</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /((x){2})*/</code></td><td align=right>100</td><td align=right>0.8983</td><td align=right>0.2300</td><td align=right>0.2560</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}FOOBARBAZ" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2829</td><td align=right>0.2300</td><td align=right>0.8129</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}FOOBARBAZ" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1859</td><td align=right>0.1700</td><td align=right>0.9143</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}FOOBARBAZ" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>1000</td><td align=right>0.1420</td><td align=right>0.1700</td><td align=right>1.1968</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>1000000</td><td align=right>0.9196</td><td align=right>0.4600</td><td align=right>0.5002</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2166</td><td align=right>0.2500</td><td align=right>1.1542</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1465</td><td align=right>0.2300</td><td align=right>1.5696</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}FOOBARBAZ" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2917</td><td align=right>0.2600</td><td align=right>0.8915</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}FOOBARBAZ" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1811</td><td align=right>0.1800</td><td align=right>0.9942</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}FOOBARBAZ" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>1000</td><td align=right>0.1424</td><td align=right>0.1600</td><td align=right>1.1233</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>1000000</td><td align=right>0.9154</td><td align=right>0.7400</td><td align=right>0.8083</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2170</td><td align=right>0.2800</td><td align=right>1.2901</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1497</td><td align=right>0.2300</td><td align=right>1.5360</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}FOOBARBAZ" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.4359</td><td align=right>0.1500</td><td align=right>0.3441</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}FOOBARBAZ" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>1000</td><td align=right>0.5456</td><td align=right>0.1500</td><td align=right>0.2749</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}FOOBARBAZ" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>10</td><td align=right>0.2039</td><td align=right>0.0600</td><td align=right>0.2943</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>1000000</td><td align=right>0.9311</td><td align=right>0.7400</td><td align=right>0.7947</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2162</td><td align=right>0.2700</td><td align=right>1.2489</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1488</td><td align=right>0.2300</td><td align=right>1.5455</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /[a-z]*FOOBARBAZ/i</code></td><td align=right>1000</td><td align=right>0.1555</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /[a-z]*FOOBARBAZ/i</code></td><td align=right>10</td><td align=right>0.1441</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /[a-z]*FOOBARBAZ/i</code></td><td align=right>10</td><td align=right>13.7150</td><td align=right>0.0100</td><td align=right>0.0007</td></tr>

</table>

<p>
As you might have noticed, Perl shines if it can reduce significant parts of the matching process to cases where it can advance through the target string one character at a time. This leads to C code where you can very efficiently test and increment a pointer into a string in a tight loop and can hardly be beaten with CL. In almost all other cases, the CMUCL/CL-PPCRE combination is usually faster than Perl - sometimes a lot faster.
<p>
Note that Perl as well as CL-PPCRE keep the rightmost matches in
registers - keep that in mind if you benchmark against other regex
implementations. Also note that <code>CL-PPCRE-TEST:TEST</code>
automatically skips test cases where Perl and CL-PPCRE don't agree.

<h4><a name="other" class=none>Other performance issues</a></h4>

While the scanners created by CL-PPCRE are pretty fast, the process which creates scanners from Perl regex strings and parse trees is currently rather inefficient and conses a lot. It is recommended that you store and re-use scanners if possible. The <code>DO-</code>macros will do this for you automatically.
<p>
Of course, the usual rules for creating efficient regular expressions apply to CL-PPCRE as well although it can optimize a couple of cases itself. The most important rule is probably that you shouldn't use capturing groups if you don't need the captured information, i.e. use <code>&quot;(?:a|b)*&quot;</code> instead of <code>&quot;(a|b)*&quot;</code> if you don't need to refer to the register. (In fact, in this particular case CL-PPCRE will be able to optimize away the register group, but it won't if you replace <code>&quot;a|b&quot;</code> with, say, <code>&quot;a|bc&quot;</code>.)
<p>
If you're really concerned with performance you can optimize the scanners for (special) character classes a little bit if you don't plan to use the whole character set of your CL implementation: Change the value of <code>+REGEX-CHAR-CODE-LIMIT+</code> in the file <code>util.lisp</code> <em>before</em> compiling CL-PPCRE. This might make sense with, e.g., LispWorks, AllegroCL, or CLISP where <a href="http://www.lispworks.com/reference/HyperSpec/Body/v_char_c.htm"><code>CHAR-CODE-LIMIT</code></a> is as high as 65536.
<p>
Another thing to consider is that, for performance reasons, CL-PPCRE assumes that most of the target strings you're trying to match are <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_smp_st.htm">simple strings</a> and coerces non-simple strings to simple strings before scanning them. If you plan on working with non-simple strings mostly you might consider modifying the CL-PPCRE source code. This is easy: Change all occurences of <code>SCHAR</code> to <code>CHAR</code> and remove the parts in <code>api.lisp</code> where the coercion takes place - that's all.

<br>&nbsp;<br><h3><a name="bugs" class=none>Bugs and problems</a></h3>

<h4><a name="stack" class=none>Stack overflow</a></h4>

CL-PPCRE can optimize away a lot of unnecessary backtracking but
sometimes this simple isn't possible. With complicated regular
expressions and long strings this might lead to stack overflows
depending on your machine and your CL implementation.
<p>
Here's one example with CLISP:

<pre>
[1]> (defun target (n) (concatenate 'string (make-string n :initial-element #\a) "b"))
TARGET

[2]> (cl-ppcre:scan "a*" (target 1000))
0 ;
1000 ;
#() ;
#()

[3]> (cl-ppcre:scan "(?:a|b)*" (target 1000))
0 ;
1001 ;
#() ;
#()

[4]> (cl-ppcre:scan "(a|b)*" (target 1000))
0 ;
1001 ;
#(1000) ;
#(1001)

[5]> (cl-ppcre:scan "(a|b)*" (target 10000))
0 ;
10001 ;
#(10000) ;
#(10001)

[6]> (cl-ppcre:scan "(a|b)*" (target 100000))
0 ;
100001 ;
#(100000) ;
#(100001)

[7]> (cl-ppcre:scan "(a|b)*" (target 1000000))
0 ;
1000001 ;
#(1000000) ;
#(1000001)

;; No problem until now - but...

[8]> (cl-ppcre:scan "(a|)*" (target 100000))
*** - Lisp stack overflow. RESET

[9]> (cl-ppcre:scan "(a|)*" (target 3200))
*** - Lisp stack overflow. RESET
</pre>

<p>
With CMUCL the situation is better and worse at the same time. It will
take a lot longer until CMUCL gives up but if it gives up the whole
Lisp image will silently die (at least on my machine):

<pre>
* (defun target (n) (concatenate 'string (make-string n :initial-element #\a) "b"))
TARGET

* (cl-ppcre:scan "(a|)*" (target 3200))
0
3200
#(3200)
#(3200)

* (cl-ppcre:scan "(a|)*" (target 10000))
0
10000
#(10000)
#(10000)

* (cl-ppcre:scan "(a|)*" (target 100000))
0
100000
#(100000)
#(100000)

* (cl-ppcre:scan "(a|)*" (target 1000000))
0
1000000
#(1000000)
#(1000000)

;; No problem until now - but...

* (cl-ppcre:scan "(a|)*" (target 10000000))
edi@bird:~ &gt;
</pre>

This behaviour can be changed with <em>very</em> conservative optimization settings but that'll make CL-PPCRE crawl compared to Perl.

<p>
You might want to compare this to the way Perl handles the same situation. It might lie to you:

<pre>
edi@bird:~ > perl -le '$_="a" x 32766 . "b"; /(a|)*/; print $1'

edi@bird:~ > perl -le '$_="a" x 32767 . "b"; /(a|)*/; print $1'
a
</pre>

Or it might warn you before it's lying to you:
<pre>
edi@bird:~ > perl -lwe '$_="a" x 32767 . "b"; /(a|)*/; print $1'
Complex regular subexpression recursion limit (32766) exceeded at -e line 1.
a
</pre>

Or it might simply die:
<pre>
edi@bird:~ > /opt/perl-5.8/bin/perl -lwe '$_="a" x 32767 . "b"; /(a|)*/; print $1'
Segmentation fault
</pre>

Your mileage may vary, of course...


<h4><a name="strange" class=none>Strange-looking output of <code>regex-apropos</code> with CLISP</a></h4>

This isn't really a problem of CL-PPCRE but of <a href="http://article.gmane.org/gmane.lisp.clisp.general/1206">CLISP's (lack of) pretty printing support</a>.

<br>&nbsp;<br><h3><a class=none name="remarks">Remarks</a></h3>

The sample output from CMUCL and CLISP has been slightly edited to increase readability.
<p>
All test cases and benchmarks in this document where performed on an IBM Thinkpad T23 laptop (Pentium&nbsp;III 1.2&nbsp;GHz, 768&nbsp;MB&nbsp;RAM) running <a href="http://www.gentoo.org/">Gentoo Linux</a> 1.1a.

<br>&nbsp;<br><h3><a class=none name="ack">Acknowledgements</a></h3>

Although I didn't use their code I was heavily inspired by looking at
the Scheme/CL regex implementations of <a
href="http://www.ccs.neu.edu/home/dorai/pregexp/pregexp.html">Dorai
Sitaram</a> and <a
href="http://www.geocities.com/mparker762/clawk#regex">Michael
Parker</a>. Also, the nice folks from CMUCL's <a
href="http://www.cons.org/cmucl/support.html">mailing list</a> as well
as the output of Perl's <code>use re &quot;debug&quot;</code> pragma
have been very helpful in optimizing the scanners created by CL-PPCRE.

<p>
Thanks to the guys at &quot;Caf&eacute; Ol&eacute;&quot; in Hamburg
where I wrote most of the code and thanks to my wife for lending me
her PowerBook to test CL-PPCRE with MCL and OpenMCL.

<p>
$Header: /usr/local/cvsrep/cl-ppcre/doc/index.html,v 1.1.1.1 2002/12/20 10:10:44 edi Exp $
<p><a href="http://weitz.de/index.html">BACK TO MY HOMEPAGE</a>

<p><hr>
<a HREF="http://www.anybrowser.org/campaign/"><img SRC="../pics/compmon.gif" ALT="viewable with any browser" WIDTH="256" HEIGHT="46" BORDER="1" ALIGN="left"></a>
<a HREF="http://validator.w3.org/check/referer"><img SRC="../pics/validate40.gif" ALT="valid HTML 4.0" WIDTH="88" HEIGHT="31" BORDER="1" ALIGN="right"></a>

</body>
</html>