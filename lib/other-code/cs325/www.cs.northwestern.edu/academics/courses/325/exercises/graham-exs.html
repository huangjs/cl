<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<HEAD>
   <TITLE>Graham Exercises</TITLE>
<link href="../styles/cs325.css" rel="stylesheet" type="text/css">
</HEAD>
<BODY>
<DIV ID="logo">
<A CLASS="plain" HREF="../index.html" target=_top>
<IMG SRC="../images/cs325logo.gif" ALT="CS 325 Logo" BORDER="0"></A>
</DIV>
<DIV ID="banner">Exercises from Graham</DIV>

<P>Below are exercises, often modified or extended, from Graham.</P>

<ul>
  <li>Do not send exercises not listed.</li>
  <li>Read the comments for an exercise before doing it.</li>
  <li>Use the exercise name given as the Subject of your email.</li>
  <li>One exercise per email! Note: in a few cases, such as Chapter 2, several 
    exercises are asked for as a group. In that case, and only in that case, include 
    the entire group in one email.</li>
  <li>Send only your code. Don't send Graham's code. </li>
  <li>Send only code that has been <a href="critic.html">tested and critiqued</a>.</li>
</ul>

<P>Warning: many of the exercises suggest <U>terrible</U> names for the functions 
  to define. Use the function names given in the exercise descriptions below. 
  These are the names used by <a href="critic.html#bug">the Lisp Unit tests</a>
	defined in <a href="../programs/exercise-tests.lisp"><code>exercise-tests.lisp</code></a>.
  When inventing your own names, ignore Graham's examples and use <A HREF="../readings/names.html">the 
  principles of good naming</A>. </P>

<P>Define subfunctions when they make the code clearer. Some students think &quot;define 
  a function&quot; means &quot;define just one function.&quot; That's not true 
  in Lisp or anywhere else. It's just how programmers describe the API (application 
  program interface) for a function that other code will call.</P>
  
<HR>


<P>Quick jump to notes for Chapter <A HREF="#ch2">2</A>,
<A HREF="#ch3">3</A>, <A HREF="#ch4">4</A>, <A HREF="#chap-5">5</A>,
<A HREF="#ch6">6</A>, <A HREF="#ch7">7</A>, <A HREF="#ch8">8</A>,
<A HREF="#ch9">9</A>, <A HREF="#ch10">10</A>, <A HREF="#ch11">11</A>,
<A HREF="#ch12">12</A></P>


<HR>


<H2><A NAME="ch2"></A>Chapter 2</H2>

<h3>Exercise Name: <tt>Ex 2-4+7+8+9</tt></h3>

<P>Function names: <code>greater</code>, <code>has-list-p,</code> <code>print-dots</code>, 
  <code>get-a-count</code>, <code>summit</code></P>

<P>Send the code for exercises 4, 7, 8, and 9 in
one email, with the Subject line above.</P>

<P>Even though the instructions say to use only what you've seen so far, use <code>cond</code> 
  rather than <code>if</code>, where appropriate.</P>

<HR>

<H2><A NAME="ch3"></A>Chapter 3</H2>

<h3>Exercise name: <tt>Ex 3-2</tt></h3>

<P>Function names: <code>stable-union</code>,
<code>stable-intersection</code>, <code>stable-set-difference</code></P>

<P>Names like <code>new-xxx</code> are always a bad idea. "New" says nothing 
  about what the function does. And how long can something stay "new?" 
  The term "stable" is used in computer science 
  to refer to sorting algorithms that don't mess up the order of elements any 
  more than they have to. Common Lisp provides two sorting functions: <code>sort</code> 
  and <code>stable-sort</code> to capture this difference.</P>

<P>Define stable versions of the three major
set functions: union, intersection, and difference.
These should work like the built-in versions (see Graham's glossary), 
but items in the result
should have the same relative ordering they have in <code>l1</code>,
if any, or in <code>l2</code>, if any. Don't worry about handling
keyword arguments.</P>

<P>Avoid redundant code. Avoid needless CONSing or list scanning.</P>

<h3>Exercise name: <tt>Ex 3-3</tt></h3>

<P>Function name: <code>occurrences</code> (yes, that is how you spell it)</P>

<P>It's very inefficient to do this by creating a new list of count pairs every 
  time you count a new element. Instead, keep a list of <code>(<em>item . count</em>)</code> 
  pairs, initially empty. For each element in the input list, update this list 
  of pairs, where updating means incrementing the counter in the appropriate pair, 
  if one exists, otherwise adding a new pair.</P>

<P>To increment the count, use <code>(INCF (CDR <em>pair</em>))</code> which increments 
  the <code>CDR</code> of a pair.</P>

<P>NOTE: it's OK to get "a little too long" from the Lisp Critic on this, though 
  there are many reasonably short solutions.</P>

<h3>Exercise name: <tt>Ex 3-5</tt></h3>

<P>Function name: <code>position+</code></P>

<P>In case you're not sure why the return value is (7 6 3 7): The first element 
  is 7 (the first element of the original list) + 0 (the position of the first 
  element, counting from 0), the second element is 5 (from the original list) 
  plus position 1, the third element is 1 plus position 2, and the last element 
  is 4 plus position 3.</P>

<h3>Exercise name: <tt>Ex 3-8</tt></h3>

<P>Function names: <code>show-dots</code>, <code>show-list</code>.</P>

<P>Define <code>show-dots</code> as described in Graham. This is a simple function 
  and should have simple code. Look at the test cases in <a href="../programs/exercise-tests.lisp">exercises-tests.lisp</a> 
  for examples.</P>

<P>Define <code>show-list</code> to act like Lisp's PRINT, except that it should 
  print square brackets instead of parentheses. (Printing to a string and replacing 
  parentheses doesn't count.)</P>
<P>Both functions should be able to print any S-expression, including atoms.</P>

<h3>Exercise name: <tt>Ex 3-9</tt></h3>

<P>Function name: <code>longest-path</code></P>
<P>There are two problems with this exercise as given. First, Graham's phrase 
  "the longest finite path" makes no sense if you allow cycles in the network, 
  as he does and should. There are an infinite number of finite paths when the 
  network has cycles.</P>

<P>We could say "find the longest path with no cycles," but 
consider asking for the longest path
from node <b>A</b>
to node <b>A</b>. This has a cycle, but it's asking a reasonable question:
what is the longest round-trip tour from <b>A</b>?</P>

<P>So, define your function to find the longest path with
no <em>internal</em> cycles, i.e., no node repeated except possibly
the first and last nodes.</P>

<P>The second problem is that 
looking for longest paths means that Graham's breadth-first
<code>BFS</code> function is <b>not</b> appropriate. Why? Because
breadth-first search has to build
a queue of alternatives, and such a queue is only worth doing
if it lets you stop before you've tried all possibilities.</P>

<P>There's no way to find the longest path without trying 
all possibilities. Therefore, there is no point to keeping a queue.
Depth-first search would work just fine and is more efficient..</P>

<P>Define a recursive <code>longest-path</code> function that uses depth-first
search to explore all paths without internal cycles, one at a time. 
That is, there will be a variable with the current
path, and perhaps another with the best path, but no list of all paths.
</P>

<HR>

<H2><A NAME="ch4"></A>Chapter 4</H2>

<h3>Exercise name: <tt>Ex 4-1</tt></h3>

<P>Function names: <code>rotate-array</code>, <code>nrotate-array</code>.</P>

<P>Define <code>rotate-array</code> to create a new array and copy the
elements from the old array into it. This can be done pretty simply
with a pair of nested <code>dotimes</code> and a formula that maps (x, y)
in the old array into a position in the new array.</P>

<P>In Lisp, for obscure historical reasons, destructive versions
of functions start with the letter "n" as in <code>reverse</code> /
<code>nreverse</code> and <code>subst</code> / <code>nsubst</code>. So <code>nrotate-array</code>
should be a version of
<code>rotate-array</code> that modifies and returns the original array. The
trick is to notice that every element participates in a 4-step
circular rotation. For example, in a 5x5 array, the element at (0, 0)
goes to (0, 4) which goes to (4, 4) which goes to (4, 0) which goes
to (0, 0). (In odd-sized arrays, the center element doesn't move.)
The formula for what goes where is not hard to figure out and similar
to the one needed for the easy version of this exercise.</P>

<P>Common Lisp has a very handy special form, <code>rotatef</code>, which
takes N "places" (variables, aref's, whatever), and "rotates" the
values in those places 1 position. <code>(rotatef x y)</code>, for
example, swaps <code>x</code> and <code>y</code>.</P>

<P>Use <code>rotatef</code> to implement the 4-step rotations that
<code>nrotate-array</code> needs in a concise fashion. Don't rotate any
element more than once!</P>

<h3>Exercise name: <tt>Ex 4-2+6</tt></h3>

<P>Function names: <code>my-copy-list</code>, <code>my-reverse</code>, <code>hash-table->alist</code>, 
  <code>alist->hash-table</code></P>
<P>Send code for exercises 2 and 6 in one email with the Subject line above.</P>

<h3>Exercise name: <tt>Ex 4-3</tt></h3>

<P>Structure name: <code>3tree</code></P>
<P>Function names: <code>3tree-clone</code>, <code>3tree-member</code></P>
<P>Do as specified.</P>

<h3>Exercise name: <tt>Ex 4-4</tt></h3>

<P>Function name: <code>bst-elements</code></P>
<P>The specification "in order from greatest to least" 
is a bit confusing. Is this assuming a particular ordering predicate
was used to build the tree?</P>

<P>In any case, define <code>bst-elements</code> to
return the elements of a binary search tree in the reverse order of 
how they
appear in the tree. So <code>bst-elements</code> on
a tree with 1, 2 and 3 would return <code>(3 2 1)</code>.</p>

<p>
Your solution should only do N conses (not
counting internal CONSes out of your control) to produce an
N-element result. Hint: there's a BST function to make this
fairly simple. The code code for Graham's binary 
search tree is in <a href="../programs/bst.lisp">bst.lisp</a>. Send only your 
code, not Graham's.</P>


<HR>

<H2><A NAME="chap-5"></A>Chapter 5</H2>

<h3>Exercise name: <tt>Ex 5-5</tt></h3>

<P>Function name: <code>preceders</code></P>

<P>Do as specified. Put both versions in 
  the same email.</P>

<h3>Exercise name: <tt>Ex 5-6</tt></h3>

<P>Function name: <code>intersperse</code></P>
<P>Put both versions in the same email.</P>

<P>NOTE: <CODE>(intersperse '- '(a))</CODE> should return <CODE>(a)</CODE>
and <CODE>(intersperse '- '())</CODE> should return <CODE>()</CODE>.
</P>

<P>Avoid inefficiencies. There are two easy traps to fall into:</P>

<UL>
   <LI>a test in your iteration or recursion that can never be true
   after the first pass
   
   <LI>adding an item to the result that you then remove at the end
</UL>

<h3>Exercise name: <tt>Ex 5-7</tt></h3>

<P>Function name: <code>diff-by-one-p</code></P>

<P>Define <em>four</em> versions, all with the same name. The fourth should
use <code>every</code>. Put all four versions in the same email.</P>

<P><code>return-from</code> makes more sense than <code>return</code> in part
c.</P>

<h3>Exercise name: <tt>Ex 5-8</tt></h3>

<P>Function name: <code>max-min</code></P>
<P>Don't worry about using just one function, if more would make the code clearer 
  or more efficient. Only one <em>recursive</em> function is needed though. </P>

<P>Don't use <CODE>subseq</CODE> to create subvectors. This is
expensive. Don't call <code>length</code> on every iteration either. This
is unnecessary. It also limits the generality of <code>maxmin</code>.
</P>

<P>Instead, define <CODE>max-min</CODE> to take the keywords <CODE>:start</CODE> 
  and <CODE>:end</CODE>, just like the other sequence functions do. With<CODE>:start</CODE> 
  and <CODE>:end</CODE>, your code should be more efficient than code with <code>subseq</code> 
  and multiple calls to <code>length</code>, and more flexible at the same time. 
  Think about what other keyword arguments would provide similar efficiency and 
  flexibility.</P>

<h3>Exercise name: <tt>Ex 5-9</tt></h3>

<P>Do as specified. Put both versions in the same email.</P>

<HR>


<H2><A NAME="ch6"></A>Chapter 6</H2>

<h3>Exercise name: <tt>Ex 6-2</tt></h3>

<P>Graham's <code>finder</code> function is not great Common Lisp. Run the Critic 
  on it and see. </P>
<P>Furthermore, it has a serious bug, as noted on <a href="http://www.paulgraham.com/ancomliser.html">the 
  errata page</a> at his web site.</P>
<P>Therefore, part of your job here is to reimplement the code to work correctly 
  (pass the test cases) and be in good Common Lisp style. </P>
<P>Redefine <code>bin-search</code> so that</P>
<blockquote>
  <pre>(bin-search <em>object vector </em>:key <em>key-fn</em> :start <em>start</em> :end <em>end</em>)</pre>
</blockquote>
<P> uses binary search to find an item in <em>vector</em> whose <code>(funcall 
  <em>key-fn item</em>)</code> value is equal to <em>object</em>. For example,</P>
<pre>> (bin-search 8 #((1 a) (3 b) (5 c) (7 d) (8 e) (10 f))
              :key #'car :start 3 :end 5)
(8 E)</pre>
<P> The search should go from <em>start</em> (inclusive) to <em>end</em> (exclusive). 
  All parameters should take their usual values. In particular, in Lisp, C++, 
  Java and elsewhere, the end of a sequence is the first index past the last element. 
  Graham uses the index of the last element, which makes his arithmetic more complicated. 
  With the standard value you can test for the end case and calculate the midpoint 
  without a range calculation.</P>
<P>Do not define a <code>:test</code> parameter. A <code>:test</code> parameter 
  makes little sense here, because the code takes a vector previously sorted using 
  <code>&lt;</code>, and that implicitly defines an equality predicate.</P>
<P>You should not need a helper function, just a recursive <code>bin-search</code>. 
</P>

<h3>Exercise name: <tt>Ex 6-5+6+7+8</tt></h3>

<P>Function names: <code>my-remove-if</code>, <code>greatest-arg</code>,
 <code>bigger-arg</code>, <code>memoize</code></P>
 
<P>Send code for exercises 5, 6, 7 and 8 in one email with the above Subject line.</P>

<p>The parameter to <code>greatest-arg</code> and <code>bigger-arg</code> should
be optional. If omitted, it should reset the internal data to its initial state.</p>
		
<P>Instead of <code>frugal</code>, define <code>(memoize <em>function</em>)</code>.
<code>(memoize <em>function</em>)</code> should take one argument that is
itself a function of one argument, e.g., <code>(memoize #'sqrt)</code>.
<code>memoize</code> should return a new function object, i.e., closure. The closure
should call <em>function</em> when it gets new argument values, and return
whatever <em>function</em> returns. When passed previously seen 
<code>equal</code> values, the closure should return the previous answer without
calling <em>function</em>. If the closure is called with no arguments,
it should clear its internal table of argument values, and start over.</p>

<p>See the test cases in 
<a href="../programs/exercise-tests.lisp">exercise-tests.lisp</a> for examples.
</p>


	
<HR>

<H2><A NAME="ch7"></A>Chapter 7</H2>

<h3>Exercise name: <tt>Ex 7-2</tt></h3>

<P>Function names: <code>map-file</code>, <code>map-stream</code>,

<P>Exercise 7-1 is good practice for this exercise, but only send Exercise 7-2.
</p>
<p>
Instead of making a list of the expressions in a file, define 
<code class="code-syntax">(map-stream <em>function stream</em>)</code>
to apply <em>function</em> to every Lisp expression in <em>stream</em>. It
should return <code>nil</code>. 
Define
<code class="code-syntax">(map-file <em>function pathname</em>)</code>
to apply <em>function</em> to every Lisp expression in the file
named by <em>pathname</em>, and return <code>nil</code>. These functions
can be very useful for checking code files, collecting the names of
functions defined in a file, and so on.
</P>

<h3>Exercise name: <tt>Ex 7-4</tt></h3>

<P>Do as specified.</P>

<HR>


<H2><A NAME="ch8"></A>Chapter 8</H2>

<h3>Exercise name: <tt>Ex 8-4</tt></h3>

<P>Do as specified. To test your package setup, use</P>
<blockquote>
  <pre>(run-tests ring-package)</pre>
</blockquote>

<h3>Exercise name: <tt>Ex 8-5</tt></h3>

<P>Henley is the random text generator in Figures 8.2 and 8.3.</P>

<P>I didn't understand what Graham meant, originally, but a student
clarified it for me. The problem is to tell whether or not a given
quote could have been produced by Henley. Hint: what tells Henley
which words can follow which?</P>

<P>Along the way, change <CODE>generate-text</CODE> to be iterative.
In Scheme, you can count on tail-recursion optimization to get a
working text generator. In Common Lisp, this may happen, but
it depends on the platform. Making the code iterative 
will also allow you to drop the optional
argument <CODE>prev</CODE>.</P>

<p>To test your code, initialize Henley on some corpus. You can
get plain text versions of many books at 
<a href="http://www.gutenberg.org/wiki/Main_Page">Project Gutenberg</a>.
<em>Paradise Lost</em> for example is 
<a href="http://www.gutenberg.org/dirs/etext91/plboss10.txt">here</a>.
Be sure to remove the Project Gutenberg notice before feeding to
Henley.</p>

<p>Then generate some texts with Henley, and feed the results to your predicate.
It should always return true. Then feed it some texts from other sources.
While some may return true, most should return false.</p>



<h3>Exercise name: <tt>Ex 8-6</tt></h3>

<p>Do Exercise 8-5 first, because you need the predicate 
it defines to test your solution to this exercise.</p>


<P>It's not too difficult to use the existing hashtable to find a
word that can precede a given word, and hence generate backwards from
an initial word to the start of a sentence. But this is expensive and
doesn't have the random generation statistical propertes of Henley.
</P>

<P>A better approach is to create an equivalent hashtable for going
backwards, using the data in the existing hashtable. Then generating
in either direction is basically a matter of which hashtable you're
using.</P>

<p>To test your code, feed the output of your generator into
your Henley tester. It should always return true.</p>

<HR>


<H2><A NAME="ch9"></A>Chapter 9</H2>

<h3><a name="make-change"></a>Exercise name: <tt>Ex 9-2</tt></h3>

<P>Function name: <code>make-change</code></P>

<P>Define your function to take the number of cents and an optional list of the 
available coins, largest to smallest, e.g., <code>(make-change 72 '(25 10 1))</code>. 
The default list should be <code>(25 10 5 1)</code>.</P>

<p>You can assume that the coins are such that the simple greedy algorithm
will get the answer with the fewest coins. For a more challenging exercise
that doesn't make this assumption, after you do this, try 
<a href="challenges.html#make-best-change">make-best-change</a>.</p>


<h3>Exercise name: <tt>Ex 9-5</tt></h3>

<P>Function name: <code>solve</code></P>
<P>Graham says that <code>max</code> and <code>min</code> have opposite signs. 
  This makes no sense. It should say that <code>(funcall f max)</code> and <code>(funcall 
  f min)</code> have opposite signs.</P>

<P>Also, students frequently misunderstand the use of
<code>epsilon</code>. What Graham means (and what is usually intended) is
that you stop approximating when <code>max</code> and <code>min</code> are
within <code>epsilon</code> of each other.</P>

<P>Finally, my best solution requires two functions, one to check the initial 
  values and handle some special cases that have no solution or an exact solution, 
  and another to do the actual solving. The style critic calls the first a little 
  too long, the latter somewhat too long.</P>

<h3>Exercise name: <tt>Ex 9-6</tt></h3>

<P>Function name: <code>horner</code></P>
<P>Do as specified.</P>

<hr>

<p>See <a href="challenges.html">the challenge exercises</a> for challenges based on exercises 
in this chapter.</p>

<HR>


<H2><A NAME="ch10"></A>Chapter 10</H2>

<h3>Exercise name: <tt>Ex 10-3+5</tt></h3>

<P>Send code for exercises 3 and 5 in
one email, with the Subject line above.</P>

<P><code>nth-expr</code> is very poorly described and the 
one test case Graham gives leaves open a
number of possible incompatible behaviors. In particular, it's not
clear whether <code>nth-expr</code> evaluates all expressions and then
returns the Nth one, or only evaluates the Nth one. Both would be
valuable, but only the latter needs to be a macro. If all arguments
are to be evaluated, then we can define <code>nth-expr</code> as a
function.</P>

<P>Since this is the macro chapter, we'll take the interpretation
that requires a macro. The form <code>(nth-expr</code> <I>n exp1 exp2
exp3 </I>...) should evaluate <I><code>n</code></I> (which should yield a
number N). Then <I><code>expN</code></I>, and only <I><code>expN</code></I>,
should be evaluated and returned.</P>

<P>Here's a test case that your code has to handle correctly. Only
one thing should print and it'll be clear if you're right.</P>

<BLOCKQUOTE><PRE>(let ((n 3) (x "lose") (y "win"))
  (nth-expr n
    (format t "You ~S!" x)
    (format t "You ~S!" x)
    (format t "You ~S!" y)
    (format t "You ~S!" x)
    ))</PRE></BLOCKQUOTE>

<h3>Exercise name: <tt>Ex 10-6</tt></h3>

<P>Function name: <code>preserve</code></P>
<P>This exercise requires you to understand how variable bindings work, but the 
  answer is quite short. Your macro needs to work for both lexical and special 
  variables.</P>

  
<h3>Exercise name: <tt>Ex 10-8</tt></h3>

<P>Function name: <code>doublef</code></P>

<P>Note the name change: Graham's name does not suggest the close connection
between this macro and <code>incf</code>.</p>

<p>Make sure <code>doublef</code> correctly handles generalized references.</P>

<HR>


<H2><A NAME="ch11"></A>Chapter 11</H2>

<h3>Exercise name: <tt>Ex 11-1+5</tt></h3>

<P>Send code for exercises 1 and 5 in
one email, with the Subject line above.</P>

<h3>Exercise name: <tt>Ex 11-2</tt></h3>

<P>Do as specified.</P>


<HR>

<H2><A NAME="ch12"></A>Chapter 12</H2>

<h3>Exercise name: <tt>Ex 12-3+4+5</tt></h3>

<P>Function names: <code>make-queue</code>, </code><code>queue-empty-p</code>, <code>copy-queue</code>, 
  <code>enqueue-front</code>, 
  <code>requeue-front</code></P>
<P>Send all the queue functions in one email with the Subject line above.</P>

<P>Queues in Lisp are easy and useful, but Graham left out one essential function, 
  and should have made <code>make-queue</code> more convenient. Define <code>empty-queue-p</code> 
  to return true if a queue is empty. Redefine <code>(make-queue <em>arg1 arg2</em> 
  ...</code> to return a queue initialized with the items given, if any.</P>


<h3>Exercise name: <tt>Ex 12-6+7</tt></h3>

<P>Function names: <code>circular-member-p</code>, <code>cdr-circular-p</code></P>
<P>As far as I can tell, you need to do Exercise 7 first, before doing Exercise 
  6, so submit both as one email.</P>

<BLOCKQUOTE><P>For all the circular list exercises, make sure you set
the global variable <code>*PRINT-CIRCLE*</code> to true first! This tells
Lisp to use a special printing algorithm that handles circular lists.
Note that what Lisp prints can be typed in to make a circular list
too. It's not just an output format.</P></BLOCKQUOTE>

<P>As you might expect, by chapter 12, a simple question doesn't mean
a simple answer. Graham should've said more.</P>

<P>First, for Exercise 7, something like</P>

<BLOCKQUOTE><PRE>(eq l (cdr l))</PRE></BLOCKQUOTE>

<P>won't work. This only catches a 1-element cdr-circular list, not
lists like</P>

<PRE>  (let ((l (list 1 2 3))) (nconc l l))
  </PRE>

<P>or</P>

<PRE>  (let ((l (list 1 2 3))) (nconc l (cddr l)))
  </PRE>

<P>The obvious solution is to keep a list of every CDR and return
true if you find the same list twice before hitting NIL.</P>

<P>The problem with this solution is that it requires potentially large amounts 
  of memory space to hold the table, either in a list or hashtable. If you want 
  to trade more pointer following for using no extra memory, there's a trick: 
  Start a loop with two variables -- a "turtle" that CDR's down the list and a 
  rabbit that CDDR's. That means the rabbit goes twice as fast as the turtle. 
  If the list is CDR-circular, eventually the rabbit and turtle will bump into 
  each other. If the list is not circular, the rabbit will hit NIL.</P>

<P>After you have CDR-circular lists working, then you can do Exercise 6. Careful! 
  Make sure you test this thoroughly. It's easy to write a version that says false 
  when it should say true.</P>

<P>Make sure your function works for regular lists too, and for lists that become 
  circular somewhere in the middle. </P>
<h3>Exercise name: <tt>Ex 12-8</tt></h3>

<P>Function name: <code>car-circular-p</code></P>

<P>This is much harder than the CDR-circular case. All the solutions I've seen 
  keep a stack of sublists.</P>
<P>There are quite a few test cases in <a href="../programs/exercise-tests.lisp">exercise-tests.lisp</a>. 
  All should pass but if you're convinced one of them is wrong, note which test 
  case you disagree with in your submission. Before doing so, though, draw the 
  test case in box and arrow notation, as shown in the figures in Chapter 12. 
  If there is a loop and it goes through the CAR side of a box, then it's CAR-circular.</P>


<HR>

<P ID="closing">Comments? <IMG SRC="../images/comments.gif"
ALIGN=bottom> Send mail to <A HREF="mailto:riesbeck@cs.northwestern.edu">Chris
Riesbeck</A>.</P>

</BODY>
</HTML>