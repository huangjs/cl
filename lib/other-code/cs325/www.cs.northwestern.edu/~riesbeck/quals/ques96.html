<!--This file created 7/2/97 9:57 AM by Claris Home Page version 2.0-->
<HTML>
<HEAD>
   <TITLE>96 Programming Question</TITLE>
   <META NAME=GENERATOR CONTENT="Claris Home Page 2.0">
   <X-SAS-WINDOW TOP=66 BOTTOM=624 LEFT=8 RIGHT=538>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<H1>The Qual 96 Programming Question</H1>

<P>First, read and try implementing a solution to the original
question below. Remember that on the qual, students had an hour.</P>

<P>Now, assess your answer based on <A HREF="assess96.html">these
critiques</A>.</P>

<P>Finally, look at <A HREF="ans96.lisp">the answer I generated</A>.
It's more than what can be done in an hour, but it's also complete
and more polished than I would expect.</P>

<P>
<HR>
</P>

<H1>Programming Question</H1>

<P>Congratulations! <B>One-Hour Software </B>("ready in 60 or you
don't pay!") has hired you to implement Fitzgerald's Indexed Concept
Parser (ICP). ICP takes an input text and returns a list of target
concepts, sorted by how strongly the text indexes the targets. ICP
uses a memory containing:</P>

<UL>
   <LI>concepts, organized into abstraction hierachies, e.g.,
   <TT>m-water</TT> is a kind of <TT>m-liquid</TT> and
   <TT>m-transfer-water</TT> is a kind of <TT>m-transfer</TT>
   
   <LI>links from words and phrases to concepts, e.g., `water' links
   to both <TT>m-water</TT> and <TT>m-transfer-water</TT> (as in
   "water the garden")
   
   <LI>links from sets of concepts, called <I>indices</I>, to target
   concepts,
</UL>

<P>Here are some examples of target concepts for a robot gardener and
their indices: <TABLE BORDER=1>
   <TR>
      <TH>
         <P>Target
      </TH><TH>
         <P>Index set
      </TH></TR>
   <TR>
      <TD>
         <P><CODE>m-rake-garden</CODE>
      </TD><TD>
         <P><CODE>{m-rake, m-move-rake, m-garden}</CODE>
      </TD></TR>
   <TR>
      <TD>
         <P><CODE>m-remove-weeds-from-garden</CODE>
      </TD><TD>
         <P><CODE>{m-weed, m-remove, m-garden}</CODE>
      </TD></TR>
   <TR>
      <TD>
         <P><CODE>m-water-garden</CODE>
      </TD><TD>
         <P><CODE>{m-garden, m-transfer-water, m-water}</CODE>
      </TD></TR>
</TABLE></P>

<P>A target can have more than one index set linked to it.</P>

<P>Given an input text, ICP maps the words and phrases to a pool of
input concepts, <B><I>P</I></B>, and sorts the index sets in memory
based on how well each index set <B><I>S</I></B> matches
<B><I>P</I></B>, combining these positive and negative metrics:</P>

<UL>
   <LI><B>p+s</B>: the number of concepts in <B><I>P</I></B> that
   have an abstraction in <B><I>S</I></B>
   
   <LI><B>p-s</B>: the nunber of concepts in <B><I>P</I></B> that do
   not have an abstraction in <B><I>S</I></B>
   
   <LI><B>s-p</B>: the number of concepts in <B><I>S</I></B> that are
   not an abstraction of anything in <B><I>P</I></B>
</UL>

<P>(As usual, a concept is trivially an abstraction of itself.)
Another programmer has defined <TT>score-match(</TT><I><TT>p+s, p-s,
s-p</TT></I><TT>)</TT> to combine these numbers into a single score.
ICP then sorts the target concepts based on the score of their best
matching index set.</P>

<P>Working top-down, starting with
<TT>parse(</TT><I><TT>input-list-of-words</TT></I><TT>)</TT>,
implement as much of the code as you can. Don't worry about
implementing the links between concepts and words and index sets.
Focus on the parsing and matching. Clarity and brevity of code count
more than efficiency, but, since the obvious algorithms are
combinatoric, notes that would help later programmers improve the
efficiency of your code are important too.</P>

<P>
<HR>
</P>
</BODY>
</HTML>
